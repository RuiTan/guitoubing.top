{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/1.png","path":"images/1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/11a.PNG","path":"images/11a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/11b.PNG","path":"images/11b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/12b.PNG","path":"images/12b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/12a.PNG","path":"images/12a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555335982957.png","path":"images/1555335982957.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555336042119.png","path":"images/1555336042119.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555336181441.png","path":"images/1555336181441.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555337368613.png","path":"images/1555337368613.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555336839432.png","path":"images/1555336839432.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555337410546.png","path":"images/1555337410546.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555337487973.png","path":"images/1555337487973.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338108853.png","path":"images/1555338108853.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555337786084.png","path":"images/1555337786084.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338066598.png","path":"images/1555338066598.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338210270.png","path":"images/1555338210270.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338281068.png","path":"images/1555338281068.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338199372.png","path":"images/1555338199372.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338141910.png","path":"images/1555338141910.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338761379.png","path":"images/1555338761379.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555338670472.png","path":"images/1555338670472.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555348996560.png","path":"images/1555348996560.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555349943322.png","path":"images/1555349943322.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555348366529.png","path":"images/1555348366529.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555350134801.png","path":"images/1555350134801.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/21a.PNG","path":"images/21a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/21b.PNG","path":"images/21b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/2.png","path":"images/2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/22a.PNG","path":"images/22a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/22b.PNG","path":"images/22b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/3-B树.png","path":"images/3-B树.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/3-不用索引.png","path":"images/3-不用索引.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/3-位图.png","path":"images/3-位图.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/3-强制B树.png","path":"images/3-强制B树.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/31a.PNG","path":"images/31a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/3-强制位图.png","path":"images/3-强制位图.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/31b.PNG","path":"images/31b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/3.png","path":"images/3.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/32b.PNG","path":"images/32b.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/32a.PNG","path":"images/32a.PNG","modified":0,"renderable":1},{"_id":"themes/next/source/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png","path":"images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/AcFun.png","path":"images/AcFun.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/527DE0D27244EE625AD2D099AACDF4BA.png","path":"images/527DE0D27244EE625AD2D099AACDF4BA.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/CSDN.png","path":"images/CSDN.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/Coding.png","path":"images/Coding.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/Plunker.png","path":"images/Plunker.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/LOFTER.png","path":"images/LOFTER.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/Quora.png","path":"images/Quora.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/SegmentFault.png","path":"images/SegmentFault.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/V2EX.png","path":"images/V2EX.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/TiddlyWiki.png","path":"images/TiddlyWiki.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/bilibili.png","path":"images/bilibili.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/bitbug_favicon.ico","path":"images/bitbug_favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/detail_3.2.png","path":"images/detail_3.2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/detail_index_3.2.png","path":"images/detail_index_3.2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/exec_detail_no_index_2.png","path":"images/exec_detail_no_index_2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/exec_detail_no_index_1.1.png","path":"images/exec_detail_no_index_1.1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/exec_no_index_1.1.png","path":"images/exec_no_index_1.1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/explain_2.png","path":"images/explain_2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/explain_1.1.png","path":"images/explain_1.1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/explain_3.2.png","path":"images/explain_3.2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/explain_3.2_index.png","path":"images/explain_3.2_index.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181018143452887.png","path":"images/image-20181018143452887.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027232418408.png","path":"images/image-20181027232418408.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181106214511931.png","path":"images/image-20181106214511931.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170852678-6247332.png","path":"images/image-20181231170852678-6247332.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170852678.png","path":"images/image-20181231170852678.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170913607.png","path":"images/image-20181231170913607.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190114004746346.png","path":"images/image-20190114004746346.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190114060005845.png","path":"images/image-20190114060005845.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190114052126486.png","path":"images/image-20190114052126486.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225225802212.png","path":"images/image-20190225225802212.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225230110077.png","path":"images/image-20190225230110077.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225230647640.png","path":"images/image-20190225230647640.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225225057306.png","path":"images/image-20190225225057306.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225232407098.png","path":"images/image-20190225232407098.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225232630665.png","path":"images/image-20190225232630665.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170913607-6247353.png","path":"images/image-20181231170913607-6247353.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/niconico.png","path":"images/niconico.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/qcode.jpg","path":"images/qcode.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190225232204967.png","path":"images/image-20190225232204967.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/sns-qrcode.png","path":"images/sns-qrcode.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/rssFeed-bg.jpg","path":"images/rssFeed-bg.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/scrollbar_arrow.png","path":"images/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/time_3.2_4min.png","path":"images/time_3.2_4min.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/博客园.png","path":"images/博客园.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/修改字符集3.png","path":"images/修改字符集3.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午10.54.29.png","path":"images/屏幕快照 2019-01-12 下午10.54.29.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午10.56.20.png","path":"images/屏幕快照 2019-01-12 下午10.56.20.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午7.21.45.png","path":"images/屏幕快照 2019-01-13 下午7.21.45.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.14.59.png","path":"images/屏幕快照 2019-01-13 下午9.14.59.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.32.45.png","path":"images/屏幕快照 2019-01-13 下午9.32.45.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.35.11.png","path":"images/屏幕快照 2019-01-13 下午9.35.11.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.37.07.png","path":"images/屏幕快照 2019-01-13 下午9.37.07.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.38.39.png","path":"images/屏幕快照 2019-01-13 下午9.38.39.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.37.57.png","path":"images/屏幕快照 2019-01-13 下午9.37.57.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/新浪微博.png","path":"images/新浪微博.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.33.27.png","path":"images/屏幕快照 2019-01-14 上午12.33.27.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/知乎.png","path":"images/知乎.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/简书.png","path":"images/简书.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/网易云音乐.png","path":"images/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/虾米音乐.png","path":"images/虾米音乐.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/豆瓣.png","path":"images/豆瓣.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/锁.png","path":"images/锁.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/锁2.png","path":"images/锁2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/%E6%9E%B6%E6%9E%84.png","path":"images/%E6%9E%B6%E6%9E%84.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555228253075.png","path":"images/1555228253075.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555228331186.png","path":"images/1555228331186.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/404-bg.jpg","path":"images/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/2-B树.png","path":"images/2-B树.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/2-位图.png","path":"images/2-位图.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-4-1.png","path":"images/5-4-1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/bVbjaD6.jpeg","path":"images/bVbjaD6.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/donate-qr.png","path":"images/donate-qr.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/exec_no_index_2.png","path":"images/exec_no_index_2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/hive_textfile1.png","path":"images/hive_textfile1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181018140412582.png","path":"images/image-20181018140412582.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181018140355729.png","path":"images/image-20181018140355729.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181017150353887.png","path":"images/image-20181017150353887.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019161615728.png","path":"images/image-20181019161615728.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027150507907.png","path":"images/image-20181027150507907.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181124205409162.png","path":"images/image-20181124205409162.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181124202306595.png","path":"images/image-20181124202306595.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228192741706.png","path":"images/image-20181228192741706.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228192905376-5996545.png","path":"images/image-20181228192905376-5996545.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228192905376.png","path":"images/image-20181228192905376.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228201105314-5999065.png","path":"images/image-20181228201105314-5999065.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228201105314.png","path":"images/image-20181228201105314.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003438922-6187679.png","path":"images/image-20181231003438922-6187679.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003438922.png","path":"images/image-20181231003438922.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003442918-6187682.png","path":"images/image-20181231003442918-6187682.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003442918.png","path":"images/image-20181231003442918.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003513281-6187713.png","path":"images/image-20181231003513281-6187713.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003513281.png","path":"images/image-20181231003513281.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170937495-6247377.png","path":"images/image-20181231170937495-6247377.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231170937495.png","path":"images/image-20181231170937495.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113193023545.png","path":"images/image-20190113193023545.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190114162624572.png","path":"images/image-20190114162624572.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190308105552914.png","path":"images/image-20190308105552914.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190414155203979.png","path":"images/image-20190414155203979.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190414161020200.png","path":"images/image-20190414161020200.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/修改字符集1.png","path":"images/修改字符集1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/修改字符集2.png","path":"images/修改字符集2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午11.44.33.png","path":"images/屏幕快照 2019-01-12 下午11.44.33.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.48.45.png","path":"images/屏幕快照 2019-01-13 下午10.48.45.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午11.28.38.png","path":"images/屏幕快照 2019-01-12 下午11.28.38.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.50.07.png","path":"images/屏幕快照 2019-01-13 下午10.50.07.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.08.43.png","path":"images/屏幕快照 2019-01-13 下午8.08.43.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.25.22.png","path":"images/屏幕快照 2019-01-13 下午9.25.22.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.35.22.png","path":"images/屏幕快照 2019-01-14 上午12.35.22.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/查看执行时间.png","path":"images/查看执行时间.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/表1.png","path":"images/表1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/表3.png","path":"images/表3.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/软件过程框架.png","path":"images/软件过程框架.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/1-B树索引.png","path":"images/1-B树索引.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1-位图索引.png","path":"images/1-位图索引.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-1-1.png","path":"images/5-1-1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-2.png","path":"images/5-2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-3.png","path":"images/5-3.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/ERFinal.png","path":"images/ERFinal.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cover-night.jpg","path":"images/cover-night.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/hive_orc1.png","path":"images/hive_orc1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/hive_textfile2.png","path":"images/hive_textfile2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228192856958-5996536.png","path":"images/image-20181228192856958-5996536.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181126025537963.png","path":"images/image-20181126025537963.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228200129326-5998489.png","path":"images/image-20181228200129326-5998489.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228192856958.png","path":"images/image-20181228192856958.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181228200129326.png","path":"images/image-20181228200129326.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003424471-6187664.png","path":"images/image-20181231003424471-6187664.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003424471.png","path":"images/image-20181231003424471.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003457997-6187698.png","path":"images/image-20181231003457997-6187698.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113214926175.png","path":"images/image-20190113214926175.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/process_list.png","path":"images/process_list.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/tags-bg.png","path":"images/tags-bg.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.45.10.png","path":"images/屏幕快照 2019-01-13 下午10.45.10.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/表2.png","path":"images/表2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555227964411.png","path":"images/1555227964411.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/006tNbRwly1fwdiojeitsj31eu1444it.jpg","path":"images/006tNbRwly1fwdiojeitsj31eu1444it.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-6.png","path":"images/5-6.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-5-2.png","path":"images/5-5-2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-9.png","path":"images/5-9.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-7.png","path":"images/5-7.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-8.png","path":"images/5-8.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cover-day.jpg","path":"images/cover-day.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231003457997.png","path":"images/image-20181231003457997.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113230627090.png","path":"images/image-20190113230627090.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.46.16.png","path":"images/屏幕快照 2019-01-13 下午10.46.16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.47.49.png","path":"images/屏幕快照 2019-01-13 下午10.47.49.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-5-1.png","path":"images/5-5-1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-4-2.png","path":"images/5-4-2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/JSimple-Snapshot-Macbook Pro15.png","path":"images/JSimple-Snapshot-Macbook Pro15.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113211220925.png","path":"images/image-20190113211220925.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113230831573.png","path":"images/image-20190113230831573.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190113230717837.png","path":"images/image-20190113230717837.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/inmemory.png","path":"images/inmemory.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/双亲委派模型.png","path":"images/双亲委派模型.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/类加载机制.png","path":"images/类加载机制.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/006tNbRwly1fwdiyk83baj31ig114aw6.jpg","path":"images/006tNbRwly1fwdiyk83baj31ig114aw6.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027233529314.png","path":"images/image-20181027233529314.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231171547272-6247747.png","path":"images/image-20181231171547272-6247747.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190312200304819.png","path":"images/image-20190312200304819.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/no-inmemory.png","path":"images/no-inmemory.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.57.10.png","path":"images/屏幕快照 2019-01-13 下午10.57.10.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.30.40.png","path":"images/屏幕快照 2019-01-14 上午12.30.40.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.49.11.png","path":"images/屏幕快照 2019-01-13 下午8.49.11.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/语句执行计划.png","path":"images/语句执行计划.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019161433801.png","path":"images/image-20181019161433801.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019161451060.png","path":"images/image-20181019161451060.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027233726178.png","path":"images/image-20181027233726178.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181231171547272.png","path":"images/image-20181231171547272.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.06.20.png","path":"images/屏幕快照 2019-01-13 下午9.06.20.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.30.46.png","path":"images/屏幕快照 2019-01-14 上午12.30.46.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/images/5-1-2.png","path":"images/5-1-2.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181023205748006.png","path":"images/image-20181023205748006.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190414160931753.png","path":"images/image-20190414160931753.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.31.00.png","path":"images/屏幕快照 2019-01-13 下午8.31.00.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1555227842703.png","path":"images/1555227842703.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190325104456133.png","path":"images/image-20190325104456133.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午7.09.22.png","path":"images/屏幕快照 2019-01-13 下午7.09.22.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.07.08.png","path":"images/屏幕快照 2019-01-13 下午9.07.08.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019163053138.png","path":"images/image-20181019163053138.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027164439676.png","path":"images/image-20181027164439676.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181027150559447.png","path":"images/image-20181027150559447.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019161405925.png","path":"images/image-20181019161405925.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20190114062154430.png","path":"images/image-20190114062154430.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181019162644076.png","path":"images/image-20181019162644076.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/hive_arg.png","path":"images/hive_arg.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/image-20181009202105976.png","path":"images/image-20181009202105976.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/可达性分析算法.png","path":"images/可达性分析算法.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"44104542b39c342c2e72fd9d0d30bb7af316c5f7","modified":1576217299820},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1576233352513},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1576233352513},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1576233352513},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1576233352517},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1576233352517},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1576233352517},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1576233352517},{"_id":"themes/next/README.md","hash":"dc026053a4d9fb97a58dbc3e9060e480f6852b23","modified":1576233352518},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1576233352518},{"_id":"themes/next/_config.yml","hash":"be12cb4e6507583b5adfb2552fa873e77aa31d1a","modified":1576292395549},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1576233352524},{"_id":"themes/next/package.json","hash":"61aa2ac422e92ad435d1bfedea8d41824f5fe85e","modified":1576233352548},{"_id":"source/404/index.md","hash":"56694c2a0b254de46232a483d57969d11f871d00","modified":1576217299960},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1576217299840},{"_id":"source/_posts/2017-10-14.md","hash":"9c53ca6443f02942ee40bdc831fab99d8752b361","modified":1576217299890},{"_id":"source/_posts/C-ReadWriteLock.md","hash":"fa210550b289dd3e947ea82f088b9ac276f4f8a4","modified":1621162393998},{"_id":"source/_posts/Dotnet.md","hash":"b2f22145eda2c43372f48d9f6820cf83bdbe16b6","modified":1621162762035},{"_id":"source/_posts/JavaFX-学习小记.md","hash":"16dda40b8c50b24956ec3357a63936b6f79773f6","modified":1621162533577},{"_id":"source/_posts/Framework.md","hash":"5d334d77fe61d9377b091ac736764b02ce97517a","modified":1621162487622},{"_id":"source/_posts/NET-Framework及EntityFramework.md","hash":"048812bff7d68f3b823f39ddfc1195104908aebe","modified":1621162548167},{"_id":"source/_posts/Hadoop-Tags.md","hash":"4d18911c273fec183cc9cfe28df042213e8ff0c1","modified":1621162503721},{"_id":"source/_posts/Java类与类加载器.md","hash":"ab80012aa49a5f04cf185e885bfb4954b785bf3a","modified":1621162521675},{"_id":"source/_posts/Spring学习笔记.md","hash":"d311737f5893839f6505016b5f5d531438a42528","modified":1621162593611},{"_id":"source/_posts/Tensorflow-multi-GPU.md","hash":"ae862a14cefae134dc3cee73ee4f722245420433","modified":1621162612708},{"_id":"source/_posts/使用Docker安装Oracle-12c.md","hash":"cc93205bcad5d5c42e69658399475bf51cd74f1b","modified":1576217299890},{"_id":"source/_posts/Practice.md","hash":"2526529a9326ae09e807318159fa6695955ff9fe","modified":1621162819557},{"_id":"source/_posts/TimesTen内存数据库课程笔记.md","hash":"fe634154d4055fb21205bf0ab71592e40dfaa81e","modified":1621162813403},{"_id":"source/_posts/云计算期末项目文档.md","hash":"78b5c6bef05028021c2dbc5f16592d66bf7e65d2","modified":1621162829634},{"_id":"source/_posts/数据库与内存数据库实验报告.md","hash":"c083a0996854f600a63cd4c4f1e8b508eb6edcda","modified":1621162835325},{"_id":"source/_posts/数据仓库期末项目文档.md","hash":"190316fabb8c3382bbc13cac4f300d15be1e580a","modified":1621162838152},{"_id":"source/_posts/记一次Win10-Fedora双系统的小折腾.md","hash":"41f47a6271c6b6edb944e228540e93ef2ba3a81f","modified":1621161631564},{"_id":"source/_posts/深入GC.md","hash":"ffe212bce5e44001b457afe54da2f33e848fd7a5","modified":1621161766893},{"_id":"source/about/index.md","hash":"5602770423d0335e6acd5eaf9bceb0582c4212ff","modified":1576217299950},{"_id":"source/categories/index.md","hash":"8af1a2425342fb7069e72685050278ab03339fe3","modified":1576217299960},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1576233352513},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ef63f34bd3b6bd4d7304d48ce5e0e3e2bead385","modified":1576233352514},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"715dcf9b0429a4a4c7107d6d1d00a34e4cf9aa99","modified":1576233352515},{"_id":"themes/next/.github/config.yml","hash":"e4f4b9afe59bc508c4f7634895b33d7d460a7cb1","modified":1576233352515},{"_id":"source/tags/index.md","hash":"fbefc2d9906fa2c85992a42c25c113c89fa86f38","modified":1576217299950},{"_id":"source/_posts/深入学习Java（更新中）.md","hash":"d179cf7ac1643d51f3533d40d60d862dcde75c09","modified":1621161722363},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1576233352515},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1576233352515},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1576233352516},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1576233352517},{"_id":"themes/next/.git/FETCH_HEAD","hash":"6d2a2ba275fd672bfa10a8b1712241c4136783df","modified":1581399294461},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1576233352501},{"_id":"themes/next/.git/config","hash":"c8e8389d84a50c9e97d5a9970fe87f5dc5dfa12b","modified":1576234263245},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1576233243273},{"_id":"themes/next/.git/index","hash":"84be5d22250b0d4ae741620c14e1cae90a26394e","modified":1576331528913},{"_id":"themes/next/.git/packed-refs","hash":"f0e58bce026824d5297215cf607b03923c3512b9","modified":1576233352497},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1576233352516},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1576233352516},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"b98bc28d4db5ce96840638ae31c976700d8bdbf4","modified":1576331528916},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1576233352519},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1576233352519},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1576233352520},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1576233352520},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1576233352519},{"_id":"themes/next/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1576233352520},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1576233352520},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"682937d48bf5d243842a76190921322e26c75247","modified":1576233352521},{"_id":"themes/next/docs/MATH.md","hash":"f520b336f16665e164d6edf075bdcc6aa17b31bc","modified":1576233352521},{"_id":"themes/next/languages/default.yml","hash":"89eb0cff04435307e4eccb0d72a653499627d02d","modified":1576233352525},{"_id":"themes/next/languages/en.yml","hash":"89eb0cff04435307e4eccb0d72a653499627d02d","modified":1576233352525},{"_id":"themes/next/languages/de.yml","hash":"285b294b1dd2ce49b0694beb4fd75ed05dc20ccb","modified":1576233352525},{"_id":"themes/next/languages/fr.yml","hash":"5fe560d14824c71ea90b2a76d0c17b2332b9d08a","modified":1576233352526},{"_id":"themes/next/languages/es.yml","hash":"3bd0977225a9b9dc3cdc856161b3a77e5993ac4a","modified":1576233352525},{"_id":"themes/next/languages/id.yml","hash":"80c3db4c2dbbea0703f6c8f1191218f692899507","modified":1576233352526},{"_id":"themes/next/languages/ja.yml","hash":"e61529ddf80426a5362ed07642216027615bd740","modified":1576233352527},{"_id":"themes/next/languages/hu.yml","hash":"dd9e4cd2873ed9a9ae7cb89962eeff911de396b4","modified":1576233352526},{"_id":"themes/next/languages/fa.yml","hash":"35468531ad0236df5b188f28bd1b4bb0c0537faf","modified":1576233352526},{"_id":"themes/next/languages/pt.yml","hash":"88fb58e537a949c013a2adcdaebcbe09543c0bd2","modified":1576233352527},{"_id":"themes/next/languages/ko.yml","hash":"14a162509dc71bb364335c20281d3bccbd2a51f3","modified":1576233352527},{"_id":"themes/next/languages/it.yml","hash":"68ac5a0aa361210f51915e101c842ed1c9464889","modified":1576233352526},{"_id":"themes/next/languages/tr.yml","hash":"e08d8d6ee9507a7c7d4450bc1c76b435470a3739","modified":1576233352528},{"_id":"themes/next/languages/ru.yml","hash":"f7d5efd6289845f2375bbee8fe883813de745767","modified":1576233352528},{"_id":"themes/next/languages/nl.yml","hash":"4d9b09aff03648cbbbfeb0c51a2d1214320b5ec6","modified":1576233352527},{"_id":"themes/next/languages/zh-CN.yml","hash":"4b36a51556e87d236c6ac6ee6975de1beb95724c","modified":1576233352529},{"_id":"themes/next/languages/uk.yml","hash":"e58393cf726401bf50a772392e23507d9e11049e","modified":1576233352528},{"_id":"themes/next/languages/pt-BR.yml","hash":"024dcdeb30c93e57cd1ba4cd707f8988dcad2468","modified":1576233352527},{"_id":"themes/next/languages/zh-TW.yml","hash":"5e395cb492a0b6284f8d2ffdd93f7380db31486f","modified":1576233352529},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1576233352552},{"_id":"themes/next/languages/vi.yml","hash":"0c0890ccffcb5cca0893de63ebad66e3ce740707","modified":1576233352528},{"_id":"themes/next/languages/zh-HK.yml","hash":"6d83daf9df1811e3ae6cde5ad778c888d8027b13","modified":1576233352529},{"_id":"themes/next/layout/_layout.swig","hash":"29ee038b0d5ffdb45327598733ea968588367769","modified":1576233352529},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1576233352547},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1576233352547},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1576233352547},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1576233352547},{"_id":"themes/next/layout/archive.swig","hash":"26526c09a4334099e2141456697696fcd1f9783f","modified":1576233352547},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1576233352547},{"_id":"source/_posts/assets/依赖无倒置.png","hash":"d32a7cd279374c52ebbed3caa6ac3d5673d14d47","modified":1576423677085},{"_id":"source/_posts/assets/依赖倒置.png","hash":"819ae605c6172ae40c0f12319bffbd8e1ea62d7f","modified":1576423692295},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"ddc1f18952151f3c90f3b9043f2c5dddda857af2","modified":1576233352514},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"c9bb152643af4692af65b93c4a00690e61131c89","modified":1576233352514},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"5e55946ee51cf5b20f5a77510a2ea16c26e40642","modified":1576233352514},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"a5c007b5aa6007cb6cd4a669cf3b59c3e6628fc1","modified":1576233352514},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1576233243275},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1576233243274},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1576233243276},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1576233243277},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1576233243278},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1576233243275},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1576233243278},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1576233243277},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1576233243274},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1576233243273},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1576233243279},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1576233243277},{"_id":"themes/next/.git/logs/HEAD","hash":"5be811db2d3da00d605e26c3cfcf0d81a901d664","modified":1576331528919},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1576233352522},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1576233352522},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1576233352521},{"_id":"themes/next/docs/ru/README.md","hash":"41b1bef32fb991410ebf559b4c45022549f95215","modified":1576233352522},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1576233352523},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1576233352523},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1576233352523},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"17d7203e85a8ce9760c42a853dee0f26a8f7ee4e","modified":1576233352523},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"7f37327bbcae7ed7d04d187fd5e9bc6bbf14926a","modified":1576233352524},{"_id":"themes/next/docs/zh-CN/README.md","hash":"b6a3611d40863c12804c5846994786119ce3b79f","modified":1576233352524},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"0b0b9ec6ec4a89e701a3b91f8d7d95752d3e241b","modified":1576233352524},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"f0ffb74de522749c9f2fda46970a61bdafbfbc24","modified":1576233352524},{"_id":"themes/next/scripts/events/index.js","hash":"9047d8ae2670e43429b16a7919a08a0a0a81afe0","modified":1576233352548},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1576233352551},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1576233352551},{"_id":"themes/next/scripts/filters/locals.js","hash":"5bbfdc1c373542159660b7a68ed0b57ca18ad10b","modified":1576233352551},{"_id":"themes/next/scripts/filters/post.js","hash":"5e5035372b3d94a65309334c93303c858e072012","modified":1576233352552},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1576233352551},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1576233352552},{"_id":"themes/next/scripts/helpers/engine.js","hash":"c8c8afde59df587f883dd9b47a3c629042bc4c6e","modified":1576233352552},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"58347687b02f7ab5e64bef07525c8efa97c9e8fb","modified":1576233352552},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1576233352552},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1576233352553},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1576233352553},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1576233352553},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1576233352553},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1576233352553},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1576233352554},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1576233352554},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1576233352554},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1576233352555},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1576233352522},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e2c9db54cc9e154e882008fde6588b065fadc9a7","modified":1576233352530},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1576233352530},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1ee6335c12773dc43f8b92136770cb10d460c25c","modified":1576233352531},{"_id":"themes/next/layout/_macro/post.swig","hash":"049caf88e2cb8dde780b0c6196db984c7bc3a4cc","modified":1576233352530},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1576233352534},{"_id":"themes/next/layout/_partials/comments.swig","hash":"0c4914a5fd08f15beec71940218c814ad9a89f3f","modified":1576233352531},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1576233352536},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1576233352537},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1576233352536},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1576233352539},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1576233352539},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1576233352537},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1576233352543},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1576233352540},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"dd6bd817cb69b5ad5e9746498146314b54054ff8","modified":1576233352544},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1576233352544},{"_id":"themes/next/source/js/motion.js","hash":"09f8be6bcc6920546bb06e3f8c0181ec62c70b90","modified":1576233352585},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1576233352585},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1576233352585},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1576233352581},{"_id":"themes/next/source/js/local-search.js","hash":"9f3d3ddff86e7b2828772aba915a5ebfd7d9f55f","modified":1576233352585},{"_id":"themes/next/source/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1576233352587},{"_id":"themes/next/source/js/utils.js","hash":"32ad2609c1d80a8d5180ec059d0eea0c6735d1f2","modified":1576233352589},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1576233352589},{"_id":"themes/next/source/images/.DS_Store","hash":"82168ef6ffc3fc1f1a634ccda2c8e69436cae29c","modified":1576234316122},{"_id":"themes/next/source/images/1.png","hash":"c4a3dd9ba57eb3c0633c24293f63e08531b31462","modified":1576217357570},{"_id":"themes/next/source/images/11a.PNG","hash":"157558db491e45976c19acf68384db175d2b368b","modified":1576217356460},{"_id":"themes/next/source/images/11b.PNG","hash":"50bb7695d9e6afcf8b5afbe02956b017cf08d922","modified":1576217356350},{"_id":"themes/next/source/images/12b.PNG","hash":"56797abe3a2cccba00b05ec272fe5af8f9d88877","modified":1576217357200},{"_id":"themes/next/source/images/12a.PNG","hash":"7936e3d8716e102b288d81ba7641505a9a43828a","modified":1576217357040},{"_id":"themes/next/source/images/1555335982957.png","hash":"aaa69dcc00cb1070f3afd22d627768f20e80bb70","modified":1576217356640},{"_id":"themes/next/source/images/1555336042119.png","hash":"7c4c1345e842f360e047ff475eb64eb0c6b02220","modified":1576217356260},{"_id":"themes/next/source/images/1555336181441.png","hash":"ba395552f646ff9a2e0b05aabfac2c61ed7bbfdb","modified":1576217355630},{"_id":"themes/next/source/images/1555337368613.png","hash":"0c513d185786bc7318770d92f75cde40562c534f","modified":1576217356060},{"_id":"themes/next/source/images/1555336839432.png","hash":"699fbc1065438c1e67c665f4d7f00e0980d89b61","modified":1576217357210},{"_id":"themes/next/source/images/1555337410546.png","hash":"2a464dfe05d89059a1668600abe267f9b8b775ac","modified":1576217356540},{"_id":"themes/next/source/images/1555337487973.png","hash":"67ab08e2f5e6dc6ff8b6a5f2f9e41eb6773fbd20","modified":1576217356860},{"_id":"themes/next/source/images/1555338108853.png","hash":"5d052687aa0da02536880ab02f393eb743f5402f","modified":1576217357240},{"_id":"themes/next/source/images/1555337786084.png","hash":"fa49c803a6f13781ac2d1f5e538cb7af804808bb","modified":1576217357630},{"_id":"themes/next/source/images/1555338066598.png","hash":"a90332a668c0290f7983ac52703fe0d83b045f22","modified":1576217356080},{"_id":"themes/next/source/images/1555338210270.png","hash":"0964af81d4b077217e3b714c80c04687a0c74244","modified":1576217356250},{"_id":"themes/next/source/images/1555338281068.png","hash":"27b201f2a49ccfee7a3d954e47e098d53518221c","modified":1576217356470},{"_id":"themes/next/source/images/1555338199372.png","hash":"0964af81d4b077217e3b714c80c04687a0c74244","modified":1576217355810},{"_id":"themes/next/source/images/1555338141910.png","hash":"296ac3ab01fddef235e75a640147ab2cdebc3247","modified":1576217356190},{"_id":"themes/next/source/images/1555338761379.png","hash":"cc550f8af4cc45307c2a715b2d57b1667b0d1896","modified":1576217356730},{"_id":"themes/next/source/images/1555338670472.png","hash":"c103edbd24f552eb4d699bb2c0e690902793878c","modified":1576217356680},{"_id":"themes/next/source/images/1555348996560.png","hash":"1b8c457f47f9255d5a5378f1901afbb28e2bc871","modified":1576217356510},{"_id":"themes/next/source/images/1555349943322.png","hash":"1bb56178939eb2481d37899af8ed20b2cd3d5f7b","modified":1576217357040},{"_id":"themes/next/source/images/1555348366529.png","hash":"e89e3dd2127caf61eaa42e260def7e93787fede2","modified":1576217356870},{"_id":"themes/next/source/images/1555350134801.png","hash":"47424d9466dc333f625e2f96d126dab102108c3c","modified":1576217355740},{"_id":"themes/next/source/images/21a.PNG","hash":"892b3a2ec9e405e9dc1f5a75710b244bb383ca98","modified":1576217355850},{"_id":"themes/next/source/images/21b.PNG","hash":"cebc023c2abdcc10f95460bda73789cdc62ae803","modified":1576217355630},{"_id":"themes/next/source/images/2.png","hash":"5c6ca1cc13170a2283a8e54a1853ae7abf561ff3","modified":1576217357390},{"_id":"themes/next/source/images/22a.PNG","hash":"93b314958b05acb216d3e7fe8adfa4036a7aed2a","modified":1576217357450},{"_id":"themes/next/source/images/22b.PNG","hash":"ca739596b82b861e00f1c860e2eb3dbec0b3499c","modified":1576217357570},{"_id":"themes/next/source/images/3-B树.png","hash":"c8acd74146e1d9f3ba04006494d541a04261b235","modified":1576217357450},{"_id":"themes/next/source/images/3-不用索引.png","hash":"ee536176bb786472ed20857b71caa7ba01b433ee","modified":1576217355690},{"_id":"themes/next/source/images/3-位图.png","hash":"5294ee0f04e04c869855b94f4c02881a310e2ddb","modified":1576217356860},{"_id":"themes/next/source/images/3-强制B树.png","hash":"915c0050b8b6633a7acb26061a589946877b9782","modified":1576217356640},{"_id":"themes/next/source/images/31a.PNG","hash":"64fd6307630bf233468d805d2a898eba02f6e788","modified":1576217356250},{"_id":"themes/next/source/images/3-强制位图.png","hash":"cce241f03c942ddfa01266d71f1dbd070262d357","modified":1576217355620},{"_id":"themes/next/source/images/31b.PNG","hash":"8dcbaf6daf2ae8272e207c78503f441da76a8aaa","modified":1576217356380},{"_id":"themes/next/source/images/3.png","hash":"59d4557e45f12e91978c6ac2fb4b4d4471be1922","modified":1576217357500},{"_id":"themes/next/source/images/32b.PNG","hash":"bb6e75443de306528ebf56e44a4ac6a91474ee8a","modified":1576217356970},{"_id":"themes/next/source/images/32a.PNG","hash":"baa7764c3ec8c7db6102ec1baca23cec60c992f8","modified":1576217357070},{"_id":"themes/next/source/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png","hash":"ecd04a231dd7ca6c7f94dce25c67f2839c8b4c54","modified":1576217355650},{"_id":"themes/next/source/images/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1576217356130},{"_id":"themes/next/source/images/527DE0D27244EE625AD2D099AACDF4BA.png","hash":"ecd04a231dd7ca6c7f94dce25c67f2839c8b4c54","modified":1576217356250},{"_id":"themes/next/source/images/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1576217357160},{"_id":"themes/next/source/images/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1576217357610},{"_id":"themes/next/source/images/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1576217357570},{"_id":"themes/next/source/images/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1576217356340},{"_id":"themes/next/source/images/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1576217357560},{"_id":"themes/next/source/images/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1576217357660},{"_id":"themes/next/source/images/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1576217356620},{"_id":"themes/next/source/images/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1576217357280},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1576233072162},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1576233072161},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1576233072161},{"_id":"themes/next/source/images/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1576217356520},{"_id":"themes/next/source/images/bitbug_favicon.ico","hash":"2d3dff76c81475205cbc00ef8540259e42b2793f","modified":1576217356250},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1576233072160},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1576233072159},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1576233072158},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1576233072159},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1576233072158},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1576233072157},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1576233072157},{"_id":"themes/next/source/images/detail_3.2.png","hash":"b35ac465cf7e081162548d763a9c7bb7a34298e6","modified":1576217356360},{"_id":"themes/next/source/images/detail_index_3.2.png","hash":"911c17e7c64986e48548daef4e5b05047877cc18","modified":1576217356670},{"_id":"themes/next/source/images/exec_detail_no_index_2.png","hash":"c3fffbba3e88988aaf28b07bd8314e6f751901b5","modified":1576217356830},{"_id":"themes/next/source/images/exec_detail_no_index_1.1.png","hash":"4fd0035653c343a7828967a6d5252acf8b787abc","modified":1576217356340},{"_id":"themes/next/source/images/exec_no_index_1.1.png","hash":"cbf349bde780f11a01987c394d4ed58997a8f0e7","modified":1576217357430},{"_id":"themes/next/source/images/explain_2.png","hash":"adf95ba80e751d16b663c78c916647ffed19c333","modified":1576217357090},{"_id":"themes/next/source/images/explain_1.1.png","hash":"00777ccffa6b768387568a5e0342745121e7c41d","modified":1576217355950},{"_id":"themes/next/source/images/explain_3.2.png","hash":"39906f90abef86cae35688f5968c0ac183d05171","modified":1576217356120},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1576233072156},{"_id":"themes/next/source/images/explain_3.2_index.png","hash":"654001df395d4f4a5d484022c2dc82e11153d5be","modified":1576217357050},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1576233072155},{"_id":"themes/next/source/images/image-20181018143452887.png","hash":"0b7d690e121dd28843d212ac0e1bb69909a8b428","modified":1576217357220},{"_id":"themes/next/source/images/image-20181027232418408.png","hash":"58f47f5a197a3a114a5b96e060a882bb9a28b9f8","modified":1576217356060},{"_id":"themes/next/source/images/image-20181106214511931.png","hash":"6320227904228be1751b964c0f399e935cae17f9","modified":1576217357550},{"_id":"themes/next/source/images/image-20181231170852678-6247332.png","hash":"5fde7340ead8be22644d14ada427d9726db3b954","modified":1576217355660},{"_id":"themes/next/source/images/image-20181231170852678.png","hash":"5fde7340ead8be22644d14ada427d9726db3b954","modified":1576217356570},{"_id":"themes/next/source/images/image-20181231170913607.png","hash":"226b12ead6f15edd92b5dc53c3a214c95d3c4b18","modified":1576217357080},{"_id":"themes/next/source/images/image-20190114004746346.png","hash":"38920bb5ef1d804b7a16865bc582bb7196d57440","modified":1576217357180},{"_id":"themes/next/source/images/image-20190114060005845.png","hash":"b76c84f22ac83621bb24ac90f1e90ea11c69eb15","modified":1576217356460},{"_id":"themes/next/source/images/image-20190114052126486.png","hash":"2a0fddef7b5e64b09876a53e6c349318267b7d20","modified":1576217355690},{"_id":"themes/next/source/images/image-20190225225802212.png","hash":"5197f65bc0f66869ddd1d15b98e8be028a6dd8ab","modified":1576217356820},{"_id":"themes/next/source/images/image-20190225230110077.png","hash":"e89db87abe4854adb2bbf4deee56e16db6a82e19","modified":1576217355810},{"_id":"themes/next/source/images/image-20190225230647640.png","hash":"2a6867e463ccf575239ae49ab8b9dc42b1604f85","modified":1576217357140},{"_id":"themes/next/source/images/image-20190225225057306.png","hash":"cba04373f73979243bdc4b20769b0367e9ba8d52","modified":1576217356670},{"_id":"themes/next/source/images/image-20190225232407098.png","hash":"537ec1cd67eec992ba3dbc036fccda638c1c4ba6","modified":1576217356760},{"_id":"themes/next/source/images/image-20190225232630665.png","hash":"c58dfac3369b73d936cbbc73e7c08fff5da6ad06","modified":1576217356940},{"_id":"themes/next/source/images/image-20181231170913607-6247353.png","hash":"226b12ead6f15edd92b5dc53c3a214c95d3c4b18","modified":1576217357460},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1576217356560},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1576233072155},{"_id":"themes/next/source/images/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1576217356680},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1576217355570},{"_id":"themes/next/source/images/qcode.jpg","hash":"4a34ca272f342fc86ee769b6c998c320f3bbdec8","modified":1576217355700},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1576233072154},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1576233072154},{"_id":"themes/next/source/images/image-20190225232204967.png","hash":"a2893b2fbc7a416ccd5aa899cd12c1f2314b55be","modified":1576217357340},{"_id":"themes/next/source/images/sns-qrcode.png","hash":"e2c026527fbf1393caccdd2f8e44bac437232184","modified":1576217356560},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1576217356200},{"_id":"themes/next/source/images/rssFeed-bg.jpg","hash":"152d21e2a733e94c8a2c726fca8b2555b3d05979","modified":1576217357440},{"_id":"themes/next/source/images/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1576217356970},{"_id":"themes/next/source/images/time_3.2_4min.png","hash":"731b50cf2b291b96e4bcd9a0d23564d5223ea715","modified":1576217356440},{"_id":"themes/next/source/images/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1576217357650},{"_id":"themes/next/source/images/修改字符集3.png","hash":"5961454b3b175beca253e9ef948b28ce3a480aed","modified":1576217357560},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午10.54.29.png","hash":"6fa85c878a609b5eab1db6119d02b5defd9fe5e4","modified":1576217356820},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午10.56.20.png","hash":"dfc18fd8f6839ce4b7e7f0db1d959ca9e6d7f305","modified":1576217356730},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午7.21.45.png","hash":"1bead84ca59dbf78741efa96d0f2216ef2f2afbf","modified":1576217356940},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.14.59.png","hash":"c9c9f7ad911d820fc4aa5ecde82fa22cd60b7cd4","modified":1576217356140},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.32.45.png","hash":"b606062aabcc3497ed220565a0e7b130b692fac0","modified":1576217357360},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.35.11.png","hash":"bc26e60b10008d47b49dab7ce8d59d59bfe9954a","modified":1576217356740},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.37.07.png","hash":"1b46c5de1acc5c0c9088d704d21da315dee58f62","modified":1576217357000},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.38.39.png","hash":"fea59cfe1743f0389c22733e40b62129c1bd530d","modified":1576217355860},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.37.57.png","hash":"addb7a8d340666d79ce229f0630c292edb854316","modified":1576217355640},{"_id":"themes/next/source/images/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1576217356100},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.33.27.png","hash":"9a90ea2824eeb2c8dbf4465c5cb29e8c330e0387","modified":1576217356750},{"_id":"themes/next/source/images/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1576217355990},{"_id":"themes/next/source/images/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1576217355670},{"_id":"themes/next/source/images/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1576217356980},{"_id":"themes/next/source/images/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1576217356240},{"_id":"themes/next/source/images/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1576217357160},{"_id":"themes/next/source/images/锁.png","hash":"5895d667aa59fe92893c218f6786b3cd5a34069d","modified":1576217356240},{"_id":"themes/next/source/images/锁2.png","hash":"ed058f7e03baf67ddf14f7bc26409e89c014fe75","modified":1576217356010},{"_id":"source/_posts/assets/image-20181124205409162.png","hash":"5b4e6f4268341bf68e22009f3ca1fbb2a79b41af","modified":1576217299900},{"_id":"source/_posts/assets/image-20181124202306595.png","hash":"0d21aa7820b75b70df53adcd709a4ed6a1bb4189","modified":1576217299930},{"_id":"source/_posts/assets/依赖无倒置2.png","hash":"208f916343fc8d926f4c5af96e65a1f5186267b6","modified":1576423965426},{"_id":"source/_posts/assets/锁.png","hash":"5895d667aa59fe92893c218f6786b3cd5a34069d","modified":1576217299920},{"_id":"source/_posts/assets/锁2.png","hash":"ed058f7e03baf67ddf14f7bc26409e89c014fe75","modified":1576217299900},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1576233352575},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1576233352575},{"_id":"themes/next/source/images/%E6%9E%B6%E6%9E%84.png","hash":"8347ee81110ebd4c47fa3dd2cc771da88a17679c","modified":1576217357540},{"_id":"themes/next/source/images/1555228253075.png","hash":"23a3500e9d3e1fa72862491767a1684f6af61259","modified":1576217356550},{"_id":"themes/next/source/images/1555228331186.png","hash":"d3e83b4f78b7de7f415967ff197477097501d1d4","modified":1576217356410},{"_id":"themes/next/source/images/404-bg.jpg","hash":"85480e340d2af57c4e4b3ae93525ed608ea343b7","modified":1576217357240},{"_id":"themes/next/source/images/2-B树.png","hash":"a446c6e1298930ab7102ed0f9d0eac62d1fd566e","modified":1576217356700},{"_id":"themes/next/source/images/2-位图.png","hash":"51aefaeb23baf090b96c46bb9c01737f30f4334f","modified":1576217355710},{"_id":"themes/next/source/images/5-4-1.png","hash":"547eaed4886791bd648bc37a74b9c87cd2687d70","modified":1576217355680},{"_id":"themes/next/source/images/bVbjaD6.jpeg","hash":"eadd9d52556e1f892ee7714622a872b753233616","modified":1576217355850},{"_id":"themes/next/source/images/donate-qr.png","hash":"28c94ec4dbdebc791ab9fc614ed533ca260832d4","modified":1576217356810},{"_id":"themes/next/source/images/exec_no_index_2.png","hash":"6de66a98dc4067429651be98f625c5008d422a44","modified":1576217356680},{"_id":"themes/next/source/images/hive_textfile1.png","hash":"3f5b6f68d42e0a9b578d99a201b4d355f9345adf","modified":1576217356420},{"_id":"themes/next/source/images/image-20181018140412582.png","hash":"090319ea8d21caf98b86c00222f3c6b7e33d375b","modified":1576217356450},{"_id":"themes/next/source/images/image-20181018140355729.png","hash":"5937f8b028b627573f67292745cb470f554c9d4a","modified":1576217357080},{"_id":"themes/next/source/images/image-20181017150353887.png","hash":"fd38f6b10371f949b67e0d81a7b1db66c4337614","modified":1576217357220},{"_id":"themes/next/source/images/image-20181019161615728.png","hash":"19158acac278754e67148fe8592dd49208c23149","modified":1576217356740},{"_id":"themes/next/source/images/image-20181027150507907.png","hash":"f520608e002d2975a9ce14290c514903f7f7065e","modified":1576217357270},{"_id":"themes/next/source/images/image-20181124205409162.png","hash":"5b4e6f4268341bf68e22009f3ca1fbb2a79b41af","modified":1576217355850},{"_id":"themes/next/source/images/image-20181124202306595.png","hash":"0d21aa7820b75b70df53adcd709a4ed6a1bb4189","modified":1576217356320},{"_id":"themes/next/source/images/image-20181228192741706.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1576217357230},{"_id":"themes/next/source/images/image-20181228192905376-5996545.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1576217356460},{"_id":"themes/next/source/images/image-20181228192905376.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1576217357670},{"_id":"themes/next/source/images/image-20181228201105314-5999065.png","hash":"688c03a69ca9f54ddbeba8ca24239539e3985e93","modified":1576217356980},{"_id":"themes/next/source/images/image-20181228201105314.png","hash":"688c03a69ca9f54ddbeba8ca24239539e3985e93","modified":1576217355940},{"_id":"themes/next/source/images/image-20181231003438922-6187679.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1576217356270},{"_id":"themes/next/source/images/image-20181231003438922.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1576217355970},{"_id":"themes/next/source/images/image-20181231003442918-6187682.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1576217356970},{"_id":"themes/next/source/images/image-20181231003442918.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1576217357210},{"_id":"themes/next/source/images/image-20181231003513281-6187713.png","hash":"fa2c773ad6c3d1c4ad93a7b28b13564a3fb7e1e2","modified":1576217357220},{"_id":"themes/next/source/images/image-20181231003513281.png","hash":"fa2c773ad6c3d1c4ad93a7b28b13564a3fb7e1e2","modified":1576217356430},{"_id":"themes/next/source/images/image-20181231170937495-6247377.png","hash":"51b59aaa9b07ded242ad5ca1d60b23e1503c8ac8","modified":1576217355960},{"_id":"themes/next/source/images/image-20181231170937495.png","hash":"51b59aaa9b07ded242ad5ca1d60b23e1503c8ac8","modified":1576217355650},{"_id":"themes/next/source/images/image-20190113193023545.png","hash":"b2c97c37f8467ae3c005525dd88e14b4d4178447","modified":1576217357380},{"_id":"themes/next/source/images/image-20190114162624572.png","hash":"8a144a0b835e9ec0eea6f3e47a168d13801298c0","modified":1576217356790},{"_id":"themes/next/source/images/image-20190308105552914.png","hash":"a8cf85efc22a597142afc6081e0e6f5171752fbe","modified":1576217355570},{"_id":"themes/next/source/images/image-20190414155203979.png","hash":"f4543ff3ff0db8055b231f376737307163ab20c3","modified":1576217356210},{"_id":"themes/next/source/images/image-20190414161020200.png","hash":"c98e023034650e7cf23654bc92d5e0491df12662","modified":1576217355960},{"_id":"themes/next/source/images/修改字符集1.png","hash":"0c65e51806684dc45ebec4bc2c554db8c9df119b","modified":1576217357550},{"_id":"themes/next/source/images/修改字符集2.png","hash":"159e6d283c47cf5a671348315161b61e4c0dbcf7","modified":1576217357650},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午11.44.33.png","hash":"651eefd3c9ce973220951589bbcb9d5973ff32ed","modified":1576217355720},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.48.45.png","hash":"c43b075fccdbe11d72eabcfe4aadb06ac5d0b0a1","modified":1576217356020},{"_id":"themes/next/source/images/屏幕快照 2019-01-12 下午11.28.38.png","hash":"356ef205df665d5259aaf90c029d5a722dd3293f","modified":1576217356530},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.50.07.png","hash":"595af55cd3d656d30d93e7408d2f25ea03249ac6","modified":1576217357670},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.08.43.png","hash":"7479a6180e5e7f7a013235308c4df0f8588516e1","modified":1576217357060},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.25.22.png","hash":"c50734ef38ca556b2d763ecfa81723b3e36236ff","modified":1576217356390},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.35.22.png","hash":"edcf93540fad881a8f1665e7cdc397e4ce744717","modified":1576217357470},{"_id":"themes/next/source/images/查看执行时间.png","hash":"bdb350fbcf25aff587f362bd646ba7e52a3a91bd","modified":1576217355730},{"_id":"themes/next/source/images/表1.png","hash":"3463cef1af20c2064d7ca428849273546721b8b1","modified":1576217356210},{"_id":"themes/next/source/images/表3.png","hash":"4f9e8cd46107699e3b343fcab465b29d610637fc","modified":1576217356000},{"_id":"themes/next/source/images/软件过程框架.png","hash":"8a0c6404277f8ed485e55eaafb79cf8cead5c3ab","modified":1576217356130},{"_id":"source/_posts/assets/image-20181126025537963-3172138.png","hash":"acccdbabca03c381de0109abfc69f78f51b99c27","modified":1576217299940},{"_id":"themes/next/.git/refs/heads/master","hash":"bff089200082223016535b3e2c921222dd89e124","modified":1576331528918},{"_id":"themes/next/.git/refs/tags/v7.7.0","hash":"b36294c4a5df9cb1df8e582752dee5d4821aad00","modified":1581398337143},{"_id":"themes/next/.git/refs/tags/v7.7.1","hash":"88c02f7029cb659858b0e0554b79fa64e9f64494","modified":1581398337145},{"_id":"themes/next/.git/objects/00/9931796ddb5059311305d6bdfc0d7ce7c1e8a9","hash":"57f8fcb82e2e18486f0ffa2806ff23d1709e325d","modified":1576331518331},{"_id":"themes/next/.git/objects/03/60fda3d13fb574344da952b72f2c175df0780c","hash":"80cd82a98dda216a448bb19b3b80909bb0c178fc","modified":1576331516876},{"_id":"themes/next/.git/objects/01/7dac332ccf0f1b8c9beca5e7f27aee1783b825","hash":"53e34469be428b05113800ef39317c8fd230dd46","modified":1576331516940},{"_id":"themes/next/.git/objects/07/ea82f9dfb4d7571913cf82a09c409cbc00ab31","hash":"5e3b45754c66be10424c519112a5898662fbd83e","modified":1576331518390},{"_id":"themes/next/.git/objects/08/65e40666c6813d0c477171e4897d5de1d6a69d","hash":"7f08baa640610faf6a3a62994fae1a91b1edab82","modified":1576331517000},{"_id":"themes/next/.git/objects/0f/257807c3cd471dc7d6b7093eb47cf938ecb6df","hash":"8b6befb3e22f641e8e40e16fa18a84506f48e04e","modified":1576331517094},{"_id":"themes/next/.git/objects/10/a164517cb3c5a52c70f29d316cc2c4ea9563dd","hash":"137b27a334ba4a2b4aad94f156cb7bb897e43a75","modified":1576331517934},{"_id":"themes/next/.git/objects/1d/f21647c8fa0fbcd56da8ecd1083465b633f92b","hash":"289e5ad61f5e18a6580e97f92ff935ad174f86d6","modified":1576331516942},{"_id":"themes/next/.git/objects/1c/02eb8bf05d04f131b8a34c26f68158da09eb59","hash":"dff7e9a181acc0e3d0da02c1a8059960dca8dcb8","modified":1576331517337},{"_id":"themes/next/.git/objects/27/6d3c7e74bdc86383cb4db14cfa9c8da0603379","hash":"7bb366814034016b16f23bea1bb351b93d7f5dc3","modified":1576331517852},{"_id":"themes/next/.git/objects/26/fd8767a08bcbf2f085d4a721622f54313d9616","hash":"a22cc2cf69eebd315ce6d67f1ee54b808bbf8f22","modified":1576331516950},{"_id":"themes/next/.git/objects/2a/0a308336502aabcf50b171c7891ab2147b8512","hash":"321c5ff9918edafa355043a0e1a859c15c3a4498","modified":1576331516879},{"_id":"themes/next/.git/objects/17/cbf24b4d66c7692e7fff02cefd188f9aa21c25","hash":"7a48b90bedb1597332fdad377ab6a0cf722aec0f","modified":1576331517120},{"_id":"themes/next/.git/objects/31/4d44c170e21370be37b6f9e0ed8bda46da884e","hash":"9a695323211c74906203ba24abaf9499b8974c3b","modified":1576331516885},{"_id":"themes/next/.git/objects/31/5a240e0a89caafa1e1638fa6f0ca97da4b71ce","hash":"90dca085fbf512e8e29cb8f3bcb285316b4a16e0","modified":1576331517965},{"_id":"themes/next/.git/objects/33/fcefe9fe077f295c895f82af1ae9b7d8049b7f","hash":"d77cc3f5e26185db6dc6957fe1c2c9196b2a1190","modified":1576331516947},{"_id":"themes/next/.git/objects/32/01721eec702bf20f4f1c9cc0e04bfb082ee8b6","hash":"546232b40f4e107c1338856955c441e4ce8a04f8","modified":1576331516892},{"_id":"themes/next/.git/objects/3c/6d13b01189ff0f0c9d151cf8ff6ccf651425d3","hash":"c02b337f7a93e17708aebeb2e0e58075dbaa0d61","modified":1576331517550},{"_id":"themes/next/.git/objects/3d/1fb58f9716ef4e9d19d1806b81d6b9ffbfa41d","hash":"6b37b5ef902738665a1374a20c7d3dacdfa02ee1","modified":1576331517122},{"_id":"themes/next/.git/objects/3d/880e8dd07dbcf80e5b7c8e4ef59ef5aca8e694","hash":"c8a0df5e6444a0f3a0a7b61a4521b87e83635075","modified":1576331517340},{"_id":"themes/next/.git/objects/29/d246561d02b80938892ffc9032c8b66a2cd3aa","hash":"2481882188e054042175c4a3cbcb050ecd15ce07","modified":1576331516822},{"_id":"themes/next/.git/objects/3f/695726a4e810f39b41fb251c50cc746218bbb8","hash":"2885e9ec37c1e66660c9858cd45b24625517b613","modified":1576331528912},{"_id":"themes/next/.git/objects/3e/dbbce2d6e06822aa92cd8aeb84090d3014fbda","hash":"137084ca070db0b7baae60ad0effdb0eac263a0a","modified":1576331517209},{"_id":"themes/next/.git/objects/39/ada7701f9f8f75451bb1c5d63693aa2e6a37b4","hash":"cdddc1bef5baf6024ab34f5d05cbaf0a1fa17153","modified":1576331516952},{"_id":"themes/next/.git/objects/47/6a6ace3a3aad99836c206ed31c78ebc6f3bea0","hash":"13d2217c25e78e7eb57d6023dc725f1e594943f7","modified":1576331516955},{"_id":"themes/next/.git/objects/3e/612e92fd702e51e167c59646d6e594e03e785b","hash":"a9c4e76aa8146ee7b241ecf38695ad4a8b1b6273","modified":1576331517000},{"_id":"themes/next/.git/objects/4a/084e0cd9d2de6c4387243a583257bab60cc0fb","hash":"52fa222ed0ed5fe35034805432f1b8e0bccd553c","modified":1576234271818},{"_id":"themes/next/.git/objects/5b/b7372c9d760d5802a6becf91759b25904b4baf","hash":"6842b605313e3ba70e84114d358bde71fb2de833","modified":1576331516958},{"_id":"themes/next/.git/objects/40/396ea1eef6da29be7529716605275927927b1d","hash":"e203bd16c3417a30115f0d21d249d274e27efbeb","modified":1576331517175},{"_id":"themes/next/.git/objects/5c/ae3c96437ff0f611de10133db9f9696767eea3","hash":"091989ed7b1713d4bbe3480301c689e297231689","modified":1576331517000},{"_id":"themes/next/.git/objects/5e/7c4237cd0ff5cfefaee76cf18ed7c9e10661b6","hash":"cca7b4008b9b1db0d23b892d875180dc1bdaa8e6","modified":1576331518052},{"_id":"themes/next/.git/objects/54/56678f5178dfd828eff6c16b8bfcb974e5530d","hash":"dca7e875c63da45d2ad61bb623db43e311ab4fa6","modified":1576331528917},{"_id":"themes/next/.git/objects/60/f65f9692426c39d00e4df73297f6dc4d618ddd","hash":"4b2bd893123d6eab967007ed68a633125a9451de","modified":1576331517417},{"_id":"themes/next/.git/objects/48/e2a60c7f541d311edd2748ca2e685132a4d194","hash":"77bce669a8a2f8dc349e5fbe2be5a4be98e74265","modified":1576331516903},{"_id":"themes/next/.git/objects/69/4529c5a21ae38f5b163667cf464d7f14420252","hash":"4471e80fa957cda4f7ad8c30b079e048e2de79d5","modified":1576331517957},{"_id":"themes/next/.git/objects/6a/804aba90a641bf34b52403306a25ee543f2de9","hash":"6f84d436ccf6dcc97a3170e82b6384b2c0a85526","modified":1576331528910},{"_id":"themes/next/.git/objects/69/c35ef29bc58937edcd95afdb0ef39a867195cb","hash":"04a55910bb1851907b24779195515ce6d6e1e629","modified":1576331517800},{"_id":"themes/next/.git/objects/6a/6d2efb586e08694b4e9995cc3230fbfde6c517","hash":"878f768839811abfba3c332a7e0227c5b468feae","modified":1576331516938},{"_id":"themes/next/.git/objects/6d/7e77d7c57ad773bb72ba0a6bc103e1d012b946","hash":"1073797520d7dc39c67c2aafb19840109e4c6ceb","modified":1576331516884},{"_id":"themes/next/.git/objects/72/7377d25ab0936f146433458b82fb38185b7dd8","hash":"c3794989bc80a8360adbc6546f9d7db33fc0c6d7","modified":1576331517840},{"_id":"themes/next/.git/objects/6d/c996927afc635bd978a3f90a86f2218bbe7c40","hash":"bb0430886a85f41bb649ac52a3ee54881ef2bf8c","modified":1576331518322},{"_id":"themes/next/.git/objects/66/28b5406c5ed7eac48bc9b80e68dcc6dd3da1bc","hash":"91b8daaa6e2b591ec787098e769e6b6457dbb61c","modified":1576331516932},{"_id":"themes/next/.git/objects/72/c86586578d69b91fe5a3611cd66c84b6517f88","hash":"8418dd6cdd565f152f5c7904de63f674194f9de4","modified":1576331517195},{"_id":"themes/next/.git/objects/66/fd6a85afd0c1e9ccdde369a0de90bc524cad51","hash":"bcab73e0f760543870a91f6533a80257a74f8eb6","modified":1576331518271},{"_id":"themes/next/.git/objects/73/802aa9033642182e3738e4259f87299ad88dcf","hash":"987bab01a1ec37a3b3e80ae3ce42ae79a41a4f88","modified":1576331516935},{"_id":"themes/next/.git/objects/73/8ea0e9860cc719a2508cdc3945e1a1a4487a06","hash":"48c2d13442e98ab7a48d85a6f1ab5a4bcbbfcb0c","modified":1576331518268},{"_id":"themes/next/.git/objects/7e/62990ad58c18c03a9b820cfc9c2e8c1f817540","hash":"cce41939d176a1ebf47b4fe4b53ba476004bd7a3","modified":1576331518347},{"_id":"themes/next/.git/objects/76/9f37c5a42d77d581879de650105e17f73f9a2e","hash":"17a558342046624ebf3ca28708bb80ad9a007c7e","modified":1576331516907},{"_id":"themes/next/.git/objects/82/444232e8232e4dbb211882b81d07fdab0fa1b8","hash":"db3b174ee84e8701f3e45d002ad061c77eb93230","modified":1576331517128},{"_id":"themes/next/.git/objects/7f/4823153f242e54460775915d5a0eb6f2ccce35","hash":"ef5e05aa329d4a5f06d2c2e4de07b7d6a90b35df","modified":1576331517794},{"_id":"themes/next/.git/objects/86/b91e85e2697da19922eba2dd54ea48e19c406e","hash":"fcbd8397214a3c9f789833a6c49b78ce76eaa4c5","modified":1576331516954},{"_id":"themes/next/.git/objects/87/d306af92dc284a2740b8bbe409292db67deea2","hash":"6fdf55027de50db9635b9ec84f789e9062c61f1c","modified":1576331518388},{"_id":"themes/next/.git/objects/8a/2130026c11339a4016b587f6e9ed9229f25203","hash":"a2cc853eb0559af4f9cf0222100927f9862a10fd","modified":1576331517963},{"_id":"themes/next/.git/objects/8b/10f3484265072308f9ff8639a26f5fb80ec22d","hash":"1496878ac25eacf0f90ea4aa63ca43635e0b1cc9","modified":1576331516913},{"_id":"themes/next/.git/objects/8c/fbf4e312804ce61753432fd39ebe853ef5d8c8","hash":"4b95b64bba04f3f6fbc173d8dba2d2254426ebbd","modified":1576331517334},{"_id":"themes/next/.git/objects/8f/62eb4d08861cd72d8cd7b41a8b510dfce75251","hash":"5e1e58a7354b99fda177849a0bdc1df6648c53c4","modified":1576331528911},{"_id":"themes/next/.git/objects/92/14d4a381d4881bf709867ba4d8d1dd581ea7cb","hash":"02cc75d5eb54fba8ed37a8927a038362f4fe243e","modified":1576331518159},{"_id":"themes/next/.git/objects/92/25ed1d8fd8cbccfd46a32bd52ec1b3f145669d","hash":"54c5291cf9bb9b287e746dc109c8fde8a28f7b41","modified":1576331516900},{"_id":"themes/next/.git/objects/93/c6c1c683e1f220b2338467b86ef24c88f8894d","hash":"75dc9ec6940d96acf9181aee16a6a735515d022d","modified":1576331516889},{"_id":"themes/next/.git/objects/98/27d656c8f6744ec65e428dd25b29caee380659","hash":"3242c66a06ac1af71c2a66ba1d137b3b1834a192","modified":1576331517189},{"_id":"themes/next/.git/objects/a0/9e78a8375b076203300d387695c5454614eaaf","hash":"e53df827550b8943507ca26bcc81a570a5e0c6ef","modified":1576331516870},{"_id":"themes/next/.git/objects/9e/e7216dd362a390433f93511a4b8f9fcee9b8f9","hash":"750cff90cd840070cfafd4fa8db4ee8669fdd538","modified":1576331516881},{"_id":"themes/next/.git/objects/a0/b1d83d8930e754cc0b1116d51e61b1157bdfb4","hash":"3f0a3f1fd85eb04f2bebeeaf1c423a50554c3d63","modified":1576331518265},{"_id":"themes/next/.git/objects/a3/35bb91a6d6bfa995bc526c9316cde0f0ea58b4","hash":"aef5f179f4ee0bd3c45688f301038df186d9fdb9","modified":1576331517843},{"_id":"themes/next/.git/objects/a3/a4ffd11261fbfdef10da2368fb09a56e61867e","hash":"00406f6a36644b6383477db396dbb9df8a3316bf","modified":1576331516000},{"_id":"themes/next/.git/objects/a4/ee1245e3eb3ffc23b5a1f47ed000b2345d25f0","hash":"fd00b4fc9f3f0154dd320894ce380ee9c684af5b","modified":1576331517845},{"_id":"themes/next/.git/objects/b0/00263ffabb42b2ed70ca353155b7d12ff13a56","hash":"908668b318553bfc15b14a0791fcca0d708ba272","modified":1576331516945},{"_id":"themes/next/.git/objects/ad/dd4a59ff8c8663cd474c36809beabfa95734bf","hash":"9071f58033940741a37b6fe1f7e3d2b9e8a8005b","modified":1576331516911},{"_id":"themes/next/.git/objects/b3/0ac1d211c6ecb23882dd20426104914b2b8e05","hash":"27ba64d2b7b932ba7045db1f6b3e5b0c076e8edb","modified":1576331516934},{"_id":"themes/next/.git/objects/b4/e4e37fc838410bc481acc3d5c061afa27ede43","hash":"45d0913a5febc8fcda5c9dc08c1505ceadc2c685","modified":1576331517580},{"_id":"themes/next/.git/objects/b6/05047b4b0438b265bf07ce5d7d04554a3ff854","hash":"7e3c23ee53ef8f11136eef08ef166182b62b95a1","modified":1576331516873},{"_id":"themes/next/.git/objects/7c/801ebc60a5f28f3706f969a25adbdb67c2b8d7","hash":"ab7ca4ab4ab681d3b3a136231d5cba94f23f3a9f","modified":1576331518258},{"_id":"themes/next/.git/objects/7c/ffe7ba9bb1dd36a78c94e01711e5524b4cbb8f","hash":"bfdaa09a6c8d5742a0bfdf071420e8736f1a6cc8","modified":1576331517151},{"_id":"themes/next/.git/objects/bf/b9a0f1ccfb98a25c506c9a74461af9843bddca","hash":"0acac9812682a830cba09516c43a904e9eaef1eb","modified":1576331517154},{"_id":"themes/next/.git/objects/bc/cd691990a66ad2c308577511e8b1cf5c856b51","hash":"06a9d55b8c36cf378a81e9a2afc8009e799c4ac6","modified":1576331518262},{"_id":"themes/next/.git/objects/bc/74aa6b96b9f170137e9b2f985f01053116182b","hash":"9f2939053a197b550274dd38a9818b124b7a1999","modified":1576331517962},{"_id":"themes/next/.git/objects/bf/c3c2a25b7578e49d5b2554f9f859f5f52476b7","hash":"e0931d1e321f5a50d22c730e4adbfc045bc5f08b","modified":1576331518253},{"_id":"themes/next/.git/objects/c0/0ec76488e211ee63e9d1971aa79d2f9195c790","hash":"f7f27a6fa1fd62149ee4446b36b2ed9dcac00318","modified":1576331518345},{"_id":"themes/next/.git/objects/c3/d4033f19c64259b657b2e4651292935be7782e","hash":"17de8c8cecbfa67068eed0de853912179e6bf52b","modified":1576331516824},{"_id":"themes/next/.git/objects/c3/030a261908cda69f82396e13af65585bc9172c","hash":"297d7f9a20c60c2f00c6d19bfc4f9ae946ac9095","modified":1576331516828},{"_id":"themes/next/.git/objects/c5/0dfc9a6e9ec231bbfe251d41b6292ddcbf70a5","hash":"303dda58d4def2291ac045885232ee00f08b2a07","modified":1576331517125},{"_id":"themes/next/.git/objects/c7/75aeb1fd5c4ca0d895a8cf747f9d1f09fa103d","hash":"35481ca84db3f9462f00a2d6deb69ab639937ddd","modified":1576331516757},{"_id":"themes/next/.git/objects/c7/b34189039ab9972130da99dd6542cec6f2e539","hash":"d7578028575a3cfe22015dc60597272e87bbf658","modified":1576331517999},{"_id":"themes/next/.git/objects/ca/7e35a5f4eba38a59d672fc5a12109d816e9eff","hash":"181ed00aef7cd65f3953ac52113cecc396b18df6","modified":1576331517126},{"_id":"themes/next/.git/objects/c9/e9ba0f49266124ae1fadacc0705ec437fea24b","hash":"f36857a3acf78efedec61a779b856a5f47d920c5","modified":1576331517192},{"_id":"themes/next/.git/objects/ca/8ea8518bba2bac4469b8ce6fd082c18ff206ed","hash":"4a0920ef56b38712e48d604b29405403917d52fb","modified":1576331518379},{"_id":"themes/next/.git/objects/cb/1dc3afe995542b7c98818914c311b8b7e71a57","hash":"43497a92a2a0cde3ca382f0f2564139acb7f35c2","modified":1576331517152},{"_id":"themes/next/.git/objects/ce/3d95d5887f67b2bf131383ade5e30ee8ede474","hash":"b92cb74f727efb569fd56554154e1cc3eef81ac0","modified":1576331516957},{"_id":"themes/next/.git/objects/d1/efb7f069bdd32cf5fcee4e5c70aaf7967c73c3","hash":"8e531ed65677f70c49afd452db29959070bee1d8","modified":1576331517093},{"_id":"themes/next/.git/objects/cd/8c7f7bcb939d90fd046ba6b9b2d508ce951efe","hash":"87233c5567fec8b7bee20f1bf166cb8309e06edf","modified":1576331517203},{"_id":"themes/next/.git/objects/d6/ddfd7d208aea33d619c8bbcd99e77c6306ddf6","hash":"ce18086392a1085a97bd7f3fc947735528141b7f","modified":1576234271813},{"_id":"themes/next/.git/objects/dc/e453ede156ff25ebaa99aebc24a464118aeff5","hash":"abf4683441fd6e581b1ce4d6e4ba7e3a636169ae","modified":1576331516826},{"_id":"themes/next/.git/objects/e3/4bd666f001376f2ff81485b10fa2aa73213db7","hash":"dbe654f0ab16875b0a6a5a81d46bde5469824a6b","modified":1576331516830},{"_id":"themes/next/.git/objects/e2/e1cc1b9cadd42cb095eeacb2bbfc85c32bbf10","hash":"817b270e8c385e7f1716bf42e0925e9f43c8b968","modified":1576331517186},{"_id":"themes/next/.git/objects/e6/2b2477143b97f4bec775a185133e59fbbfc1c8","hash":"d578ce2676b84a9ef74e2f3e1de7ee0cd1c673d6","modified":1576331517000},{"_id":"themes/next/.git/objects/e7/9cace7126a7268af424a704a06fe36946caaf2","hash":"b3d3a88ba991db1830bebc6b45aaa4c50a4f28c7","modified":1576331516915},{"_id":"themes/next/.git/objects/e9/2851d282db5fa4b7a3472f3d80eb8a66bad63a","hash":"b9b2ef1ece25cb179bdf7c1e562aecee81102101","modified":1576331517207},{"_id":"themes/next/.git/objects/e8/a0be2a440b3e2184a22ee1c21f59ac8e191623","hash":"278ac65669f829d89d6409fc3b0ef50fdfcd8489","modified":1576331518055},{"_id":"themes/next/.git/objects/e8/c11f303083562885c5e8117b44f35fb3e4f512","hash":"275df93df60e09da89a7529583367683f06fc62e","modified":1576331518001},{"_id":"themes/next/.git/objects/e9/e6d788da6ee56a6097a150d345669f6ae60eda","hash":"04ea08201e0e0ca268ae31e7914daba722c74223","modified":1576331517123},{"_id":"themes/next/.git/objects/ec/08ba0f03a083463b2e851beed5f4f3e2c8b592","hash":"c226fc1b29f7c9aeb67f0d2fa94e5ef8c5c13ff7","modified":1576331517092},{"_id":"themes/next/.git/objects/e9/907ccab5343db343ba9b06d19d066af3f21129","hash":"f7a4953ccd22b57060e594e881955197addfc649","modified":1576331517975},{"_id":"themes/next/.git/objects/ef/4518d42eb7fdcee42c1612cd357a242b0cb8d9","hash":"5f932d72e2713e0de445d091b590f44f71bc6ffb","modified":1576331516937},{"_id":"themes/next/.git/objects/f1/75dd97dd20638993ca607c4d45dbdf48ecf167","hash":"686882cbf51ca7cd7e19543766b71f1bc9e4090f","modified":1576331518330},{"_id":"themes/next/.git/objects/ef/34317c3006ba8f68e162bb9f43e297d15ec679","hash":"e825548807b46363700226b7bf26ac85e8a981ef","modified":1576331517181},{"_id":"themes/next/.git/objects/f1/cd825e648c910ce088c71bce0677ed1e345655","hash":"b812a81f32b94d26e15cfde25c6d98a01d1e87be","modified":1576331516894},{"_id":"themes/next/.git/objects/f1/d73e4a074a30755cbdf5890a595ce5892015bd","hash":"392c1ffc59d780160688a0e8a289c42cb492557c","modified":1576331517847},{"_id":"themes/next/.git/objects/f2/8da1155ab012d69481a56e4c2c3f6fc67ed459","hash":"620d7946bd32e4d7bcdadcb7611ed6d5e15b0bb5","modified":1576331517854},{"_id":"themes/next/.git/objects/f4/33d231540311bc97d5e708abe19f74196cf1ef","hash":"142f7018e1fb553565a32ee0c8b95d753467be97","modified":1576331518269},{"_id":"themes/next/.git/objects/e5/8a92d1ab1efcbd02e363609ef155c3570e7a0a","hash":"f8ae90cd80472d191f0079b901c012b73847d4ef","modified":1576234271824},{"_id":"themes/next/.git/objects/f7/297019dd32a3a879a21365df6798b932f77c0f","hash":"473e330ab31a673c319d0ade1bb5fdb69da78e6b","modified":1576331517205},{"_id":"themes/next/.git/objects/fa/9c403b43032566bbfbbd078bedd54e8194db90","hash":"6536733bdc965d9eabd1143954f3bc23d3f0248b","modified":1576331516867},{"_id":"themes/next/.git/objects/pack/pack-163cb8d474c884fc2241092dded970ed4b4d0c21.idx","hash":"614c463f3756f5065a6723287ba6e7b9b18097f7","modified":1576475565097},{"_id":"themes/next/.git/objects/fc/7ee865265839518e328f9e3104f8294161478f","hash":"d73f93bf0b6db1151f27643777d7a34f39b71ac9","modified":1576331517797},{"_id":"themes/next/.git/objects/pack/pack-163cb8d474c884fc2241092dded970ed4b4d0c21.pack","hash":"8f35b0094c4e92d0186664701d9e5cf8bc4e77ad","modified":1576475565104},{"_id":"themes/next/.git/objects/ff/37bc29fdbf5e4926421669026fe8e400b790c5","hash":"7e21979c3dd93b30bb074d50aefcd7482a704e74","modified":1576331516905},{"_id":"themes/next/.git/objects/pack/pack-b988cab81c7fc761687086c6b357c076d371187d.idx","hash":"34d14048963b07f511bbf50e5a80c4daf4f7e374","modified":1581398337138},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1576233352549},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b205d72a56b1827681f0a260c266e0c02065fd08","modified":1576233352548},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1576233352549},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1576233352549},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"5ba0480c2dbb0626501c90c920be85ce2308103c","modified":1576233352550},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1576233352549},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1576233352549},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1576233352550},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1576233352550},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1576233352550},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"e24c4dd78f6e4adee0e7c15eb8bca12eb92452e4","modified":1576233352550},{"_id":"themes/next/.git/objects/f6/b3eb9be8b90402767b4752fecac4b1de0f8049","hash":"8b253dafe5dd82c5a5670a3e164f168aae16d65f","modified":1576331517850},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"1638483d2d2dad1da4c841a6fb9f6ee96b850187","modified":1576233352531},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1576233352532},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"0172055d118d1d7f4c8379c8495c1ee1aa50c7d9","modified":1576233352531},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1576233352532},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"bbf0c8e42491fac70f4f8165224f1d7d92a040d7","modified":1576233352532},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"e6076865dba066c5f0008e22217efb850d5af69c","modified":1576233352532},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1576233352533},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"54ba9508a901c295a02c8e34e9cece7c7dcad518","modified":1576233352533},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1576233352533},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1576233352534},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1576233352534},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1576233352534},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1576233352535},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"716b78cd90addc4216413719554721cb362b0c18","modified":1576233352536},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"78cb2077f50bc3b81130a516ffc04bc1fcea5834","modified":1576233352534},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1576233352535},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"d5a5f45ef0b41332cad069d263df2c449e2f1e7e","modified":1576233352537},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576233352538},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576233352538},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1576233352540},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1576233352540},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1576233352540},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1576233352540},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1576233352541},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1576233352541},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576233352538},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1576233352535},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576233352539},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1ef172bc041d6f6b6c8c642ea64496a188d79029","modified":1576233352542},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1576233352541},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"d3dc3e051e6816cdd576d00cc70b18b8a4c6a495","modified":1576233352542},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"0992d51dff4b8f4f4e69834c8cd1604593536c5d","modified":1576233352542},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1576233352542},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4d6f9e09ca4056ff6a5d4923e202126a75242183","modified":1576233352542},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1576233352543},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1576233352543},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1576233352544},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1576233352543},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1576233352544},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1576233352545},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"0ea0bac09b0747bc16fde852164c0eaab2efe02c","modified":1576233352545},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1576233352545},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1576233352545},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"4a7207c6f9ab0e56ea8f59aca3ed4c2cb2fb7450","modified":1576233352546},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1576233352545},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1576233352546},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1576233352546},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1576233352575},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1576233352575},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1576233352580},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1576233352580},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1576233352580},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1576233352580},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d4e817e2b238ace5d7ac568ce0c5380196a6d039","modified":1576233352581},{"_id":"themes/next/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1576233352588},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"52d139e6f3bc212c8c9b71bc9e57e931920434a6","modified":1576233352588},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1576233352589},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1576233352576},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1576233352589},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1576233352590},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1576233352589},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1576233352590},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1576233352599},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1576233352599},{"_id":"themes/next/source/images/1-B树索引.png","hash":"c86bffde5fced5c44e1ebaceb52f8e498af0301f","modified":1576217356650},{"_id":"themes/next/source/images/1-位图索引.png","hash":"c271edb9dd088c811bc3af63082571987318cb23","modified":1576217356930},{"_id":"themes/next/source/images/5-1-1.png","hash":"010655cce365b2308536c02c9984ec3e3525ba55","modified":1576217356490},{"_id":"themes/next/source/images/5-2.png","hash":"6cc5cea7bd31f8dd745106c4b727f90b316791ec","modified":1576217357490},{"_id":"themes/next/source/images/5-3.png","hash":"fe6bb40f3c7ebaeebfbe679837d3fb9f656316bd","modified":1576217357420},{"_id":"themes/next/source/images/ERFinal.png","hash":"19bcf5aed020586cae748b28cc3fdcee40067a2c","modified":1576217356920},{"_id":"themes/next/source/images/alipay.jpg","hash":"1389b1e7007add616e7cac0a02e03785d3c29ee6","modified":1576217357180},{"_id":"themes/next/source/images/cover-night.jpg","hash":"024e16a5f6a34afa7634526e467dfa4a725e5493","modified":1576217355670},{"_id":"themes/next/source/images/hive_orc1.png","hash":"b2fb23c94a69e6b9d9100a7d19a39d4a795f94c4","modified":1576217355800},{"_id":"themes/next/source/images/hive_textfile2.png","hash":"c40a148cffcbd181d357c63fecfab3f9ff37c88a","modified":1576217356300},{"_id":"themes/next/source/images/image-20181228192856958-5996536.png","hash":"fae45d6819fc20e580ff5eeae8d76eb0f5222b44","modified":1576217357040},{"_id":"themes/next/source/images/image-20181126025537963.png","hash":"acccdbabca03c381de0109abfc69f78f51b99c27","modified":1576217357360},{"_id":"themes/next/source/images/image-20181228200129326-5998489.png","hash":"5ee89a8996a52d7f9b301943936149ea4ef28eff","modified":1576217356900},{"_id":"themes/next/source/images/image-20181228192856958.png","hash":"fae45d6819fc20e580ff5eeae8d76eb0f5222b44","modified":1576217356390},{"_id":"themes/next/source/images/image-20181228200129326.png","hash":"5ee89a8996a52d7f9b301943936149ea4ef28eff","modified":1576217357470},{"_id":"themes/next/source/images/image-20181231003424471-6187664.png","hash":"98b5c2aaeb16fabbadb21abc07913dc9ded792f2","modified":1576217356550},{"_id":"themes/next/source/images/image-20181231003424471.png","hash":"98b5c2aaeb16fabbadb21abc07913dc9ded792f2","modified":1576217355660},{"_id":"themes/next/source/images/image-20181231003457997-6187698.png","hash":"0a0c20f7d921003c8db24d97c5910784b23cb2ee","modified":1576217357150},{"_id":"themes/next/source/images/image-20190113214926175.png","hash":"e52d0e8fa265ec07a7de62ec4a7df275c2767a32","modified":1576217356330},{"_id":"themes/next/source/images/process_list.png","hash":"4008cc356c868fbc2618205561ae7583a30bf07e","modified":1576217355970},{"_id":"themes/next/source/images/tags-bg.png","hash":"d26a01dabe7cbe25d653ffbf7367c4b66d910ce9","modified":1576217356140},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"8cdc3490eb901b963fde50fec67f535a35af4c26","modified":1576217357480},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.45.10.png","hash":"f4a42f1e33c76bb087ca99c4bf8275f3ba14d41f","modified":1576217356110},{"_id":"themes/next/source/images/表2.png","hash":"abd4d2c03607f90506f6302357cb15bc683df5a1","modified":1576217356070},{"_id":"source/_posts/assets/image-20181126025537963.png","hash":"acccdbabca03c381de0109abfc69f78f51b99c27","modified":1576217299940},{"_id":"themes/next/.git/objects/00/58cee24b6e9a7546095dfb2527c3e4e8758042","hash":"490738e51019a82e29eb211835a296524d01faa6","modified":1576331518313},{"_id":"themes/next/.git/objects/20/285a9df542a100cb2cc532af50bf551c3cba90","hash":"08493816bcbd1b1a7229be547357b3344b67e796","modified":1576331517000},{"_id":"themes/next/.git/objects/11/176c5ce50b2180702223a322bbc678bc7c3dac","hash":"0d202b1819139210583bb9a1fac3c3124daca895","modified":1576331517982},{"_id":"themes/next/.git/objects/25/478a169d071d351b380d6e40fa282cc838b089","hash":"f0b2ddfdf64939ba7fdb8542a3e1aca01397b8ed","modified":1576331517329},{"_id":"themes/next/.git/objects/3d/273c6bd4934720f8e8cae58082f22a05d77f55","hash":"fe886167961a5f070f59b8071018eabb3ff5d88a","modified":1576331518321},{"_id":"themes/next/.git/objects/68/e0aa80bc7ef38344060aa689a09a46cde8909d","hash":"583301d836dd00d55e2d303641b132110eeac4ce","modified":1576331517000},{"_id":"themes/next/.git/objects/6d/5a02e18275deed5d48dad8c571fa1c049731d8","hash":"da71b87d2d6b2ff7bd4665a98c06abe2e0b6b66e","modified":1576331517592},{"_id":"themes/next/.git/objects/72/91da8fc27159c20920921bcc94a39f37666712","hash":"3cf678c7dcdf51ec3d0bbb848d419ce810fbf5c0","modified":1576331518328},{"_id":"themes/next/.git/objects/77/cab686e6e1ad1daca3404e79a89d146f8b9da9","hash":"19d7ad7b3967997d995761df79770cb8a6d6e68b","modified":1576331518384},{"_id":"themes/next/.git/objects/89/1ec1c0816ce1444212cdc38a30d00feab71055","hash":"edc2b8ff7c58ea376a3aded10e2087676f430011","modified":1576331517763},{"_id":"themes/next/.git/objects/8c/36010214745559227029af6a1fd3bd8dc704ca","hash":"3fe7dee9ab6ab559aa81ef42037d3dc54dd38747","modified":1576331517987},{"_id":"themes/next/.git/objects/95/5e2266febf5b85915fe12292be245222f2dd29","hash":"b995ca4e986c875d497238de4801bf42f99c483d","modified":1576331516963},{"_id":"themes/next/.git/objects/9a/67b410839291146887e19f8bfe650e12750879","hash":"05e70b25d25d902c999749dc3f2fa7b53cadce92","modified":1576331516861},{"_id":"themes/next/.git/objects/a5/93e388daec11781079b9451f0b7330ca5ea230","hash":"de5e7c75b894dbdf39fb378627e4f8a6ae7095c2","modified":1576331517000},{"_id":"themes/next/.git/objects/a6/55d88f7aeca4a32eb95d0919d6a4918b435a23","hash":"a106becd77988921d6afe2f0a2cfb0fe3756c6db","modified":1576331517740},{"_id":"themes/next/.git/objects/a7/5d168d8014230511918730b94bde4020aa5019","hash":"4c4cff1cc9cd9a48a89875e522343dda783cb2f7","modified":1576331518075},{"_id":"themes/next/.git/objects/ab/b82a595ff2be0b1e70ad3a3cee84914782dc84","hash":"6cf4ec45cb9e7486926fc62afba09af07aaf1e9e","modified":1576331518167},{"_id":"themes/next/.git/objects/b1/22549c5b17aee0d1004037fec541b3984207ea","hash":"6ed3525d3a8ff22c30928f1fa49faa0be4976b50","modified":1576331518123},{"_id":"themes/next/.git/objects/7c/12eeb401c86621b624256ca99f1a96d20b4297","hash":"3f650eff03404ef5ad7f66b6ef1cbd9769171572","modified":1576331518115},{"_id":"themes/next/.git/objects/75/cbef1bb21cdde19ec15892fbbb4651210497d9","hash":"8fff3b50aca2020ba4553080c2bd2a248c651a25","modified":1576331517861},{"_id":"themes/next/.git/objects/7c/4cbbccef3f3cb414b39897bf2e4c9d0225e779","hash":"f2a53d8de31d6927e87ddd98ec0d7319c19889e5","modified":1576331516930},{"_id":"themes/next/.git/objects/ba/c72302f5f57fece696918544c3305d4a46dd07","hash":"2e5698c628df62356fc28166629a8f48dad7ec44","modified":1576331516921},{"_id":"themes/next/.git/objects/bd/dda676c14fe3dd4b41a108daad90f03b838aaa","hash":"4f7abdce9f513c7ec39872d71cb313b944da4c25","modified":1576331517000},{"_id":"themes/next/.git/objects/cb/23e3c8298440796d35412455935e99d02a6e42","hash":"075d1281dfd5bba56a51355cd7b5c391309002ed","modified":1576331517921},{"_id":"themes/next/.git/objects/d2/f21af5a273ccfbcc4fbf2a75fee146f1ddb5c9","hash":"935e885c622b0e4135c5e6a65ce495bf31853d30","modified":1576331517838},{"_id":"themes/next/.git/objects/d2/5f5f5c498844dc124cef2d3e60678e9435c9db","hash":"13975cfc156b236c66ff0d6fae6bcb9236ded822","modified":1576331517202},{"_id":"themes/next/.git/objects/dc/4030182e2dfcfa4a99e32418ed587dea598934","hash":"ef6390e6b19006b083294b6c17a9f7540da078c2","modified":1576331516765},{"_id":"themes/next/.git/objects/dd/43a567f39cdf46d730703affb3ec65633187d3","hash":"540239611fe0b7c414d6da11633219ec33303879","modified":1576331517137},{"_id":"themes/next/.git/objects/de/3da4d7d4a5b02daa537cd24fc8e362735a18c7","hash":"3248f3a8b961a6abc791657a0195c329977355bf","modified":1576331516865},{"_id":"themes/next/.git/objects/f4/4d7321d618b66e9c840e2ed68af0bfc6342b75","hash":"5296d18339cb8aeb5db0b60a122e99fc85f41fc6","modified":1576331517265},{"_id":"themes/next/.git/objects/f9/edaaf71b632479e006e8b1f093f5ea7a2454e8","hash":"f8dcf00204e238218c8705d93926af56145c50bc","modified":1576331518062},{"_id":"themes/next/.git/objects/f9/7486e087e742c419dba0cd1061834948d8f0b6","hash":"00287f3c6f8bf06ff0ca38e11d54530eba53a0e6","modified":1576331517586},{"_id":"themes/next/.git/objects/fc/18898ba5782ce89e887ca643a2dfd99dec7f01","hash":"b5b7ebbb593179f421c8184f7fae432d57403cee","modified":1576331517260},{"_id":"themes/next/.git/objects/fc/f530073ef15896ef30d91634d31f034130299c","hash":"881610b81852f33f6d0eef3c3a86046330d531ea","modified":1576331517503},{"_id":"themes/next/source/images/1555227964411.png","hash":"baafa5c2d3fa6c1de1a6171a2d5e8789d0021785","modified":1576217356000},{"_id":"themes/next/source/images/006tNbRwly1fwdiojeitsj31eu1444it.jpg","hash":"fc24434eb081d331d5bdaaae379d6456f440fab4","modified":1576217356960},{"_id":"themes/next/source/images/5-6.png","hash":"700f6123a4fd582adfe7730fee1c9a80c92c173d","modified":1576217357250},{"_id":"themes/next/source/images/5-5-2.png","hash":"75acf2f5551ea44cc8a98407e2f4d4981e2cdd07","modified":1576217356280},{"_id":"themes/next/source/images/5-9.png","hash":"63ed242d22bfc56dd484b506f99ed7675359fe0a","modified":1576217356190},{"_id":"themes/next/source/images/5-7.png","hash":"f0867e7c0a2df9c9a80966520cf051ee444b175a","modified":1576217357320},{"_id":"themes/next/source/images/5-8.png","hash":"5e2eb373e46ceda2060c5e478702abafcecf87aa","modified":1576217356220},{"_id":"themes/next/source/images/avatar.jpg","hash":"18a3f43fc8818915a664d916c19275602e6b6220","modified":1576217356850},{"_id":"themes/next/source/images/favicon.png","hash":"18a3f43fc8818915a664d916c19275602e6b6220","modified":1576217356860},{"_id":"themes/next/source/images/cover-day.jpg","hash":"8b1aa6c2fec2455bd44ce089496c561296b21371","modified":1576217357390},{"_id":"themes/next/source/images/image-20181231003457997.png","hash":"0a0c20f7d921003c8db24d97c5910784b23cb2ee","modified":1576217356570},{"_id":"themes/next/source/images/image-20190113230627090.png","hash":"6f619a887345b66551fdbe76d1e44f1e2900f37c","modified":1576217356280},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.46.16.png","hash":"ec63fafb81fa9cb3ca58ddd43351ca32da0b82ea","modified":1576217356990},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.47.49.png","hash":"a6ddd6e5257f83fed26314d3e56ab6885ce2f0de","modified":1576217356710},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1576233352500},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"5be811db2d3da00d605e26c3cfcf0d81a901d664","modified":1576331528919},{"_id":"themes/next/.git/refs/remotes/upstream/cdn","hash":"23fdaf87369768022f24935266c99f594921ab3f","modified":1581398337147},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"bff089200082223016535b3e2c921222dd89e124","modified":1576332585697},{"_id":"themes/next/.git/refs/remotes/upstream/master","hash":"8d9d59a94d9e883e6d6f436509e9c40be93d4f24","modified":1581398337153},{"_id":"themes/next/.git/refs/remotes/upstream/funding","hash":"d17cb32981a871894dc3c24c91d3c6346b60b3cb","modified":1576332343497},{"_id":"themes/next/.git/refs/remotes/upstream/i18n","hash":"a5ea6feadcdd58c9b037d1a5c4255ab5cd779e53","modified":1581398337151},{"_id":"themes/next/.git/objects/14/7dc748dc9a1f66bc8a12394ecbfeac8d4c2419","hash":"f77588f7cc186c7321ad326219e14ab6cb24ec4b","modified":1576331516801},{"_id":"themes/next/.git/objects/15/57ec83b911521cd26abb978ae51082dc2219bd","hash":"cd4a8d0dc3272977dc05e21784aa34049459d807","modified":1576331517007},{"_id":"themes/next/.git/objects/23/c7dde65ccac184455f895d13670199d2db37e7","hash":"0a1e701aaaf871bebfc41e99bef7f25d9cb7b916","modified":1576331517955},{"_id":"themes/next/.git/objects/21/b6f12d738fd50ee2ba2729d7eef83e49e36081","hash":"39bfaa9d62efec48ccdba0e68809c42ba780cefa","modified":1576331517103},{"_id":"themes/next/.git/objects/2c/319131f2d909419122b4a3a144656ae2bfc058","hash":"2e794ac44cfbcea764bfc0782539f80171eed7c9","modified":1576331517000},{"_id":"themes/next/.git/objects/31/9f6d782f42be9dc9dfadc8b01186c748303e5a","hash":"b5d6078e82afe15646ce7eb8c89c41e99e012cd8","modified":1576331518361},{"_id":"themes/next/.git/objects/2f/beb730ef4861cf3bbee65190546b802869c531","hash":"3b598400eed86eef35534a6e606b4162366e4d67","modified":1576331516970},{"_id":"themes/next/.git/objects/2d/cb652414355728ab360f4434b3c948cbe99ce4","hash":"0bad3fed7f53126f1c27a3f9a517d96f889ad46f","modified":1576331517996},{"_id":"themes/next/.git/objects/34/5790d220762617c9e58963f7233281cdda64f9","hash":"7421c1d081789a89e4ad47c9979df1aaf78581a8","modified":1576331517000},{"_id":"themes/next/.git/objects/29/c1a77e9507fad579f6b86d0224ff9311eb4b6f","hash":"1c8bee4df9a849ebd7fc1532f580ee85184fc79c","modified":1576331517000},{"_id":"themes/next/.git/objects/4b/ebc5a4ac9d653046ed41d6e0406ef47156ddad","hash":"3708af3d92b4c4a71e30080746aac519b1b091bf","modified":1576331518069},{"_id":"themes/next/.git/objects/68/26fb577ebe2fbfbe7eb3d67cddac09d214e79d","hash":"0b13b05628daf3ce63583e9af5f6423ecd3d3394","modified":1576331517899},{"_id":"themes/next/.git/objects/70/bc2a9bec180bdab094122f302e245185d709ed","hash":"78d3dd9b85f69ffa45524821308709cf668b3630","modified":1576331517000},{"_id":"themes/next/.git/objects/73/56285219caf7ca94482240c818dec122341aff","hash":"0d8bc9ce17017e2a9c613319a1817f3be415b4d3","modified":1576331518366},{"_id":"themes/next/.git/objects/88/2035e3d42e1d51ece80df6382f01f564a58f92","hash":"94fb848631d39a8bf54b1d20fac6927b3ee71869","modified":1576331516989},{"_id":"themes/next/.git/objects/9a/d31316c9c8f6838a6991a9ee962ba83abc0aa9","hash":"a161dabbb4cea91e2db086a434c80d37c7930814","modified":1576331517274},{"_id":"themes/next/.git/objects/b3/d7873eb117e6506dad0818c80d06acbe96f4e0","hash":"33dad3178f85dce43cde9c0da4f7bb8690fda095","modified":1576331517791},{"_id":"themes/next/.git/objects/bd/eb932469c787f7d14ac87350cb0af1fedb2ca8","hash":"51714cb43124f2af61344b2c3e49f946385e0627","modified":1576331518086},{"_id":"themes/next/.git/objects/c3/ed2f8ac69ead62ce94c3965354900a9fc0597d","hash":"dcf63b43b78f062dae4455c9540ab2c7236c692b","modified":1576331517783},{"_id":"themes/next/.git/objects/d7/8e285fe71d6ef449c98f08b860ea79cd366a3e","hash":"7ae842dd478eb6cd9b0d10dec8174adb1ea79fb1","modified":1576331518135},{"_id":"themes/next/.git/objects/e4/16c778f0b42faf2e36b4a82fce2fc03e2a7c04","hash":"e2e877a8ac310a7a2acc4ac72bd7caa009e2d421","modified":1576331517601},{"_id":"themes/next/.git/objects/e8/a6f6a301d8f4411e0191731d6167682348f23a","hash":"b0e0a25a7a580ee1764948e7e52b5e3e64a36913","modified":1576331517172},{"_id":"themes/next/.git/objects/f1/1d6bdaf35e039884ff4c8f9ce1538c6b936e5e","hash":"a4a88109bc31858b6c221689f752c845217c8a36","modified":1576331516819},{"_id":"themes/next/.git/objects/f2/1e5061509334a79d27b6709d41614a121c0247","hash":"31ee603607973a2db1642e0aee3db87b7087c1b3","modified":1576331517065},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1576233352567},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1576233352568},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1576233352559},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1576233352559},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1576233352559},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1576233352564},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1576233352564},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1576233352571},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4f7879a50d4608c46cc2061c725a2564597a45bd","modified":1576233352571},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1576233352571},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1576233352573},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1576233352572},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1576233352573},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"2b52b0eb4c66e06762cf115450da0ca1dd435e75","modified":1576233352573},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1576233352575},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"1693ec6b53758ac15d2c7798c789d6ae8af913ea","modified":1576233352576},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4fb385d8533877678440c8faa08b68fa793cb1a2","modified":1576233352576},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1576233352577},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1576233352576},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1576233352577},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1576233352577},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1576233352577},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1576233352577},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c6905c694c6fbbf372b53456a0d219701010a110","modified":1576233352578},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1576233352578},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1576233352578},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1576233352578},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1576233352579},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1576233352578},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d7587df06b30042091316d8b1cc58ba361211492","modified":1576233352579},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"71a3d7f2242706f7a6b79933a67ef3664cca3a24","modified":1576233352579},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1576233352579},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1576233352579},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1576233352591},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1576233352591},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1576233352592},{"_id":"themes/next/source/images/5-5-1.png","hash":"01cdc743b292c05e38887fe61783d141bfc6e148","modified":1576217356410},{"_id":"themes/next/source/images/5-4-2.png","hash":"9bd44b784b54a268a07e0e969e0c793291b89a1d","modified":1576217355900},{"_id":"themes/next/source/images/JSimple-Snapshot-Macbook Pro15.png","hash":"75a9e94c7fcdc7ffb3724c33190a19a3115639af","modified":1576217356180},{"_id":"themes/next/source/images/image-20190113211220925.png","hash":"11692dcc5bb0ccc4d3c025c825e0da9dfe7e4cd9","modified":1576217356800},{"_id":"themes/next/source/images/image-20190113230831573.png","hash":"2005c321992b1853ef53ff9de34938bf9e966acc","modified":1576217356310},{"_id":"themes/next/source/images/image-20190113230717837.png","hash":"8c41028f8698170830eb0d7da8093c11e530da9b","modified":1576217357160},{"_id":"themes/next/source/images/inmemory.png","hash":"99aaba0f7b81606069bbc404834c68520c04ddf8","modified":1576217357630},{"_id":"themes/next/source/images/双亲委派模型.png","hash":"af5aacab582bae8399521906ee09fa44076650e0","modified":1576217357530},{"_id":"themes/next/source/images/类加载机制.png","hash":"1413282e5c03d474679826aea04802bc279ee0e7","modified":1576217356800},{"_id":"themes/next/.git/objects/08/6749d12aa34e3e4ba70a985daba615579a9fb3","hash":"e2a44c852c159d9edc17a9e646b0e42491360660","modified":1576331517000},{"_id":"themes/next/.git/objects/1e/2ee32707e9a5a702e248b9ed7802d1980b96fe","hash":"815c083029b2e3af7e99427b0e35c96d27082f4d","modified":1576331517031},{"_id":"themes/next/.git/objects/36/3f30f93ae2777fd2e4cda3914bd717b4c3a9d2","hash":"67b151dabcd014819d28daa857668414d94cca18","modified":1576331516775},{"_id":"themes/next/.git/objects/77/f42711e5375b03884e41e6388b08cbaef4c244","hash":"a050081eb98448902cf373f7faddc5519c0a1cee","modified":1576331517053},{"_id":"themes/next/.git/objects/8a/efe40638b77ae11cc7e028d8354f111ce86b2b","hash":"ad6518fea778dceada8a583b118e78ed431dea50","modified":1576331517020},{"_id":"themes/next/.git/objects/9f/77feb349e8022a254ae174351bfc91ae66988e","hash":"1082b91a3ddd4306471dcb5811e3e16759e0dc56","modified":1576331517041},{"_id":"themes/next/.git/objects/a9/996d6b713c69c654eecff92edf0027f31da8cb","hash":"89fce8e31a49bfd2665dbd1297ee9ac3ddc77fb8","modified":1576331517088},{"_id":"themes/next/.git/objects/b6/4103a8225dcad7296ecb7703018472cbe70f17","hash":"3ac03cbadfa9a043079333b9fe631b5a075efdfd","modified":1576331518098},{"_id":"themes/next/.git/objects/d4/361689105d768b4a731bf090236a4a21d3f70a","hash":"809db158b0ca5f250dc5de8682778fbd846ca0fe","modified":1576331516855},{"_id":"themes/next/.git/objects/pack/pack-b988cab81c7fc761687086c6b357c076d371187d.pack","hash":"6d2168c6fa42e7ed2b4c20206d8ca897eaf1c07f","modified":1581398337139},{"_id":"themes/next/source/images/006tNbRwly1fwdiyk83baj31ig114aw6.jpg","hash":"be39820f72ba34cc04d3c8706908e16445094b2d","modified":1576217356340},{"_id":"themes/next/source/images/image-20181027233529314.png","hash":"865d8002ec8071e341838eda1ab94e6bb719b1dc","modified":1576217355900},{"_id":"themes/next/source/images/image-20181231171547272-6247747.png","hash":"dd4e3c133e818e99c234d4a63908c1c5265fb00b","modified":1576217356910},{"_id":"themes/next/source/images/image-20190312200304819.png","hash":"ea1522d93871c2fc41ba7403ad8289eb3feaa6bf","modified":1576217356520},{"_id":"themes/next/source/images/no-inmemory.png","hash":"bd03a1ed5f97dcce3d30ecfa32dcdee58a53bba1","modified":1576217357340},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午10.57.10.png","hash":"0e5986ef83ee3b45cb836e93f5e382fea49feba7","modified":1576217356160},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.30.40.png","hash":"bd37a9eb009802a10a34bfcf4b0628af19d327e0","modified":1576217356360},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.49.11.png","hash":"c59e53398b004300d08d3b959a891f7d27c0d194","modified":1576217356470},{"_id":"themes/next/source/images/语句执行计划.png","hash":"bf57257f59f92327e1da9c7fa73e49782cabe28d","modified":1576217357310},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"b3d95511cd6ac3145f06d21811239ac064a5ecd1","modified":1576233352500},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"b3cbb68ce17cddba06d2d478b4394196928fb32e","modified":1576332585702},{"_id":"themes/next/.git/logs/refs/remotes/upstream/cdn","hash":"b838b899534a3c58ec4cdd084865b5def7693218","modified":1581398337147},{"_id":"themes/next/.git/logs/refs/remotes/upstream/master","hash":"630141bacc4c7ac561582a8fc837719049ed765b","modified":1581398337152},{"_id":"themes/next/.git/logs/refs/remotes/upstream/funding","hash":"376abb973270d3ae4ef75261326827bde4587422","modified":1576332343497},{"_id":"themes/next/.git/objects/0c/1adb60fa74ee407b1473478771da7648a6e1b9","hash":"fd6380242114a1843ece99cfead5465f02c79e65","modified":1576331518010},{"_id":"themes/next/.git/logs/refs/remotes/upstream/i18n","hash":"530940dda1385df2a79012050e55cc173b03e646","modified":1581398337150},{"_id":"themes/next/.git/objects/32/268fa2aa494005b8d2f08932f9d531526ec074","hash":"f485edba490ee05a9caca9ed2f30a495fb017153","modified":1576331516792},{"_id":"themes/next/.git/objects/6a/58f849ebba0e28eb9b582a70f593f6a8dcdc8c","hash":"5275a7450833d6cd46b20f0c32a9d4568e2f7659","modified":1576331518353},{"_id":"themes/next/.git/objects/6f/6cb56da775b46efa4aaa897701bdadff44ed91","hash":"485c59dd4602de9e29bed77acdd6d77584a6987f","modified":1576331517973},{"_id":"themes/next/.git/objects/79/71364a5ee7218592aaa12ae40fd42805247fa2","hash":"5e98ca78fcddc087a093b06ed9875cbe155f88ec","modified":1576331517000},{"_id":"themes/next/.git/objects/e5/43e70d9d70de82e2dce70e0b184b3127decc0a","hash":"17cacacbcefccb78570406583ea4b391b0d11e0b","modified":1576331518343},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1576233352566},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1576233352566},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1576233352566},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f5821481440a0624c8aec5fc85f093de1527095f","modified":1576233352566},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1576233352567},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1576233352567},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1576233352567},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"c27b3056d5e22d3c66d8a152a23634314d5c4a60","modified":1576233352567},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1576233352569},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1576233352569},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1576233352569},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1576233352569},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1576233352569},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1576233352570},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1576233352570},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1576233352570},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1576233352571},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"c83d750238d6ac13b65869a909465fe621c464c3","modified":1576233352570},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1576233352559},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1576233352560},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1576233352560},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1576233352560},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1576233352560},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1576233352561},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1576233352562},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1576233352561},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"5d5c022aa3b2f89c2f2a178212338bb64804dd75","modified":1576233352562},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1576233352562},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"bcba503e956e4b737b062faa66341bd880f16c10","modified":1576233352562},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1576233352563},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9df5ba77e6cf36129bddc270407215c23c60ff38","modified":1576233352562},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1576233352563},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1576233352563},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1576233352563},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"284249dcfa3b49c5d76210bbb0f74f65fc2f12ea","modified":1576233352563},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1576233352564},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1576233352565},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1576233352565},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1576233352565},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1576233352565},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"b4923515ca8e44aa62e839ce948f759cfd1f896f","modified":1576233352572},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"b492a45422773ab2af06ee345d527ba4c6bbc608","modified":1576233352572},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1576233352572},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1576233352572},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1576233352574},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1576233352573},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1576233352573},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"1a14c1b92d8a4dd8aabb5949333ac0ac79094c6c","modified":1576233352574},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1576233352574},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"d2f0f2171722533bba308f944a2ec727b083582c","modified":1576233352574},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1576233352574},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1576233352597},{"_id":"themes/next/source/images/image-20181019161433801.png","hash":"ea5d03a276ea8058e52ad55cc7a9ab961553a24b","modified":1576217357120},{"_id":"themes/next/source/images/image-20181019161451060.png","hash":"c407eb3fd8e5ffb20871e52ca93980a6c13373c3","modified":1576217357140},{"_id":"themes/next/source/images/image-20181027233726178.png","hash":"5cc3bda1f0e3b57b95bc48c4aca58251004baa08","modified":1576217357170},{"_id":"themes/next/source/images/image-20181231171547272.png","hash":"dd4e3c133e818e99c234d4a63908c1c5265fb00b","modified":1576217356580},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.06.20.png","hash":"b322e16bbed6edb9a603bf4e69fc85a8e56b3a08","modified":1576217356760},{"_id":"themes/next/source/images/屏幕快照 2019-01-14 上午12.30.46.png","hash":"48f4f56c16d0c7090e2be7cc3c6d5a3b6ce2ba5f","modified":1576217356600},{"_id":"themes/next/.git/objects/0a/a7ccf8d5052d906841512468fee5062debd2e3","hash":"3350543285fa7b33f5a53656860e838b908e4af0","modified":1576331517563},{"_id":"themes/next/.git/objects/0d/38e3a8431453e40e474d76668e83dd028a2dd8","hash":"0d5e4249bf4e00a7b1e5f921deb8571ac7c636c8","modified":1576331518208},{"_id":"themes/next/.git/objects/27/9bc481026002b95a9fe085f7edb8f78c47230b","hash":"c05ccaa66d896a003e193ab7a0a70a1a2ecc231a","modified":1576331517772},{"_id":"themes/next/.git/objects/3c/e29f924fec88ea424eb58512a42f25e942efb4","hash":"e0713eb178902176ae538ee11bd3d0112f48c0fe","modified":1576331518248},{"_id":"themes/next/.git/objects/5c/2e22c76723c6483ae628dc53874ffda01254ab","hash":"d0cad8f95e01cfcb5ca256d87bef3f4a3f231267","modified":1576331517753},{"_id":"themes/next/.git/objects/63/437a7f3e975f73bab57475887f2af126b8dc10","hash":"1240477ad87acfb6b67c7f976e838f9cbfbd4dc2","modified":1576331517943},{"_id":"themes/next/.git/objects/81/ac00f1e7d4c58324980fa34c78cc14ce8cfaac","hash":"2d7f786abfb63233242ead58380c1a371a98a5af","modified":1576331518308},{"_id":"themes/next/.git/objects/76/9e43937506d66fcc19e3567e8127fccf5ace19","hash":"efdf7cacb1518a18ef9d8f9d76477fe71f985cb2","modified":1576331517932},{"_id":"themes/next/.git/objects/54/c76db4f0a1733b5446a9b0342f538913e41de1","hash":"bbfb5c48bebfca2872ecab4663384253f1592cec","modified":1576331517915},{"_id":"themes/next/.git/objects/84/6abbddcacc87a54ddf6a3c5894a0bdd34bf844","hash":"05eeffc090bc0733ee0f6457660464847ba82983","modified":1576331516980},{"_id":"themes/next/.git/objects/9a/510778fc5a7cef33ba47108df0db469852be14","hash":"54272fbbadeec0fe4ee021305b533f538447a7d4","modified":1576331518378},{"_id":"themes/next/.git/objects/d3/695c5e72a8acced96cdb8e057151472886e0c6","hash":"6a55bfa0ab433db182e15f52cce4706b45bf80db","modified":1576331517578},{"_id":"themes/next/.git/objects/e7/0ac61ba5681a5b23e270a07a7571b7904dd78a","hash":"085270c659d145699620b0e8b5cb2c100d32bbee","modified":1576331517118},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1576233352596},{"_id":"themes/next/source/images/5-1-2.png","hash":"510890f22e89e818b38c63db7bcb303b7352ee20","modified":1576217356620},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1576233352593},{"_id":"themes/next/source/images/image-20181023205748006.png","hash":"72acca09aef38e6cb0860b31e77473f7b5f1d66f","modified":1576217357630},{"_id":"themes/next/source/images/image-20190414160931753.png","hash":"dbdd3150eebbc9c8ec3239ec6334c4e32a381a76","modified":1576217357110},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午8.31.00.png","hash":"aac6ace85aaad620251afed80c3b5778be740208","modified":1576217356880},{"_id":"themes/next/.git/objects/09/0910461d8d778f004af6e9a1e24746f21b7cd9","hash":"c05358bc25e1b3a6c9b34090d2662387952f67ef","modified":1576331517165},{"_id":"themes/next/.git/objects/9a/fe7dd92fe09ed6b70333b53341b197e79802d2","hash":"083128012916de1a0f5750ae4a81e9caeb5df14a","modified":1576331517411},{"_id":"themes/next/.git/objects/a6/2a33c87977d1b4b50ec5152af527fef7785a6e","hash":"606e02809a58174135a0ec0fe5aae0d5bd252692","modified":1576331517873},{"_id":"themes/next/.git/objects/c5/c4472d4e45883d37567454d777a6ec29dfedfe","hash":"fe4d594ff2eeadea3242b6d4d3df6a5177dc3ee1","modified":1576331518228},{"_id":"themes/next/.git/objects/e1/60a2b1c96bc960af14fa98e7f089065ef0c553","hash":"e63896d3aab7fd5508ff29660c499f2e370df165","modified":1576331517000},{"_id":"themes/next/.git/objects/e4/611ccaf2cdbb5d9be955cb45232f34cd8c47e9","hash":"81a9e7aedfd01920486ee4f3911f335cc5c742ed","modified":1576331518188},{"_id":"themes/next/.git/objects/pack/pack-666594c97f2d6fc25b15240545298692629b23ba.idx","hash":"5942d3af516f3a738781f555871fc5a4cbd5b00e","modified":1576233352478},{"_id":"themes/next/source/images/1555227842703.png","hash":"9094bc60f240d9bb2f0951a2ff22b0b8389f88ec","modified":1576217356600},{"_id":"themes/next/source/images/image-20190325104456133.png","hash":"b7a9264385bbede10697ef82ebd6e95d9f257d21","modified":1576217357010},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午7.09.22.png","hash":"d809f33950627ad4deebc1619efb16ebdcc146b1","modified":1576217357510},{"_id":"themes/next/source/images/屏幕快照 2019-01-13 下午9.07.08.png","hash":"235d186aa80b16a6e96b135164885c9da982e798","modified":1576217355920},{"_id":"themes/next/.git/objects/25/9de2d1577884db523afcedfe139d8af8937a3d","hash":"9c449891ecf66806a2d35c5b48fc89eb2674d9e2","modified":1576331517076},{"_id":"themes/next/.git/objects/5e/0a3a9008a7b60194c829f65fec13abf8e93f32","hash":"06a6f9703a95c6e0c35d64c8201c5ddda3602a9f","modified":1576331517394},{"_id":"themes/next/.git/objects/9a/568a31ce861c6798538394f4cde9a685b1a1a9","hash":"2dd2286ac02f52f4c4734ddb50245c953cfee5f0","modified":1576331517522},{"_id":"themes/next/source/images/image-20181019163053138.png","hash":"02fdb4951c6fcb85e8e595a16c7dfaaf1d1ba5c2","modified":1576217357410},{"_id":"themes/next/.git/objects/8d/ab92c3592b3582fd52dc2dd5fcb14673fdee32","hash":"cc0cec74d4f5845ae12317fdc9a98e74e886e072","modified":1576331517498},{"_id":"themes/next/.git/objects/8e/07287308b0ff1a2ffcaf3a477be563d952b99e","hash":"298016bcc47bcd0278e5ce6c5d0df3fa02304563","modified":1576331517475},{"_id":"themes/next/.git/objects/00/2137a0e31715d3451ebb9872d3f043366bbace","hash":"fabae5872f3de2562b436ca857b507a95ed2c086","modified":1576331516846},{"_id":"themes/next/.git/objects/32/400e885e753b0665f7bc8fc9248adee5c53376","hash":"2305061bf51816441543b364ef8e7c1640dbe03a","modified":1576331517891},{"_id":"themes/next/.git/objects/7a/9aff3a1e67cc729944aa6f6cb97efbed49c81c","hash":"bc068a3d96d361881ee569b4ebfbae7a743c83bc","modified":1576331518154},{"_id":"themes/next/.git/objects/ac/c343c11325a0c10105b702e3ca2b8f55b5ce43","hash":"926f5128f80dd84c3a34d1596eed10e28e060c88","modified":1576331517545},{"_id":"themes/next/source/images/image-20181027164439676.png","hash":"ee5c6f3c746832646d6d4d2bec40686aea3559dc","modified":1576217356100},{"_id":"themes/next/.git/objects/0c/dd38214cfface1b89417bf615dba155c73ada5","hash":"6eb36fd757beb34ea0293483dddc4dac26c0780a","modified":1576331518288},{"_id":"themes/next/source/images/image-20181027150559447.png","hash":"029d96a0987dfd36f7258578008dcfc6f5a096c6","modified":1576217356050},{"_id":"themes/next/source/images/image-20181019161405925.png","hash":"9f1a4ba492fe865041303cbad2fa39c94d4adc93","modified":1576217355890},{"_id":"themes/next/source/images/image-20190114062154430.png","hash":"43ffcaafc066198327fc52ec7be0017b3cdc572c","modified":1576217355840},{"_id":"themes/next/source/images/image-20181019162644076.png","hash":"34203a08787cb00bd720902f477e30b7f49745a8","modified":1576217355770},{"_id":"themes/next/.git/objects/55/e71f3a8f33640e321b98d89e958cb46e3c2a03","hash":"21b9f69a9f5723b135a55a87d811547a28436826","modified":1576331517316},{"_id":"themes/next/.git/objects/43/f424c4303a68ecfef71fcf40da7970e0d6747f","hash":"052c08410f328646332c177480d4d4ec2688addb","modified":1576331517452},{"_id":"themes/next/.git/objects/90/6aa49791fb093f53be301bc45b0eb2b7e1a1c8","hash":"abf7fc02f2945744644bf015f54835438aafc22b","modified":1576331518049},{"_id":"themes/next/.git/objects/d3/2ff82a7730d42ade4b9ae3851ac5b913ac234c","hash":"d4338b200f8637b506b40ee91f13e923da251fe8","modified":1576331517380},{"_id":"themes/next/source/images/hive_arg.png","hash":"0dd1e826588aad247b63228f0f91fb55c2c0911f","modified":1576217357280},{"_id":"themes/next/.git/objects/22/f3891cfbde87ecf8a164c15ec90ed48030cc48","hash":"038e00f6329462fa2b45daf75b9aae090880f2ee","modified":1576331517831},{"_id":"themes/next/.git/objects/89/ca6e53e0ade2f5002e23677ef67a72daaab01c","hash":"5114aa047904e7cb0aee4c83bef1b8491140a8c3","modified":1576331517252},{"_id":"themes/next/source/images/image-20181009202105976.png","hash":"b24a4a2482085275d15d8ce2a7104dd77943c1ea","modified":1576217357610},{"_id":"themes/next/source/images/可达性分析算法.png","hash":"dbd335492727ca73ee16fea0ec97aca988865d70","modified":1576217355770},{"_id":"themes/next/.git/objects/pack/pack-666594c97f2d6fc25b15240545298692629b23ba.pack","hash":"14246333d2fc561c552a6907231926dd6f36925f","modified":1576331516000},{"_id":"source/_posts/分布式计算期末项目文档.md","hash":"e96f340339c792faf07797b5a137289ac98891bf","modified":1621161615075},{"_id":"source/_posts/assets/1.png","hash":"c4a3dd9ba57eb3c0633c24293f63e08531b31462","modified":1601783167438},{"_id":"source/_posts/assets/11b.PNG","hash":"50bb7695d9e6afcf8b5afbe02956b017cf08d922","modified":1601783167438},{"_id":"source/_posts/assets/11a.PNG","hash":"157558db491e45976c19acf68384db175d2b368b","modified":1601783167438},{"_id":"source/_posts/assets/12a.PNG","hash":"7936e3d8716e102b288d81ba7641505a9a43828a","modified":1601783167438},{"_id":"source/_posts/assets/12b.PNG","hash":"56797abe3a2cccba00b05ec272fe5af8f9d88877","modified":1601783167438},{"_id":"source/_posts/assets/1555335982957.png","hash":"aaa69dcc00cb1070f3afd22d627768f20e80bb70","modified":1601783167438},{"_id":"source/_posts/assets/1555336042119.png","hash":"7c4c1345e842f360e047ff475eb64eb0c6b02220","modified":1601783167438},{"_id":"source/_posts/assets/1555336181441.png","hash":"ba395552f646ff9a2e0b05aabfac2c61ed7bbfdb","modified":1601783167438},{"_id":"source/_posts/assets/1555336839432.png","hash":"699fbc1065438c1e67c665f4d7f00e0980d89b61","modified":1601783167439},{"_id":"source/_posts/assets/1555337410546.png","hash":"2a464dfe05d89059a1668600abe267f9b8b775ac","modified":1601783167438},{"_id":"source/_posts/assets/1555337368613.png","hash":"0c513d185786bc7318770d92f75cde40562c534f","modified":1601783167439},{"_id":"source/_posts/assets/1555338066598.png","hash":"a90332a668c0290f7983ac52703fe0d83b045f22","modified":1601783167439},{"_id":"source/_posts/assets/1555337786084.png","hash":"fa49c803a6f13781ac2d1f5e538cb7af804808bb","modified":1601783167439},{"_id":"source/_posts/assets/1555337487973.png","hash":"67ab08e2f5e6dc6ff8b6a5f2f9e41eb6773fbd20","modified":1601783167439},{"_id":"source/_posts/assets/1555338108853.png","hash":"5d052687aa0da02536880ab02f393eb743f5402f","modified":1601783167439},{"_id":"source/_posts/assets/1555338141910.png","hash":"296ac3ab01fddef235e75a640147ab2cdebc3247","modified":1601783167439},{"_id":"source/_posts/assets/1555338199372.png","hash":"0964af81d4b077217e3b714c80c04687a0c74244","modified":1601783167439},{"_id":"source/_posts/assets/1555338210270.png","hash":"0964af81d4b077217e3b714c80c04687a0c74244","modified":1601783167439},{"_id":"source/_posts/assets/1555338281068.png","hash":"27b201f2a49ccfee7a3d954e47e098d53518221c","modified":1601783167439},{"_id":"source/_posts/assets/1555338670472.png","hash":"c103edbd24f552eb4d699bb2c0e690902793878c","modified":1601783167439},{"_id":"source/_posts/assets/1555338761379.png","hash":"cc550f8af4cc45307c2a715b2d57b1667b0d1896","modified":1601783167439},{"_id":"source/_posts/assets/1555348366529.png","hash":"e89e3dd2127caf61eaa42e260def7e93787fede2","modified":1601783167439},{"_id":"source/_posts/assets/1555349943322.png","hash":"1bb56178939eb2481d37899af8ed20b2cd3d5f7b","modified":1601783167439},{"_id":"source/_posts/assets/1555350134801.png","hash":"47424d9466dc333f625e2f96d126dab102108c3c","modified":1601783167439},{"_id":"source/_posts/assets/1555348996560.png","hash":"1b8c457f47f9255d5a5378f1901afbb28e2bc871","modified":1601783167439},{"_id":"source/_posts/assets/2.png","hash":"5c6ca1cc13170a2283a8e54a1853ae7abf561ff3","modified":1601783167439},{"_id":"source/_posts/assets/21a.PNG","hash":"892b3a2ec9e405e9dc1f5a75710b244bb383ca98","modified":1601783167439},{"_id":"source/_posts/assets/21b.PNG","hash":"cebc023c2abdcc10f95460bda73789cdc62ae803","modified":1601783167439},{"_id":"source/_posts/assets/22a.PNG","hash":"93b314958b05acb216d3e7fe8adfa4036a7aed2a","modified":1601783167439},{"_id":"source/_posts/assets/22b.PNG","hash":"ca739596b82b861e00f1c860e2eb3dbec0b3499c","modified":1601783167439},{"_id":"source/_posts/assets/2kbg02YRqSS3ZofE.png!original","hash":"90cac441683580a4afa62ac9e9412cfc02c0facf","modified":1609833046287},{"_id":"source/_posts/assets/2YC2iJF2OJvYbs1R.png!original","hash":"a9949a4117434f3d0179b8001b770459e68d831f","modified":1609833136614},{"_id":"source/_posts/assets/3-B树.png","hash":"c8acd74146e1d9f3ba04006494d541a04261b235","modified":1601783167439},{"_id":"source/_posts/assets/3-不用索引.png","hash":"ee536176bb786472ed20857b71caa7ba01b433ee","modified":1601783167439},{"_id":"source/_posts/assets/3-位图.png","hash":"5294ee0f04e04c869855b94f4c02881a310e2ddb","modified":1601783167440},{"_id":"source/_posts/assets/3-强制B树.png","hash":"915c0050b8b6633a7acb26061a589946877b9782","modified":1601783167440},{"_id":"source/_posts/assets/3-强制位图.png","hash":"cce241f03c942ddfa01266d71f1dbd070262d357","modified":1601783167440},{"_id":"source/_posts/assets/31a.PNG","hash":"64fd6307630bf233468d805d2a898eba02f6e788","modified":1601783167440},{"_id":"source/_posts/assets/3.png","hash":"59d4557e45f12e91978c6ac2fb4b4d4471be1922","modified":1601783167440},{"_id":"source/_posts/assets/31b.PNG","hash":"8dcbaf6daf2ae8272e207c78503f441da76a8aaa","modified":1601783167440},{"_id":"source/_posts/assets/32a.PNG","hash":"baa7764c3ec8c7db6102ec1baca23cec60c992f8","modified":1601783167440},{"_id":"source/_posts/assets/32b.PNG","hash":"bb6e75443de306528ebf56e44a4ac6a91474ee8a","modified":1601783167440},{"_id":"source/_posts/assets/527DE0D27244EE625AD2D099AACDF4BA-6182656.png","hash":"ecd04a231dd7ca6c7f94dce25c67f2839c8b4c54","modified":1601783167440},{"_id":"source/_posts/assets/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1601783167440},{"_id":"source/_posts/assets/527DE0D27244EE625AD2D099AACDF4BA.png","hash":"ecd04a231dd7ca6c7f94dce25c67f2839c8b4c54","modified":1601783167440},{"_id":"source/_posts/assets/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1601783167440},{"_id":"source/_posts/assets/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1601783167441},{"_id":"source/_posts/assets/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1601783167440},{"_id":"source/_posts/assets/NM80fSViYPVEfD3Q.png!original","hash":"c851a63eef0ac124fd558f3b4e0c1ee90465a946","modified":1609833288371},{"_id":"source/_posts/assets/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1601783167440},{"_id":"source/_posts/assets/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1601783167440},{"_id":"source/_posts/assets/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1601783167440},{"_id":"source/_posts/assets/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1601783167440},{"_id":"source/_posts/assets/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1601783167440},{"_id":"source/_posts/assets/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1601783167440},{"_id":"source/_posts/assets/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1601783167441},{"_id":"source/_posts/assets/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1601783167441},{"_id":"source/_posts/assets/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1601783167441},{"_id":"source/_posts/assets/bitbug_favicon.ico","hash":"2d3dff76c81475205cbc00ef8540259e42b2793f","modified":1601783167441},{"_id":"source/_posts/assets/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1601783167441},{"_id":"source/_posts/assets/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1601783167441},{"_id":"source/_posts/assets/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1601783167441},{"_id":"source/_posts/assets/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1601783167451},{"_id":"source/_posts/assets/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1601783167441},{"_id":"source/_posts/assets/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1601783167441},{"_id":"source/_posts/assets/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1601783167441},{"_id":"source/_posts/assets/dXULEPSCEIT3QZW0.png!original","hash":"60739f3b00093d4301a43032978c568d85bf3df5","modified":1609833160742},{"_id":"source/_posts/assets/detail_3.2.png","hash":"b35ac465cf7e081162548d763a9c7bb7a34298e6","modified":1601783167451},{"_id":"source/_posts/assets/detail_index_3.2.png","hash":"911c17e7c64986e48548daef4e5b05047877cc18","modified":1601783167451},{"_id":"source/_posts/assets/exec_detail_no_index_1.1.png","hash":"4fd0035653c343a7828967a6d5252acf8b787abc","modified":1601783167451},{"_id":"source/_posts/assets/exec_no_index_1.1.png","hash":"cbf349bde780f11a01987c394d4ed58997a8f0e7","modified":1601783167451},{"_id":"source/_posts/assets/exec_detail_no_index_2.png","hash":"c3fffbba3e88988aaf28b07bd8314e6f751901b5","modified":1601783167451},{"_id":"source/_posts/assets/explain_1.1.png","hash":"00777ccffa6b768387568a5e0342745121e7c41d","modified":1601783167451},{"_id":"source/_posts/assets/explain_3.2.png","hash":"39906f90abef86cae35688f5968c0ac183d05171","modified":1601783167452},{"_id":"source/_posts/assets/explain_2.png","hash":"adf95ba80e751d16b663c78c916647ffed19c333","modified":1601783167454},{"_id":"source/_posts/assets/explain_3.2_index.png","hash":"654001df395d4f4a5d484022c2dc82e11153d5be","modified":1601783167452},{"_id":"source/_posts/assets/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1601783167452},{"_id":"source/_posts/assets/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1601783167452},{"_id":"source/_posts/assets/image-20181018143452887.png","hash":"0b7d690e121dd28843d212ac0e1bb69909a8b428","modified":1601783167454},{"_id":"source/_posts/assets/image-20181027232418408.png","hash":"58f47f5a197a3a114a5b96e060a882bb9a28b9f8","modified":1601783167452},{"_id":"source/_posts/assets/image-20181106214511931.png","hash":"6320227904228be1751b964c0f399e935cae17f9","modified":1601783167454},{"_id":"source/_posts/assets/image-20181231170852678-6247332.png","hash":"5fde7340ead8be22644d14ada427d9726db3b954","modified":1601783167452},{"_id":"source/_posts/assets/image-20181231170913607-6247353.png","hash":"226b12ead6f15edd92b5dc53c3a214c95d3c4b18","modified":1601783167452},{"_id":"source/_posts/assets/image-20181231170852678.png","hash":"5fde7340ead8be22644d14ada427d9726db3b954","modified":1601783167452},{"_id":"source/_posts/assets/image-20181231170913607.png","hash":"226b12ead6f15edd92b5dc53c3a214c95d3c4b18","modified":1601783167452},{"_id":"source/_posts/assets/image-20190114004746346.png","hash":"38920bb5ef1d804b7a16865bc582bb7196d57440","modified":1601783167452},{"_id":"source/_posts/assets/image-20190114052126486.png","hash":"2a0fddef7b5e64b09876a53e6c349318267b7d20","modified":1601783167452},{"_id":"source/_posts/assets/image-20190114060005845.png","hash":"b76c84f22ac83621bb24ac90f1e90ea11c69eb15","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225225057306.png","hash":"cba04373f73979243bdc4b20769b0367e9ba8d52","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225225802212.png","hash":"5197f65bc0f66869ddd1d15b98e8be028a6dd8ab","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225230110077.png","hash":"e89db87abe4854adb2bbf4deee56e16db6a82e19","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225230647640.png","hash":"2a6867e463ccf575239ae49ab8b9dc42b1604f85","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225232204967.png","hash":"a2893b2fbc7a416ccd5aa899cd12c1f2314b55be","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225232407098.png","hash":"537ec1cd67eec992ba3dbc036fccda638c1c4ba6","modified":1601783167452},{"_id":"source/_posts/assets/image-20190225232630665.png","hash":"c58dfac3369b73d936cbbc73e7c08fff5da6ad06","modified":1601783167452},{"_id":"source/_posts/assets/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1601783167452},{"_id":"source/_posts/assets/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1601783167452},{"_id":"source/_posts/assets/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1601783167452},{"_id":"source/_posts/assets/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1601783167453},{"_id":"source/_posts/assets/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1601783167453},{"_id":"source/_posts/assets/qcode.jpg","hash":"4a34ca272f342fc86ee769b6c998c320f3bbdec8","modified":1601783167453},{"_id":"source/_posts/assets/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1601783167453},{"_id":"source/_posts/assets/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1601783167453},{"_id":"source/_posts/assets/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1601783167453},{"_id":"source/_posts/assets/rssFeed-bg.jpg","hash":"152d21e2a733e94c8a2c726fca8b2555b3d05979","modified":1601783167453},{"_id":"source/_posts/assets/sns-qrcode.png","hash":"e2c026527fbf1393caccdd2f8e44bac437232184","modified":1601783167453},{"_id":"source/_posts/assets/time_3.2_4min.png","hash":"731b50cf2b291b96e4bcd9a0d23564d5223ea715","modified":1601783167453},{"_id":"source/_posts/assets/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1601783167453},{"_id":"source/_posts/assets/修改字符集3.png","hash":"5961454b3b175beca253e9ef948b28ce3a480aed","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-12 下午10.56.20.png","hash":"dfc18fd8f6839ce4b7e7f0db1d959ca9e6d7f305","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-12 下午10.54.29.png","hash":"6fa85c878a609b5eab1db6119d02b5defd9fe5e4","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午7.21.45.png","hash":"1bead84ca59dbf78741efa96d0f2216ef2f2afbf","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.14.59.png","hash":"c9c9f7ad911d820fc4aa5ecde82fa22cd60b7cd4","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.32.45.png","hash":"b606062aabcc3497ed220565a0e7b130b692fac0","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.37.07.png","hash":"1b46c5de1acc5c0c9088d704d21da315dee58f62","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.38.39.png","hash":"fea59cfe1743f0389c22733e40b62129c1bd530d","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.37.57.png","hash":"addb7a8d340666d79ce229f0630c292edb854316","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.35.11.png","hash":"bc26e60b10008d47b49dab7ce8d59d59bfe9954a","modified":1601783167453},{"_id":"source/_posts/assets/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1601783167453},{"_id":"source/_posts/assets/屏幕快照 2019-01-14 上午12.33.27.png","hash":"9a90ea2824eeb2c8dbf4465c5cb29e8c330e0387","modified":1601783167453},{"_id":"source/_posts/assets/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1601783167453},{"_id":"source/_posts/assets/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1601783167453},{"_id":"source/_posts/assets/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1601783167453},{"_id":"source/_posts/assets/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1601783167453},{"_id":"source/_posts/assets/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1601783167453},{"_id":"source/_posts/assets/%E6%9E%B6%E6%9E%84.png","hash":"8347ee81110ebd4c47fa3dd2cc771da88a17679c","modified":1601783167542},{"_id":"source/_posts/assets/1555228253075.png","hash":"23a3500e9d3e1fa72862491767a1684f6af61259","modified":1601783167542},{"_id":"source/_posts/assets/1555228331186.png","hash":"d3e83b4f78b7de7f415967ff197477097501d1d4","modified":1601783167542},{"_id":"source/_posts/assets/404-bg.jpg","hash":"85480e340d2af57c4e4b3ae93525ed608ea343b7","modified":1601783167542},{"_id":"source/_posts/assets/3rK4jBFXZs3Ig47t.png!original","hash":"96eac110e839e0c0b1de8d371faef8e24354433b","modified":1609833382806},{"_id":"source/_posts/assets/5-4-1.png","hash":"547eaed4886791bd648bc37a74b9c87cd2687d70","modified":1601783167542},{"_id":"source/_posts/assets/bVbjaD6.jpeg","hash":"eadd9d52556e1f892ee7714622a872b753233616","modified":1601783167542},{"_id":"source/_posts/assets/donate-qr.png","hash":"28c94ec4dbdebc791ab9fc614ed533ca260832d4","modified":1601783167542},{"_id":"source/_posts/assets/dw7Q7n01PquYb8xX.png!original","hash":"6c8d6902a6ac9ca5f0d9eae539adb269fac847a9","modified":1609833356609},{"_id":"source/_posts/assets/exec_no_index_2.png","hash":"6de66a98dc4067429651be98f625c5008d422a44","modified":1601783167542},{"_id":"source/_posts/assets/hive_textfile1.png","hash":"3f5b6f68d42e0a9b578d99a201b4d355f9345adf","modified":1601783167542},{"_id":"source/_posts/assets/image-20181017150353887.png","hash":"fd38f6b10371f949b67e0d81a7b1db66c4337614","modified":1601783167542},{"_id":"source/_posts/assets/image-20181018140355729.png","hash":"5937f8b028b627573f67292745cb470f554c9d4a","modified":1601783167543},{"_id":"source/_posts/assets/image-20181018140412582.png","hash":"090319ea8d21caf98b86c00222f3c6b7e33d375b","modified":1601783167543},{"_id":"source/_posts/assets/image-20181019161615728.png","hash":"19158acac278754e67148fe8592dd49208c23149","modified":1601783167543},{"_id":"source/_posts/assets/image-20181027150507907.png","hash":"f520608e002d2975a9ce14290c514903f7f7065e","modified":1601783167546},{"_id":"source/_posts/assets/image-20181124202306595 2.png","hash":"0d21aa7820b75b70df53adcd709a4ed6a1bb4189","modified":1576217299000},{"_id":"source/_posts/assets/image-20181124205409162 2.png","hash":"5b4e6f4268341bf68e22009f3ca1fbb2a79b41af","modified":1576217299000},{"_id":"source/_posts/assets/image-20181228192741706.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1601783167543},{"_id":"source/_posts/assets/image-20181228192905376-5996545.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1601783167543},{"_id":"source/_posts/assets/image-20181228201105314.png","hash":"688c03a69ca9f54ddbeba8ca24239539e3985e93","modified":1601783167543},{"_id":"source/_posts/assets/image-20181228192905376.png","hash":"98a5c5c5c7f00f3c62700b4ca9eb50f391ebffaf","modified":1601783167545},{"_id":"source/_posts/assets/image-20181228201105314-5999065.png","hash":"688c03a69ca9f54ddbeba8ca24239539e3985e93","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003438922-6187679.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003438922.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003442918-6187682.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003442918.png","hash":"589bacd47a2eaf5399b9f9c08a8d273818820757","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003513281-6187713.png","hash":"fa2c773ad6c3d1c4ad93a7b28b13564a3fb7e1e2","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231003513281.png","hash":"fa2c773ad6c3d1c4ad93a7b28b13564a3fb7e1e2","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231170937495-6247377.png","hash":"51b59aaa9b07ded242ad5ca1d60b23e1503c8ac8","modified":1601783167543},{"_id":"source/_posts/assets/image-20181231170937495.png","hash":"51b59aaa9b07ded242ad5ca1d60b23e1503c8ac8","modified":1601783167543},{"_id":"source/_posts/assets/image-20190113193023545.png","hash":"b2c97c37f8467ae3c005525dd88e14b4d4178447","modified":1601783167543},{"_id":"source/_posts/assets/image-20190308105552914.png","hash":"a8cf85efc22a597142afc6081e0e6f5171752fbe","modified":1601783167544},{"_id":"source/_posts/assets/image-20190114162624572.png","hash":"8a144a0b835e9ec0eea6f3e47a168d13801298c0","modified":1601783167543},{"_id":"source/_posts/assets/image-20190414155203979.png","hash":"f4543ff3ff0db8055b231f376737307163ab20c3","modified":1601783167544},{"_id":"source/_posts/assets/image-20190414161020200.png","hash":"c98e023034650e7cf23654bc92d5e0491df12662","modified":1601783167544},{"_id":"source/_posts/assets/image-20210105151742421.png","hash":"14c06e70af5673a060a4ffa9b7b6e81831e8f021","modified":1609831062425},{"_id":"source/_posts/assets/修改字符集1.png","hash":"0c65e51806684dc45ebec4bc2c554db8c9df119b","modified":1601783167544},{"_id":"source/_posts/assets/修改字符集2.png","hash":"159e6d283c47cf5a671348315161b61e4c0dbcf7","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-12 下午11.28.38.png","hash":"356ef205df665d5259aaf90c029d5a722dd3293f","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-12 下午11.44.33.png","hash":"651eefd3c9ce973220951589bbcb9d5973ff32ed","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.50.07.png","hash":"595af55cd3d656d30d93e7408d2f25ea03249ac6","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.48.45.png","hash":"c43b075fccdbe11d72eabcfe4aadb06ac5d0b0a1","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午8.08.43.png","hash":"7479a6180e5e7f7a013235308c4df0f8588516e1","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.25.22.png","hash":"c50734ef38ca556b2d763ecfa81723b3e36236ff","modified":1601783167544},{"_id":"source/_posts/assets/查看执行时间.png","hash":"bdb350fbcf25aff587f362bd646ba7e52a3a91bd","modified":1601783167544},{"_id":"source/_posts/assets/屏幕快照 2019-01-14 上午12.35.22.png","hash":"edcf93540fad881a8f1665e7cdc397e4ce744717","modified":1601783167544},{"_id":"source/_posts/assets/表1.png","hash":"3463cef1af20c2064d7ca428849273546721b8b1","modified":1601783167544},{"_id":"source/_posts/assets/表3.png","hash":"4f9e8cd46107699e3b343fcab465b29d610637fc","modified":1601783167544},{"_id":"source/_posts/assets/软件过程框架.png","hash":"8a0c6404277f8ed485e55eaafb79cf8cead5c3ab","modified":1601783167544},{"_id":"source/_posts/assets/1-位图索引.png","hash":"c271edb9dd088c811bc3af63082571987318cb23","modified":1601783167595},{"_id":"source/_posts/assets/2-B树.png","hash":"a446c6e1298930ab7102ed0f9d0eac62d1fd566e","modified":1601783167542},{"_id":"source/_posts/assets/2-位图.png","hash":"51aefaeb23baf090b96c46bb9c01737f30f4334f","modified":1601783167542},{"_id":"source/_posts/assets/5-1-1.png","hash":"010655cce365b2308536c02c9984ec3e3525ba55","modified":1601783167595},{"_id":"source/_posts/assets/5-3.png","hash":"fe6bb40f3c7ebaeebfbe679837d3fb9f656316bd","modified":1601783167595},{"_id":"source/_posts/assets/5-2.png","hash":"6cc5cea7bd31f8dd745106c4b727f90b316791ec","modified":1601783167688},{"_id":"source/_posts/assets/5-5-1.png","hash":"01cdc743b292c05e38887fe61783d141bfc6e148","modified":1601783167639},{"_id":"source/_posts/assets/ERFinal.png","hash":"19bcf5aed020586cae748b28cc3fdcee40067a2c","modified":1601783167636},{"_id":"source/_posts/assets/ZyxlBMGXXPu08Qws.png!original","hash":"7a9a68f1bb3ea6a48c7228fbd4fdf2c7e2436d49","modified":1609832953208},{"_id":"source/_posts/assets/alipay.jpg","hash":"1389b1e7007add616e7cac0a02e03785d3c29ee6","modified":1601783167595},{"_id":"source/_posts/assets/avatar.jpg","hash":"18a3f43fc8818915a664d916c19275602e6b6220","modified":1601783167597},{"_id":"source/_posts/assets/favicon.png","hash":"18a3f43fc8818915a664d916c19275602e6b6220","modified":1601783167638},{"_id":"source/_posts/assets/hive_orc1.png","hash":"b2fb23c94a69e6b9d9100a7d19a39d4a795f94c4","modified":1601783167598},{"_id":"source/_posts/assets/hive_textfile2.png","hash":"c40a148cffcbd181d357c63fecfab3f9ff37c88a","modified":1601783167595},{"_id":"source/_posts/assets/image-20181126025537963 2.png","hash":"acccdbabca03c381de0109abfc69f78f51b99c27","modified":1576217299000},{"_id":"source/_posts/assets/image-20181228192856958-5996536.png","hash":"fae45d6819fc20e580ff5eeae8d76eb0f5222b44","modified":1601783167595},{"_id":"source/_posts/assets/image-20181228192856958.png","hash":"fae45d6819fc20e580ff5eeae8d76eb0f5222b44","modified":1601783167636},{"_id":"source/_posts/assets/image-20181228200129326-5998489.png","hash":"5ee89a8996a52d7f9b301943936149ea4ef28eff","modified":1601783167596},{"_id":"source/_posts/assets/image-20181231003424471-6187664.png","hash":"98b5c2aaeb16fabbadb21abc07913dc9ded792f2","modified":1601783167595},{"_id":"source/_posts/assets/image-20181228200129326.png","hash":"5ee89a8996a52d7f9b301943936149ea4ef28eff","modified":1601783167595},{"_id":"source/_posts/assets/image-20181231003424471.png","hash":"98b5c2aaeb16fabbadb21abc07913dc9ded792f2","modified":1601783167595},{"_id":"source/_posts/assets/image-20181231003457997-6187698.png","hash":"0a0c20f7d921003c8db24d97c5910784b23cb2ee","modified":1601783167595},{"_id":"source/_posts/assets/image-20181231003457997.png","hash":"0a0c20f7d921003c8db24d97c5910784b23cb2ee","modified":1601783167596},{"_id":"source/_posts/assets/process_list.png","hash":"4008cc356c868fbc2618205561ae7583a30bf07e","modified":1601783167638},{"_id":"source/_posts/assets/tags-bg.png","hash":"d26a01dabe7cbe25d653ffbf7367c4b66d910ce9","modified":1601783167714},{"_id":"source/_posts/assets/wechatpay.jpg","hash":"8cdc3490eb901b963fde50fec67f535a35af4c26","modified":1601783167595},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.45.10.png","hash":"f4a42f1e33c76bb087ca99c4bf8275f3ba14d41f","modified":1601783167596},{"_id":"source/_posts/assets/表2.png","hash":"abd4d2c03607f90506f6302357cb15bc683df5a1","modified":1601783167596},{"_id":"source/_posts/assets/1-B树索引.png","hash":"c86bffde5fced5c44e1ebaceb52f8e498af0301f","modified":1601783167594},{"_id":"source/_posts/assets/5-7.png","hash":"f0867e7c0a2df9c9a80966520cf051ee444b175a","modified":1601783167714},{"_id":"source/_posts/assets/5-9.png","hash":"63ed242d22bfc56dd484b506f99ed7675359fe0a","modified":1601783167638},{"_id":"source/_posts/assets/5-8.png","hash":"5e2eb373e46ceda2060c5e478702abafcecf87aa","modified":1601783167638},{"_id":"source/_posts/assets/cover-day.jpg","hash":"8b1aa6c2fec2455bd44ce089496c561296b21371","modified":1601783167737},{"_id":"source/_posts/assets/cover-night.jpg","hash":"024e16a5f6a34afa7634526e467dfa4a725e5493","modified":1601783167597},{"_id":"source/_posts/assets/image-20190113214926175.png","hash":"e52d0e8fa265ec07a7de62ec4a7df275c2767a32","modified":1601783167596},{"_id":"source/_posts/assets/no-inmemory.png","hash":"bd03a1ed5f97dcce3d30ecfa32dcdee58a53bba1","modified":1601783167719},{"_id":"source/_posts/assets/双亲委派模型.png","hash":"af5aacab582bae8399521906ee09fa44076650e0","modified":1601783167596},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.46.16.png","hash":"ec63fafb81fa9cb3ca58ddd43351ca32da0b82ea","modified":1601783167714},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.47.49.png","hash":"a6ddd6e5257f83fed26314d3e56ab6885ce2f0de","modified":1601783167713},{"_id":"source/_posts/assets/语句执行计划.png","hash":"bf57257f59f92327e1da9c7fa73e49782cabe28d","modified":1601783167719},{"_id":"source/_posts/assets/006tNbRwly1fwdiyk83baj31ig114aw6.jpg","hash":"be39820f72ba34cc04d3c8706908e16445094b2d","modified":1601783167739},{"_id":"source/_posts/assets/1555227964411.png","hash":"baafa5c2d3fa6c1de1a6171a2d5e8789d0021785","modified":1601783167638},{"_id":"source/_posts/assets/5-6.png","hash":"700f6123a4fd582adfe7730fee1c9a80c92c173d","modified":1601783167714},{"_id":"source/_posts/assets/JSimple-Snapshot-Macbook Pro15.png","hash":"75a9e94c7fcdc7ffb3724c33190a19a3115639af","modified":1601783167748},{"_id":"source/_posts/assets/image-20181231171547272-6247747.png","hash":"dd4e3c133e818e99c234d4a63908c1c5265fb00b","modified":1601783167739},{"_id":"source/_posts/assets/image-20190113230831573.png","hash":"2005c321992b1853ef53ff9de34938bf9e966acc","modified":1601783167714},{"_id":"source/_posts/assets/image-20190113230717837.png","hash":"8c41028f8698170830eb0d7da8093c11e530da9b","modified":1601783167714},{"_id":"source/_posts/assets/inmemory.png","hash":"99aaba0f7b81606069bbc404834c68520c04ddf8","modified":1601783167738},{"_id":"source/_posts/assets/类加载机制.png","hash":"1413282e5c03d474679826aea04802bc279ee0e7","modified":1601783167714},{"_id":"source/_posts/assets/5-1-2.png","hash":"510890f22e89e818b38c63db7bcb303b7352ee20","modified":1601783167768},{"_id":"source/_posts/assets/5-5-2.png","hash":"75acf2f5551ea44cc8a98407e2f4d4981e2cdd07","modified":1601783167714},{"_id":"source/_posts/assets/aCFEDYqbUtuMMWFm.png!original","hash":"7de5b1c60b997b22b6cd7de355f3e1c8858c6d7b","modified":1609833316240},{"_id":"source/_posts/assets/image-20181019161433801.png","hash":"ea5d03a276ea8058e52ad55cc7a9ab961553a24b","modified":1601783167737},{"_id":"source/_posts/assets/image-20181027233726178.png","hash":"5cc3bda1f0e3b57b95bc48c4aca58251004baa08","modified":1601783167769},{"_id":"source/_posts/assets/image-20181027233529314.png","hash":"865d8002ec8071e341838eda1ab94e6bb719b1dc","modified":1601783167748},{"_id":"source/_posts/assets/image-20181231171547272.png","hash":"dd4e3c133e818e99c234d4a63908c1c5265fb00b","modified":1601783167714},{"_id":"source/_posts/assets/image-20190312200304819.png","hash":"ea1522d93871c2fc41ba7403ad8289eb3feaa6bf","modified":1601783167720},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午10.57.10.png","hash":"0e5986ef83ee3b45cb836e93f5e382fea49feba7","modified":1601783167639},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.07.08.png","hash":"235d186aa80b16a6e96b135164885c9da982e798","modified":1601783167749},{"_id":"source/_posts/assets/屏幕快照 2019-01-14 上午12.30.40.png","hash":"bd37a9eb009802a10a34bfcf4b0628af19d327e0","modified":1601783167749},{"_id":"source/_posts/assets/006tNbRwly1fwdiojeitsj31eu1444it.jpg","hash":"fc24434eb081d331d5bdaaae379d6456f440fab4","modified":1601783167719},{"_id":"source/_posts/assets/5-4-2.png","hash":"9bd44b784b54a268a07e0e969e0c793291b89a1d","modified":1601783167639},{"_id":"source/_posts/assets/image-20190113211220925.png","hash":"11692dcc5bb0ccc4d3c025c825e0da9dfe7e4cd9","modified":1601783167755},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午9.06.20.png","hash":"b322e16bbed6edb9a603bf4e69fc85a8e56b3a08","modified":1601783167749},{"_id":"source/_posts/assets/image-20181019161451060.png","hash":"c407eb3fd8e5ffb20871e52ca93980a6c13373c3","modified":1601783167739},{"_id":"source/_posts/assets/image-20190113230627090.png","hash":"6f619a887345b66551fdbe76d1e44f1e2900f37c","modified":1601783167737},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午8.31.00.png","hash":"aac6ace85aaad620251afed80c3b5778be740208","modified":1601783167739},{"_id":"source/_posts/assets/1555227842703.png","hash":"9094bc60f240d9bb2f0951a2ff22b0b8389f88ec","modified":1601783167749},{"_id":"source/_posts/assets/image-20190414160931753.png","hash":"dbdd3150eebbc9c8ec3239ec6334c4e32a381a76","modified":1601783167739},{"_id":"source/_posts/assets/image-20190325104456133.png","hash":"b7a9264385bbede10697ef82ebd6e95d9f257d21","modified":1601783167739},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午7.09.22.png","hash":"d809f33950627ad4deebc1619efb16ebdcc146b1","modified":1601783167749},{"_id":"source/_posts/assets/屏幕快照 2019-01-14 上午12.30.46.png","hash":"48f4f56c16d0c7090e2be7cc3c6d5a3b6ce2ba5f","modified":1601783167749},{"_id":"source/_posts/assets/image-20181027164439676.png","hash":"ee5c6f3c746832646d6d4d2bec40686aea3559dc","modified":1601783167773},{"_id":"source/_posts/assets/image-20181027150559447.png","hash":"029d96a0987dfd36f7258578008dcfc6f5a096c6","modified":1601783167769},{"_id":"source/_posts/assets/屏幕快照 2019-01-13 下午8.49.11.png","hash":"c59e53398b004300d08d3b959a891f7d27c0d194","modified":1601783167741},{"_id":"source/_posts/assets/image-20181023205748006.png","hash":"72acca09aef38e6cb0860b31e77473f7b5f1d66f","modified":1601783167773},{"_id":"source/_posts/assets/image-20181019163053138.png","hash":"02fdb4951c6fcb85e8e595a16c7dfaaf1d1ba5c2","modified":1601783167751},{"_id":"source/_posts/assets/khmfgplaXcfeVygE.png!original","hash":"5819733d47c746be282b69c63edb891454c4500f","modified":1609833335230},{"_id":"source/_posts/assets/image-20181019161405925.png","hash":"9f1a4ba492fe865041303cbad2fa39c94d4adc93","modified":1601783167776},{"_id":"source/_posts/assets/image-20181019162644076.png","hash":"34203a08787cb00bd720902f477e30b7f49745a8","modified":1601783167793},{"_id":"source/_posts/assets/hive_arg.png","hash":"0dd1e826588aad247b63228f0f91fb55c2c0911f","modified":1601783167793},{"_id":"source/_posts/assets/f7g9O8xBBwHpkdZB.png!original","hash":"d704c21ac60520cc507d4a7d90d32593f1fc66b9","modified":1609833265092},{"_id":"source/_posts/assets/image-20190114062154430.png","hash":"43ffcaafc066198327fc52ec7be0017b3cdc572c","modified":1601783167776},{"_id":"source/_posts/assets/rlXjbmDdWKPLQS5R.png!original","hash":"675dacdd613acba8c6cad531daf46c7d1f424dd2","modified":1609833408748},{"_id":"source/_posts/assets/iwXvfrzHPmTxAVJ9.png!original","hash":"0120921787d2f3216e3fac086ac994fe2d8d0e99","modified":1609833447038},{"_id":"source/_posts/assets/可达性分析算法.png","hash":"dbd335492727ca73ee16fea0ec97aca988865d70","modified":1601783167792},{"_id":"source/_posts/assets/image-20181009202105976.png","hash":"b24a4a2482085275d15d8ce2a7104dd77943c1ea","modified":1601783167792},{"_id":"public/baidusitemap.xml","hash":"0ba0c2d002bf73ece2071a7bbad0e820b26ca699","modified":1621163014130},{"_id":"public/content.json","hash":"8b3f4554321db52c5352b1cd8872e1b362c67d6d","modified":1621163014146},{"_id":"public/atom.xml","hash":"a6e45f59333030008dbff19b915e9b9a6122e6ff","modified":1621163014146},{"_id":"public/search.json","hash":"ac6800b918f030779c647f59eee9ba475419a7ec","modified":1621163014148},{"_id":"public/post-sitemap.xml","hash":"8ecde9c508fbbda11767e03d753ef42c16cb6b65","modified":1621163014147},{"_id":"public/page-sitemap.xml","hash":"257dceb60f339521e9aed6c1729d8dbe7ebe7b6e","modified":1621161435902},{"_id":"public/category-sitemap.xml","hash":"7f79bac51abdc4af00e10796434fd82a90be69b8","modified":1621163014147},{"_id":"public/tag-sitemap.xml","hash":"53153a60cb6f4b8736c6e452c640f665a67b1912","modified":1621162850511},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1621161435902},{"_id":"public/sitemap.xml","hash":"91b1c35bb4bc1371c429e095758ee7bf6782b49a","modified":1621163014148},{"_id":"public/404.html","hash":"2561d53599e028c1e997c0ff930f289d0c238ae3","modified":1621162635967},{"_id":"public/about/index.html","hash":"cfae63c3989dd6c8de432033d530954e9fb6cba2","modified":1621162635968},{"_id":"public/categories/index.html","hash":"6cd3ac7cc4c57048be4a4154d5c901e4aa7eafbc","modified":1621162850521},{"_id":"public/tags/index.html","hash":"640733fffae516b16bae4f004d40b79240db502b","modified":1621162635968},{"_id":"public/archives/2018/06/index.html","hash":"229c5fe4e67e2de534d07671c43e5b0b9bd3d39e","modified":1621162635968},{"_id":"public/archives/2018/09/index.html","hash":"13ed6943180745efbfd0eb5bb72971b0fa8f05f3","modified":1621162635968},{"_id":"public/archives/2018/10/index.html","hash":"9ab0b82109111fe32ba9c13024f2d7ca87609689","modified":1621162635968},{"_id":"public/archives/2018/11/index.html","hash":"4615caed38774b7048debe3b1525dff7c301656c","modified":1621162635968},{"_id":"public/archives/2018/12/index.html","hash":"ae0f9b45eacdc7fa3e5a9ee3de9418a22c1edaf8","modified":1621162635968},{"_id":"public/archives/2019/03/index.html","hash":"cb71dcc16d2052e440c89a263ccd0f59722df065","modified":1621162635968},{"_id":"public/archives/2019/04/index.html","hash":"5493e614bdb90c48588b436711e2fe8b88090b0a","modified":1621162635968},{"_id":"public/archives/2019/05/index.html","hash":"17bad9a056d4eefbb2f1a652863bf8c4532a56b8","modified":1621162635969},{"_id":"public/archives/2019/10/index.html","hash":"9bde73711cbbe16d4f50921b1bd268c74d563756","modified":1621162635969},{"_id":"public/archives/2020/index.html","hash":"9a62a0445396507813d545be461b651d0595eb44","modified":1621162635969},{"_id":"public/archives/2020/10/index.html","hash":"fb4bd885cef01c04121164606afbc6d4e7340c77","modified":1621162635969},{"_id":"public/categories/life/index.html","hash":"1068c6015bad914c5eb3d490f6c01885d68a8e55","modified":1621161435926},{"_id":"public/categories/C/index.html","hash":"3dbe1c202707f67924c3e5fe40331dfbb20ced74","modified":1621162635969},{"_id":"public/categories/Java/index.html","hash":"0b4edf4d9ccb6f1dd9252ad176bf8b0ffb37fd7a","modified":1621162635969},{"_id":"public/categories/Hadoop/index.html","hash":"72060d3350da13fcc895ea0ce4778e624bae95cf","modified":1621162011810},{"_id":"public/categories/深度学习/index.html","hash":"dbe53290356f0e8cf5d844c678d48b4f8dd9ab16","modified":1621162635969},{"_id":"public/categories/数据库/index.html","hash":"1ee9b96084d5e5da5ab5a56d91296f7a95cae268","modified":1621162850521},{"_id":"public/categories/Win10/index.html","hash":"f516da99c7e5df16d16810f6e4423b1abee40ad5","modified":1621161435927},{"_id":"public/tags/Hexo/index.html","hash":"ebe7d41f73d65c2fa790d3927df0353a7683f3bf","modified":1621161435927},{"_id":"public/tags/Net/index.html","hash":"fe27b1c711acc1b5959967d15649440517655317","modified":1621162635970},{"_id":"public/tags/数据库/index.html","hash":"97a383360122d4514c5e85f3b2c0c6b1f597925e","modified":1621162011810},{"_id":"public/tags/NET/index.html","hash":"50a093124f8ad685f3534ef0a6aa1f1afd33d0d0","modified":1621162635970},{"_id":"public/tags/C/index.html","hash":"8745cc47b6cd4a14963a4accfb7bb8bd7c07beb4","modified":1621162635971},{"_id":"public/tags/JavaFX/index.html","hash":"8d330d2552837899d6eee826d1acde6e6eb76609","modified":1621162635971},{"_id":"public/tags/Java/index.html","hash":"dae3ecd5184cc039dcee39f8e4fe843b993526e2","modified":1621162011811},{"_id":"public/tags/Hadoop/index.html","hash":"d164b738c34c2d1f19bb372469b2815281eb7830","modified":1621162635971},{"_id":"public/tags/Spring/index.html","hash":"4b66b90892d942b52df10f79312d79ad0c212659","modified":1621162635971},{"_id":"public/tags/TensorFlow/index.html","hash":"3c64b972fbdefb4c9152bf565aa2fb493392768c","modified":1621162635971},{"_id":"public/tags/图像分割/index.html","hash":"0090b9e66cf2aeba2b254b55b13cfbe4df39cf2f","modified":1621162635971},{"_id":"public/tags/Docker/index.html","hash":"7da42d3f2a79a9cbc3cd5e1c7058d1bd189630d5","modified":1621162635971},{"_id":"public/tags/Oracle/index.html","hash":"b04a4575e6b4c0a188f2dceb192aac817d7a0b28","modified":1621162635971},{"_id":"public/tags/TimesTen/index.html","hash":"ede67ffaa8b2a20d8d1e7bd29b102cdc5b3d0d62","modified":1621162635971},{"_id":"public/tags/内存数据库/index.html","hash":"75e7fd07020e30fda34880bf5d1d69074a8b770f","modified":1621162635971},{"_id":"public/tags/云计算/index.html","hash":"ff803790df14edc96c8f760abc2dd5d18f9f40c7","modified":1621162635971},{"_id":"public/tags/Timesten/index.html","hash":"ef46b457daaffa88a2b1ea373fee671c50aed9b7","modified":1621162635971},{"_id":"public/tags/大三上笔记/index.html","hash":"8394f0e7c93b05cd2869b34b9b6f4053015bec72","modified":1621161435928},{"_id":"public/tags/数据仓库/index.html","hash":"2f3e58f27be3c366877a50c55760a8a33c47c8e5","modified":1621161435928},{"_id":"public/tags/Win10/index.html","hash":"8cb9dd88f71dcab9a633daeb55d996aae1437068","modified":1621162635971},{"_id":"public/tags/Linux/index.html","hash":"ccaab8296d7b426de1e83fa7e98be0f8a9a9514a","modified":1621162635971},{"_id":"public/tags/双系统/index.html","hash":"8d83d04adeb72d77343f728ad8a6c75cebb208c1","modified":1621162635971},{"_id":"public/tags/引导修复/index.html","hash":"ebcdeb71f0d39367ea5fb060411becefb9e894b9","modified":1621162635971},{"_id":"public/2020/10/02/Tensorflow-multi-GPU/index.html","hash":"cf72b3749fa38dc4d3e3a73c579f3b247aa4ebf4","modified":1621162635972},{"_id":"public/2019/10/19/Spring学习笔记/index.html","hash":"abe26d5064f604cc368bfd30095778e2e9280999","modified":1621162635972},{"_id":"public/2019/05/03/C-ReadWriteLock/index.html","hash":"bc6e429652297008046add95b3542c3c2dcc48ae","modified":1621162635972},{"_id":"public/2019/04/18/NET-Framework及EntityFramework/index.html","hash":"67baf197843a60a3c8023565d393fd30356aca4a","modified":1621162635972},{"_id":"public/2019/04/18/Framework/index.html","hash":"9b8874eaa9099205fcc8b0a8f33de2a11bab5e11","modified":1621162635972},{"_id":"public/2019/04/11/深入GC/index.html","hash":"f952a43319d4d0baa9b64b949bd4466a362174cf","modified":1621162635972},{"_id":"public/2019/03/27/Java类与类加载器/index.html","hash":"b9ce520b75ad61bbe020d1c3c483d1969a751fe8","modified":1621162635972},{"_id":"public/2019/03/06/深入学习Java（更新中）/index.html","hash":"8e7fa21d8f64fafe2b39a9f976867d1260c5ff93","modified":1621162635972},{"_id":"public/2019/03/05/数据库与内存数据库实验报告/index.html","hash":"be86d8baca3432b0a7a7bc0e5a6a493e851f3052","modified":1621162850521},{"_id":"public/2018/12/31/数据仓库期末项目文档/index.html","hash":"bc94895f78291f0288fd456c0ffad32561ca7193","modified":1621162850522},{"_id":"public/2018/12/31/云计算期末项目文档/index.html","hash":"e036781ca316ea93aef5e3d239a46f064c6b033f","modified":1621162850522},{"_id":"public/2018/12/12/Hadoop-Tags/index.html","hash":"7b4134fe9491e84ac238977f649e1664e14012fd","modified":1621162635972},{"_id":"public/2018/11/24/Practice/index.html","hash":"76fd1851bad91b5af7b859e88acb97db777f54ed","modified":1621162850522},{"_id":"public/2018/11/12/使用Docker安装Oracle-12c/index.html","hash":"0b8de3eac5e24ba5206899b1522caae0833bbe36","modified":1621162635973},{"_id":"public/2018/11/06/记一次Win10-Fedora双系统的小折腾/index.html","hash":"bbe267b422ad11f3207456040a4c78467f9cd794","modified":1621162635973},{"_id":"public/2018/10/28/JavaFX-学习小记/index.html","hash":"e94e59f89054877ed20e3e14bee0482d636d190a","modified":1621162635973},{"_id":"public/2018/09/02/TimesTen内存数据库课程笔记/index.html","hash":"dab5a78df8c76d11183272c001b78eb785324f4b","modified":1621162850522},{"_id":"public/2018/06/26/Dotnet/index.html","hash":"5754cefcd1d091cf155c6154831060d8e35c77e5","modified":1621162784248},{"_id":"public/2018/06/26/2017-10-14/index.html","hash":"93cae95187946634efe9298aabb9023a9d96ee6a","modified":1621161435932},{"_id":"public/archives/index.html","hash":"30547c449f07322e3a398642a98121795992f307","modified":1621162635974},{"_id":"public/archives/page/2/index.html","hash":"202e3e6557ecc857fc8d8e628259d5ad37e35caf","modified":1621162635974},{"_id":"public/archives/2018/index.html","hash":"e0ee7d1dfd7a1aec9489d67fa3b8b9e37b8a9099","modified":1621162635974},{"_id":"public/archives/2019/index.html","hash":"67bd9bf67c510a44aef8392959db2feb3bcdcdbc","modified":1621162635974},{"_id":"public/index.html","hash":"949571f2abe802a4f5b7c055f8b3ff97ff744165","modified":1621162850522},{"_id":"public/page/2/index.html","hash":"cacfaf96ffd3d96c5c46e679bcf1e877db79e267","modified":1621163014156},{"_id":"public/archives/2020/11/index.html","hash":"f60a0268d941ce4726278c708fd02b87395e50fc","modified":1621162635969},{"_id":"public/tags/分布式/index.html","hash":"e020fa0750abbdbcb397b34daadb71ca5dec3d87","modified":1621161435934},{"_id":"public/2020/11/02/分布式计算期末项目文档/index.html","hash":"531e7d5913e58a1c95dcd72f9f87bce2c92db0b7","modified":1621162850521},{"_id":"source/_posts/我们梦中见.md","hash":"950518500f418e6d5e8b610db9ad5543e709d7aa","modified":1621163005055},{"_id":"public/categories/小折腾/index.html","hash":"fb0eac9c5f5ce3ebe271caeebd00317cefd288c1","modified":1621162635970},{"_id":"public/categories/分布式与云计算/index.html","hash":"dd90ba03784257176ec57f79c63a97ec3cbf2c54","modified":1621162635970},{"_id":"public/categories/数据库/课程笔记/index.html","hash":"5e77f055757969ed2f5a0207b3f89e7d84918353","modified":1621162635970},{"_id":"public/categories/数据库-课程笔记/index.html","hash":"44146a1c87e63e54f4e364738f3b058e22b225ad","modified":1621162635970},{"_id":"public/categories/心记/index.html","hash":"bd4d8b1d66853505b9cf58cff3f4028ec9ed7862","modified":1621162635970},{"_id":"public/categories/分布式与云计算/课程笔记/index.html","hash":"5a17b757b53157c1ec0f259d4f5c03578ddd91e6","modified":1621162635970},{"_id":"public/tags/HDFS/index.html","hash":"2548a9c387105ac27af10f0ff084faceea085b0a","modified":1621162635971},{"_id":"public/tags/垃圾回收/index.html","hash":"272084fbf91881411cdcde69aeae79ee83ffde3b","modified":1621162635971},{"_id":"public/tags/泛型编程/index.html","hash":"3b1d607edf61ec500f76a245bf1c393cb94a3d22","modified":1621162635971},{"_id":"public/tags/容器/index.html","hash":"7d83ab3207cd43736329850ffae9c0d340391625","modified":1621162635971},{"_id":"public/tags/可达性分析/index.html","hash":"3e5a4d2eb736750bed32df786b600902872cfe72","modified":1621162635971},{"_id":"public/tags/HotSpot/index.html","hash":"a5a17e344c90579a9bd6b19b2ee887dc279a7592","modified":1621162635971},{"_id":"public/tags/Neo4j/index.html","hash":"ea52c6f2afce6a8dfe18f805e638c9e1ac5d4ef8","modified":1621162635971},{"_id":"public/tags/MySQL/index.html","hash":"216f570da64a9e3a0eb4565c8b2bed6880a33f8a","modified":1621162635971},{"_id":"public/tags/Influx/index.html","hash":"5ab887d04c3888561f6f6279316f1fa8f5f3d11b","modified":1621162635971},{"_id":"public/tags/Hive/index.html","hash":"7ad5ab1cd0b1e1e4e5b84c7b8ee97e800cb51507","modified":1621162635971},{"_id":"public/2018/06/26/我们梦中见/index.html","hash":"f854291bfc4d178066b41ae75e3903b534c98578","modified":1621163014156},{"_id":"public/tags/EFCore/index.html","hash":"93676e787313214e992f2bed1b26576668eee599","modified":1621162635976},{"_id":"public/tags/ADO-NET/index.html","hash":"748d686c1c68bc647fa4b6fab87394c7e408172d","modified":1621162635976},{"_id":"public/tags/Hadoop配置记录/index.html","hash":"367badfebc021181af72b8facef6a27d3f036dc2","modified":1621162635976},{"_id":"public/tags/ClassLoader/index.html","hash":"68a2b9a5694d45894ee5468ec1e3ea1623c8a9dd","modified":1621162635976},{"_id":"public/tags/NET-Framework/index.html","hash":"23f9d5679972069dd70eeb3a20fe8e2c04c6dbba","modified":1621162635976},{"_id":"public/tags/EntityFramework/index.html","hash":"09cf4cde98e0b83b724a33259b4d3d1e7cd2dafc","modified":1621162635976},{"_id":"public/tags/遥感影像/index.html","hash":"226d2ca44a116e29df591f3c56bf4fedbbca7391","modified":1621162635976}],"Category":[{"name":"life","_id":"ckfukja8w0004szxong45k6tg"},{"name":"C#","_id":"ckfukja96000bszxohywikf3k"},{"name":"Java","_id":"ckfukja9k000mszxoqsti1xwa"},{"name":"Hadoop","_id":"ckfukja9q000yszxoilg2dbi8"},{"name":"深度学习","_id":"ckfukjaa2001hszxo6y3x3gxd"},{"name":"数据库","_id":"ckfukjaa4001oszxom8x6v3nm"},{"name":"Win10","_id":"ckfukjaac0029szxoak6ue3i0"},{"name":"小折腾","_id":"ckor1sg7j000351xondtp676x"},{"name":"分布式与云计算","_id":"ckor1sg7s000551xonz6dr3zu"},{"name":"课程笔记","parent":"ckfukjaa4001oszxom8x6v3nm","_id":"ckor1viba000n51xo1cjrrwav"},{"name":"数据库 - 课程笔记","_id":"ckor1w7qp000x51xoc0r1wdvx"},{"name":"心记","_id":"ckor1xrzn000z51xokh8j3vxh"},{"name":"课程笔记","parent":"ckor1sg7s000551xonz6dr3zu","_id":"ckor1ycrk001451xombhc5ny3"}],"Data":[],"Page":[{"title":"404 Not Found 该页无法显示","date":"2018-11-05T17:08:58.000Z","toc":false,"_content":"","source":"404/index.md","raw":"---\ntitle: 404 Not Found 该页无法显示\ndate: 2018-11-06 01:08:58\ntoc: false\npermalink: /404\n---\n","updated":"2019-12-13T06:08:19.960Z","path":"/404.html","comments":1,"layout":"page","_id":"ckfukja8n0000szxowk879rgb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2017-10-20T13:04:41.000Z","_content":"\n## 用心写文，用脚上传\n\n## 每日一问\n\n> 芳芳到底什么时候下班呢？\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-10-20 21:04:41\n---\n\n## 用心写文，用脚上传\n\n## 每日一问\n\n> 芳芳到底什么时候下班呢？\n\n","updated":"2019-12-13T06:08:19.950Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfukja8s0002szxo387mnifk","content":"<h2 id=\"用心写文，用脚上传\"><a href=\"#用心写文，用脚上传\" class=\"headerlink\" title=\"用心写文，用脚上传\"></a>用心写文，用脚上传</h2><h2 id=\"每日一问\"><a href=\"#每日一问\" class=\"headerlink\" title=\"每日一问\"></a>每日一问</h2><blockquote>\n<p>芳芳到底什么时候下班呢？</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"用心写文，用脚上传\"><a href=\"#用心写文，用脚上传\" class=\"headerlink\" title=\"用心写文，用脚上传\"></a>用心写文，用脚上传</h2><h2 id=\"每日一问\"><a href=\"#每日一问\" class=\"headerlink\" title=\"每日一问\"></a>每日一问</h2><blockquote>\n<p>芳芳到底什么时候下班呢？</p>\n</blockquote>\n"},{"title":"categories","date":"2019-03-11T04:41:37.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-11 12:41:37\ntype: \"categories\"\n---\n","updated":"2019-12-13T06:08:19.960Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckfukja910006szxobes9kbov","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-05T17:00:28.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-06 01:00:28\ntype: \"tags\"\n---\n","updated":"2019-12-13T06:08:19.950Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckfukja930008szxosdwx43v2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C# - dotnet基本配置及EFCore连接Mysql","date":"2018-06-26T08:57:08.000Z","_content":"\n## 前奏部分\n\n- 下载并安装[dotnet core](https://www.microsoft.com/net/learn/get-started/)\n\n- 下载并安装[vscode](https://code.visualstudio.com/)（需要把vscode添加到path中）\n\n<!-- more -->\n\n- vscode中搜索并安装C#插件、NuGet Package Manager插件\n\n  > ![image-20180607144445947](http://getme.guitoubing.top/image-20180607144445947.png)\n\n- 新建项目\n\n  > ```shell\n  > mkdir dotnet\n  > cd dotnet\n  > dotnet new mvc\n  > code .\n  > ```\n\n- commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择\n\n  > ![image-20180607145123118](http://getme.guitoubing.top/image-20180607145223693.png)\n\n  > 添加包时以下代码将自动在dotnet.csproj中添加：\n  > ```xml\n  > <ItemGroup>\n  >     <PackageReference Include=\"Microsoft.AspNetCore.All\" Version=\"2.0.6\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite\" Version=\"2.1.0\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"2.1.0\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite.Design\" Version=\"2.0.0-preview1-final\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/>\n  >     <PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql\" Version=\"2.1.0-rc1-final\"/>\n  >     <PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql.Design\" Version=\"1.1.2\"/>\n  > </ItemGroup>\n  > ```\n\n## Model部分\n\n- 连接数据库创建实体：\n\n  在vscode终端中输入以下命令\n\n  ```\n  dotnet ef dbcontext scaffold \"server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;\" Pomelo.EntityFrameworkCore.MySql -o Models\n  ```\n\n- dotnet ef两个问题\n\n  > 问题1：No executable found matching command \"dotnet-ef\"\n  > 解决方法：dotnet.csproj中添加如下行： \n  >\n  > ```XML\n  >  <ItemGroup>\n  > \t<DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/>\n  > </ItemGroup>\n  > ```\n\n  > 问题2：Version for package `Microsoft.EntityFrameworkCore.Tools.DotNet` could not be resolved.\n  >\n  > 原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可\n\n  此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。**至此MVC已完成Model部分**。\n\n## Controller及View部分\n\n- 目前项目Models文件夹下已有DBFirst模式生成的实体文件：\n\n  ![image-20180607150002112](http://getme.guitoubing.top/image-20180607150002112.png)\n\n- 我们选择Student的Model创建C-V视图\n\n  > 这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index：\n  >\n  > ```C#\n  > public IActionResult Index(){\n  >         return View(_context.Student.ToList());\n  >     }\n  > ```\n  >\n  > 如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，**View只负责处理布局，Controller只负责处理逻辑。**\n\n  - 创建StudentController.cs\n\n    > ```c#\n    > using System;\n    > using System.Collections.Generic;\n    > using System.Diagnostics;\n    > using System.Linq;\n    > using System.Threading.Tasks;\n    > using Microsoft.AspNetCore.Mvc;\n    > using dotnet.Models;\n    > using dotnet;\n    > \n    > public class StudentController : Controller{\n    >     private universityContext _context;\n    > \n    >     public StudentController(universityContext context){\n    >         _context = context;\n    >     }\n    >     \n    >     public IActionResult Index(){\n    >         return View(_context.Student.ToList());\n    >     }\n    > \n    >     public IActionResult Register(){\n    >         return View();\n    >     }\n    > \n    >     [HttpPost]\n    >     [ValidateAntiForgeryToken]\n    >     public IActionResult Register(Student student){\n    >         if(ModelState.IsValid){\n    >             _context.Student.Add(student);\n    >             _context.SaveChanges();\n    >             return RedirectToAction(\"Index\");\n    >         }\n    >         return View(student);\n    >     }\n    > }\n    > ```\n\n  - 创建Student文件夹，以及对应路由的cshtml\n\n    > - Index.cshtml\n    >\n    > ```html\n    > @{\n    >     ViewData[\"Title\"] = \"学生主页\";\n    > }\n    > \n    > <!-- 此处这个model声明不能忘记 -->\n    > @model IEnumerable<dotnet.Student>\n    > \n    > <table class=\"table\">\n    >     <tr>\n    >         <th>Id</th>\n    >         <th>姓名</th>\n    >         <th>系</th>\n    >         <th>学分</th>\n    >     </tr>\n    >     @foreach (var item in Model){\n    >         <tr>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.Id)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.Name)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.DeptName)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.TotCred)\n    >             </td>\n    >         </tr>\n    >     }\n    > </table>\n    > ```\n    >\n    > - Register.cshtml\n    >\n    > ```html\n    > @model dotnet.Student\n    > \n    > @{\n    >     ViewData[\"Title\"] = \"注册\";\n    > }\n    > \n    > <form asp-controller=\"Student\" asp-action=\"Register\" method=\"POST\">\n    >     <div class=\"form-group\">\n    >         <label asp-for=\"Id\" class=\"col-md-2 control-label\">编号：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"Id\"/>\n    >             <span asp-validation-for=\"Id\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"Name\" class=\"col-md-2 control-label\">名字：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"Name\"/>\n    >             <span asp-validation-for=\"Name\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"DeptName\" class=\"col-md-2 control-label\">系：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"DeptName\"/>\n    >             <span asp-validation-for=\"DeptName\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"TotCred\" class=\"col-md-2 control-label\">学分：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"TotCred\"/>\n    >             <span asp-validation-for=\"TotCred\" class=\"text-danger\"></span>\n    >         </div>\n    >         <div class=\"col-md-offset-2 col-md-10\">\n    >             <input type=\"submit\" value=\"保存\" class=\"btn btn-default\"/>\n    >         </div>\n    >     </div>\n    > </form>\n    > ```\n\n- 关于抛出以下错误的解决方法\n\n  - 错误：\n\n    > ![image-20180607142732374](http://getme.guitoubing.top/image-20180607142732374.png)\n\n  - 解决方法：\n\n    > ![dotnet配置](http://getme.guitoubing.top/dotnet%E9%85%8D%E7%BD%AE.png)\n    >\n    > 注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码：\n    >\n    > ```c#\n    > public void ConfigureServices(IServiceCollection services)\n    >         {\n    >             services.AddDbContext<universityContext>();\n    >             services.AddMvc();\n    >         }\n    > ```\n    >\n    > 即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下：\n    >\n    > ```c#\n    > //if (!optionsBuilder.IsConfigured){ \n    > optionsBuilder.UseMySql(\"server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;\");\n    > //}\n    > ```\n\n  ## 运行项目\n\n  - 调试的方法\n\n    > - vscode下点按“开始调试”\n    >\n    >   ![image-20180607151747548](http://getme.guitoubing.top/image-20180607151747548.png)\n    >\n    > - 浏览器将会自动跳转至localhost:5000\n    >\n    >   ![image-20180607152008469](http://getme.guitoubing.top/image-20180607152008469.png)\n    >\n    > - 在URL中添加<u>/student</u>或<u>student/index</u>跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中：\n    >\n    >   ![image-20180607152229016](http://getme.guitoubing.top/image-20180607152229016.png)\n\n  - 戳这里下载[Asp.net Core开发实战.pdf](http://getme.guitoubing.top/ASP.NET%20Core%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%20,%E5%BC%A0%E5%89%91%E6%A1%A5%20,2017.04%20,Pg319_14181929.pdf)\n","source":"_posts/Dotnet.md","raw":"---\ntitle: C# - dotnet基本配置及EFCore连接Mysql\ndate: 2018-06-26 16:57:08\ntags: \n  - .Net\n  - EFCore\n  - MySQL\ncategories: \n  - C#\n---\n\n## 前奏部分\n\n- 下载并安装[dotnet core](https://www.microsoft.com/net/learn/get-started/)\n\n- 下载并安装[vscode](https://code.visualstudio.com/)（需要把vscode添加到path中）\n\n<!-- more -->\n\n- vscode中搜索并安装C#插件、NuGet Package Manager插件\n\n  > ![image-20180607144445947](http://getme.guitoubing.top/image-20180607144445947.png)\n\n- 新建项目\n\n  > ```shell\n  > mkdir dotnet\n  > cd dotnet\n  > dotnet new mvc\n  > code .\n  > ```\n\n- commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择\n\n  > ![image-20180607145123118](http://getme.guitoubing.top/image-20180607145223693.png)\n\n  > 添加包时以下代码将自动在dotnet.csproj中添加：\n  > ```xml\n  > <ItemGroup>\n  >     <PackageReference Include=\"Microsoft.AspNetCore.All\" Version=\"2.0.6\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite\" Version=\"2.1.0\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"2.1.0\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite.Design\" Version=\"2.0.0-preview1-final\"/>\n  >     <PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/>\n  >     <PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql\" Version=\"2.1.0-rc1-final\"/>\n  >     <PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql.Design\" Version=\"1.1.2\"/>\n  > </ItemGroup>\n  > ```\n\n## Model部分\n\n- 连接数据库创建实体：\n\n  在vscode终端中输入以下命令\n\n  ```\n  dotnet ef dbcontext scaffold \"server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;\" Pomelo.EntityFrameworkCore.MySql -o Models\n  ```\n\n- dotnet ef两个问题\n\n  > 问题1：No executable found matching command \"dotnet-ef\"\n  > 解决方法：dotnet.csproj中添加如下行： \n  >\n  > ```XML\n  >  <ItemGroup>\n  > \t<DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/>\n  > </ItemGroup>\n  > ```\n\n  > 问题2：Version for package `Microsoft.EntityFrameworkCore.Tools.DotNet` could not be resolved.\n  >\n  > 原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可\n\n  此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。**至此MVC已完成Model部分**。\n\n## Controller及View部分\n\n- 目前项目Models文件夹下已有DBFirst模式生成的实体文件：\n\n  ![image-20180607150002112](http://getme.guitoubing.top/image-20180607150002112.png)\n\n- 我们选择Student的Model创建C-V视图\n\n  > 这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index：\n  >\n  > ```C#\n  > public IActionResult Index(){\n  >         return View(_context.Student.ToList());\n  >     }\n  > ```\n  >\n  > 如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，**View只负责处理布局，Controller只负责处理逻辑。**\n\n  - 创建StudentController.cs\n\n    > ```c#\n    > using System;\n    > using System.Collections.Generic;\n    > using System.Diagnostics;\n    > using System.Linq;\n    > using System.Threading.Tasks;\n    > using Microsoft.AspNetCore.Mvc;\n    > using dotnet.Models;\n    > using dotnet;\n    > \n    > public class StudentController : Controller{\n    >     private universityContext _context;\n    > \n    >     public StudentController(universityContext context){\n    >         _context = context;\n    >     }\n    >     \n    >     public IActionResult Index(){\n    >         return View(_context.Student.ToList());\n    >     }\n    > \n    >     public IActionResult Register(){\n    >         return View();\n    >     }\n    > \n    >     [HttpPost]\n    >     [ValidateAntiForgeryToken]\n    >     public IActionResult Register(Student student){\n    >         if(ModelState.IsValid){\n    >             _context.Student.Add(student);\n    >             _context.SaveChanges();\n    >             return RedirectToAction(\"Index\");\n    >         }\n    >         return View(student);\n    >     }\n    > }\n    > ```\n\n  - 创建Student文件夹，以及对应路由的cshtml\n\n    > - Index.cshtml\n    >\n    > ```html\n    > @{\n    >     ViewData[\"Title\"] = \"学生主页\";\n    > }\n    > \n    > <!-- 此处这个model声明不能忘记 -->\n    > @model IEnumerable<dotnet.Student>\n    > \n    > <table class=\"table\">\n    >     <tr>\n    >         <th>Id</th>\n    >         <th>姓名</th>\n    >         <th>系</th>\n    >         <th>学分</th>\n    >     </tr>\n    >     @foreach (var item in Model){\n    >         <tr>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.Id)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.Name)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.DeptName)\n    >             </td>\n    >             <td>\n    >                 @Html.DisplayFor(modelItem => item.TotCred)\n    >             </td>\n    >         </tr>\n    >     }\n    > </table>\n    > ```\n    >\n    > - Register.cshtml\n    >\n    > ```html\n    > @model dotnet.Student\n    > \n    > @{\n    >     ViewData[\"Title\"] = \"注册\";\n    > }\n    > \n    > <form asp-controller=\"Student\" asp-action=\"Register\" method=\"POST\">\n    >     <div class=\"form-group\">\n    >         <label asp-for=\"Id\" class=\"col-md-2 control-label\">编号：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"Id\"/>\n    >             <span asp-validation-for=\"Id\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"Name\" class=\"col-md-2 control-label\">名字：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"Name\"/>\n    >             <span asp-validation-for=\"Name\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"DeptName\" class=\"col-md-2 control-label\">系：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"DeptName\"/>\n    >             <span asp-validation-for=\"DeptName\" class=\"text-danger\"></span>\n    >         </div>\n    >         <label asp-for=\"TotCred\" class=\"col-md-2 control-label\">学分：</label>\n    >         <div class=\"col-md-10\">\n    >             <input class=\"form-control\" asp-for=\"TotCred\"/>\n    >             <span asp-validation-for=\"TotCred\" class=\"text-danger\"></span>\n    >         </div>\n    >         <div class=\"col-md-offset-2 col-md-10\">\n    >             <input type=\"submit\" value=\"保存\" class=\"btn btn-default\"/>\n    >         </div>\n    >     </div>\n    > </form>\n    > ```\n\n- 关于抛出以下错误的解决方法\n\n  - 错误：\n\n    > ![image-20180607142732374](http://getme.guitoubing.top/image-20180607142732374.png)\n\n  - 解决方法：\n\n    > ![dotnet配置](http://getme.guitoubing.top/dotnet%E9%85%8D%E7%BD%AE.png)\n    >\n    > 注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码：\n    >\n    > ```c#\n    > public void ConfigureServices(IServiceCollection services)\n    >         {\n    >             services.AddDbContext<universityContext>();\n    >             services.AddMvc();\n    >         }\n    > ```\n    >\n    > 即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下：\n    >\n    > ```c#\n    > //if (!optionsBuilder.IsConfigured){ \n    > optionsBuilder.UseMySql(\"server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;\");\n    > //}\n    > ```\n\n  ## 运行项目\n\n  - 调试的方法\n\n    > - vscode下点按“开始调试”\n    >\n    >   ![image-20180607151747548](http://getme.guitoubing.top/image-20180607151747548.png)\n    >\n    > - 浏览器将会自动跳转至localhost:5000\n    >\n    >   ![image-20180607152008469](http://getme.guitoubing.top/image-20180607152008469.png)\n    >\n    > - 在URL中添加<u>/student</u>或<u>student/index</u>跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中：\n    >\n    >   ![image-20180607152229016](http://getme.guitoubing.top/image-20180607152229016.png)\n\n  - 戳这里下载[Asp.net Core开发实战.pdf](http://getme.guitoubing.top/ASP.NET%20Core%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%20,%E5%BC%A0%E5%89%91%E6%A1%A5%20,2017.04%20,Pg319_14181929.pdf)\n","slug":"Dotnet","published":1,"updated":"2021-05-16T10:59:22.035Z","_id":"ckfukja8t0003szxopnv39i7f","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前奏部分\"><a href=\"#前奏部分\" class=\"headerlink\" title=\"前奏部分\"></a>前奏部分</h2><ul>\n<li><p>下载并安装<a href=\"https://www.microsoft.com/net/learn/get-started/\" target=\"_blank\" rel=\"noopener\">dotnet core</a></p>\n</li>\n<li><p>下载并安装<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">vscode</a>（需要把vscode添加到path中）</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>vscode中搜索并安装C#插件、NuGet Package Manager插件</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607144445947.png\" alt=\"image-20180607144445947\"></p>\n</blockquote>\n</li>\n<li><p>新建项目</p>\n<blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> mkdir dotnet</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> cd dotnet</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> dotnet new mvc</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> code .</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607145223693.png\" alt=\"image-20180607145123118\"></p>\n</blockquote>\n<blockquote>\n<p>添加包时以下代码将自动在dotnet.csproj中添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.AspNetCore.All\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.0.6\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Sqlite\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Sqlite.Design\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.0.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools.DotNet\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Pomelo.EntityFrameworkCore.MySql\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-rc1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Pomelo.EntityFrameworkCore.MySql.Design\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"1.1.2\"</span>/&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Model部分\"><a href=\"#Model部分\" class=\"headerlink\" title=\"Model部分\"></a>Model部分</h2><ul>\n<li><p>连接数据库创建实体：</p>\n<p>在vscode终端中输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dotnet ef dbcontext scaffold &quot;server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;&quot; Pomelo.EntityFrameworkCore.MySql -o Models</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dotnet ef两个问题</p>\n<blockquote>\n<p>问题1：No executable found matching command “dotnet-ef”<br>解决方法：dotnet.csproj中添加如下行： </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;  <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt; \t<span class=\"tag\">&lt;<span class=\"name\">DotNetCliToolReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools.DotNet\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>问题2：Version for package <code>Microsoft.EntityFrameworkCore.Tools.DotNet</code> could not be resolved.</p>\n<p>原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可</p>\n</blockquote>\n<p>此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。<strong>至此MVC已完成Model部分</strong>。</p>\n</li>\n</ul>\n<h2 id=\"Controller及View部分\"><a href=\"#Controller及View部分\" class=\"headerlink\" title=\"Controller及View部分\"></a>Controller及View部分</h2><ul>\n<li><p>目前项目Models文件夹下已有DBFirst模式生成的实体文件：</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607150002112.png\" alt=\"image-20180607150002112\"></p>\n</li>\n<li><p>我们选择Student的Model创建C-V视图</p>\n<blockquote>\n<p>这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; public IActionResult Index()&#123;</span><br><span class=\"line\">&gt;         return View(_context.Student.ToList());</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，<strong>View只负责处理布局，Controller只负责处理逻辑。</strong></p>\n</blockquote>\n<ul>\n<li><p>创建StudentController.cs</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; using System;</span><br><span class=\"line\">&gt; using System.Collections.Generic;</span><br><span class=\"line\">&gt; using System.Diagnostics;</span><br><span class=\"line\">&gt; using System.Linq;</span><br><span class=\"line\">&gt; using System.Threading.Tasks;</span><br><span class=\"line\">&gt; using Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">&gt; using dotnet.Models;</span><br><span class=\"line\">&gt; using dotnet;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; public class StudentController : Controller&#123;</span><br><span class=\"line\">&gt;     private universityContext _context;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     public StudentController(universityContext context)&#123;</span><br><span class=\"line\">&gt;         _context = context;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt;     </span><br><span class=\"line\">&gt;     public IActionResult Index()&#123;</span><br><span class=\"line\">&gt;         return View(_context.Student.ToList());</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     public IActionResult Register()&#123;</span><br><span class=\"line\">&gt;         return View();</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     [HttpPost]</span><br><span class=\"line\">&gt;     [ValidateAntiForgeryToken]</span><br><span class=\"line\">&gt;     public IActionResult Register(Student student)&#123;</span><br><span class=\"line\">&gt;         if(ModelState.IsValid)&#123;</span><br><span class=\"line\">&gt;             _context.Student.Add(student);</span><br><span class=\"line\">&gt;             _context.SaveChanges();</span><br><span class=\"line\">&gt;             return RedirectToAction(&quot;Index&quot;);</span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;         return View(student);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>创建Student文件夹，以及对应路由的cshtml</p>\n<blockquote>\n<ul>\n<li>Index.cshtml</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; @&#123;</span><br><span class=\"line\">&gt;     ViewData[\"Title\"] = \"学生主页\";</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"comment\">&lt;!-- 此处这个model声明不能忘记 --&gt;</span></span><br><span class=\"line\">&gt; @model IEnumerable<span class=\"tag\">&lt;<span class=\"name\">dotnet.Student</span>&gt;</span></span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table\"</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>Id<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>姓名<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>系<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>学分<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;     @foreach (var item in Model)&#123;</span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Id)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Name)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.DeptName)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.TotCred)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>Register.cshtml</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; @model dotnet.Student</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; @&#123;</span><br><span class=\"line\">&gt;     ViewData[\"Title\"] = \"注册\";</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">asp-controller</span>=<span class=\"string\">\"Student\"</span> <span class=\"attr\">asp-action</span>=<span class=\"string\">\"Register\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-group\"</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Id\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>编号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Id\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"Id\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Name\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>名字：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Name\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"Name\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"DeptName\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>系：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"DeptName\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"DeptName\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"TotCred\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>学分：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"TotCred\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"TotCred\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-offset-2 col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"保存\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-default\"</span>/&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>关于抛出以下错误的解决方法</p>\n<ul>\n<li><p>错误：</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607142732374.png\" alt=\"image-20180607142732374\"></p>\n</blockquote>\n</li>\n<li><p>解决方法：</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/dotnet%E9%85%8D%E7%BD%AE.png\" alt=\"dotnet配置\"></p>\n<p>注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">&gt;         &#123;</span><br><span class=\"line\">&gt;             services.AddDbContext&lt;universityContext&gt;();</span><br><span class=\"line\">&gt;             services.AddMvc();</span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; //if (!optionsBuilder.IsConfigured)&#123; </span><br><span class=\"line\">&gt; optionsBuilder.UseMySql(&quot;server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;&quot;);</span><br><span class=\"line\">&gt; //&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"运行项目\"><a href=\"#运行项目\" class=\"headerlink\" title=\"运行项目\"></a>运行项目</h2><ul>\n<li><p>调试的方法</p>\n<blockquote>\n<ul>\n<li><p>vscode下点按“开始调试”</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607151747548.png\" alt=\"image-20180607151747548\"></p>\n</li>\n<li><p>浏览器将会自动跳转至localhost:5000</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607152008469.png\" alt=\"image-20180607152008469\"></p>\n</li>\n<li><p>在URL中添加<u>/student</u>或<u>student/index</u>跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中：</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607152229016.png\" alt=\"image-20180607152229016\"></p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>戳这里下载<a href=\"http://getme.guitoubing.top/ASP.NET%20Core%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%20,%E5%BC%A0%E5%89%91%E6%A1%A5%20,2017.04%20,Pg319_14181929.pdf\" target=\"_blank\" rel=\"noopener\">Asp.net Core开发实战.pdf</a></p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前奏部分\"><a href=\"#前奏部分\" class=\"headerlink\" title=\"前奏部分\"></a>前奏部分</h2><ul>\n<li><p>下载并安装<a href=\"https://www.microsoft.com/net/learn/get-started/\" target=\"_blank\" rel=\"noopener\">dotnet core</a></p>\n</li>\n<li><p>下载并安装<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">vscode</a>（需要把vscode添加到path中）</p>\n</li>\n</ul>","more":"<ul>\n<li><p>vscode中搜索并安装C#插件、NuGet Package Manager插件</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607144445947.png\" alt=\"image-20180607144445947\"></p>\n</blockquote>\n</li>\n<li><p>新建项目</p>\n<blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> mkdir dotnet</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> cd dotnet</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> dotnet new mvc</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> code .</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607145223693.png\" alt=\"image-20180607145123118\"></p>\n</blockquote>\n<blockquote>\n<p>添加包时以下代码将自动在dotnet.csproj中添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.AspNetCore.All\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.0.6\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Sqlite\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Sqlite.Design\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.0.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools.DotNet\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Pomelo.EntityFrameworkCore.MySql\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-rc1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">PackageReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Pomelo.EntityFrameworkCore.MySql.Design\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"1.1.2\"</span>/&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Model部分\"><a href=\"#Model部分\" class=\"headerlink\" title=\"Model部分\"></a>Model部分</h2><ul>\n<li><p>连接数据库创建实体：</p>\n<p>在vscode终端中输入以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dotnet ef dbcontext scaffold &quot;server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;&quot; Pomelo.EntityFrameworkCore.MySql -o Models</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dotnet ef两个问题</p>\n<blockquote>\n<p>问题1：No executable found matching command “dotnet-ef”<br>解决方法：dotnet.csproj中添加如下行： </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;  <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt; \t<span class=\"tag\">&lt;<span class=\"name\">DotNetCliToolReference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"Microsoft.EntityFrameworkCore.Tools.DotNet\"</span> <span class=\"attr\">Version</span>=<span class=\"string\">\"2.1.0-preview1-final\"</span>/&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>问题2：Version for package <code>Microsoft.EntityFrameworkCore.Tools.DotNet</code> could not be resolved.</p>\n<p>原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可</p>\n</blockquote>\n<p>此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。<strong>至此MVC已完成Model部分</strong>。</p>\n</li>\n</ul>\n<h2 id=\"Controller及View部分\"><a href=\"#Controller及View部分\" class=\"headerlink\" title=\"Controller及View部分\"></a>Controller及View部分</h2><ul>\n<li><p>目前项目Models文件夹下已有DBFirst模式生成的实体文件：</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607150002112.png\" alt=\"image-20180607150002112\"></p>\n</li>\n<li><p>我们选择Student的Model创建C-V视图</p>\n<blockquote>\n<p>这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; public IActionResult Index()&#123;</span><br><span class=\"line\">&gt;         return View(_context.Student.ToList());</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，<strong>View只负责处理布局，Controller只负责处理逻辑。</strong></p>\n</blockquote>\n<ul>\n<li><p>创建StudentController.cs</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; using System;</span><br><span class=\"line\">&gt; using System.Collections.Generic;</span><br><span class=\"line\">&gt; using System.Diagnostics;</span><br><span class=\"line\">&gt; using System.Linq;</span><br><span class=\"line\">&gt; using System.Threading.Tasks;</span><br><span class=\"line\">&gt; using Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">&gt; using dotnet.Models;</span><br><span class=\"line\">&gt; using dotnet;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; public class StudentController : Controller&#123;</span><br><span class=\"line\">&gt;     private universityContext _context;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     public StudentController(universityContext context)&#123;</span><br><span class=\"line\">&gt;         _context = context;</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt;     </span><br><span class=\"line\">&gt;     public IActionResult Index()&#123;</span><br><span class=\"line\">&gt;         return View(_context.Student.ToList());</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     public IActionResult Register()&#123;</span><br><span class=\"line\">&gt;         return View();</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     [HttpPost]</span><br><span class=\"line\">&gt;     [ValidateAntiForgeryToken]</span><br><span class=\"line\">&gt;     public IActionResult Register(Student student)&#123;</span><br><span class=\"line\">&gt;         if(ModelState.IsValid)&#123;</span><br><span class=\"line\">&gt;             _context.Student.Add(student);</span><br><span class=\"line\">&gt;             _context.SaveChanges();</span><br><span class=\"line\">&gt;             return RedirectToAction(&quot;Index&quot;);</span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;         return View(student);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>创建Student文件夹，以及对应路由的cshtml</p>\n<blockquote>\n<ul>\n<li>Index.cshtml</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; @&#123;</span><br><span class=\"line\">&gt;     ViewData[\"Title\"] = \"学生主页\";</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"comment\">&lt;!-- 此处这个model声明不能忘记 --&gt;</span></span><br><span class=\"line\">&gt; @model IEnumerable<span class=\"tag\">&lt;<span class=\"name\">dotnet.Student</span>&gt;</span></span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table\"</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>Id<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>姓名<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>系<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>学分<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;     @foreach (var item in Model)&#123;</span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Id)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Name)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.DeptName)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;                 @Html.DisplayFor(modelItem =&gt; item.TotCred)</span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>Register.cshtml</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; @model dotnet.Student</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; @&#123;</span><br><span class=\"line\">&gt;     ViewData[\"Title\"] = \"注册\";</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">asp-controller</span>=<span class=\"string\">\"Student\"</span> <span class=\"attr\">asp-action</span>=<span class=\"string\">\"Register\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-group\"</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Id\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>编号：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Id\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"Id\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Name\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>名字：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"Name\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"Name\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"DeptName\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>系：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"DeptName\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"DeptName\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"TotCred\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-2 control-label\"</span>&gt;</span>学分：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"form-control\"</span> <span class=\"attr\">asp-for</span>=<span class=\"string\">\"TotCred\"</span>/&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">asp-validation-for</span>=<span class=\"string\">\"TotCred\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-offset-2 col-md-10\"</span>&gt;</span></span><br><span class=\"line\">&gt;             <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"保存\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn btn-default\"</span>/&gt;</span></span><br><span class=\"line\">&gt;         <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt;     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>关于抛出以下错误的解决方法</p>\n<ul>\n<li><p>错误：</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/image-20180607142732374.png\" alt=\"image-20180607142732374\"></p>\n</blockquote>\n</li>\n<li><p>解决方法：</p>\n<blockquote>\n<p><img src=\"http://getme.guitoubing.top/dotnet%E9%85%8D%E7%BD%AE.png\" alt=\"dotnet配置\"></p>\n<p>注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">&gt;         &#123;</span><br><span class=\"line\">&gt;             services.AddDbContext&lt;universityContext&gt;();</span><br><span class=\"line\">&gt;             services.AddMvc();</span><br><span class=\"line\">&gt;         &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; //if (!optionsBuilder.IsConfigured)&#123; </span><br><span class=\"line\">&gt; optionsBuilder.UseMySql(&quot;server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;&quot;);</span><br><span class=\"line\">&gt; //&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"运行项目\"><a href=\"#运行项目\" class=\"headerlink\" title=\"运行项目\"></a>运行项目</h2><ul>\n<li><p>调试的方法</p>\n<blockquote>\n<ul>\n<li><p>vscode下点按“开始调试”</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607151747548.png\" alt=\"image-20180607151747548\"></p>\n</li>\n<li><p>浏览器将会自动跳转至localhost:5000</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607152008469.png\" alt=\"image-20180607152008469\"></p>\n</li>\n<li><p>在URL中添加<u>/student</u>或<u>student/index</u>跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中：</p>\n<p><img src=\"http://getme.guitoubing.top/image-20180607152229016.png\" alt=\"image-20180607152229016\"></p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>戳这里下载<a href=\"http://getme.guitoubing.top/ASP.NET%20Core%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%20,%E5%BC%A0%E5%89%91%E6%A1%A5%20,2017.04%20,Pg319_14181929.pdf\" target=\"_blank\" rel=\"noopener\">Asp.net Core开发实战.pdf</a></p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"C# - 实现读写锁","date":"2019-05-02T16:33:11.000Z","_content":"使用C#实现的`可重入`、`非公平`的`读写锁`，主要目的实现**并发读写**以及**读写同步**问题。为了**减少读等待时间**以及**防止出现写饥饿现象**，本锁使用了**非同步锁**的实现，允许**读优先（提高效率）**的同时**使用一个阈值限定读者的最大数量（防止写饥饿）**；重入机制允许某个线程可以获取锁多次（如多次函数调用导致的锁重入），每次获取都需要有对应的释放，否则会出错。\n\n<!-- more -->\n\n本锁的目的是实现对读写线程队列的调度，而不是对线程获取锁的顺序进行调度。要注意读写线程进入队列的顺序是系统调度的（意即创建多个线程并Start时，其进入线程的时机是系统决定的，可能最后创建的线程最先执行），这里实现的是**对进入队列后的线程进行阻塞、唤醒等操作**。\n\n本锁使用了`C#`中的`lock原语`，目的是为了实现一些**队列操作的原子性**。\n\n实现本锁时作者参考了`Java`中`AQS`和`ReentrantReadWriteLock`的一些实现细节，予以理解仿效，设计了这个简单的读写锁，实现逻辑上可能仍有很多缺陷或矛盾，望各位看官批评指正！\n\n## Node节点\n\nNode节点是实现本读写锁的关键所在，读写线程队列也是基于Node节点实现的。Node内部持有了一个线程，同时有很多指向其他Node的引用。Node类实现如下：\n\n```c#\npublic class Node\n    {\n        // 读节点\n        public static readonly Node SHARED = new Node();\n        // 写节点\n        public static readonly Node EXCLUSIVE = null;\n        // 读链长度阈值\n        public static int Threshold = 3;\n\n        // 节点状态\n        public static readonly int CANCELLED = 1;\n        public static readonly int RUNNING = -1;\n        public static readonly int WAITING = -2;\n        public static readonly int SIGNAL = -3;\n    \n        public int waitStatus;\n        // 前驱节点\n        public Node prev;\n        // 后继节点\n        public Node next;\n        // 持有线程\n        public Thread thread;\n\n        //以下参数仅对读节点适用\n        // 读链头\n        public Node readerHead;\n        // 后继读节点\n        public Node nextReader;\n        // 读链长度\n        public int readerCount = 1;\n\n        // 节点类型\n        public Node mode;\n        // 是否是共享节点\n        public bool isShared()\n        {\n            return mode == SHARED;\n        }\n        public Node()\n        {\n        }\n\n        // 创建共享或独占节点\n        public Node(Thread thread, Node mode)\n        {\n            this.mode = mode;\n            this.thread = thread;\n        }\n\n    \t// 获取状态\n        public static string GetStatus(int status)\n        {\n            switch (status)\n            {\n                case 1:\n                    return \"CANCELLED\";\n                case -1:\n                    return \"RUNNING\";\n                case -2:\n                    return \"WAITING\";\n                case -3:\n                    return \"SIGNAL\";\n            }\n            return \"DEFAULT\";\n        }\n    }\n```\n\n各属性及方法的涵义如上述代码注释所示，而由Node组成的等待队列结构（双向链表）如下图所示（可能出现的一种情况）：\n\n![队列示意图.png](http://getme.guitoubing.top/队列示意图.png)\n\n对于写节点来说，锁是独占的，一次仅能有一个写线程在执行；而对于读节点来说，锁是共享的，在同一读链上的所有节点都可同时进行读。\n\n## 重要变量\n\n### 头节点 head\n\n头节点是个傀儡节点，`private volatile Node head`，其无实际涵义，只是为了作为队列头而存在；其使用了惰性初始化的方法，仅在第一个节点入队列时初始化。\n\n> `volatile`关键字在是为了实现变量的内存可见性，使用该关键字修饰的变量的修改会直接反映到内存中而不是缓存中。\n\n### 尾节点 tail\n\n尾节点是队列的最后一个节点，`private volatile Node tail`，引入尾节点是为了防止在新节点入列时遍历队列，提高了效率。\n\n### 重入量 reentrants\n\n对于写锁（独占锁）来说，当一个写线程获取锁时，`reentrants`为`1`，后续每当锁重入一次，`reentrants`增加`1`；释放锁时，每释放一次`reentrants`减少1，直到`reentrants`为`0`时该线程释放当前锁，唤醒后续线程；\n\n对于读锁（共享锁）来说，由于读链中可能会有不超过`Node.Threshold`个数的读节点，且每个读节点都可能会产生重入，这里会将`reentrants`初始化为读链长度，在`Node.RUNNING``时读链每增加一个读节点会增加一个reentrants`，读链中的每个节点多一次重入也会导致`reentrants`增加`1`。\n\n## 写锁\n\n### 获取 WriteLock()\n\n先看获取写锁的流程：\n\n```c#\n/**\n * 获取写锁\n */\npublic void WriteLock()\n{\n    // 当前节点\n    Node currentNode = null;\n    // 这里使用了惰性初始化，如果头节点为空，则初始化头节点\n    lock (this)\n    {\n        if (head == null)\n            head = new Node();\n    }\n    // 如果尾节点为空，说明当前队列为空，此时线程直接入队列设置为RUNNING状态\n    lock (this)\n    {\n        if (tail == null)\n        {\n            EnqWhenTailNull(Node.EXCLUSIVE);\n            return;\n        }\n    }\n    lock (this)\n    {\n        // 如果当前线程就是持有线程，说明锁在重入，reentrants加1\n        if (owner == Thread.CurrentThread)\n        {\n            reentrants += 1;\n            return;\n        }\n        // 否则，当前线程需要进入等待队列进行等待\n        else\n        {\n            // 获取尾节点\n            Node t = tail;\n            // 由于可能出现其他线程的介入，需要再次检测为节点是否为空\n            if (t == null)\n            {\n                EnqWhenTailNull(Node.EXCLUSIVE);\n                return;\n            }\n            // 否则直接入队列等待\n            else\n                currentNode = Enq(Node.EXCLUSIVE);\n        }\n    }\n    // 检测当前节点是否可以被唤醒\n    while (currentNode.waitStatus != Node.SIGNAL) { }\n    // 此时线程已被唤醒，设置重入量及状态等\n    reentrants = 1;\n    currentNode.waitStatus = Node.RUNNING;\n    owner = Thread.CurrentThread;\n}\n```\n\n基本流程如下：\n\n1. 先判断队列是否已初始化，若未初始化，先初始化head节点\n2. 判断队列是否为空（即判断`tail==null`），若是直接进入队列，成功获取锁，返回；否则进入下一步\n3. 判断当前线程是否为持有锁的线程，若是说明线程在重入当前锁，直接`reentrants`加`1`，成功获取锁，返回；否则进入下一步\n4. 获取尾节点，由于第2步结束时可能有其他线程的介入，因此需再次判断`tail==null`，若是直接进入队列，成功获取锁，返回；否则以当前线程创建节点并入队列，同时阻塞\n5. 循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，并成功获取独占锁\n\n### 释放 WriteUnlock()\n\n释放写锁的逻辑很简单：\n\n```c#\n/**\n * 释放写锁\n */\npublic void WriteUnlock()\n{\n    // 加锁是为了同步修改队列信息\n    lock (this)\n    {\n        // 当前锁持有者重入量直接-1\n        reentrants -= 1;\n        // 获取队列头（除了head之外的头）\n        Node node = GetHolderNode();\n        // 如果后续节点为空，则释放完成，队列已空；若后续节点不为空，则可能需要唤醒后续节点\n        if (node != null)\n        {\n            // 若当前锁的重入量为0，说明锁已经完全释放，则需要唤醒后继有效节点（否则可能只是释放了一个锁内部的锁）\n            if (reentrants == 0)\n            {\n                // 当前节点置为无效\n                node.waitStatus = Node.CANCELLED;\n                // 唤醒后继有效节点\n                AwakeNext();\n            }\n        }\n    }\n}\n```\n\n逻辑如下：\n\n1. 锁`reentrants`减`1`\n2. 获取当前锁持有的节点\n3. 判断上述获取的节点是否为空，若为空说明队列已空，已无等待节点，直接返回；否则检查`reentrants`是否已减至`0`\n4. 若是则当前节点线程已完成，置为`Node.CANCELLED`状态，并唤醒后继有效节点\n\n## 读锁\n\n### 获取 ReadLock()\n\n相比于写锁的获取，读锁的获取要复杂一点，因为涉及到读的共享以及阈值的控制：\n\n```c#\n/**\n * 获取读锁\n */\npublic void ReadLock()\n{\n    Node reader = null;\n    // 这里基本的初始化方式和读锁相似，不赘述\n    lock (this)\n    {\n        if (head == null)\n            head = new Node();\n    }\n    Thread current = Thread.CurrentThread;\n    lock (this)\n    {\n        if (tail == null)\n        {\n            EnqWhenTailNull(Node.SHARED);\n            return;\n        }\n    }\n    Node currentNode = null;\n    lock (this)\n    {\n        // 读可重入\n        if (ReaderCanReentranted())\n        {\n            reentrants += 1;\n            return;\n        }\n        // 获取当前持有锁节点\n        Node node = head.next;\n        if (node == null)\n        {\n            EnqWhenTailNull(Node.SHARED);\n            return;\n        }\n        else\n        {\n            // 队列中有写者的情况\n            if (HasWriter())\n            {\n                // 创建当前持有当前线程的读节点\n                reader = new Node(current, Node.SHARED);\n                // 获取第一个读节点（可能为null）\n                while (node != null && (!node.isShared() || node.waitStatus == Node.CANCELLED))\n                {\n                    if (node.isShared())\n                    {\n                        if (!CheckReadChainCancelled(node))\n                            break;\n                        else\n                            node = node.next;\n                    }\n                    else\n                        node = node.next;\n                }\n                // 未找到读节点，说明队列中只有写节点，此时直接添加到队列尾\n                if (node == null)\n                {\n                    currentNode = Enq(Node.SHARED);\n                }\n                // 否则说明找到了有效的读节点，此时此读节点为队列中第一个读节点，只需要判断此读节点链长是否达到了阈值，\n                //  若未超过阈值，直接添加到读链中，并判断当前读链头是否正在读，则可以直接读，否则需要循环检测；\n                //  若超过了阈值：\n                //      若队尾为写节点，则添加到队列尾，并循环等待；\n                //      若队尾为读节点，判断是否到达阈值：\n                //          若是则添加到队列尾，并循环等待；\n                //          否则添加到读链中。\n                else\n                {\n                    // 未超过阈值\n                    if (node.readerCount < Node.Threshold)\n                    {\n                        // 添加到读链中\n                        currentNode = AddReader(node, reader);\n                        // 链头正在读，此节点也直接读，且reentrants+1\n                        if (node.waitStatus == Node.RUNNING)\n                        {\n                            reader.waitStatus = Node.RUNNING;\n                            reentrants += 1;\n                            return;\n                        }\n                    }\n                    // 超过了阈值\n                    else\n                    {\n                        // 判断队尾节点类型\n                        Node t = tail;\n                        // 队尾为“写节点”或“达到阈值的读节点”\n                        if (!t.isShared() || (t.isShared() && t.readerCount >= Node.Threshold))\n                            currentNode = Enq(Node.SHARED);\n                        // 队尾为“未达到阈值的读节点”\n                        else\n                        {\n                            // 添加到队尾节点所在的读链中\n                            currentNode = AddReader(t, reader);\n                            // 链头正在读，此节点也直接读，且reentrants+1\n                            if (t.waitStatus == Node.RUNNING)\n                            {\n                                reader.waitStatus = Node.RUNNING;\n                                reentrants += 1;\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            // 队列中无写者，说明队列中要么为空，要么全为读者，直接加到队尾或者队尾所在的读链\n            else\n            {\n                // 队列为空，直接入队\n                if (tail == null)\n                {\n                    EnqWhenTailNull(Node.SHARED);\n                    return;\n                }\n                // 队尾节点读链长度未达到阈值\n                if (tail.readerCount < Node.Threshold)\n                {\n                    reader = new Node(current, Node.SHARED);\n                    // 添加到链尾\n                    currentNode = AddReader(tail, reader);\n                    // 是否需要循环等待\n                    if (tail.waitStatus == Node.RUNNING)\n                    {\n                        reader.waitStatus = Node.RUNNING;\n                        reentrants += 1;\n                        return;\n                    }\n                }\n                // 队尾节点读链达到了阈值，直接加入队尾，并等待唤醒\n                else\n                {\n                    currentNode = Enq(Node.SHARED);\n                }\n            }\n        }\n    }\n    while (currentNode.waitStatus != Node.SIGNAL) { }\n    currentNode.waitStatus = Node.RUNNING;\n    reentrants = currentNode.readerHead.readerCount;\n    owner = currentNode.readerHead == null ? null : currentNode.readerHead.thread;\n}\n```\n\n逻辑如下：\n\n1. 先判断队列是否已初始化，若未初始化，先初始化head节点\n2. 判断队列是否为空（即判断`tail==null`），若是直接进入队列，成功获取锁，返回；否则进入下一步\n3. 判断当前线程是否可重入锁（读线程的可重入判断与写不同，会在后面对`ReaderCanReentranted()`方法解释时介绍到），若是`reentrants`加`1`，返回；否则进入下一步\n4. 获取当前持有锁节点，若为空说明队列为空，直接进入队列，成功获取锁，返回；否则进入下一步\n5. 判断队列中是否有写者，若是跳至第6步，否则跳至第7步\n6. 队列中有写者，为防止出现写饥饿的情况，此读节点可能在写者前或后：\n   1. 若队列中无读节点，即只有写节点，直接添加至队列尾，并阻塞\n   2. 若找到了队列中的第一个有效读节点，判断其读链是否达到阈值\n   3. 若未超过阈值，则直接添加到读链中，是否阻塞由读链头的状态决定\n   4. 若超过了阈值，则有两种情况：\n      - 队尾为**写节点**或者队尾为**读节点且读链长度达到阈值**，此时节点添加至队列尾，并阻塞\n      - 队尾为**读节点且读链长度未达到阈值**，将节点加入队尾的读链中，与队尾节点状态一致\n7. 队列中无写者，说明队列中要么为空，要么全为读者，则根据队尾节点读链长度来决定是直接加到队尾还是加到队尾所在的读链\n8. 循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，设置`reentrants`为读链长度，并成功获取共享锁\n\n### 释放 ReadUnlock()\n\n```c#\n/**\n * 释放读锁\n */\npublic void ReadUnlock()\n{\n    lock (this)\n    {\n        // 读重入量-1\n        reentrants -= 1;\n        // 获取到锁持有节点\n        Node node = head.next;\n        while (node != null)\n        {\n            if (CheckReadChainCancelled(node))\n            {\n                node = node.next;\n                head.next = node;\n                if (node != null)\n                    node.prev = head;\n            }\n            else\n                break;\n        }\n        // 获取到有效读节点了\n        if (node != null)\n        {\n            // 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点\n            node = GetCurrentNodeByReader(node);\n            // 当前节点置为取消\n            node.waitStatus = Node.CANCELLED;\n            // 重入量为0，需要判断读链是否已全部读完成，若是则需要唤醒后续线程\n            if (reentrants == 0)\n                AwakeNext();\n        }\n    }\n}\n```\n\n释放读锁的逻辑与释放写锁逻辑基本类似，无需多提。\n\n## 其余辅助方法\n\n### Enq(Node mode)\n\n以当前线程为基础，指定类型创建节点，并入队列并阻塞，同时返回此节点\n\n```c#\n/**\n * 读写节点入队列操作，入队列后需等待\n */\nprivate Node Enq(Node mode)\n{\n    Node t = tail;\n    // 以当前线程创建独占节点\n    Node node = new Node(Thread.CurrentThread, mode);\n    // 连接尾节点与当前节点\n    t.next = node;\n    node.prev = t;\n    // 重置尾节点为当前节点\n    tail = node;\n    // 设置节点等待状态为WAITING\n    node.waitStatus = Node.WAITING;\n    // 若为读节点，需要设置读链头\n    if (node.isShared())\n        node.readerHead = node;\n    return node;\n}\n```\n\n### EnqWhenTailNull(Node mode)\n\n以当前线程为基础，指定类型创建节点，在队列为空时，此节点直接入队列且当前线程继续执行\n\n```c#\n/**\n * 读写节点入队列操作，此时队列尾为空，入队列之后继续运行，无需等待\n */\nprivate void EnqWhenTailNull(Node mode)\n{\n    // 以当前线程创建独占节点\n    Node node = new Node(Thread.CurrentThread, mode);\n    // 设置等待类型为RUNNING\n    node.waitStatus = Node.RUNNING;\n    // 当前节点加入队列，尾节点为当前节点\n    tail = node;\n    // 设置锁的持有者为当前线程\n    owner = Thread.CurrentThread;\n    // 重入量初始为1\n    reentrants = 1;\n    // 连接头节点与此节点\n    head.next = node;\n    node.prev = head;\n    // 若为读节点，需要设置读链头\n    if (node.isShared())\n        node.readerHead = node;\n}\n```\n\n### AwakeNext()\n\n当某个节点置为`Node.CANCELLED`状态时，会唤醒其后一个有效节点，主要是将节点状态修改为`Node.SIGNAL`状态，以被各自节点监测到。\n\n对于写节点来说，由于是独占的，只需要修改该节点；对于读节点来说，由于是共享的，需要遍历该节点所在的读链并修改每个节点的状态，才能达到唤醒整条读链的目的。\n\n```c#\n/**\n * 唤醒后一个节点\n */\nprivate void AwakeNext()\n{\n    // 获取持有当前锁的节点，此时锁刚好被上个节点释放，获取的节点应处于Node.WAITING状态\n    Node node = GetHolderNode();\n    // 当前节点为空，说明队列中无有效节点，直接返回即可\n    if (node == null)\n    {\n        tail = null;\n        owner = null;\n        reentrants = 0;\n        return;\n    }\n    // 否则需要唤醒此有效节点\n    else\n    {\n        // 连接到头节点\n        node.prev = head;\n        // 对于写节点，readerCount为1，即为reentrants初始值1\n        // 对于读节点，readerCount即为reentrants的初始值\n        reentrants = node.readerCount;\n        // 对于读节点来说，需唤醒读链中的所有节点；对于写节点来说，无读链，只会唤醒当前节点\n        while (node != null)\n        {\n            // 等待类型设置为SIGNAL，会被捕捉从而唤醒相关线程\n            node.waitStatus = Node.SIGNAL;\n            // 若为读节点，可获取下一个读者；否则获取了null\n            node = node.nextReader;\n            // 下一个读者不为空，则也将其前驱节点设置为头节点\n            if (node != null)\n                node.prev = head;\n        }\n    }\n}\n```\n\n### GetHolderNode()\n\n```c#\n/** \n *   删除无效节点（可能由于主动中断或者其他因素导致的线程失效），获取第一个有效节点或空节点，\n * 或者称作获取锁持有节点\n */\nprivate Node GetHolderNode()\n{\n    Node node = head.next;\n    // 此循环的判断条件可能出现歧义，因存在读链头为取消状态时，读链中仍然有读节点读未完成，但是此函数只在释放写锁(WriteUnlock)和唤醒后续节点(AwakeNext)中使用到，当AwakeNext被触发时，读链头的状态便可以代表整个读链的状态了。\n    while (node != null && node.waitStatus == Node.CANCELLED)\n        node = node.next;\n    // 连接头节点和持有节点，无效节点全部交由垃圾收集器回收\n    head.next = node;\n    if (node != null)\n        node.prev = head;\n    return node;\n}\n```\n\n### HasWriter()\n\n在读节点获取锁时，有一步是需要判断队列中是否存在写者，即用到此函数\n\n```c#\n/**\n * 返回当前队列中是否存在写者，用在读者入队列时的决策\n */\nprivate bool HasWriter()\n{\n    bool exclusive = false;\n    Node excluNode = head.next;\n    while (excluNode != null)\n    {\n        if (!excluNode.isShared())\n        {\n            exclusive = true;\n            break;\n        }\n        excluNode = excluNode.next;\n    }\n    return exclusive;\n}\n```\n\n### GetCurrentNodeByReader(Node node)\n\n在释放读锁时，我们无法直接获取到当前节点，只能通过线程名称来确定当前线程的持有者在`node`所在的读链中的位置，返回获取到的节点，以在释放锁时修改状态。\n\n而由于是通过线程名称来判断线程是否相等，可能会因线程重名导致异常，待改进。\n\n```c#\n/**\n * 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点\n */\nprivate Node GetCurrentNodeByReader(Node node)\n{\n    Node nextReader = node.readerHead;\n    // 以线程名称为依据，这里可能出现多个线程同名的情况，待改进\n    while (nextReader != null)\n    {\n        if (nextReader.thread.Name.Equals(Thread.CurrentThread.Name))\n            return nextReader;\n        else\n            nextReader = nextReader.nextReader;\n    }\n    return null;\n}\n```\n\n### CheckReadChainCancelled(Node node)\n\n对于写节点来说，只要节点状态为`Node.CANCELLED`，说明写已经完成；而对于读节点，需要遍历读链中所有节点的状态才能确定读是否完成，此方法便是如此。\n\n```c#\n/**\n * 通过一个读节点判断其所在读链是否已全部读完成\n */\nprivate bool CheckReadChainCancelled(Node node)\n{\n    Node nextReader = node.readerHead;\n    while (nextReader != null)\n    {\n        if (nextReader.waitStatus != Node.CANCELLED)\n            return false;\n        else\n            nextReader = nextReader.nextReader;\n    }\n    return true;\n}\n```\n\n### AddReader(Node readerHead, Node node)\n\n```c#\n/**\n * 添加读者到指定读链头所在的读链中\n */\nprivate Node AddReader(Node readerHead, Node node)\n{\n    // 获取到读链尾\n    Node reader = readerHead;\n    while (reader.nextReader != null)\n    {\n        reader = reader.nextReader;\n    }\n    // 读链头的前驱节点也是读链中任何节点的前驱节点\n    node.prev = reader.prev;\n    // 连接到读链尾\n    reader.nextReader = node;\n    node.readerHead = readerHead;\n    node.waitStatus = readerHead.waitStatus;\n    // 读链头记录的读链长度+1\n    readerHead.readerCount++;\n    return node;\n}\n```\n\n### ReaderCanReentranted()\n\n对于来说写者，只需判断当前线程是否为持有锁线程即可判断是否可以重入；而对于读者来说，只要当前线程与正在读的读链中的任意一个线程相等即可重入。\n\n同样线程同名的情况也不可避免。\n\n```\n/**\n * 判断读者是否可以重入，判断依据为当前线程是否被正在执行读的读链中的某一个节点持有\n */\nprivate bool ReaderCanReentranted()\n{\n    Node node = head.next;\n    if (node == null || !node.isShared())\n        return false;\n    else\n    {\n        Node reader = node;\n        while (reader != null)\n        {\n            if (reader.thread == Thread.CurrentThread)\n            {\n                return true;\n            }\n            reader = reader.nextReader;\n        }\n    }\n    return false;\n}\n```\n\n### ToString()\n\n```c#\n/**\n * 覆盖ToString方法，格式化输出当前队列情况\n */\npublic override string ToString()\n{\n    StringBuilder sb = new StringBuilder();\n    if (head != null)\n    {\n        if (owner != null)\n            sb.Append(\"Head(持有线程：\" + owner.Name + \"，重入量：\" + reentrants + \")\\n\");\n        else\n            sb.Append(\"Head(持有线程：未持有线程，重入量：\" + reentrants + \")\\n\");\n        Node node = head.next;\n        while (node != null)\n        {\n            Node reader = node;\n            if (node.isShared())\n            {\n                while (reader != null)\n                {\n                    sb.AppendFormat(\"->【线程名称：{0}，类型：读，状态：{1}】\", reader.thread.Name, Node.GetStatus(reader.waitStatus));\n                    reader = reader.nextReader;\n                }\n                sb.AppendLine();\n            }\n            else\n            {\n                sb.AppendFormat(\"->【线程名称：{0}，类型：写，状态：{1}】\", node.thread.Name, Node.GetStatus(node.waitStatus));\n                sb.AppendLine();\n            }\n            node = node.next;\n        }\n    }\n    return sb.ToString();\n}\n```\n\n## 测试\n\n测试代码：\n\n```c#\nusing System;\nusing System.Threading;\n\nnamespace ReadWriteLock\n{\n    class MainClass\n    {\n      \tpublic static void Add(ReadWriteLock readWriteLock)\n        {\n            for (int i = 0; i < 100000000; i++)\n            {\n                readWriteLock.WriteLock();\n                N++;\n                readWriteLock.WriteUnlock();\n            }\n        }\n        public static void TestReentrantWriter(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            Thread.Sleep(1000);\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n        }\n        public static void TestWriter(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.WriteLock();\n            Thread.Sleep(500);\n            //Console.WriteLine(Thread.CurrentThread.Name + \"执行完毕\");\n            readWriteLock.WriteUnlock();\n        }\n        public static void TestReader(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.ReadLock();\n            Thread.Sleep(500);\n            //Console.WriteLine(Thread.CurrentThread.Name + \"执行完毕\");\n            readWriteLock.ReadUnlock();\n        }\n        public static void Main(string[] args)\n        {\n            ReadWriteLock readWriteLock = new ReadWriteLock();\n            for (int i = 1; i <= 10; i++)\n                CreateThread(false, i, readWriteLock);\n            for (int i = 1; i <= 20; i++)\n                CreateThread(true, i, readWriteLock);\n            for (int i = 0; i < 100; i++)\n            {\n                Thread.Sleep(500);\n                readWriteLock.PrintQueue();\n            }\n            Console.ReadKey();\n        }\n        static void CreateThread(bool share, int i, ReadWriteLock readWriteLock)\n        {\n            Thread thread;\n            if (share) \n            {\n                thread = new Thread(() => TestReader(readWriteLock));\n                thread.Name = \"Reader-\" + i;            \n            }\n            else\n            {\n                thread = i == 5 ? new Thread(() => TestReentrantWriter(readWriteLock)) : new Thread(() => TestWriter(readWriteLock));\n                thread.Name = \"Writer-\" + i;\n            }\n            thread.Start();\n        }\n    }\n}\n```\n\n首先是两个线程同时增加1亿次的时间：约30s，比Monitor大概慢了5倍。\n\n其次，测试创建了10个写线程、20个读线程，假定每个线程持续时间为500毫秒，每隔500毫秒输出等待队列的情况如下：\n\n```\nHead(持有线程：Writer-2，重入量：1)\n->【线程名称：Writer-2，类型：写，状态：RUNNING】\n->【线程名称：Writer-8，类型：写，状态：WAITING】\n->【线程名称：Reader-10，类型：读，状态：WAITING】->【线程名称：Reader-6，类型：读，状态：WAITING】->【线程名称：Reader-4，类型：读，状态：WAITING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-8，重入量：1)\n->【线程名称：Writer-8，类型：写，状态：RUNNING】\n->【线程名称：Reader-10，类型：读，状态：WAITING】->【线程名称：Reader-6，类型：读，状态：WAITING】->【线程名称：Reader-4，类型：读，状态：WAITING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-10，重入量：3)\n->【线程名称：Reader-10，类型：读，状态：RUNNING】->【线程名称：Reader-6，类型：读，状态：RUNNING】->【线程名称：Reader-4，类型：读，状态：RUNNING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-6，重入量：1)\n->【线程名称：Writer-6，类型：写，状态：RUNNING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-7，重入量：1)\n->【线程名称：Writer-7，类型：写，状态：RUNNING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-3，重入量：1)\n->【线程名称：Writer-3，类型：写，状态：RUNNING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-5，重入量：4)\n->【线程名称：Writer-5，类型：写，状态：RUNNING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-5，重入量：4)\n->【线程名称：Writer-5，类型：写，状态：RUNNING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-3，重入量：3)\n->【线程名称：Reader-3，类型：读，状态：RUNNING】->【线程名称：Reader-5，类型：读，状态：RUNNING】->【线程名称：Reader-7，类型：读，状态：RUNNING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-8，重入量：1)\n->【线程名称：Reader-8，类型：读，状态：RUNNING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-8，重入量：1)\n->【线程名称：Writer-9，类型：写，状态：SIGNAL】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-9，重入量：1)\n->【线程名称：Writer-9，类型：写，状态：RUNNING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-9，重入量：1)\n->【线程名称：Reader-9，类型：读，状态：RUNNING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-4，重入量：1)\n->【线程名称：Writer-4，类型：写，状态：RUNNING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-1，重入量：1)\n->【线程名称：Writer-1，类型：写，状态：RUNNING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-11，重入量：3)\n->【线程名称：Reader-11，类型：读，状态：RUNNING】->【线程名称：Reader-2，类型：读，状态：RUNNING】->【线程名称：Reader-1，类型：读，状态：RUNNING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-12，重入量：3)\n->【线程名称：Reader-12，类型：读，状态：RUNNING】->【线程名称：Reader-13，类型：读，状态：RUNNING】->【线程名称：Reader-14，类型：读，状态：RUNNING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-15，重入量：3)\n->【线程名称：Reader-15，类型：读，状态：RUNNING】->【线程名称：Reader-16，类型：读，状态：RUNNING】->【线程名称：Reader-17，类型：读，状态：RUNNING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-18，重入量：3)\n->【线程名称：Reader-18，类型：读，状态：RUNNING】->【线程名称：Reader-19，类型：读，状态：RUNNING】->【线程名称：Reader-20，类型：读，状态：RUNNING】\n\nHead(持有线程：未持有线程，重入量：0)\n\nHead(持有线程：未持有线程，重入量：0)\n```\n\n如上述结果，每一行代表一个节点（读节点有不超过读链阈值的节点个数），Head开头说明打印了一次线程队列中的执行和等待情况。结果说明该读写锁可支持：\n\n1. 多个线程的并发读访问\n2. 多个线程的写访问\n3. 避免了写饥饿","source":"_posts/C-ReadWriteLock.md","raw":"---\ntitle: C# - 实现读写锁\ndate: 2019-05-03 00:33:11\ntags:\n    - \n    - C#\ncategories:\n    - C#\n---\n使用C#实现的`可重入`、`非公平`的`读写锁`，主要目的实现**并发读写**以及**读写同步**问题。为了**减少读等待时间**以及**防止出现写饥饿现象**，本锁使用了**非同步锁**的实现，允许**读优先（提高效率）**的同时**使用一个阈值限定读者的最大数量（防止写饥饿）**；重入机制允许某个线程可以获取锁多次（如多次函数调用导致的锁重入），每次获取都需要有对应的释放，否则会出错。\n\n<!-- more -->\n\n本锁的目的是实现对读写线程队列的调度，而不是对线程获取锁的顺序进行调度。要注意读写线程进入队列的顺序是系统调度的（意即创建多个线程并Start时，其进入线程的时机是系统决定的，可能最后创建的线程最先执行），这里实现的是**对进入队列后的线程进行阻塞、唤醒等操作**。\n\n本锁使用了`C#`中的`lock原语`，目的是为了实现一些**队列操作的原子性**。\n\n实现本锁时作者参考了`Java`中`AQS`和`ReentrantReadWriteLock`的一些实现细节，予以理解仿效，设计了这个简单的读写锁，实现逻辑上可能仍有很多缺陷或矛盾，望各位看官批评指正！\n\n## Node节点\n\nNode节点是实现本读写锁的关键所在，读写线程队列也是基于Node节点实现的。Node内部持有了一个线程，同时有很多指向其他Node的引用。Node类实现如下：\n\n```c#\npublic class Node\n    {\n        // 读节点\n        public static readonly Node SHARED = new Node();\n        // 写节点\n        public static readonly Node EXCLUSIVE = null;\n        // 读链长度阈值\n        public static int Threshold = 3;\n\n        // 节点状态\n        public static readonly int CANCELLED = 1;\n        public static readonly int RUNNING = -1;\n        public static readonly int WAITING = -2;\n        public static readonly int SIGNAL = -3;\n    \n        public int waitStatus;\n        // 前驱节点\n        public Node prev;\n        // 后继节点\n        public Node next;\n        // 持有线程\n        public Thread thread;\n\n        //以下参数仅对读节点适用\n        // 读链头\n        public Node readerHead;\n        // 后继读节点\n        public Node nextReader;\n        // 读链长度\n        public int readerCount = 1;\n\n        // 节点类型\n        public Node mode;\n        // 是否是共享节点\n        public bool isShared()\n        {\n            return mode == SHARED;\n        }\n        public Node()\n        {\n        }\n\n        // 创建共享或独占节点\n        public Node(Thread thread, Node mode)\n        {\n            this.mode = mode;\n            this.thread = thread;\n        }\n\n    \t// 获取状态\n        public static string GetStatus(int status)\n        {\n            switch (status)\n            {\n                case 1:\n                    return \"CANCELLED\";\n                case -1:\n                    return \"RUNNING\";\n                case -2:\n                    return \"WAITING\";\n                case -3:\n                    return \"SIGNAL\";\n            }\n            return \"DEFAULT\";\n        }\n    }\n```\n\n各属性及方法的涵义如上述代码注释所示，而由Node组成的等待队列结构（双向链表）如下图所示（可能出现的一种情况）：\n\n![队列示意图.png](http://getme.guitoubing.top/队列示意图.png)\n\n对于写节点来说，锁是独占的，一次仅能有一个写线程在执行；而对于读节点来说，锁是共享的，在同一读链上的所有节点都可同时进行读。\n\n## 重要变量\n\n### 头节点 head\n\n头节点是个傀儡节点，`private volatile Node head`，其无实际涵义，只是为了作为队列头而存在；其使用了惰性初始化的方法，仅在第一个节点入队列时初始化。\n\n> `volatile`关键字在是为了实现变量的内存可见性，使用该关键字修饰的变量的修改会直接反映到内存中而不是缓存中。\n\n### 尾节点 tail\n\n尾节点是队列的最后一个节点，`private volatile Node tail`，引入尾节点是为了防止在新节点入列时遍历队列，提高了效率。\n\n### 重入量 reentrants\n\n对于写锁（独占锁）来说，当一个写线程获取锁时，`reentrants`为`1`，后续每当锁重入一次，`reentrants`增加`1`；释放锁时，每释放一次`reentrants`减少1，直到`reentrants`为`0`时该线程释放当前锁，唤醒后续线程；\n\n对于读锁（共享锁）来说，由于读链中可能会有不超过`Node.Threshold`个数的读节点，且每个读节点都可能会产生重入，这里会将`reentrants`初始化为读链长度，在`Node.RUNNING``时读链每增加一个读节点会增加一个reentrants`，读链中的每个节点多一次重入也会导致`reentrants`增加`1`。\n\n## 写锁\n\n### 获取 WriteLock()\n\n先看获取写锁的流程：\n\n```c#\n/**\n * 获取写锁\n */\npublic void WriteLock()\n{\n    // 当前节点\n    Node currentNode = null;\n    // 这里使用了惰性初始化，如果头节点为空，则初始化头节点\n    lock (this)\n    {\n        if (head == null)\n            head = new Node();\n    }\n    // 如果尾节点为空，说明当前队列为空，此时线程直接入队列设置为RUNNING状态\n    lock (this)\n    {\n        if (tail == null)\n        {\n            EnqWhenTailNull(Node.EXCLUSIVE);\n            return;\n        }\n    }\n    lock (this)\n    {\n        // 如果当前线程就是持有线程，说明锁在重入，reentrants加1\n        if (owner == Thread.CurrentThread)\n        {\n            reentrants += 1;\n            return;\n        }\n        // 否则，当前线程需要进入等待队列进行等待\n        else\n        {\n            // 获取尾节点\n            Node t = tail;\n            // 由于可能出现其他线程的介入，需要再次检测为节点是否为空\n            if (t == null)\n            {\n                EnqWhenTailNull(Node.EXCLUSIVE);\n                return;\n            }\n            // 否则直接入队列等待\n            else\n                currentNode = Enq(Node.EXCLUSIVE);\n        }\n    }\n    // 检测当前节点是否可以被唤醒\n    while (currentNode.waitStatus != Node.SIGNAL) { }\n    // 此时线程已被唤醒，设置重入量及状态等\n    reentrants = 1;\n    currentNode.waitStatus = Node.RUNNING;\n    owner = Thread.CurrentThread;\n}\n```\n\n基本流程如下：\n\n1. 先判断队列是否已初始化，若未初始化，先初始化head节点\n2. 判断队列是否为空（即判断`tail==null`），若是直接进入队列，成功获取锁，返回；否则进入下一步\n3. 判断当前线程是否为持有锁的线程，若是说明线程在重入当前锁，直接`reentrants`加`1`，成功获取锁，返回；否则进入下一步\n4. 获取尾节点，由于第2步结束时可能有其他线程的介入，因此需再次判断`tail==null`，若是直接进入队列，成功获取锁，返回；否则以当前线程创建节点并入队列，同时阻塞\n5. 循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，并成功获取独占锁\n\n### 释放 WriteUnlock()\n\n释放写锁的逻辑很简单：\n\n```c#\n/**\n * 释放写锁\n */\npublic void WriteUnlock()\n{\n    // 加锁是为了同步修改队列信息\n    lock (this)\n    {\n        // 当前锁持有者重入量直接-1\n        reentrants -= 1;\n        // 获取队列头（除了head之外的头）\n        Node node = GetHolderNode();\n        // 如果后续节点为空，则释放完成，队列已空；若后续节点不为空，则可能需要唤醒后续节点\n        if (node != null)\n        {\n            // 若当前锁的重入量为0，说明锁已经完全释放，则需要唤醒后继有效节点（否则可能只是释放了一个锁内部的锁）\n            if (reentrants == 0)\n            {\n                // 当前节点置为无效\n                node.waitStatus = Node.CANCELLED;\n                // 唤醒后继有效节点\n                AwakeNext();\n            }\n        }\n    }\n}\n```\n\n逻辑如下：\n\n1. 锁`reentrants`减`1`\n2. 获取当前锁持有的节点\n3. 判断上述获取的节点是否为空，若为空说明队列已空，已无等待节点，直接返回；否则检查`reentrants`是否已减至`0`\n4. 若是则当前节点线程已完成，置为`Node.CANCELLED`状态，并唤醒后继有效节点\n\n## 读锁\n\n### 获取 ReadLock()\n\n相比于写锁的获取，读锁的获取要复杂一点，因为涉及到读的共享以及阈值的控制：\n\n```c#\n/**\n * 获取读锁\n */\npublic void ReadLock()\n{\n    Node reader = null;\n    // 这里基本的初始化方式和读锁相似，不赘述\n    lock (this)\n    {\n        if (head == null)\n            head = new Node();\n    }\n    Thread current = Thread.CurrentThread;\n    lock (this)\n    {\n        if (tail == null)\n        {\n            EnqWhenTailNull(Node.SHARED);\n            return;\n        }\n    }\n    Node currentNode = null;\n    lock (this)\n    {\n        // 读可重入\n        if (ReaderCanReentranted())\n        {\n            reentrants += 1;\n            return;\n        }\n        // 获取当前持有锁节点\n        Node node = head.next;\n        if (node == null)\n        {\n            EnqWhenTailNull(Node.SHARED);\n            return;\n        }\n        else\n        {\n            // 队列中有写者的情况\n            if (HasWriter())\n            {\n                // 创建当前持有当前线程的读节点\n                reader = new Node(current, Node.SHARED);\n                // 获取第一个读节点（可能为null）\n                while (node != null && (!node.isShared() || node.waitStatus == Node.CANCELLED))\n                {\n                    if (node.isShared())\n                    {\n                        if (!CheckReadChainCancelled(node))\n                            break;\n                        else\n                            node = node.next;\n                    }\n                    else\n                        node = node.next;\n                }\n                // 未找到读节点，说明队列中只有写节点，此时直接添加到队列尾\n                if (node == null)\n                {\n                    currentNode = Enq(Node.SHARED);\n                }\n                // 否则说明找到了有效的读节点，此时此读节点为队列中第一个读节点，只需要判断此读节点链长是否达到了阈值，\n                //  若未超过阈值，直接添加到读链中，并判断当前读链头是否正在读，则可以直接读，否则需要循环检测；\n                //  若超过了阈值：\n                //      若队尾为写节点，则添加到队列尾，并循环等待；\n                //      若队尾为读节点，判断是否到达阈值：\n                //          若是则添加到队列尾，并循环等待；\n                //          否则添加到读链中。\n                else\n                {\n                    // 未超过阈值\n                    if (node.readerCount < Node.Threshold)\n                    {\n                        // 添加到读链中\n                        currentNode = AddReader(node, reader);\n                        // 链头正在读，此节点也直接读，且reentrants+1\n                        if (node.waitStatus == Node.RUNNING)\n                        {\n                            reader.waitStatus = Node.RUNNING;\n                            reentrants += 1;\n                            return;\n                        }\n                    }\n                    // 超过了阈值\n                    else\n                    {\n                        // 判断队尾节点类型\n                        Node t = tail;\n                        // 队尾为“写节点”或“达到阈值的读节点”\n                        if (!t.isShared() || (t.isShared() && t.readerCount >= Node.Threshold))\n                            currentNode = Enq(Node.SHARED);\n                        // 队尾为“未达到阈值的读节点”\n                        else\n                        {\n                            // 添加到队尾节点所在的读链中\n                            currentNode = AddReader(t, reader);\n                            // 链头正在读，此节点也直接读，且reentrants+1\n                            if (t.waitStatus == Node.RUNNING)\n                            {\n                                reader.waitStatus = Node.RUNNING;\n                                reentrants += 1;\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            // 队列中无写者，说明队列中要么为空，要么全为读者，直接加到队尾或者队尾所在的读链\n            else\n            {\n                // 队列为空，直接入队\n                if (tail == null)\n                {\n                    EnqWhenTailNull(Node.SHARED);\n                    return;\n                }\n                // 队尾节点读链长度未达到阈值\n                if (tail.readerCount < Node.Threshold)\n                {\n                    reader = new Node(current, Node.SHARED);\n                    // 添加到链尾\n                    currentNode = AddReader(tail, reader);\n                    // 是否需要循环等待\n                    if (tail.waitStatus == Node.RUNNING)\n                    {\n                        reader.waitStatus = Node.RUNNING;\n                        reentrants += 1;\n                        return;\n                    }\n                }\n                // 队尾节点读链达到了阈值，直接加入队尾，并等待唤醒\n                else\n                {\n                    currentNode = Enq(Node.SHARED);\n                }\n            }\n        }\n    }\n    while (currentNode.waitStatus != Node.SIGNAL) { }\n    currentNode.waitStatus = Node.RUNNING;\n    reentrants = currentNode.readerHead.readerCount;\n    owner = currentNode.readerHead == null ? null : currentNode.readerHead.thread;\n}\n```\n\n逻辑如下：\n\n1. 先判断队列是否已初始化，若未初始化，先初始化head节点\n2. 判断队列是否为空（即判断`tail==null`），若是直接进入队列，成功获取锁，返回；否则进入下一步\n3. 判断当前线程是否可重入锁（读线程的可重入判断与写不同，会在后面对`ReaderCanReentranted()`方法解释时介绍到），若是`reentrants`加`1`，返回；否则进入下一步\n4. 获取当前持有锁节点，若为空说明队列为空，直接进入队列，成功获取锁，返回；否则进入下一步\n5. 判断队列中是否有写者，若是跳至第6步，否则跳至第7步\n6. 队列中有写者，为防止出现写饥饿的情况，此读节点可能在写者前或后：\n   1. 若队列中无读节点，即只有写节点，直接添加至队列尾，并阻塞\n   2. 若找到了队列中的第一个有效读节点，判断其读链是否达到阈值\n   3. 若未超过阈值，则直接添加到读链中，是否阻塞由读链头的状态决定\n   4. 若超过了阈值，则有两种情况：\n      - 队尾为**写节点**或者队尾为**读节点且读链长度达到阈值**，此时节点添加至队列尾，并阻塞\n      - 队尾为**读节点且读链长度未达到阈值**，将节点加入队尾的读链中，与队尾节点状态一致\n7. 队列中无写者，说明队列中要么为空，要么全为读者，则根据队尾节点读链长度来决定是直接加到队尾还是加到队尾所在的读链\n8. 循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，设置`reentrants`为读链长度，并成功获取共享锁\n\n### 释放 ReadUnlock()\n\n```c#\n/**\n * 释放读锁\n */\npublic void ReadUnlock()\n{\n    lock (this)\n    {\n        // 读重入量-1\n        reentrants -= 1;\n        // 获取到锁持有节点\n        Node node = head.next;\n        while (node != null)\n        {\n            if (CheckReadChainCancelled(node))\n            {\n                node = node.next;\n                head.next = node;\n                if (node != null)\n                    node.prev = head;\n            }\n            else\n                break;\n        }\n        // 获取到有效读节点了\n        if (node != null)\n        {\n            // 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点\n            node = GetCurrentNodeByReader(node);\n            // 当前节点置为取消\n            node.waitStatus = Node.CANCELLED;\n            // 重入量为0，需要判断读链是否已全部读完成，若是则需要唤醒后续线程\n            if (reentrants == 0)\n                AwakeNext();\n        }\n    }\n}\n```\n\n释放读锁的逻辑与释放写锁逻辑基本类似，无需多提。\n\n## 其余辅助方法\n\n### Enq(Node mode)\n\n以当前线程为基础，指定类型创建节点，并入队列并阻塞，同时返回此节点\n\n```c#\n/**\n * 读写节点入队列操作，入队列后需等待\n */\nprivate Node Enq(Node mode)\n{\n    Node t = tail;\n    // 以当前线程创建独占节点\n    Node node = new Node(Thread.CurrentThread, mode);\n    // 连接尾节点与当前节点\n    t.next = node;\n    node.prev = t;\n    // 重置尾节点为当前节点\n    tail = node;\n    // 设置节点等待状态为WAITING\n    node.waitStatus = Node.WAITING;\n    // 若为读节点，需要设置读链头\n    if (node.isShared())\n        node.readerHead = node;\n    return node;\n}\n```\n\n### EnqWhenTailNull(Node mode)\n\n以当前线程为基础，指定类型创建节点，在队列为空时，此节点直接入队列且当前线程继续执行\n\n```c#\n/**\n * 读写节点入队列操作，此时队列尾为空，入队列之后继续运行，无需等待\n */\nprivate void EnqWhenTailNull(Node mode)\n{\n    // 以当前线程创建独占节点\n    Node node = new Node(Thread.CurrentThread, mode);\n    // 设置等待类型为RUNNING\n    node.waitStatus = Node.RUNNING;\n    // 当前节点加入队列，尾节点为当前节点\n    tail = node;\n    // 设置锁的持有者为当前线程\n    owner = Thread.CurrentThread;\n    // 重入量初始为1\n    reentrants = 1;\n    // 连接头节点与此节点\n    head.next = node;\n    node.prev = head;\n    // 若为读节点，需要设置读链头\n    if (node.isShared())\n        node.readerHead = node;\n}\n```\n\n### AwakeNext()\n\n当某个节点置为`Node.CANCELLED`状态时，会唤醒其后一个有效节点，主要是将节点状态修改为`Node.SIGNAL`状态，以被各自节点监测到。\n\n对于写节点来说，由于是独占的，只需要修改该节点；对于读节点来说，由于是共享的，需要遍历该节点所在的读链并修改每个节点的状态，才能达到唤醒整条读链的目的。\n\n```c#\n/**\n * 唤醒后一个节点\n */\nprivate void AwakeNext()\n{\n    // 获取持有当前锁的节点，此时锁刚好被上个节点释放，获取的节点应处于Node.WAITING状态\n    Node node = GetHolderNode();\n    // 当前节点为空，说明队列中无有效节点，直接返回即可\n    if (node == null)\n    {\n        tail = null;\n        owner = null;\n        reentrants = 0;\n        return;\n    }\n    // 否则需要唤醒此有效节点\n    else\n    {\n        // 连接到头节点\n        node.prev = head;\n        // 对于写节点，readerCount为1，即为reentrants初始值1\n        // 对于读节点，readerCount即为reentrants的初始值\n        reentrants = node.readerCount;\n        // 对于读节点来说，需唤醒读链中的所有节点；对于写节点来说，无读链，只会唤醒当前节点\n        while (node != null)\n        {\n            // 等待类型设置为SIGNAL，会被捕捉从而唤醒相关线程\n            node.waitStatus = Node.SIGNAL;\n            // 若为读节点，可获取下一个读者；否则获取了null\n            node = node.nextReader;\n            // 下一个读者不为空，则也将其前驱节点设置为头节点\n            if (node != null)\n                node.prev = head;\n        }\n    }\n}\n```\n\n### GetHolderNode()\n\n```c#\n/** \n *   删除无效节点（可能由于主动中断或者其他因素导致的线程失效），获取第一个有效节点或空节点，\n * 或者称作获取锁持有节点\n */\nprivate Node GetHolderNode()\n{\n    Node node = head.next;\n    // 此循环的判断条件可能出现歧义，因存在读链头为取消状态时，读链中仍然有读节点读未完成，但是此函数只在释放写锁(WriteUnlock)和唤醒后续节点(AwakeNext)中使用到，当AwakeNext被触发时，读链头的状态便可以代表整个读链的状态了。\n    while (node != null && node.waitStatus == Node.CANCELLED)\n        node = node.next;\n    // 连接头节点和持有节点，无效节点全部交由垃圾收集器回收\n    head.next = node;\n    if (node != null)\n        node.prev = head;\n    return node;\n}\n```\n\n### HasWriter()\n\n在读节点获取锁时，有一步是需要判断队列中是否存在写者，即用到此函数\n\n```c#\n/**\n * 返回当前队列中是否存在写者，用在读者入队列时的决策\n */\nprivate bool HasWriter()\n{\n    bool exclusive = false;\n    Node excluNode = head.next;\n    while (excluNode != null)\n    {\n        if (!excluNode.isShared())\n        {\n            exclusive = true;\n            break;\n        }\n        excluNode = excluNode.next;\n    }\n    return exclusive;\n}\n```\n\n### GetCurrentNodeByReader(Node node)\n\n在释放读锁时，我们无法直接获取到当前节点，只能通过线程名称来确定当前线程的持有者在`node`所在的读链中的位置，返回获取到的节点，以在释放锁时修改状态。\n\n而由于是通过线程名称来判断线程是否相等，可能会因线程重名导致异常，待改进。\n\n```c#\n/**\n * 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点\n */\nprivate Node GetCurrentNodeByReader(Node node)\n{\n    Node nextReader = node.readerHead;\n    // 以线程名称为依据，这里可能出现多个线程同名的情况，待改进\n    while (nextReader != null)\n    {\n        if (nextReader.thread.Name.Equals(Thread.CurrentThread.Name))\n            return nextReader;\n        else\n            nextReader = nextReader.nextReader;\n    }\n    return null;\n}\n```\n\n### CheckReadChainCancelled(Node node)\n\n对于写节点来说，只要节点状态为`Node.CANCELLED`，说明写已经完成；而对于读节点，需要遍历读链中所有节点的状态才能确定读是否完成，此方法便是如此。\n\n```c#\n/**\n * 通过一个读节点判断其所在读链是否已全部读完成\n */\nprivate bool CheckReadChainCancelled(Node node)\n{\n    Node nextReader = node.readerHead;\n    while (nextReader != null)\n    {\n        if (nextReader.waitStatus != Node.CANCELLED)\n            return false;\n        else\n            nextReader = nextReader.nextReader;\n    }\n    return true;\n}\n```\n\n### AddReader(Node readerHead, Node node)\n\n```c#\n/**\n * 添加读者到指定读链头所在的读链中\n */\nprivate Node AddReader(Node readerHead, Node node)\n{\n    // 获取到读链尾\n    Node reader = readerHead;\n    while (reader.nextReader != null)\n    {\n        reader = reader.nextReader;\n    }\n    // 读链头的前驱节点也是读链中任何节点的前驱节点\n    node.prev = reader.prev;\n    // 连接到读链尾\n    reader.nextReader = node;\n    node.readerHead = readerHead;\n    node.waitStatus = readerHead.waitStatus;\n    // 读链头记录的读链长度+1\n    readerHead.readerCount++;\n    return node;\n}\n```\n\n### ReaderCanReentranted()\n\n对于来说写者，只需判断当前线程是否为持有锁线程即可判断是否可以重入；而对于读者来说，只要当前线程与正在读的读链中的任意一个线程相等即可重入。\n\n同样线程同名的情况也不可避免。\n\n```\n/**\n * 判断读者是否可以重入，判断依据为当前线程是否被正在执行读的读链中的某一个节点持有\n */\nprivate bool ReaderCanReentranted()\n{\n    Node node = head.next;\n    if (node == null || !node.isShared())\n        return false;\n    else\n    {\n        Node reader = node;\n        while (reader != null)\n        {\n            if (reader.thread == Thread.CurrentThread)\n            {\n                return true;\n            }\n            reader = reader.nextReader;\n        }\n    }\n    return false;\n}\n```\n\n### ToString()\n\n```c#\n/**\n * 覆盖ToString方法，格式化输出当前队列情况\n */\npublic override string ToString()\n{\n    StringBuilder sb = new StringBuilder();\n    if (head != null)\n    {\n        if (owner != null)\n            sb.Append(\"Head(持有线程：\" + owner.Name + \"，重入量：\" + reentrants + \")\\n\");\n        else\n            sb.Append(\"Head(持有线程：未持有线程，重入量：\" + reentrants + \")\\n\");\n        Node node = head.next;\n        while (node != null)\n        {\n            Node reader = node;\n            if (node.isShared())\n            {\n                while (reader != null)\n                {\n                    sb.AppendFormat(\"->【线程名称：{0}，类型：读，状态：{1}】\", reader.thread.Name, Node.GetStatus(reader.waitStatus));\n                    reader = reader.nextReader;\n                }\n                sb.AppendLine();\n            }\n            else\n            {\n                sb.AppendFormat(\"->【线程名称：{0}，类型：写，状态：{1}】\", node.thread.Name, Node.GetStatus(node.waitStatus));\n                sb.AppendLine();\n            }\n            node = node.next;\n        }\n    }\n    return sb.ToString();\n}\n```\n\n## 测试\n\n测试代码：\n\n```c#\nusing System;\nusing System.Threading;\n\nnamespace ReadWriteLock\n{\n    class MainClass\n    {\n      \tpublic static void Add(ReadWriteLock readWriteLock)\n        {\n            for (int i = 0; i < 100000000; i++)\n            {\n                readWriteLock.WriteLock();\n                N++;\n                readWriteLock.WriteUnlock();\n            }\n        }\n        public static void TestReentrantWriter(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            readWriteLock.WriteLock();\n            Thread.Sleep(1000);\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n            readWriteLock.WriteUnlock();\n        }\n        public static void TestWriter(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.WriteLock();\n            Thread.Sleep(500);\n            //Console.WriteLine(Thread.CurrentThread.Name + \"执行完毕\");\n            readWriteLock.WriteUnlock();\n        }\n        public static void TestReader(ReadWriteLock readWriteLock)\n        {\n            readWriteLock.ReadLock();\n            Thread.Sleep(500);\n            //Console.WriteLine(Thread.CurrentThread.Name + \"执行完毕\");\n            readWriteLock.ReadUnlock();\n        }\n        public static void Main(string[] args)\n        {\n            ReadWriteLock readWriteLock = new ReadWriteLock();\n            for (int i = 1; i <= 10; i++)\n                CreateThread(false, i, readWriteLock);\n            for (int i = 1; i <= 20; i++)\n                CreateThread(true, i, readWriteLock);\n            for (int i = 0; i < 100; i++)\n            {\n                Thread.Sleep(500);\n                readWriteLock.PrintQueue();\n            }\n            Console.ReadKey();\n        }\n        static void CreateThread(bool share, int i, ReadWriteLock readWriteLock)\n        {\n            Thread thread;\n            if (share) \n            {\n                thread = new Thread(() => TestReader(readWriteLock));\n                thread.Name = \"Reader-\" + i;            \n            }\n            else\n            {\n                thread = i == 5 ? new Thread(() => TestReentrantWriter(readWriteLock)) : new Thread(() => TestWriter(readWriteLock));\n                thread.Name = \"Writer-\" + i;\n            }\n            thread.Start();\n        }\n    }\n}\n```\n\n首先是两个线程同时增加1亿次的时间：约30s，比Monitor大概慢了5倍。\n\n其次，测试创建了10个写线程、20个读线程，假定每个线程持续时间为500毫秒，每隔500毫秒输出等待队列的情况如下：\n\n```\nHead(持有线程：Writer-2，重入量：1)\n->【线程名称：Writer-2，类型：写，状态：RUNNING】\n->【线程名称：Writer-8，类型：写，状态：WAITING】\n->【线程名称：Reader-10，类型：读，状态：WAITING】->【线程名称：Reader-6，类型：读，状态：WAITING】->【线程名称：Reader-4，类型：读，状态：WAITING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-8，重入量：1)\n->【线程名称：Writer-8，类型：写，状态：RUNNING】\n->【线程名称：Reader-10，类型：读，状态：WAITING】->【线程名称：Reader-6，类型：读，状态：WAITING】->【线程名称：Reader-4，类型：读，状态：WAITING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-10，重入量：3)\n->【线程名称：Reader-10，类型：读，状态：RUNNING】->【线程名称：Reader-6，类型：读，状态：RUNNING】->【线程名称：Reader-4，类型：读，状态：RUNNING】\n->【线程名称：Writer-6，类型：写，状态：WAITING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-6，重入量：1)\n->【线程名称：Writer-6，类型：写，状态：RUNNING】\n->【线程名称：Writer-7，类型：写，状态：WAITING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-7，重入量：1)\n->【线程名称：Writer-7，类型：写，状态：RUNNING】\n->【线程名称：Writer-3，类型：写，状态：WAITING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-3，重入量：1)\n->【线程名称：Writer-3，类型：写，状态：RUNNING】\n->【线程名称：Writer-5，类型：写，状态：WAITING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-5，重入量：4)\n->【线程名称：Writer-5，类型：写，状态：RUNNING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-5，重入量：4)\n->【线程名称：Writer-5，类型：写，状态：RUNNING】\n->【线程名称：Reader-3，类型：读，状态：WAITING】->【线程名称：Reader-5，类型：读，状态：WAITING】->【线程名称：Reader-7，类型：读，状态：WAITING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-3，重入量：3)\n->【线程名称：Reader-3，类型：读，状态：RUNNING】->【线程名称：Reader-5，类型：读，状态：RUNNING】->【线程名称：Reader-7，类型：读，状态：RUNNING】\n->【线程名称：Reader-8，类型：读，状态：WAITING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-8，重入量：1)\n->【线程名称：Reader-8，类型：读，状态：RUNNING】\n->【线程名称：Writer-9，类型：写，状态：WAITING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-8，重入量：1)\n->【线程名称：Writer-9，类型：写，状态：SIGNAL】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-9，重入量：1)\n->【线程名称：Writer-9，类型：写，状态：RUNNING】\n->【线程名称：Reader-9，类型：读，状态：WAITING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-9，重入量：1)\n->【线程名称：Reader-9，类型：读，状态：RUNNING】\n->【线程名称：Writer-4，类型：写，状态：WAITING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-4，重入量：1)\n->【线程名称：Writer-4，类型：写，状态：RUNNING】\n->【线程名称：Writer-1，类型：写，状态：WAITING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Writer-1，重入量：1)\n->【线程名称：Writer-1，类型：写，状态：RUNNING】\n->【线程名称：Reader-11，类型：读，状态：WAITING】->【线程名称：Reader-2，类型：读，状态：WAITING】->【线程名称：Reader-1，类型：读，状态：WAITING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-11，重入量：3)\n->【线程名称：Reader-11，类型：读，状态：RUNNING】->【线程名称：Reader-2，类型：读，状态：RUNNING】->【线程名称：Reader-1，类型：读，状态：RUNNING】\n->【线程名称：Reader-12，类型：读，状态：WAITING】->【线程名称：Reader-13，类型：读，状态：WAITING】->【线程名称：Reader-14，类型：读，状态：WAITING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-12，重入量：3)\n->【线程名称：Reader-12，类型：读，状态：RUNNING】->【线程名称：Reader-13，类型：读，状态：RUNNING】->【线程名称：Reader-14，类型：读，状态：RUNNING】\n->【线程名称：Reader-15，类型：读，状态：WAITING】->【线程名称：Reader-16，类型：读，状态：WAITING】->【线程名称：Reader-17，类型：读，状态：WAITING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-15，重入量：3)\n->【线程名称：Reader-15，类型：读，状态：RUNNING】->【线程名称：Reader-16，类型：读，状态：RUNNING】->【线程名称：Reader-17，类型：读，状态：RUNNING】\n->【线程名称：Reader-18，类型：读，状态：WAITING】->【线程名称：Reader-19，类型：读，状态：WAITING】->【线程名称：Reader-20，类型：读，状态：WAITING】\n\nHead(持有线程：Reader-18，重入量：3)\n->【线程名称：Reader-18，类型：读，状态：RUNNING】->【线程名称：Reader-19，类型：读，状态：RUNNING】->【线程名称：Reader-20，类型：读，状态：RUNNING】\n\nHead(持有线程：未持有线程，重入量：0)\n\nHead(持有线程：未持有线程，重入量：0)\n```\n\n如上述结果，每一行代表一个节点（读节点有不超过读链阈值的节点个数），Head开头说明打印了一次线程队列中的执行和等待情况。结果说明该读写锁可支持：\n\n1. 多个线程的并发读访问\n2. 多个线程的写访问\n3. 避免了写饥饿","slug":"C-ReadWriteLock","published":1,"updated":"2021-05-16T10:53:13.998Z","_id":"ckfukja920007szxofpjwt0x7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用C#实现的<code>可重入</code>、<code>非公平</code>的<code>读写锁</code>，主要目的实现<strong>并发读写</strong>以及<strong>读写同步</strong>问题。为了<strong>减少读等待时间</strong>以及<strong>防止出现写饥饿现象</strong>，本锁使用了<strong>非同步锁</strong>的实现，允许<strong>读优先（提高效率）</strong>的同时<strong>使用一个阈值限定读者的最大数量（防止写饥饿）</strong>；重入机制允许某个线程可以获取锁多次（如多次函数调用导致的锁重入），每次获取都需要有对应的释放，否则会出错。</p>\n<a id=\"more\"></a>\n<p>本锁的目的是实现对读写线程队列的调度，而不是对线程获取锁的顺序进行调度。要注意读写线程进入队列的顺序是系统调度的（意即创建多个线程并Start时，其进入线程的时机是系统决定的，可能最后创建的线程最先执行），这里实现的是<strong>对进入队列后的线程进行阻塞、唤醒等操作</strong>。</p>\n<p>本锁使用了<code>C#</code>中的<code>lock原语</code>，目的是为了实现一些<strong>队列操作的原子性</strong>。</p>\n<p>实现本锁时作者参考了<code>Java</code>中<code>AQS</code>和<code>ReentrantReadWriteLock</code>的一些实现细节，予以理解仿效，设计了这个简单的读写锁，实现逻辑上可能仍有很多缺陷或矛盾，望各位看官批评指正！</p>\n<h2 id=\"Node节点\"><a href=\"#Node节点\" class=\"headerlink\" title=\"Node节点\"></a>Node节点</h2><p>Node节点是实现本读写锁的关键所在，读写线程队列也是基于Node节点实现的。Node内部持有了一个线程，同时有很多指向其他Node的引用。Node类实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读节点</span><br><span class=\"line\">        public static readonly Node SHARED = new Node();</span><br><span class=\"line\">        // 写节点</span><br><span class=\"line\">        public static readonly Node EXCLUSIVE = null;</span><br><span class=\"line\">        // 读链长度阈值</span><br><span class=\"line\">        public static int Threshold = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 节点状态</span><br><span class=\"line\">        public static readonly int CANCELLED = 1;</span><br><span class=\"line\">        public static readonly int RUNNING = -1;</span><br><span class=\"line\">        public static readonly int WAITING = -2;</span><br><span class=\"line\">        public static readonly int SIGNAL = -3;</span><br><span class=\"line\">    </span><br><span class=\"line\">        public int waitStatus;</span><br><span class=\"line\">        // 前驱节点</span><br><span class=\"line\">        public Node prev;</span><br><span class=\"line\">        // 后继节点</span><br><span class=\"line\">        public Node next;</span><br><span class=\"line\">        // 持有线程</span><br><span class=\"line\">        public Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        //以下参数仅对读节点适用</span><br><span class=\"line\">        // 读链头</span><br><span class=\"line\">        public Node readerHead;</span><br><span class=\"line\">        // 后继读节点</span><br><span class=\"line\">        public Node nextReader;</span><br><span class=\"line\">        // 读链长度</span><br><span class=\"line\">        public int readerCount = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 节点类型</span><br><span class=\"line\">        public Node mode;</span><br><span class=\"line\">        // 是否是共享节点</span><br><span class=\"line\">        public bool isShared()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return mode == SHARED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Node()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建共享或独占节点</span><br><span class=\"line\">        public Node(Thread thread, Node mode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.mode = mode;</span><br><span class=\"line\">            this.thread = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t// 获取状态</span><br><span class=\"line\">        public static string GetStatus(int status)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            switch (status)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                case 1:</span><br><span class=\"line\">                    return &quot;CANCELLED&quot;;</span><br><span class=\"line\">                case -1:</span><br><span class=\"line\">                    return &quot;RUNNING&quot;;</span><br><span class=\"line\">                case -2:</span><br><span class=\"line\">                    return &quot;WAITING&quot;;</span><br><span class=\"line\">                case -3:</span><br><span class=\"line\">                    return &quot;SIGNAL&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return &quot;DEFAULT&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>各属性及方法的涵义如上述代码注释所示，而由Node组成的等待队列结构（双向链表）如下图所示（可能出现的一种情况）：</p>\n<p><img src=\"http://getme.guitoubing.top/队列示意图.png\" alt=\"队列示意图.png\"></p>\n<p>对于写节点来说，锁是独占的，一次仅能有一个写线程在执行；而对于读节点来说，锁是共享的，在同一读链上的所有节点都可同时进行读。</p>\n<h2 id=\"重要变量\"><a href=\"#重要变量\" class=\"headerlink\" title=\"重要变量\"></a>重要变量</h2><h3 id=\"头节点-head\"><a href=\"#头节点-head\" class=\"headerlink\" title=\"头节点 head\"></a>头节点 head</h3><p>头节点是个傀儡节点，<code>private volatile Node head</code>，其无实际涵义，只是为了作为队列头而存在；其使用了惰性初始化的方法，仅在第一个节点入队列时初始化。</p>\n<blockquote>\n<p><code>volatile</code>关键字在是为了实现变量的内存可见性，使用该关键字修饰的变量的修改会直接反映到内存中而不是缓存中。</p>\n</blockquote>\n<h3 id=\"尾节点-tail\"><a href=\"#尾节点-tail\" class=\"headerlink\" title=\"尾节点 tail\"></a>尾节点 tail</h3><p>尾节点是队列的最后一个节点，<code>private volatile Node tail</code>，引入尾节点是为了防止在新节点入列时遍历队列，提高了效率。</p>\n<h3 id=\"重入量-reentrants\"><a href=\"#重入量-reentrants\" class=\"headerlink\" title=\"重入量 reentrants\"></a>重入量 reentrants</h3><p>对于写锁（独占锁）来说，当一个写线程获取锁时，<code>reentrants</code>为<code>1</code>，后续每当锁重入一次，<code>reentrants</code>增加<code>1</code>；释放锁时，每释放一次<code>reentrants</code>减少1，直到<code>reentrants</code>为<code>0</code>时该线程释放当前锁，唤醒后续线程；</p>\n<p>对于读锁（共享锁）来说，由于读链中可能会有不超过<code>Node.Threshold</code>个数的读节点，且每个读节点都可能会产生重入，这里会将<code>reentrants</code>初始化为读链长度，在<code>Node.RUNNING`</code>时读链每增加一个读节点会增加一个reentrants<code>，读链中的每个节点多一次重入也会导致</code>reentrants<code>增加</code>1`。</p>\n<h2 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h2><h3 id=\"获取-WriteLock\"><a href=\"#获取-WriteLock\" class=\"headerlink\" title=\"获取 WriteLock()\"></a>获取 WriteLock()</h3><p>先看获取写锁的流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取写锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void WriteLock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 当前节点</span><br><span class=\"line\">    Node currentNode = null;</span><br><span class=\"line\">    // 这里使用了惰性初始化，如果头节点为空，则初始化头节点</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            head = new Node();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果尾节点为空，说明当前队列为空，此时线程直接入队列设置为RUNNING状态</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (tail == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 如果当前线程就是持有线程，说明锁在重入，reentrants加1</span><br><span class=\"line\">        if (owner == Thread.CurrentThread)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reentrants += 1;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 否则，当前线程需要进入等待队列进行等待</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 获取尾节点</span><br><span class=\"line\">            Node t = tail;</span><br><span class=\"line\">            // 由于可能出现其他线程的介入，需要再次检测为节点是否为空</span><br><span class=\"line\">            if (t == null)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 否则直接入队列等待</span><br><span class=\"line\">            else</span><br><span class=\"line\">                currentNode = Enq(Node.EXCLUSIVE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 检测当前节点是否可以被唤醒</span><br><span class=\"line\">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class=\"line\">    // 此时线程已被唤醒，设置重入量及状态等</span><br><span class=\"line\">    reentrants = 1;</span><br><span class=\"line\">    currentNode.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    owner = Thread.CurrentThread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本流程如下：</p>\n<ol>\n<li>先判断队列是否已初始化，若未初始化，先初始化head节点</li>\n<li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断当前线程是否为持有锁的线程，若是说明线程在重入当前锁，直接<code>reentrants</code>加<code>1</code>，成功获取锁，返回；否则进入下一步</li>\n<li>获取尾节点，由于第2步结束时可能有其他线程的介入，因此需再次判断<code>tail==null</code>，若是直接进入队列，成功获取锁，返回；否则以当前线程创建节点并入队列，同时阻塞</li>\n<li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，并成功获取独占锁</li>\n</ol>\n<h3 id=\"释放-WriteUnlock\"><a href=\"#释放-WriteUnlock\" class=\"headerlink\" title=\"释放 WriteUnlock()\"></a>释放 WriteUnlock()</h3><p>释放写锁的逻辑很简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 释放写锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void WriteUnlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 加锁是为了同步修改队列信息</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 当前锁持有者重入量直接-1</span><br><span class=\"line\">        reentrants -= 1;</span><br><span class=\"line\">        // 获取队列头（除了head之外的头）</span><br><span class=\"line\">        Node node = GetHolderNode();</span><br><span class=\"line\">        // 如果后续节点为空，则释放完成，队列已空；若后续节点不为空，则可能需要唤醒后续节点</span><br><span class=\"line\">        if (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 若当前锁的重入量为0，说明锁已经完全释放，则需要唤醒后继有效节点（否则可能只是释放了一个锁内部的锁）</span><br><span class=\"line\">            if (reentrants == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 当前节点置为无效</span><br><span class=\"line\">                node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">                // 唤醒后继有效节点</span><br><span class=\"line\">                AwakeNext();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑如下：</p>\n<ol>\n<li>锁<code>reentrants</code>减<code>1</code></li>\n<li>获取当前锁持有的节点</li>\n<li>判断上述获取的节点是否为空，若为空说明队列已空，已无等待节点，直接返回；否则检查<code>reentrants</code>是否已减至<code>0</code></li>\n<li>若是则当前节点线程已完成，置为<code>Node.CANCELLED</code>状态，并唤醒后继有效节点</li>\n</ol>\n<h2 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h2><h3 id=\"获取-ReadLock\"><a href=\"#获取-ReadLock\" class=\"headerlink\" title=\"获取 ReadLock()\"></a>获取 ReadLock()</h3><p>相比于写锁的获取，读锁的获取要复杂一点，因为涉及到读的共享以及阈值的控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取读锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void ReadLock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node reader = null;</span><br><span class=\"line\">    // 这里基本的初始化方式和读锁相似，不赘述</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            head = new Node();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread current = Thread.CurrentThread;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (tail == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node currentNode = null;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读可重入</span><br><span class=\"line\">        if (ReaderCanReentranted())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reentrants += 1;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 获取当前持有锁节点</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        if (node == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 队列中有写者的情况</span><br><span class=\"line\">            if (HasWriter())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 创建当前持有当前线程的读节点</span><br><span class=\"line\">                reader = new Node(current, Node.SHARED);</span><br><span class=\"line\">                // 获取第一个读节点（可能为null）</span><br><span class=\"line\">                while (node != null &amp;&amp; (!node.isShared() || node.waitStatus == Node.CANCELLED))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (node.isShared())</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        if (!CheckReadChainCancelled(node))</span><br><span class=\"line\">                            break;</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                            node = node.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        node = node.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 未找到读节点，说明队列中只有写节点，此时直接添加到队列尾</span><br><span class=\"line\">                if (node == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 否则说明找到了有效的读节点，此时此读节点为队列中第一个读节点，只需要判断此读节点链长是否达到了阈值，</span><br><span class=\"line\">                //  若未超过阈值，直接添加到读链中，并判断当前读链头是否正在读，则可以直接读，否则需要循环检测；</span><br><span class=\"line\">                //  若超过了阈值：</span><br><span class=\"line\">                //      若队尾为写节点，则添加到队列尾，并循环等待；</span><br><span class=\"line\">                //      若队尾为读节点，判断是否到达阈值：</span><br><span class=\"line\">                //          若是则添加到队列尾，并循环等待；</span><br><span class=\"line\">                //          否则添加到读链中。</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    // 未超过阈值</span><br><span class=\"line\">                    if (node.readerCount &lt; Node.Threshold)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        // 添加到读链中</span><br><span class=\"line\">                        currentNode = AddReader(node, reader);</span><br><span class=\"line\">                        // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class=\"line\">                        if (node.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                            reentrants += 1;</span><br><span class=\"line\">                            return;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 超过了阈值</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        // 判断队尾节点类型</span><br><span class=\"line\">                        Node t = tail;</span><br><span class=\"line\">                        // 队尾为“写节点”或“达到阈值的读节点”</span><br><span class=\"line\">                        if (!t.isShared() || (t.isShared() &amp;&amp; t.readerCount &gt;= Node.Threshold))</span><br><span class=\"line\">                            currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                        // 队尾为“未达到阈值的读节点”</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            // 添加到队尾节点所在的读链中</span><br><span class=\"line\">                            currentNode = AddReader(t, reader);</span><br><span class=\"line\">                            // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class=\"line\">                            if (t.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                                reentrants += 1;</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 队列中无写者，说明队列中要么为空，要么全为读者，直接加到队尾或者队尾所在的读链</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 队列为空，直接入队</span><br><span class=\"line\">                if (tail == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 队尾节点读链长度未达到阈值</span><br><span class=\"line\">                if (tail.readerCount &lt; Node.Threshold)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    reader = new Node(current, Node.SHARED);</span><br><span class=\"line\">                    // 添加到链尾</span><br><span class=\"line\">                    currentNode = AddReader(tail, reader);</span><br><span class=\"line\">                    // 是否需要循环等待</span><br><span class=\"line\">                    if (tail.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                        reentrants += 1;</span><br><span class=\"line\">                        return;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 队尾节点读链达到了阈值，直接加入队尾，并等待唤醒</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class=\"line\">    currentNode.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    reentrants = currentNode.readerHead.readerCount;</span><br><span class=\"line\">    owner = currentNode.readerHead == null ? null : currentNode.readerHead.thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑如下：</p>\n<ol>\n<li>先判断队列是否已初始化，若未初始化，先初始化head节点</li>\n<li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断当前线程是否可重入锁（读线程的可重入判断与写不同，会在后面对<code>ReaderCanReentranted()</code>方法解释时介绍到），若是<code>reentrants</code>加<code>1</code>，返回；否则进入下一步</li>\n<li>获取当前持有锁节点，若为空说明队列为空，直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断队列中是否有写者，若是跳至第6步，否则跳至第7步</li>\n<li>队列中有写者，为防止出现写饥饿的情况，此读节点可能在写者前或后：<ol>\n<li>若队列中无读节点，即只有写节点，直接添加至队列尾，并阻塞</li>\n<li>若找到了队列中的第一个有效读节点，判断其读链是否达到阈值</li>\n<li>若未超过阈值，则直接添加到读链中，是否阻塞由读链头的状态决定</li>\n<li>若超过了阈值，则有两种情况：<ul>\n<li>队尾为<strong>写节点</strong>或者队尾为<strong>读节点且读链长度达到阈值</strong>，此时节点添加至队列尾，并阻塞</li>\n<li>队尾为<strong>读节点且读链长度未达到阈值</strong>，将节点加入队尾的读链中，与队尾节点状态一致</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>队列中无写者，说明队列中要么为空，要么全为读者，则根据队尾节点读链长度来决定是直接加到队尾还是加到队尾所在的读链</li>\n<li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，设置<code>reentrants</code>为读链长度，并成功获取共享锁</li>\n</ol>\n<h3 id=\"释放-ReadUnlock\"><a href=\"#释放-ReadUnlock\" class=\"headerlink\" title=\"释放 ReadUnlock()\"></a>释放 ReadUnlock()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 释放读锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void ReadUnlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读重入量-1</span><br><span class=\"line\">        reentrants -= 1;</span><br><span class=\"line\">        // 获取到锁持有节点</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (CheckReadChainCancelled(node))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                node = node.next;</span><br><span class=\"line\">                head.next = node;</span><br><span class=\"line\">                if (node != null)</span><br><span class=\"line\">                    node.prev = head;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 获取到有效读节点了</span><br><span class=\"line\">        if (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class=\"line\">            node = GetCurrentNodeByReader(node);</span><br><span class=\"line\">            // 当前节点置为取消</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">            // 重入量为0，需要判断读链是否已全部读完成，若是则需要唤醒后续线程</span><br><span class=\"line\">            if (reentrants == 0)</span><br><span class=\"line\">                AwakeNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>释放读锁的逻辑与释放写锁逻辑基本类似，无需多提。</p>\n<h2 id=\"其余辅助方法\"><a href=\"#其余辅助方法\" class=\"headerlink\" title=\"其余辅助方法\"></a>其余辅助方法</h2><h3 id=\"Enq-Node-mode\"><a href=\"#Enq-Node-mode\" class=\"headerlink\" title=\"Enq(Node mode)\"></a>Enq(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，并入队列并阻塞，同时返回此节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 读写节点入队列操作，入队列后需等待</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node Enq(Node mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    // 以当前线程创建独占节点</span><br><span class=\"line\">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class=\"line\">    // 连接尾节点与当前节点</span><br><span class=\"line\">    t.next = node;</span><br><span class=\"line\">    node.prev = t;</span><br><span class=\"line\">    // 重置尾节点为当前节点</span><br><span class=\"line\">    tail = node;</span><br><span class=\"line\">    // 设置节点等待状态为WAITING</span><br><span class=\"line\">    node.waitStatus = Node.WAITING;</span><br><span class=\"line\">    // 若为读节点，需要设置读链头</span><br><span class=\"line\">    if (node.isShared())</span><br><span class=\"line\">        node.readerHead = node;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EnqWhenTailNull-Node-mode\"><a href=\"#EnqWhenTailNull-Node-mode\" class=\"headerlink\" title=\"EnqWhenTailNull(Node mode)\"></a>EnqWhenTailNull(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，在队列为空时，此节点直接入队列且当前线程继续执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 读写节点入队列操作，此时队列尾为空，入队列之后继续运行，无需等待</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void EnqWhenTailNull(Node mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 以当前线程创建独占节点</span><br><span class=\"line\">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class=\"line\">    // 设置等待类型为RUNNING</span><br><span class=\"line\">    node.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    // 当前节点加入队列，尾节点为当前节点</span><br><span class=\"line\">    tail = node;</span><br><span class=\"line\">    // 设置锁的持有者为当前线程</span><br><span class=\"line\">    owner = Thread.CurrentThread;</span><br><span class=\"line\">    // 重入量初始为1</span><br><span class=\"line\">    reentrants = 1;</span><br><span class=\"line\">    // 连接头节点与此节点</span><br><span class=\"line\">    head.next = node;</span><br><span class=\"line\">    node.prev = head;</span><br><span class=\"line\">    // 若为读节点，需要设置读链头</span><br><span class=\"line\">    if (node.isShared())</span><br><span class=\"line\">        node.readerHead = node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AwakeNext\"><a href=\"#AwakeNext\" class=\"headerlink\" title=\"AwakeNext()\"></a>AwakeNext()</h3><p>当某个节点置为<code>Node.CANCELLED</code>状态时，会唤醒其后一个有效节点，主要是将节点状态修改为<code>Node.SIGNAL</code>状态，以被各自节点监测到。</p>\n<p>对于写节点来说，由于是独占的，只需要修改该节点；对于读节点来说，由于是共享的，需要遍历该节点所在的读链并修改每个节点的状态，才能达到唤醒整条读链的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 唤醒后一个节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void AwakeNext()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 获取持有当前锁的节点，此时锁刚好被上个节点释放，获取的节点应处于Node.WAITING状态</span><br><span class=\"line\">    Node node = GetHolderNode();</span><br><span class=\"line\">    // 当前节点为空，说明队列中无有效节点，直接返回即可</span><br><span class=\"line\">    if (node == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tail = null;</span><br><span class=\"line\">        owner = null;</span><br><span class=\"line\">        reentrants = 0;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 否则需要唤醒此有效节点</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 连接到头节点</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">        // 对于写节点，readerCount为1，即为reentrants初始值1</span><br><span class=\"line\">        // 对于读节点，readerCount即为reentrants的初始值</span><br><span class=\"line\">        reentrants = node.readerCount;</span><br><span class=\"line\">        // 对于读节点来说，需唤醒读链中的所有节点；对于写节点来说，无读链，只会唤醒当前节点</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 等待类型设置为SIGNAL，会被捕捉从而唤醒相关线程</span><br><span class=\"line\">            node.waitStatus = Node.SIGNAL;</span><br><span class=\"line\">            // 若为读节点，可获取下一个读者；否则获取了null</span><br><span class=\"line\">            node = node.nextReader;</span><br><span class=\"line\">            // 下一个读者不为空，则也将其前驱节点设置为头节点</span><br><span class=\"line\">            if (node != null)</span><br><span class=\"line\">                node.prev = head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GetHolderNode\"><a href=\"#GetHolderNode\" class=\"headerlink\" title=\"GetHolderNode()\"></a>GetHolderNode()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> *   删除无效节点（可能由于主动中断或者其他因素导致的线程失效），获取第一个有效节点或空节点，</span><br><span class=\"line\"> * 或者称作获取锁持有节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node GetHolderNode()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node node = head.next;</span><br><span class=\"line\">    // 此循环的判断条件可能出现歧义，因存在读链头为取消状态时，读链中仍然有读节点读未完成，但是此函数只在释放写锁(WriteUnlock)和唤醒后续节点(AwakeNext)中使用到，当AwakeNext被触发时，读链头的状态便可以代表整个读链的状态了。</span><br><span class=\"line\">    while (node != null &amp;&amp; node.waitStatus == Node.CANCELLED)</span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">    // 连接头节点和持有节点，无效节点全部交由垃圾收集器回收</span><br><span class=\"line\">    head.next = node;</span><br><span class=\"line\">    if (node != null)</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HasWriter\"><a href=\"#HasWriter\" class=\"headerlink\" title=\"HasWriter()\"></a>HasWriter()</h3><p>在读节点获取锁时，有一步是需要判断队列中是否存在写者，即用到此函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 返回当前队列中是否存在写者，用在读者入队列时的决策</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool HasWriter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bool exclusive = false;</span><br><span class=\"line\">    Node excluNode = head.next;</span><br><span class=\"line\">    while (excluNode != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!excluNode.isShared())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            exclusive = true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        excluNode = excluNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return exclusive;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GetCurrentNodeByReader-Node-node\"><a href=\"#GetCurrentNodeByReader-Node-node\" class=\"headerlink\" title=\"GetCurrentNodeByReader(Node node)\"></a>GetCurrentNodeByReader(Node node)</h3><p>在释放读锁时，我们无法直接获取到当前节点，只能通过线程名称来确定当前线程的持有者在<code>node</code>所在的读链中的位置，返回获取到的节点，以在释放锁时修改状态。</p>\n<p>而由于是通过线程名称来判断线程是否相等，可能会因线程重名导致异常，待改进。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node GetCurrentNodeByReader(Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node nextReader = node.readerHead;</span><br><span class=\"line\">    // 以线程名称为依据，这里可能出现多个线程同名的情况，待改进</span><br><span class=\"line\">    while (nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (nextReader.thread.Name.Equals(Thread.CurrentThread.Name))</span><br><span class=\"line\">            return nextReader;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            nextReader = nextReader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CheckReadChainCancelled-Node-node\"><a href=\"#CheckReadChainCancelled-Node-node\" class=\"headerlink\" title=\"CheckReadChainCancelled(Node node)\"></a>CheckReadChainCancelled(Node node)</h3><p>对于写节点来说，只要节点状态为<code>Node.CANCELLED</code>，说明写已经完成；而对于读节点，需要遍历读链中所有节点的状态才能确定读是否完成，此方法便是如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过一个读节点判断其所在读链是否已全部读完成</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool CheckReadChainCancelled(Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node nextReader = node.readerHead;</span><br><span class=\"line\">    while (nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (nextReader.waitStatus != Node.CANCELLED)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            nextReader = nextReader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AddReader-Node-readerHead-Node-node\"><a href=\"#AddReader-Node-readerHead-Node-node\" class=\"headerlink\" title=\"AddReader(Node readerHead, Node node)\"></a>AddReader(Node readerHead, Node node)</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 添加读者到指定读链头所在的读链中</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node AddReader(Node readerHead, Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 获取到读链尾</span><br><span class=\"line\">    Node reader = readerHead;</span><br><span class=\"line\">    while (reader.nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        reader = reader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 读链头的前驱节点也是读链中任何节点的前驱节点</span><br><span class=\"line\">    node.prev = reader.prev;</span><br><span class=\"line\">    // 连接到读链尾</span><br><span class=\"line\">    reader.nextReader = node;</span><br><span class=\"line\">    node.readerHead = readerHead;</span><br><span class=\"line\">    node.waitStatus = readerHead.waitStatus;</span><br><span class=\"line\">    // 读链头记录的读链长度+1</span><br><span class=\"line\">    readerHead.readerCount++;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ReaderCanReentranted\"><a href=\"#ReaderCanReentranted\" class=\"headerlink\" title=\"ReaderCanReentranted()\"></a>ReaderCanReentranted()</h3><p>对于来说写者，只需判断当前线程是否为持有锁线程即可判断是否可以重入；而对于读者来说，只要当前线程与正在读的读链中的任意一个线程相等即可重入。</p>\n<p>同样线程同名的情况也不可避免。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断读者是否可以重入，判断依据为当前线程是否被正在执行读的读链中的某一个节点持有</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool ReaderCanReentranted()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node node = head.next;</span><br><span class=\"line\">    if (node == null || !node.isShared())</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Node reader = node;</span><br><span class=\"line\">        while (reader != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (reader.thread == Thread.CurrentThread)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            reader = reader.nextReader;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString()\"></a>ToString()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 覆盖ToString方法，格式化输出当前队列情况</span><br><span class=\"line\"> */</span><br><span class=\"line\">public override string ToString()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">    if (head != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (owner != null)</span><br><span class=\"line\">            sb.Append(&quot;Head(持有线程：&quot; + owner.Name + &quot;，重入量：&quot; + reentrants + &quot;)\\n&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            sb.Append(&quot;Head(持有线程：未持有线程，重入量：&quot; + reentrants + &quot;)\\n&quot;);</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Node reader = node;</span><br><span class=\"line\">            if (node.isShared())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                while (reader != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：读，状态：&#123;1&#125;】&quot;, reader.thread.Name, Node.GetStatus(reader.waitStatus));</span><br><span class=\"line\">                    reader = reader.nextReader;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sb.AppendLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：写，状态：&#123;1&#125;】&quot;, node.thread.Name, Node.GetStatus(node.waitStatus));</span><br><span class=\"line\">                sb.AppendLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sb.ToString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ReadWriteLock</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class MainClass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      \tpublic static void Add(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000000; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                readWriteLock.WriteLock();</span><br><span class=\"line\">                N++;</span><br><span class=\"line\">                readWriteLock.WriteUnlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestReentrantWriter(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            Thread.Sleep(1000);</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestWriter(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            Thread.Sleep(500);</span><br><span class=\"line\">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestReader(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.ReadLock();</span><br><span class=\"line\">            Thread.Sleep(500);</span><br><span class=\"line\">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class=\"line\">            readWriteLock.ReadUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ReadWriteLock readWriteLock = new ReadWriteLock();</span><br><span class=\"line\">            for (int i = 1; i &lt;= 10; i++)</span><br><span class=\"line\">                CreateThread(false, i, readWriteLock);</span><br><span class=\"line\">            for (int i = 1; i &lt;= 20; i++)</span><br><span class=\"line\">                CreateThread(true, i, readWriteLock);</span><br><span class=\"line\">            for (int i = 0; i &lt; 100; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Thread.Sleep(500);</span><br><span class=\"line\">                readWriteLock.PrintQueue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void CreateThread(bool share, int i, ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread;</span><br><span class=\"line\">            if (share) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                thread = new Thread(() =&gt; TestReader(readWriteLock));</span><br><span class=\"line\">                thread.Name = &quot;Reader-&quot; + i;            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                thread = i == 5 ? new Thread(() =&gt; TestReentrantWriter(readWriteLock)) : new Thread(() =&gt; TestWriter(readWriteLock));</span><br><span class=\"line\">                thread.Name = &quot;Writer-&quot; + i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是两个线程同时增加1亿次的时间：约30s，比Monitor大概慢了5倍。</p>\n<p>其次，测试创建了10个写线程、20个读线程，假定每个线程持续时间为500毫秒，每隔500毫秒输出等待队列的情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Head(持有线程：Writer-2，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-2，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-8，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-8，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-10，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-6，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-4，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-6，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-7，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-3，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-5，重入量：4)</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-5，重入量：4)</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-3，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-5，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-7，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：SIGNAL】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-9，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-9，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-4，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-1，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-11，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-2，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-1，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-12，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-13，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-14，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-15，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-16，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-17，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-18，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-19，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-20，类型：读，状态：RUNNING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：未持有线程，重入量：0)</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：未持有线程，重入量：0)</span><br></pre></td></tr></table></figure>\n<p>如上述结果，每一行代表一个节点（读节点有不超过读链阈值的节点个数），Head开头说明打印了一次线程队列中的执行和等待情况。结果说明该读写锁可支持：</p>\n<ol>\n<li>多个线程的并发读访问</li>\n<li>多个线程的写访问</li>\n<li>避免了写饥饿</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>使用C#实现的<code>可重入</code>、<code>非公平</code>的<code>读写锁</code>，主要目的实现<strong>并发读写</strong>以及<strong>读写同步</strong>问题。为了<strong>减少读等待时间</strong>以及<strong>防止出现写饥饿现象</strong>，本锁使用了<strong>非同步锁</strong>的实现，允许<strong>读优先（提高效率）</strong>的同时<strong>使用一个阈值限定读者的最大数量（防止写饥饿）</strong>；重入机制允许某个线程可以获取锁多次（如多次函数调用导致的锁重入），每次获取都需要有对应的释放，否则会出错。</p>","more":"<p>本锁的目的是实现对读写线程队列的调度，而不是对线程获取锁的顺序进行调度。要注意读写线程进入队列的顺序是系统调度的（意即创建多个线程并Start时，其进入线程的时机是系统决定的，可能最后创建的线程最先执行），这里实现的是<strong>对进入队列后的线程进行阻塞、唤醒等操作</strong>。</p>\n<p>本锁使用了<code>C#</code>中的<code>lock原语</code>，目的是为了实现一些<strong>队列操作的原子性</strong>。</p>\n<p>实现本锁时作者参考了<code>Java</code>中<code>AQS</code>和<code>ReentrantReadWriteLock</code>的一些实现细节，予以理解仿效，设计了这个简单的读写锁，实现逻辑上可能仍有很多缺陷或矛盾，望各位看官批评指正！</p>\n<h2 id=\"Node节点\"><a href=\"#Node节点\" class=\"headerlink\" title=\"Node节点\"></a>Node节点</h2><p>Node节点是实现本读写锁的关键所在，读写线程队列也是基于Node节点实现的。Node内部持有了一个线程，同时有很多指向其他Node的引用。Node类实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读节点</span><br><span class=\"line\">        public static readonly Node SHARED = new Node();</span><br><span class=\"line\">        // 写节点</span><br><span class=\"line\">        public static readonly Node EXCLUSIVE = null;</span><br><span class=\"line\">        // 读链长度阈值</span><br><span class=\"line\">        public static int Threshold = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 节点状态</span><br><span class=\"line\">        public static readonly int CANCELLED = 1;</span><br><span class=\"line\">        public static readonly int RUNNING = -1;</span><br><span class=\"line\">        public static readonly int WAITING = -2;</span><br><span class=\"line\">        public static readonly int SIGNAL = -3;</span><br><span class=\"line\">    </span><br><span class=\"line\">        public int waitStatus;</span><br><span class=\"line\">        // 前驱节点</span><br><span class=\"line\">        public Node prev;</span><br><span class=\"line\">        // 后继节点</span><br><span class=\"line\">        public Node next;</span><br><span class=\"line\">        // 持有线程</span><br><span class=\"line\">        public Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        //以下参数仅对读节点适用</span><br><span class=\"line\">        // 读链头</span><br><span class=\"line\">        public Node readerHead;</span><br><span class=\"line\">        // 后继读节点</span><br><span class=\"line\">        public Node nextReader;</span><br><span class=\"line\">        // 读链长度</span><br><span class=\"line\">        public int readerCount = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 节点类型</span><br><span class=\"line\">        public Node mode;</span><br><span class=\"line\">        // 是否是共享节点</span><br><span class=\"line\">        public bool isShared()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return mode == SHARED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Node()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建共享或独占节点</span><br><span class=\"line\">        public Node(Thread thread, Node mode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.mode = mode;</span><br><span class=\"line\">            this.thread = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t// 获取状态</span><br><span class=\"line\">        public static string GetStatus(int status)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            switch (status)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                case 1:</span><br><span class=\"line\">                    return &quot;CANCELLED&quot;;</span><br><span class=\"line\">                case -1:</span><br><span class=\"line\">                    return &quot;RUNNING&quot;;</span><br><span class=\"line\">                case -2:</span><br><span class=\"line\">                    return &quot;WAITING&quot;;</span><br><span class=\"line\">                case -3:</span><br><span class=\"line\">                    return &quot;SIGNAL&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return &quot;DEFAULT&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>各属性及方法的涵义如上述代码注释所示，而由Node组成的等待队列结构（双向链表）如下图所示（可能出现的一种情况）：</p>\n<p><img src=\"http://getme.guitoubing.top/队列示意图.png\" alt=\"队列示意图.png\"></p>\n<p>对于写节点来说，锁是独占的，一次仅能有一个写线程在执行；而对于读节点来说，锁是共享的，在同一读链上的所有节点都可同时进行读。</p>\n<h2 id=\"重要变量\"><a href=\"#重要变量\" class=\"headerlink\" title=\"重要变量\"></a>重要变量</h2><h3 id=\"头节点-head\"><a href=\"#头节点-head\" class=\"headerlink\" title=\"头节点 head\"></a>头节点 head</h3><p>头节点是个傀儡节点，<code>private volatile Node head</code>，其无实际涵义，只是为了作为队列头而存在；其使用了惰性初始化的方法，仅在第一个节点入队列时初始化。</p>\n<blockquote>\n<p><code>volatile</code>关键字在是为了实现变量的内存可见性，使用该关键字修饰的变量的修改会直接反映到内存中而不是缓存中。</p>\n</blockquote>\n<h3 id=\"尾节点-tail\"><a href=\"#尾节点-tail\" class=\"headerlink\" title=\"尾节点 tail\"></a>尾节点 tail</h3><p>尾节点是队列的最后一个节点，<code>private volatile Node tail</code>，引入尾节点是为了防止在新节点入列时遍历队列，提高了效率。</p>\n<h3 id=\"重入量-reentrants\"><a href=\"#重入量-reentrants\" class=\"headerlink\" title=\"重入量 reentrants\"></a>重入量 reentrants</h3><p>对于写锁（独占锁）来说，当一个写线程获取锁时，<code>reentrants</code>为<code>1</code>，后续每当锁重入一次，<code>reentrants</code>增加<code>1</code>；释放锁时，每释放一次<code>reentrants</code>减少1，直到<code>reentrants</code>为<code>0</code>时该线程释放当前锁，唤醒后续线程；</p>\n<p>对于读锁（共享锁）来说，由于读链中可能会有不超过<code>Node.Threshold</code>个数的读节点，且每个读节点都可能会产生重入，这里会将<code>reentrants</code>初始化为读链长度，在<code>Node.RUNNING`</code>时读链每增加一个读节点会增加一个reentrants<code>，读链中的每个节点多一次重入也会导致</code>reentrants<code>增加</code>1`。</p>\n<h2 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h2><h3 id=\"获取-WriteLock\"><a href=\"#获取-WriteLock\" class=\"headerlink\" title=\"获取 WriteLock()\"></a>获取 WriteLock()</h3><p>先看获取写锁的流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取写锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void WriteLock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 当前节点</span><br><span class=\"line\">    Node currentNode = null;</span><br><span class=\"line\">    // 这里使用了惰性初始化，如果头节点为空，则初始化头节点</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            head = new Node();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果尾节点为空，说明当前队列为空，此时线程直接入队列设置为RUNNING状态</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (tail == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 如果当前线程就是持有线程，说明锁在重入，reentrants加1</span><br><span class=\"line\">        if (owner == Thread.CurrentThread)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reentrants += 1;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 否则，当前线程需要进入等待队列进行等待</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 获取尾节点</span><br><span class=\"line\">            Node t = tail;</span><br><span class=\"line\">            // 由于可能出现其他线程的介入，需要再次检测为节点是否为空</span><br><span class=\"line\">            if (t == null)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 否则直接入队列等待</span><br><span class=\"line\">            else</span><br><span class=\"line\">                currentNode = Enq(Node.EXCLUSIVE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 检测当前节点是否可以被唤醒</span><br><span class=\"line\">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class=\"line\">    // 此时线程已被唤醒，设置重入量及状态等</span><br><span class=\"line\">    reentrants = 1;</span><br><span class=\"line\">    currentNode.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    owner = Thread.CurrentThread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本流程如下：</p>\n<ol>\n<li>先判断队列是否已初始化，若未初始化，先初始化head节点</li>\n<li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断当前线程是否为持有锁的线程，若是说明线程在重入当前锁，直接<code>reentrants</code>加<code>1</code>，成功获取锁，返回；否则进入下一步</li>\n<li>获取尾节点，由于第2步结束时可能有其他线程的介入，因此需再次判断<code>tail==null</code>，若是直接进入队列，成功获取锁，返回；否则以当前线程创建节点并入队列，同时阻塞</li>\n<li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，并成功获取独占锁</li>\n</ol>\n<h3 id=\"释放-WriteUnlock\"><a href=\"#释放-WriteUnlock\" class=\"headerlink\" title=\"释放 WriteUnlock()\"></a>释放 WriteUnlock()</h3><p>释放写锁的逻辑很简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 释放写锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void WriteUnlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 加锁是为了同步修改队列信息</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 当前锁持有者重入量直接-1</span><br><span class=\"line\">        reentrants -= 1;</span><br><span class=\"line\">        // 获取队列头（除了head之外的头）</span><br><span class=\"line\">        Node node = GetHolderNode();</span><br><span class=\"line\">        // 如果后续节点为空，则释放完成，队列已空；若后续节点不为空，则可能需要唤醒后续节点</span><br><span class=\"line\">        if (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 若当前锁的重入量为0，说明锁已经完全释放，则需要唤醒后继有效节点（否则可能只是释放了一个锁内部的锁）</span><br><span class=\"line\">            if (reentrants == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 当前节点置为无效</span><br><span class=\"line\">                node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">                // 唤醒后继有效节点</span><br><span class=\"line\">                AwakeNext();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑如下：</p>\n<ol>\n<li>锁<code>reentrants</code>减<code>1</code></li>\n<li>获取当前锁持有的节点</li>\n<li>判断上述获取的节点是否为空，若为空说明队列已空，已无等待节点，直接返回；否则检查<code>reentrants</code>是否已减至<code>0</code></li>\n<li>若是则当前节点线程已完成，置为<code>Node.CANCELLED</code>状态，并唤醒后继有效节点</li>\n</ol>\n<h2 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h2><h3 id=\"获取-ReadLock\"><a href=\"#获取-ReadLock\" class=\"headerlink\" title=\"获取 ReadLock()\"></a>获取 ReadLock()</h3><p>相比于写锁的获取，读锁的获取要复杂一点，因为涉及到读的共享以及阈值的控制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取读锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void ReadLock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node reader = null;</span><br><span class=\"line\">    // 这里基本的初始化方式和读锁相似，不赘述</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            head = new Node();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread current = Thread.CurrentThread;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (tail == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node currentNode = null;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读可重入</span><br><span class=\"line\">        if (ReaderCanReentranted())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reentrants += 1;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 获取当前持有锁节点</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        if (node == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 队列中有写者的情况</span><br><span class=\"line\">            if (HasWriter())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 创建当前持有当前线程的读节点</span><br><span class=\"line\">                reader = new Node(current, Node.SHARED);</span><br><span class=\"line\">                // 获取第一个读节点（可能为null）</span><br><span class=\"line\">                while (node != null &amp;&amp; (!node.isShared() || node.waitStatus == Node.CANCELLED))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    if (node.isShared())</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        if (!CheckReadChainCancelled(node))</span><br><span class=\"line\">                            break;</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                            node = node.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                        node = node.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 未找到读节点，说明队列中只有写节点，此时直接添加到队列尾</span><br><span class=\"line\">                if (node == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 否则说明找到了有效的读节点，此时此读节点为队列中第一个读节点，只需要判断此读节点链长是否达到了阈值，</span><br><span class=\"line\">                //  若未超过阈值，直接添加到读链中，并判断当前读链头是否正在读，则可以直接读，否则需要循环检测；</span><br><span class=\"line\">                //  若超过了阈值：</span><br><span class=\"line\">                //      若队尾为写节点，则添加到队列尾，并循环等待；</span><br><span class=\"line\">                //      若队尾为读节点，判断是否到达阈值：</span><br><span class=\"line\">                //          若是则添加到队列尾，并循环等待；</span><br><span class=\"line\">                //          否则添加到读链中。</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    // 未超过阈值</span><br><span class=\"line\">                    if (node.readerCount &lt; Node.Threshold)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        // 添加到读链中</span><br><span class=\"line\">                        currentNode = AddReader(node, reader);</span><br><span class=\"line\">                        // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class=\"line\">                        if (node.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                            reentrants += 1;</span><br><span class=\"line\">                            return;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // 超过了阈值</span><br><span class=\"line\">                    else</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        // 判断队尾节点类型</span><br><span class=\"line\">                        Node t = tail;</span><br><span class=\"line\">                        // 队尾为“写节点”或“达到阈值的读节点”</span><br><span class=\"line\">                        if (!t.isShared() || (t.isShared() &amp;&amp; t.readerCount &gt;= Node.Threshold))</span><br><span class=\"line\">                            currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                        // 队尾为“未达到阈值的读节点”</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            // 添加到队尾节点所在的读链中</span><br><span class=\"line\">                            currentNode = AddReader(t, reader);</span><br><span class=\"line\">                            // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class=\"line\">                            if (t.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                                reentrants += 1;</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 队列中无写者，说明队列中要么为空，要么全为读者，直接加到队尾或者队尾所在的读链</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // 队列为空，直接入队</span><br><span class=\"line\">                if (tail == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    EnqWhenTailNull(Node.SHARED);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 队尾节点读链长度未达到阈值</span><br><span class=\"line\">                if (tail.readerCount &lt; Node.Threshold)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    reader = new Node(current, Node.SHARED);</span><br><span class=\"line\">                    // 添加到链尾</span><br><span class=\"line\">                    currentNode = AddReader(tail, reader);</span><br><span class=\"line\">                    // 是否需要循环等待</span><br><span class=\"line\">                    if (tail.waitStatus == Node.RUNNING)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        reader.waitStatus = Node.RUNNING;</span><br><span class=\"line\">                        reentrants += 1;</span><br><span class=\"line\">                        return;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                // 队尾节点读链达到了阈值，直接加入队尾，并等待唤醒</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    currentNode = Enq(Node.SHARED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class=\"line\">    currentNode.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    reentrants = currentNode.readerHead.readerCount;</span><br><span class=\"line\">    owner = currentNode.readerHead == null ? null : currentNode.readerHead.thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑如下：</p>\n<ol>\n<li>先判断队列是否已初始化，若未初始化，先初始化head节点</li>\n<li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断当前线程是否可重入锁（读线程的可重入判断与写不同，会在后面对<code>ReaderCanReentranted()</code>方法解释时介绍到），若是<code>reentrants</code>加<code>1</code>，返回；否则进入下一步</li>\n<li>获取当前持有锁节点，若为空说明队列为空，直接进入队列，成功获取锁，返回；否则进入下一步</li>\n<li>判断队列中是否有写者，若是跳至第6步，否则跳至第7步</li>\n<li>队列中有写者，为防止出现写饥饿的情况，此读节点可能在写者前或后：<ol>\n<li>若队列中无读节点，即只有写节点，直接添加至队列尾，并阻塞</li>\n<li>若找到了队列中的第一个有效读节点，判断其读链是否达到阈值</li>\n<li>若未超过阈值，则直接添加到读链中，是否阻塞由读链头的状态决定</li>\n<li>若超过了阈值，则有两种情况：<ul>\n<li>队尾为<strong>写节点</strong>或者队尾为<strong>读节点且读链长度达到阈值</strong>，此时节点添加至队列尾，并阻塞</li>\n<li>队尾为<strong>读节点且读链长度未达到阈值</strong>，将节点加入队尾的读链中，与队尾节点状态一致</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>队列中无写者，说明队列中要么为空，要么全为读者，则根据队尾节点读链长度来决定是直接加到队尾还是加到队尾所在的读链</li>\n<li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，设置<code>reentrants</code>为读链长度，并成功获取共享锁</li>\n</ol>\n<h3 id=\"释放-ReadUnlock\"><a href=\"#释放-ReadUnlock\" class=\"headerlink\" title=\"释放 ReadUnlock()\"></a>释放 ReadUnlock()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 释放读锁</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void ReadUnlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    lock (this)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 读重入量-1</span><br><span class=\"line\">        reentrants -= 1;</span><br><span class=\"line\">        // 获取到锁持有节点</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (CheckReadChainCancelled(node))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                node = node.next;</span><br><span class=\"line\">                head.next = node;</span><br><span class=\"line\">                if (node != null)</span><br><span class=\"line\">                    node.prev = head;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 获取到有效读节点了</span><br><span class=\"line\">        if (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class=\"line\">            node = GetCurrentNodeByReader(node);</span><br><span class=\"line\">            // 当前节点置为取消</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">            // 重入量为0，需要判断读链是否已全部读完成，若是则需要唤醒后续线程</span><br><span class=\"line\">            if (reentrants == 0)</span><br><span class=\"line\">                AwakeNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>释放读锁的逻辑与释放写锁逻辑基本类似，无需多提。</p>\n<h2 id=\"其余辅助方法\"><a href=\"#其余辅助方法\" class=\"headerlink\" title=\"其余辅助方法\"></a>其余辅助方法</h2><h3 id=\"Enq-Node-mode\"><a href=\"#Enq-Node-mode\" class=\"headerlink\" title=\"Enq(Node mode)\"></a>Enq(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，并入队列并阻塞，同时返回此节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 读写节点入队列操作，入队列后需等待</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node Enq(Node mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    // 以当前线程创建独占节点</span><br><span class=\"line\">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class=\"line\">    // 连接尾节点与当前节点</span><br><span class=\"line\">    t.next = node;</span><br><span class=\"line\">    node.prev = t;</span><br><span class=\"line\">    // 重置尾节点为当前节点</span><br><span class=\"line\">    tail = node;</span><br><span class=\"line\">    // 设置节点等待状态为WAITING</span><br><span class=\"line\">    node.waitStatus = Node.WAITING;</span><br><span class=\"line\">    // 若为读节点，需要设置读链头</span><br><span class=\"line\">    if (node.isShared())</span><br><span class=\"line\">        node.readerHead = node;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EnqWhenTailNull-Node-mode\"><a href=\"#EnqWhenTailNull-Node-mode\" class=\"headerlink\" title=\"EnqWhenTailNull(Node mode)\"></a>EnqWhenTailNull(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，在队列为空时，此节点直接入队列且当前线程继续执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 读写节点入队列操作，此时队列尾为空，入队列之后继续运行，无需等待</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void EnqWhenTailNull(Node mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 以当前线程创建独占节点</span><br><span class=\"line\">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class=\"line\">    // 设置等待类型为RUNNING</span><br><span class=\"line\">    node.waitStatus = Node.RUNNING;</span><br><span class=\"line\">    // 当前节点加入队列，尾节点为当前节点</span><br><span class=\"line\">    tail = node;</span><br><span class=\"line\">    // 设置锁的持有者为当前线程</span><br><span class=\"line\">    owner = Thread.CurrentThread;</span><br><span class=\"line\">    // 重入量初始为1</span><br><span class=\"line\">    reentrants = 1;</span><br><span class=\"line\">    // 连接头节点与此节点</span><br><span class=\"line\">    head.next = node;</span><br><span class=\"line\">    node.prev = head;</span><br><span class=\"line\">    // 若为读节点，需要设置读链头</span><br><span class=\"line\">    if (node.isShared())</span><br><span class=\"line\">        node.readerHead = node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AwakeNext\"><a href=\"#AwakeNext\" class=\"headerlink\" title=\"AwakeNext()\"></a>AwakeNext()</h3><p>当某个节点置为<code>Node.CANCELLED</code>状态时，会唤醒其后一个有效节点，主要是将节点状态修改为<code>Node.SIGNAL</code>状态，以被各自节点监测到。</p>\n<p>对于写节点来说，由于是独占的，只需要修改该节点；对于读节点来说，由于是共享的，需要遍历该节点所在的读链并修改每个节点的状态，才能达到唤醒整条读链的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 唤醒后一个节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void AwakeNext()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 获取持有当前锁的节点，此时锁刚好被上个节点释放，获取的节点应处于Node.WAITING状态</span><br><span class=\"line\">    Node node = GetHolderNode();</span><br><span class=\"line\">    // 当前节点为空，说明队列中无有效节点，直接返回即可</span><br><span class=\"line\">    if (node == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tail = null;</span><br><span class=\"line\">        owner = null;</span><br><span class=\"line\">        reentrants = 0;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 否则需要唤醒此有效节点</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 连接到头节点</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">        // 对于写节点，readerCount为1，即为reentrants初始值1</span><br><span class=\"line\">        // 对于读节点，readerCount即为reentrants的初始值</span><br><span class=\"line\">        reentrants = node.readerCount;</span><br><span class=\"line\">        // 对于读节点来说，需唤醒读链中的所有节点；对于写节点来说，无读链，只会唤醒当前节点</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 等待类型设置为SIGNAL，会被捕捉从而唤醒相关线程</span><br><span class=\"line\">            node.waitStatus = Node.SIGNAL;</span><br><span class=\"line\">            // 若为读节点，可获取下一个读者；否则获取了null</span><br><span class=\"line\">            node = node.nextReader;</span><br><span class=\"line\">            // 下一个读者不为空，则也将其前驱节点设置为头节点</span><br><span class=\"line\">            if (node != null)</span><br><span class=\"line\">                node.prev = head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GetHolderNode\"><a href=\"#GetHolderNode\" class=\"headerlink\" title=\"GetHolderNode()\"></a>GetHolderNode()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> *   删除无效节点（可能由于主动中断或者其他因素导致的线程失效），获取第一个有效节点或空节点，</span><br><span class=\"line\"> * 或者称作获取锁持有节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node GetHolderNode()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node node = head.next;</span><br><span class=\"line\">    // 此循环的判断条件可能出现歧义，因存在读链头为取消状态时，读链中仍然有读节点读未完成，但是此函数只在释放写锁(WriteUnlock)和唤醒后续节点(AwakeNext)中使用到，当AwakeNext被触发时，读链头的状态便可以代表整个读链的状态了。</span><br><span class=\"line\">    while (node != null &amp;&amp; node.waitStatus == Node.CANCELLED)</span><br><span class=\"line\">        node = node.next;</span><br><span class=\"line\">    // 连接头节点和持有节点，无效节点全部交由垃圾收集器回收</span><br><span class=\"line\">    head.next = node;</span><br><span class=\"line\">    if (node != null)</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HasWriter\"><a href=\"#HasWriter\" class=\"headerlink\" title=\"HasWriter()\"></a>HasWriter()</h3><p>在读节点获取锁时，有一步是需要判断队列中是否存在写者，即用到此函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 返回当前队列中是否存在写者，用在读者入队列时的决策</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool HasWriter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bool exclusive = false;</span><br><span class=\"line\">    Node excluNode = head.next;</span><br><span class=\"line\">    while (excluNode != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!excluNode.isShared())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            exclusive = true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        excluNode = excluNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return exclusive;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GetCurrentNodeByReader-Node-node\"><a href=\"#GetCurrentNodeByReader-Node-node\" class=\"headerlink\" title=\"GetCurrentNodeByReader(Node node)\"></a>GetCurrentNodeByReader(Node node)</h3><p>在释放读锁时，我们无法直接获取到当前节点，只能通过线程名称来确定当前线程的持有者在<code>node</code>所在的读链中的位置，返回获取到的节点，以在释放锁时修改状态。</p>\n<p>而由于是通过线程名称来判断线程是否相等，可能会因线程重名导致异常，待改进。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node GetCurrentNodeByReader(Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node nextReader = node.readerHead;</span><br><span class=\"line\">    // 以线程名称为依据，这里可能出现多个线程同名的情况，待改进</span><br><span class=\"line\">    while (nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (nextReader.thread.Name.Equals(Thread.CurrentThread.Name))</span><br><span class=\"line\">            return nextReader;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            nextReader = nextReader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CheckReadChainCancelled-Node-node\"><a href=\"#CheckReadChainCancelled-Node-node\" class=\"headerlink\" title=\"CheckReadChainCancelled(Node node)\"></a>CheckReadChainCancelled(Node node)</h3><p>对于写节点来说，只要节点状态为<code>Node.CANCELLED</code>，说明写已经完成；而对于读节点，需要遍历读链中所有节点的状态才能确定读是否完成，此方法便是如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过一个读节点判断其所在读链是否已全部读完成</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool CheckReadChainCancelled(Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node nextReader = node.readerHead;</span><br><span class=\"line\">    while (nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (nextReader.waitStatus != Node.CANCELLED)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            nextReader = nextReader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AddReader-Node-readerHead-Node-node\"><a href=\"#AddReader-Node-readerHead-Node-node\" class=\"headerlink\" title=\"AddReader(Node readerHead, Node node)\"></a>AddReader(Node readerHead, Node node)</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 添加读者到指定读链头所在的读链中</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Node AddReader(Node readerHead, Node node)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 获取到读链尾</span><br><span class=\"line\">    Node reader = readerHead;</span><br><span class=\"line\">    while (reader.nextReader != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        reader = reader.nextReader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 读链头的前驱节点也是读链中任何节点的前驱节点</span><br><span class=\"line\">    node.prev = reader.prev;</span><br><span class=\"line\">    // 连接到读链尾</span><br><span class=\"line\">    reader.nextReader = node;</span><br><span class=\"line\">    node.readerHead = readerHead;</span><br><span class=\"line\">    node.waitStatus = readerHead.waitStatus;</span><br><span class=\"line\">    // 读链头记录的读链长度+1</span><br><span class=\"line\">    readerHead.readerCount++;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ReaderCanReentranted\"><a href=\"#ReaderCanReentranted\" class=\"headerlink\" title=\"ReaderCanReentranted()\"></a>ReaderCanReentranted()</h3><p>对于来说写者，只需判断当前线程是否为持有锁线程即可判断是否可以重入；而对于读者来说，只要当前线程与正在读的读链中的任意一个线程相等即可重入。</p>\n<p>同样线程同名的情况也不可避免。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断读者是否可以重入，判断依据为当前线程是否被正在执行读的读链中的某一个节点持有</span><br><span class=\"line\"> */</span><br><span class=\"line\">private bool ReaderCanReentranted()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node node = head.next;</span><br><span class=\"line\">    if (node == null || !node.isShared())</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Node reader = node;</span><br><span class=\"line\">        while (reader != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (reader.thread == Thread.CurrentThread)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            reader = reader.nextReader;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString()\"></a>ToString()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 覆盖ToString方法，格式化输出当前队列情况</span><br><span class=\"line\"> */</span><br><span class=\"line\">public override string ToString()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">    if (head != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (owner != null)</span><br><span class=\"line\">            sb.Append(&quot;Head(持有线程：&quot; + owner.Name + &quot;，重入量：&quot; + reentrants + &quot;)\\n&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            sb.Append(&quot;Head(持有线程：未持有线程，重入量：&quot; + reentrants + &quot;)\\n&quot;);</span><br><span class=\"line\">        Node node = head.next;</span><br><span class=\"line\">        while (node != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Node reader = node;</span><br><span class=\"line\">            if (node.isShared())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                while (reader != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：读，状态：&#123;1&#125;】&quot;, reader.thread.Name, Node.GetStatus(reader.waitStatus));</span><br><span class=\"line\">                    reader = reader.nextReader;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sb.AppendLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：写，状态：&#123;1&#125;】&quot;, node.thread.Name, Node.GetStatus(node.waitStatus));</span><br><span class=\"line\">                sb.AppendLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sb.ToString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ReadWriteLock</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class MainClass</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      \tpublic static void Add(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000000; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                readWriteLock.WriteLock();</span><br><span class=\"line\">                N++;</span><br><span class=\"line\">                readWriteLock.WriteUnlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestReentrantWriter(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            Thread.Sleep(1000);</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestWriter(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.WriteLock();</span><br><span class=\"line\">            Thread.Sleep(500);</span><br><span class=\"line\">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class=\"line\">            readWriteLock.WriteUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void TestReader(ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readWriteLock.ReadLock();</span><br><span class=\"line\">            Thread.Sleep(500);</span><br><span class=\"line\">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class=\"line\">            readWriteLock.ReadUnlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ReadWriteLock readWriteLock = new ReadWriteLock();</span><br><span class=\"line\">            for (int i = 1; i &lt;= 10; i++)</span><br><span class=\"line\">                CreateThread(false, i, readWriteLock);</span><br><span class=\"line\">            for (int i = 1; i &lt;= 20; i++)</span><br><span class=\"line\">                CreateThread(true, i, readWriteLock);</span><br><span class=\"line\">            for (int i = 0; i &lt; 100; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Thread.Sleep(500);</span><br><span class=\"line\">                readWriteLock.PrintQueue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void CreateThread(bool share, int i, ReadWriteLock readWriteLock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread;</span><br><span class=\"line\">            if (share) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                thread = new Thread(() =&gt; TestReader(readWriteLock));</span><br><span class=\"line\">                thread.Name = &quot;Reader-&quot; + i;            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                thread = i == 5 ? new Thread(() =&gt; TestReentrantWriter(readWriteLock)) : new Thread(() =&gt; TestWriter(readWriteLock));</span><br><span class=\"line\">                thread.Name = &quot;Writer-&quot; + i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先是两个线程同时增加1亿次的时间：约30s，比Monitor大概慢了5倍。</p>\n<p>其次，测试创建了10个写线程、20个读线程，假定每个线程持续时间为500毫秒，每隔500毫秒输出等待队列的情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Head(持有线程：Writer-2，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-2，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-8，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-8，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-10，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-10，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-6，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-4，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-6，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-6，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-7，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-7，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-3，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-3，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-5，重入量：4)</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-5，重入量：4)</span><br><span class=\"line\">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-3，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-3，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-5，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-7，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Reader-8，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-8，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：SIGNAL】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-9，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-9，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-9，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Reader-9，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-4，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-4，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Writer-1，重入量：1)</span><br><span class=\"line\">-&gt;【线程名称：Writer-1，类型：写，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-11，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-11，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-2，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-1，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-12，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-12，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-13，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-14，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-15，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-15，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-16，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-17，类型：读，状态：RUNNING】</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：Reader-18，重入量：3)</span><br><span class=\"line\">-&gt;【线程名称：Reader-18，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-19，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-20，类型：读，状态：RUNNING】</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：未持有线程，重入量：0)</span><br><span class=\"line\"></span><br><span class=\"line\">Head(持有线程：未持有线程，重入量：0)</span><br></pre></td></tr></table></figure>\n<p>如上述结果，每一行代表一个节点（读节点有不超过读链阈值的节点个数），Head开头说明打印了一次线程队列中的执行和等待情况。结果说明该读写锁可支持：</p>\n<ol>\n<li>多个线程的并发读访问</li>\n<li>多个线程的写访问</li>\n<li>避免了写饥饿</li>\n</ol>"},{"title":"Java - JavaFX学习小记","date":"2018-10-27T16:08:25.000Z","_content":"# JavaFX小记\n\n## 简介\n\n- JavaFX\n\n  `JavaFX`是由[甲骨文(Oracle)公司](https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8)推出的一系列的产品和技术，主要应用于创建Rich Internet application([RIAs](https://zh.wikipedia.org/wiki/RIA))，它是一个跨平台的桌面应用程序开发框架。\n\n<!-- more -->\n\n- 典型的MVC架构\n\n  - 定义`Model`，使用`javafx.beans`封装类型定义属性类型\n  - 使用`fxml`文件创建`View`，利用SceneBuilder工具进行布局\n  - 创建`Controller`实现动作操作以及`Model`和`View`的联系\n\n## View\n\n- **创建FXML文件，利用SceneBuilder工具进行布局**\n\n## Model\n\n- **定义`Model`中的`Person`类，使用`Property`和`Bind`**\n\n  `java.beans`包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，`Property`和`Bind`方便我们实现以下功能：当某个属性如`First Name`被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考[JavaFX文档](https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm)。\n\n  **Person.java**\n\n  ```java\n  package com.tanrui.model;\n\n  import java.time.LocalDate;\n\n  import javafx.beans.property.IntegerProperty;\n  import javafx.beans.property.ObjectProperty;\n  import javafx.beans.property.SimpleIntegerProperty;\n  import javafx.beans.property.SimpleObjectProperty;\n  import javafx.beans.property.SimpleStringProperty;\n  import javafx.beans.property.StringProperty;\n\n  /**\n   * Model class for a Person.\n   */\n  public class Person {\n\n      private final StringProperty firstName;\n      private final StringProperty lastName;\n      private final StringProperty street;\n      private final IntegerProperty postalCode;\n      private final StringProperty city;\n      private final ObjectProperty<LocalDate> birthday;\n\n      /**\n       * Default constructor.\n       */\n      public Person() {\n          this(null, null);\n      }\n\n      /**\n       * Constructor with some initial data.\n       *\n       * @param firstName\n       * @param lastName\n       */\n      public Person(String firstName, String lastName) {\n          this.firstName = new SimpleStringProperty(firstName);\n          this.lastName = new SimpleStringProperty(lastName);\n\n          // Some initial dummy data, just for convenient testing.\n          this.street = new SimpleStringProperty(\"some street\");\n          this.postalCode = new SimpleIntegerProperty(1234);\n          this.city = new SimpleStringProperty(\"some city\");\n          this.birthday = new SimpleObjectProperty<LocalDate>(LocalDate.of(1999, 2, 21));\n      }\n\n      public String getFirstName() {\n          return firstName.get();\n      }\n\n      public void setFirstName(String firstName) {\n          this.firstName.set(firstName);\n      }\n\n      public StringProperty firstNameProperty() {\n          return firstName;\n      }\n\n      public String getLastName() {\n          return lastName.get();\n      }\n\n      public void setLastName(String lastName) {\n          this.lastName.set(lastName);\n      }\n\n      public StringProperty lastNameProperty() {\n          return lastName;\n      }\n\n      public String getStreet() {\n          return street.get();\n      }\n\n      public void setStreet(String street) {\n          this.street.set(street);\n      }\n\n      public StringProperty streetProperty() {\n          return street;\n      }\n\n      public int getPostalCode() {\n          return postalCode.get();\n      }\n\n      public void setPostalCode(int postalCode) {\n          this.postalCode.set(postalCode);\n      }\n\n      public IntegerProperty postalCodeProperty() {\n          return postalCode;\n      }\n\n      public String getCity() {\n          return city.get();\n      }\n\n      public void setCity(String city) {\n          this.city.set(city);\n      }\n\n      public StringProperty cityProperty() {\n          return city;\n      }\n\n      public LocalDate getBirthday() {\n          return birthday.get();\n      }\n\n      public void setBirthday(LocalDate birthday) {\n          this.birthday.set(birthday);\n      }\n\n      public ObjectProperty<LocalDate> birthdayProperty() {\n          return birthday;\n      }\n  }\n  ```\n\n- **使用`ObservableList`管理`Person`**\n\n  前一点所述的<u>**后续**</u>操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是`ObservableList`，`ObservableList`继承了`List`类、实现了`Observable`接口，其实现视图和数据同步的方法是在声明`ObservableList`时为方法传递一个监听器，此监听器需要会通过监听`personData`的变化同步改变视图中对应的值，可参考[ObservableList文档](https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html)\n\n  **Main.java:**\n\n  ```java\n\n  public class Main extends Application {\n\n      /*......Other variables......*/\n\n      /**\n       *\n       * The data of a observable list of Persons\n       */\n      private ObservableList<Person> personData = FXCollections.observableArrayList();\n\n      public ObservableList<Person> getPersonData() {\n          return personData;\n      }\n\n      public Main(){\n          personData.add(new Person(\"Tan\", \"Rui\"));\n          personData.add(new Person(\"Chen\", \"Chao\"));\n          personData.add(new Person(\"Liang\", \"Chengwei\"));\n          personData.add(new Person(\"Xiao\", \"Xin\"));\n          personData.add(new Person(\"Li\", \"Yang\"));\n          personData.add(new Person(\"Chen\", \"Runqian\"));\n          personData.add(new Person(\"Liang\", \"Yongchao\"));\n          personData.add(new Person(\"Luo\", \"Jihao\"));\n          personData.add(new Person(\"Chen\", \"Zhi\"));\n          personData.add(new Person(\"Fan\", \"Fan\"));\n\n      }\n\n      /* ......Other function..... */\n  }\n  ```\n\n## Controller\n\n### PersonOverviewController.java\n\n```java\npackage com.tanrui.view;\n\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TableColumn;\nimport javafx.scene.control.TableView;\nimport com.tanrui.Main;\nimport com.tanrui.model.Person;\n\npublic class PersonOverviewController {\n    @FXML\n    private TableView<Person> personTable;\n    @FXML\n    private TableColumn<Person, String> firstNameColumn;\n    @FXML\n    private TableColumn<Person, String> lastNameColumn;\n\n    @FXML\n    private Label firstNameLabel;\n    @FXML\n    private Label lastNameLabel;\n    @FXML\n    private Label streetLabel;\n    @FXML\n    private Label postalCodeLabel;\n    @FXML\n    private Label cityLabel;\n    @FXML\n    private Label birthdayLabel;\n\n    // Reference to the main application.\n    private Main main;\n\n    /**\n     * The constructor.\n     * The constructor is called before the initialize() method.\n     */\n    public PersonOverviewController() {\n    }\n\n    /**\n     * Initializes the controller class. This method is automatically called\n     * after the fxml file has been loaded.\n     */\n    @FXML\n    private void initialize() {\n        // Initialize the person table with the two columns.\n        firstNameColumn.setCellValueFactory(cellData -> cellData.getValue().firstNameProperty());\n        lastNameColumn.setCellValueFactory(cellData -> cellData.getValue().lastNameProperty());\n    }\n\n    /**\n     * Is called by the main application to give a reference back to itself.\n     *\n     * @param main\n     */\n    public void setMain(Main main) {\n        this.main = main;\n\n        // Add observable list data to the table\n        personTable.setItems(main.getPersonData());\n    }\n}\n```\n\n- **`@FXML`注解（Annotation）**\n\n  使用`@FXML`注解可以将操作的属性、方法绑定到`FXML`文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用`@FXML`注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！\n\n- **`initialize()`方法**\n\n  `initialize()`字面意思可知其是用于初始化对应`FXML`文件中的属性，此方法会在加载`FXML`文件时被自动执行，此时，所有的`FXML`属性都应已被初始化\n\n- **`setCellValueFactory(...)`方法**\n\n  我们对表格列上使用`setCellValueFactory(...)`方法来确定为特定列使用前面`Person`的某个属性。`->`表示使用的是[Lambdas](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html)特性；另外一种方法是使用[PropertyValueFactory](https://docs.oracle.com/javase/8/javafx/api/)(待研究…)。\n\n  这里我们之所以可以使用`cellData -> cellData.getValue().firstNameProperty()`，便是因为之前我们将Person的属性都定义为`javafx.beans`中的封装属性，`firstNameProperty()`等方法都会在声明成`Beans`封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便\n\n### 连接Main和PersonOverviewController\n\n- **`showPersonOverview()` 方法**\n\n  **Main.java**\n\n  ```java\n\n      /**\n       * Shows the person overview inside the root layout.\n       */\n      public void showPersonOverview() {\n          try {\n              // Load person overview.\n              FXMLLoader loader = new FXMLLoader();\n              loader.setLocation(Main.class.getResource(\"view/PersonOverview.fxml\"));\n              AnchorPane personOverview = (AnchorPane) loader.load();\n\n              // Set person overview into the center of root layout.\n              rootLayout.setCenter(personOverview);\n\n              // Give the controller access to the main app.\n              PersonOverviewController controller = loader.getController();\n              controller.setMain(this);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  ```\n\n### 将View与Controller绑定\n\n我们还需要为`FXML文件`指定其对应的`Controller`，以及`FXML元素`与`控制器的属性`的对应关系，这是因为FXML文件中的元素只能被对应`Controller`修改更新，若在其他方法中修改会产生运行时错误。例如：在`PersonOverviewController.java`中将某个`Label`返回到`Main.java`中而后在其中修改该`Label`的值，意即在`非FX线程`中执行`FX线程`相关的任务，则会造成当前的线程阻塞，解决方法之一是使用`Platform.runLater()`方法，如下所示，括号中的`FX线程`相关任务便不会阻塞当前进程。\n\n```\nPlatform.runLater(() -> {\n        ………相关FX线程代码………\n});\n```\n\n当然，最好的选择还是讲`FX线程`任务和其他任务区分开来，将特定的`FXML文件`与对应的`Controller`联系起来，当需要建立联系时可通过之前所说的使用`java.beans`、`ObservableList`等方法实现动态更新视图。\n\n- **为`FXML文件`指定`Controller`**\n\n  在Eclipse中好像有图形化界面直接为`FXML文件`选择`Controller`的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。\n\n  **PersonOverview.fxml**\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n  <AnchorPane maxHeight=\"-Infinity\" maxWidth=\"-Infinity\" minHeight=\"-Infinity\" minWidth=\"-Infinity\" prefHeight=\"300.0\" prefWidth=\"600.0\" xmlns=\"http://javafx.com/javafx/8.0.121\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"com.tanrui.view.PersonOverviewController\">\n      <children>\n          <? ... 内容省略 ... ?>\n      </children>\n  </AnchorPane>\n  ```\n\n  如上述代码所述，在顶层节点（此处是`AnchorPane`）标签中添加属性如下：`fx:controller=\"com.tanrui.view.PersonOverviewController”`，以此为`FXML文件`指定`Controller`\n\n- 为`FXML元素`指定`fx:id`，使其绑定对应的`控制器属性`\n\n  ![image-20181023205748006](/img/image-20181023205748006.png)\n\n  如图，选定特定元素，在右侧界面找到`Code`->`fx:id`，将其对应的控制器属性填入即可\n\n### Details界面更新\n\n- **`showPersonDetails(Person person)`方法**\n\n  `showPersonDetails(Person person)`方法用于使用Person实例的数据填写标签。\n\n  **PersonOverviewController.java**\n\n  ```java\n  /**\n   * Fills all text fields to show details about the person.\n   * If the specified person is null, all text fields are cleared.\n   *\n   * @param person the person or null\n   */\n  private void showPersonDetails(Person person) {\n      if (person != null) {\n          // Fill the labels with info from the person object.\n          firstNameLabel.setText(person.getFirstName());\n          lastNameLabel.setText(person.getLastName());\n          streetLabel.setText(person.getStreet());\n          postalCodeLabel.setText(Integer.toString(person.getPostalCode()));\n          cityLabel.setText(person.getCity());\n\n          // TODO: We need a way to convert the birthday into a String!\n          // birthdayLabel.setText(...);\n      } else {\n          // Person is null, remove all the text.\n          firstNameLabel.setText(\"\");\n          lastNameLabel.setText(\"\");\n          streetLabel.setText(\"\");\n          postalCodeLabel.setText(\"\");\n          cityLabel.setText(\"\");\n          birthdayLabel.setText(\"\");\n      }\n  }\n  ```\n\n- **监听用户在人员表中的选择**\n\n  **PersonOverviewController.java**\n\n  ```java\n  @FXML\n  private void initialize() {\n      // Initialize the person table with the two columns.\n      firstNameColumn.setCellValueFactory(\n              cellData -> cellData.getValue().firstNameProperty());\n      lastNameColumn.setCellValueFactory(\n              cellData -> cellData.getValue().lastNameProperty());\n\n      // Clear person details.\n      showPersonDetails(null);\n\n      // Listen for selection changes and show the person details when changed.\n      personTable.getSelectionModel().selectedItemProperty().addListener(\n              (observable, oldValue, newValue) -> showPersonDetails(newValue));\n  }\n  ```\n\n### 删除按钮事件\n\n我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下：\n\n**PersonOverviewController.java**:\n\n```java\n/**\n     * Called when the user clicks on the delete button.\n     */\n    @FXML\n    private void handleDeletePerson() {\n        int selectedIndex = personTable.getSelectionModel().getSelectedIndex();\n        if (selectedIndex >= 0){\n            personTable.getItems().remove(selectedIndex);\n        }\n        else{\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n#### 错误处理\n\n从上述代码可以看到我们使用了条件判断语句来判断`selectedIndex`的值，当其小于0时，正常情况我们应该会让其抛出`ArrayIndexOutOfBoundsException`异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了`controlsfx`包，用于弹出各类提示框（可在[ControlsFX](http://fxexperience.com/controlsfx/)官网获取）。\n\n`controlsfx`有两个主要的版本，同时对于不同的版本，二者的用法也不同：\n\n- 对于Java 8，需要下载[ControlsFX 8.40.14](http://fxexperience.com/downloads/controlsfx-8-40-14/)包\n- 对于Java 9及以上，需要下载[ControlsFX 9.0.0](http://fxexperience.com/downloads/controlsfx-9-0-0/)包\n\n我们这里用到的是Java 10，因此使用`ControlsFX 9.0.0`，使用方法如下：\n\n**ShowDialog.java**:\n\n```java\npackage com.tanrui.util;\n\nimport javafx.scene.control.Alert;\nimport javafx.stage.Stage;\n\n/**\n * Util to create and show Dialog.\n *\n * @author Tan Rui\n */\npublic class ShowDialog {\n\n    private Stage stage;\n    private Alert.AlertType type;\n    private String title;\n    private String message;\n\n    public ShowDialog(Stage stage, Alert.AlertType type, String title, String message){\n        this.stage = stage;\n        this.type = type;\n        this.title = title;\n        this.message = message;\n    }\n\n    public void ShowSpecificDialog(){\n        Alert dlg = new Alert(type);\n        dlg.initOwner(stage);\n        dlg.setTitle(title);\n        dlg.getDialogPane().setContentText(message);\n        dlg.show();\n    }\n}\n```\n\n**PersonOverviewController.java**\n\n```java\n/**\n     * Called when the user clicks on the delete button.\n     */\n    @FXML\n    private void handleDeletePerson() {\n        int selectedIndex = personTable.getSelectionModel().getSelectedIndex();\n        if (selectedIndex >= 0){\n            personTable.getItems().remove(selectedIndex);\n        }\n        else{\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n### 新建和编辑对话框\n\n> Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是：\n>\n> 1. 创建FXML文件，使用SceneBuilder编辑界面；\n> 2. 创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等；\n> 3. 连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性；\n> 4. 在Main函数中加载该控制器\n\n为之前的`New`和`Edit`按钮添加动作，弹出对话框（新的Stage）。\n\n#### 设计对话框\n\n创建`PersonEditDialog.fxml`，完成弹出对话框的设计：\n\n![image-20181027150559447](/img/image-20181027150559447.png)\n\n#### 创建控制器\n\n为对话框创建控制器`PersonEditDialogController.java`。\n\n**PersonEditDialogController.java：**\n\n```java\npackage com.tanrui.view;\n\nimport com.tanrui.util.ShowDialog;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Alert;\nimport javafx.scene.control.TextField;\nimport javafx.stage.Stage;\n\nimport com.tanrui.model.Person;\nimport com.tanrui.util.DateUtil;\n\n\n/**\n * Dialog to edit details of a person.\n *\n * @author Marco Jakob\n */\npublic class PersonEditDialogController {\n\n    @FXML\n    private TextField firstNameField;\n    @FXML\n    private TextField lastNameField;\n    @FXML\n    private TextField streetField;\n    @FXML\n    private TextField postalCodeField;\n    @FXML\n    private TextField cityField;\n    @FXML\n    private TextField birthdayField;\n\n\n    private Stage dialogStage;\n    private Person person;\n    private boolean okClicked = false;\n\n    /**\n     * Initializes the controller class. This method is automatically called\n     * after the fxml file has been loaded.\n     */\n    @FXML\n    private void initialize() {\n    }\n\n    /**\n     * Sets the stage of this dialog.\n     *\n     * @param dialogStage\n     */\n    public void setDialogStage(Stage dialogStage) {\n        this.dialogStage = dialogStage;\n    }\n\n    /**\n     * Sets the person to be edited in the dialog.\n     *\n     * @param person\n     */\n    public void setPerson(Person person) {\n        this.person = person;\n\n        firstNameField.setText(person.getFirstName());\n        lastNameField.setText(person.getLastName());\n        streetField.setText(person.getStreet());\n        postalCodeField.setText(Integer.toString(person.getPostalCode()));\n        cityField.setText(person.getCity());\n        birthdayField.setText(DateUtil.format(person.getBirthday()));\n        birthdayField.setPromptText(\"dd.mm.yyyy\");\n    }\n\n    /**\n     * Returns true if the user clicked OK, false otherwise.\n     *\n     * @return\n     */\n    public boolean isOkClicked() {\n        return okClicked;\n    }\n\n    /**\n     * Called when the user clicks ok.\n     */\n    @FXML\n    private void handleOk() {\n        if (isInputValid()) {\n            person.setFirstName(firstNameField.getText());\n            person.setLastName(lastNameField.getText());\n            person.setStreet(streetField.getText());\n            person.setPostalCode(Integer.parseInt(postalCodeField.getText()));\n            person.setCity(cityField.getText());\n            person.setBirthday(DateUtil.parse(birthdayField.getText()));\n\n            okClicked = true;\n            dialogStage.close();\n        }\n    }\n\n    /**\n     * Called when the user clicks cancel.\n     */\n    @FXML\n    private void handleCancel() {\n        dialogStage.close();\n    }\n\n    /**\n     * Validates the user input in the text fields.\n     *\n     * @return true if the input is valid\n     */\n    private boolean isInputValid() {\n        String errorMessage = \"\";\n\n        if (firstNameField.getText() == null || firstNameField.getText().length() == 0) {\n            errorMessage += \"No valid first name!\\n\";\n        }\n        if (lastNameField.getText() == null || lastNameField.getText().length() == 0) {\n            errorMessage += \"No valid last name!\\n\";\n        }\n        if (streetField.getText() == null || streetField.getText().length() == 0) {\n            errorMessage += \"No valid street!\\n\";\n        }\n\n        if (postalCodeField.getText() == null || postalCodeField.getText().length() == 0) {\n            errorMessage += \"No valid postal code!\\n\";\n        } else {\n            try {\n                Integer.parseInt(postalCodeField.getText());\n            } catch (NumberFormatException e) {\n                errorMessage += \"No valid postal code (must be an integer)!\\n\";\n            }\n        }\n\n        if (cityField.getText() == null || cityField.getText().length() == 0) {\n            errorMessage += \"No valid city!\\n\";\n        }\n\n        if (birthdayField.getText() == null || birthdayField.getText().length() == 0) {\n            errorMessage += \"No valid birthday!\\n\";\n        } else {\n            if (!DateUtil.validDate(birthdayField.getText())) {\n                errorMessage += \"No valid birthday. Use the format dd.mm.yyyy!\\n\";\n            }\n        }\n\n        if (errorMessage.length() == 0) {\n            return true;\n        } else {\n            new ShowDialog(dialogStage, Alert.AlertType.ERROR, \"Invalid Fields\", \"Please correct invalid fields\").ShowSpecificDialog();\n            return false;\n        }\n    }\n}\n```\n\n关于该控制器的一些事情应该注意：\n\n1. `setPerson(…)`方法可以从其它类中调用，用来设置编辑的人员。\n2. 当用户点击OK按钮时，调用`handleOK()`方法。首先，通过调用`isInputValid()`方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给`setPerson(…)`。\n3. 布尔值`okClicked`被使用，以便调用者决定用户是否点击OK或者Cancel按钮。\n\n#### 连接视图和控制器\n\n使用已经创建的视图（FXML）和控制器，需要连接到一起。\n\n1. 使用SceneBuilder打开`PersonEditDialog.fxml`文件\n2. 在左边的*Controller*组中选择`PersonEditDialogController`作为控制器类\n3. 设置所有**TextField**的`fx:id`到相应的控制器字段上。\n4. 设置两个按钮的**onAction**到相应的处理方法上。\n\n#### 在Main中部署该控制器\n\n**Main.java:**\n\n```java\n/**\n * Opens a dialog to edit details for the specified person. If the user\n * clicks OK, the changes are saved into the provided person object and true\n * is returned.\n *\n * @param person the person object to be edited\n * @return true if the user clicked OK, false otherwise.\n */\npublic boolean showPersonEditDialog(Person person) {\n    try {\n        // Load the fxml file and create a new stage for the popup dialog.\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(Main.class.getResource(\"view/PersonEditDialog.fxml\"));\n        AnchorPane page = (AnchorPane) loader.load();\n\n        // Create the dialog Stage.\n        Stage dialogStage = new Stage();\n        dialogStage.setTitle(\"Edit Person\");\n        dialogStage.initModality(Modality.WINDOW_MODAL);\n        dialogStage.initOwner(primaryStage);\n        Scene scene = new Scene(page);\n        dialogStage.setScene(scene);\n\n        // Set the person into the controller.\n        PersonEditDialogController controller = loader.getController();\n        controller.setDialogStage(dialogStage);\n        controller.setPerson(person);\n\n        // Show the dialog and wait until the user closes it\n        dialogStage.showAndWait();\n\n        return controller.isOkClicked();\n    } catch (IOException e) {\n        e.printStackTrace();\n        return false;\n    }\n}\n```\n\n为主界面中`New`和`Edit`按钮创建OnAction方法，这些方法将从`Main`中调用`showPersonEditDialog(…)`方法。\n\n**PersonOverviewController.java:**\n\n```java\n    /**\n     * Called when the user clicks the new button. Opens a dialog to edit\n     * details for a new person.\n     */\n    @FXML\n    private void handleNewPerson() {\n        Person tempPerson = new Person();\n        boolean okClicked = main.showPersonEditDialog(tempPerson);\n        if (okClicked) {\n            main.getPersonData().add(tempPerson);\n        }\n    }\n\n    /**\n     * Called when the user clicks the edit button. Opens a dialog to edit\n     * details for the selected person.\n     */\n    @FXML\n    private void handleEditPerson() {\n        Person selectedPerson = personTable.getSelectionModel().getSelectedItem();\n        if (selectedPerson != null) {\n            boolean okClicked = main.showPersonEditDialog(selectedPerson);\n            if (okClicked) {\n                showPersonDetails(selectedPerson);\n            }\n\n        } else {\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n而后在`PersonOverview.fxml`中为New和Edit两个按钮绑定对应的OnAction方法：\n\n![image-20181027164439676](/img/image-20181027164439676.png)\n\n### 数据持久化\n\n我们有很多种方法来实现应用数据的持久化，例如：\n\n- 使用数据库存储\n- 使用Json文件存储\n- 使用XML文件存储\n- ……\n\n这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是：\n\n1. 每次打开应用可加载上一次的用户数据\n2. 用户可选择保存当前数据到指定XML文件\n3. 用户可选择从指定XML文件加载数据\n\n#### 使用Preferences保存应用状态\n\n`Java`提供了`Preferences`类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），`Preferences`类底层对各类操作系统进行了封装（实际上是`Windows系统`、`OS X系统`和`类Unix文件系统`三种），用户配置在`Windows系统`上可能保存在注册表中、在`类Unix文件系统`上可能保存在`/tmp`下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道`Preferences`类是用来保存用户配置即可。用法如下：\n\n**Main.java:**\n\n```java\n/**\n     * Returns the person file preference, i.e. the file that was last opened.\n     * The preference is read from the OS specific registry. If no such\n     * preference can be found, null is returned.\n     *\n     * @return\n     */\n    public File getPersonFilePath() {\n        Preferences prefs = Preferences.userNodeForPackage(Main.class);\n        String filePath = prefs.get(\"filePath\", null);\n        if (filePath != null) {\n            return new File(filePath);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Sets the file path of the currently loaded file. The path is persisted in\n     * the OS specific registry.\n     *\n     * @param file the file or null to remove the path\n     */\n    public void setPersonFilePath(File file) {\n        Preferences prefs = Preferences.userNodeForPackage(Main.class);\n        if (file != null) {\n            prefs.put(\"filePath\", file.getPath());\n            // Update the stage title.\n            primaryStage.setTitle(\"AddressApp - \" + file.getName());\n        } else {\n            prefs.remove(\"filePath\");\n            // Update the stage title.\n            primaryStage.setTitle(\"AddressApp\");\n        }\n    }\n```\n\n#### 使用JAXB\n\n`JAXB包`是Java中提供的对数据进行`编列(marshall)`成XML文件以及对XML文件`反编列(unmarshall)`为数据结构的包，`Java SE`中有如下支持类型：`JAXB 2.0`是`JDK 1.6`的组成部分。`JAXB 2.2.3`是`JDK 1.7以上`的组成部分，而实际上在`Java 9`之后就已将`JAXB`包移除，因此使用时需添加额外的lib包，详情可见博客[真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException](https://blog.csdn.net/hadues/article/details/79188793)。\n\n##### JAXB模型类\n\n我们希望持久化的数据应该是`Main`中的`personData`，而`JAXB`有以下要求：\n\n- 使用`@XmlRootElement`定义`XML根元素`的名称\n- 使用`@XmlElement`指定一个`XML元素`，可选\n\n而`Main`中的`personData`是`ObservableList`类型，由于`ObservableList`类型不支持添加注解，因此我们需要创建另外一个能保存`Person`列表同时又能存储为`XML文件`的类，如下。\n\n**PersonListWrapper.java:**\n\n```java\npackage com.tanrui.model;\n\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n/**\n * Helper class to wrap a list of persons. This is used for saving the\n * list of persons to XML.\n */\n@XmlRootElement(name = \"persons\")\npublic class PersonListWrapper {\n\n    private List<Person> persons;\n\n    @XmlElement(name = \"person\")\n    public List<Person> getPersons() {\n        return persons;\n    }\n\n    public void setPersons(List<Person> persons) {\n        this.persons = persons;\n    }\n}\n```\n\n##### 使用JAXB读写数据到XML文件\n\n我们将读写XML文件的逻辑放到`Main类`中，`Controller`在用到相应的逻辑时，直接调用`Main`中的方法即可。\n\n**Main.java:**\n\n```java\n\n    /**\n     * Loads person data from the specified file. The current person data will\n     * be replaced.\n     *\n     * @param file\n     */\n    public void loadPersonDataFromFile(File file) {\n        try {\n            JAXBContext context = JAXBContext\n                    .newInstance(PersonListWrapper.class);\n            Unmarshaller um = context.createUnmarshaller();\n\n            // Reading XML from the file and unmarshalling.\n            PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file);\n\n            personData.clear();\n            personData.addAll(wrapper.getPersons());\n\n            // Save the file path to the registry.\n            setPersonFilePath(file);\n\n        } catch (Exception e) { // catches ANY exception\n            new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog();\n        }\n    }\n\n    /**\n     * Saves the current person data to the specified file.\n     *\n     * @param file\n     */\n    public void savePersonDataToFile(File file) {\n        try {\n            JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class);\n            Marshaller m = context.createMarshaller();\n            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n            // Wrapping our person data.\n            PersonListWrapper wrapper = new PersonListWrapper();\n            wrapper.setPersons(personData);\n\n            // Marshalling and saving XML to the file.\n            m.marshal(wrapper, file);\n\n            // Save the file path to the registry.\n            setPersonFilePath(file);\n        } catch (Exception e) { // catches ANY exception\n            new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog();\n        }\n    }\n```\n\n`编组(marshall):savePersonDataToFile(…)`和`解组(unmarshall):loadPersonDataFromFile(…)`已准备好，下面在界面中使用它。\n\n#### 创建打开和保存菜单\n\n##### 为File菜单添加子项\n\n![image-20181027232418408](/img/image-20181027232418408.png)\n\n##### 处理菜单相应动作\n\n`Controller`中使用`FileChooser`的方法，`FileChooser`同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。\n\n本类中使用了`FileChooser.ExtensionFilter`，对文件系统中文件进行过滤，保留`.xml`结尾的文件。\n\n当用户选择特定文件而后点击`打开`按钮时，会返回该文件，否则返回`Null`。\n\n```java\npackage com.tanrui.view;\n\nimport com.tanrui.Main;\nimport com.tanrui.util.ShowDialog;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Alert;\nimport javafx.stage.FileChooser;\n\nimport java.io.File;\n\n/**\n * The controller for the root layout. The root layout provides the basic\n * application layout containing a menu bar and space where other JavaFX\n * elements can be placed.\n */\npublic class RootLayoutController {\n\n    // Reference to the main application\n    private Main main;\n\n    /**\n     * Is called by the main application to give a reference back to itself.\n     *\n     * @param main\n     */\n    public void setMain(Main main) {\n        this.main = main;\n    }\n\n    /**\n     * Creates an empty address book.\n     */\n    @FXML\n    private void handleNew() {\n        main.getPersonData().clear();\n        main.setPersonFilePath(null);\n    }\n\n    /**\n     * Opens a FileChooser to let the user select an address book to load.\n     */\n    @FXML\n    private void handleOpen() {\n        FileChooser fileChooser = new FileChooser();\n\n        // Set extension filter\n        FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(\n                \"XML files (*.xml)\", \"*.xml\");\n        fileChooser.getExtensionFilters().add(extFilter);\n\n        // Show save file dialog\n        File file = fileChooser.showOpenDialog(main.getPrimaryStage());\n\n        if (file != null) {\n            main.loadPersonDataFromFile(file);\n        }\n    }\n\n    /**\n     * Saves the file to the person file that is currently open. If there is no\n     * open file, the \"save as\" dialog is shown.\n     */\n    @FXML\n    private void handleSave() {\n        File personFile = main.getPersonFilePath();\n        if (personFile != null) {\n            main.savePersonDataToFile(personFile);\n        } else {\n            handleSaveAs();\n        }\n    }\n\n    /**\n     * Opens a FileChooser to let the user select a file to save to.\n     */\n    @FXML\n    private void handleSaveAs() {\n        FileChooser fileChooser = new FileChooser();\n\n        // Set extension filter\n        FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(\n                \"XML files (*.xml)\", \"*.xml\");\n        fileChooser.getExtensionFilters().add(extFilter);\n\n        // Show save file dialog\n        File file = fileChooser.showSaveDialog(main.getPrimaryStage());\n\n        if (file != null) {\n            // Make sure it has the correct extension\n            if (!file.getPath().endsWith(\".xml\")) {\n                file = new File(file.getPath() + \".xml\");\n            }\n            main.savePersonDataToFile(file);\n        }\n    }\n\n    /**\n     * Opens an about dialog.\n     */\n    @FXML\n    private void handleAbout() {\n        new ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, \"About\", \"Author: Tan\\\\nWebsite: https://guitoubing.top\").ShowSpecificDialog();\n    }\n\n    /**\n     * Closes the application.\n     */\n    @FXML\n    private void handleExit() {\n        System.exit(0);\n    }\n\n    /**\n     * Opens the birthday statistics.\n     */\n    @FXML\n    private void handleShowBirthdayStatistics() {\n        main.showBirthdayStatistics();\n    }\n}\n```\n\n##### 连接FXML文件和Controller、绑定菜单和对应动作\n\n![image-20181027233726178](/img/image-20181027233726178.png)\n\n![image-20181027233529314](/img/image-20181027233529314.png)\n\n##### 在Main中部署该控制器\n\n**Main.java:**\n\n```java\n /**\n     * Initializes the root layout.\n     */\n    public void initRootLayout() {\n        try {\n            // Load root layout from fxml file.\n            FXMLLoader loader = new FXMLLoader();\n            loader.setLocation(Main.class.getResource(\"view/RootLayout.fxml\"));\n            rootLayout = (BorderPane) loader.load();\n\n            // Show the scene containing the root layout.\n            Scene scene = new Scene(rootLayout);\n            primaryStage.setScene(scene);\n\n            RootLayoutController controller = loader.getController();\n            controller.setMain(this);\n\n            primaryStage.show();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        File file = getPersonFilePath();\n        if (file != null){\n            loadPersonDataFromFile(file);\n        }\n    }\n```\n\n## 参考资料\n\n1. [code.makery —— JavaFX中文教程](https://code.makery.ch/)\n2. [JavaFX Tutorial](https://www.tutorialspoint.com/javafx/)\n3. [真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException](https://blog.csdn.net/hadues/article/details/79188793)\n4. [fxexperience —— ControlFX](http://fxexperience.com/controlsfx/)\n5. [Java SE8 —— Lambda](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html)\n6. …………\n\n## 写在后面\n\n本博主要是在学习[code.makery —— JavaFX中文教程](https://code.makery.ch/)博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是`JDK 8u40`，我这里使用的是`Java 10 2018-03-20`）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击[JavaFX-Test](http://getme.guitoubing.top/JavaFX_PRE.zip)中获取源码。\n\n希望藉此次`JavaFX`学习开启我的Java源码学习之旅，道阻且长！\n","source":"_posts/JavaFX-学习小记.md","raw":"---\ntitle: Java - JavaFX学习小记\ndate: 2018-10-28 00:08:25\ntags:\n    - JavaFX\ncategories:\n    - Java\n---\n# JavaFX小记\n\n## 简介\n\n- JavaFX\n\n  `JavaFX`是由[甲骨文(Oracle)公司](https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8)推出的一系列的产品和技术，主要应用于创建Rich Internet application([RIAs](https://zh.wikipedia.org/wiki/RIA))，它是一个跨平台的桌面应用程序开发框架。\n\n<!-- more -->\n\n- 典型的MVC架构\n\n  - 定义`Model`，使用`javafx.beans`封装类型定义属性类型\n  - 使用`fxml`文件创建`View`，利用SceneBuilder工具进行布局\n  - 创建`Controller`实现动作操作以及`Model`和`View`的联系\n\n## View\n\n- **创建FXML文件，利用SceneBuilder工具进行布局**\n\n## Model\n\n- **定义`Model`中的`Person`类，使用`Property`和`Bind`**\n\n  `java.beans`包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，`Property`和`Bind`方便我们实现以下功能：当某个属性如`First Name`被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考[JavaFX文档](https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm)。\n\n  **Person.java**\n\n  ```java\n  package com.tanrui.model;\n\n  import java.time.LocalDate;\n\n  import javafx.beans.property.IntegerProperty;\n  import javafx.beans.property.ObjectProperty;\n  import javafx.beans.property.SimpleIntegerProperty;\n  import javafx.beans.property.SimpleObjectProperty;\n  import javafx.beans.property.SimpleStringProperty;\n  import javafx.beans.property.StringProperty;\n\n  /**\n   * Model class for a Person.\n   */\n  public class Person {\n\n      private final StringProperty firstName;\n      private final StringProperty lastName;\n      private final StringProperty street;\n      private final IntegerProperty postalCode;\n      private final StringProperty city;\n      private final ObjectProperty<LocalDate> birthday;\n\n      /**\n       * Default constructor.\n       */\n      public Person() {\n          this(null, null);\n      }\n\n      /**\n       * Constructor with some initial data.\n       *\n       * @param firstName\n       * @param lastName\n       */\n      public Person(String firstName, String lastName) {\n          this.firstName = new SimpleStringProperty(firstName);\n          this.lastName = new SimpleStringProperty(lastName);\n\n          // Some initial dummy data, just for convenient testing.\n          this.street = new SimpleStringProperty(\"some street\");\n          this.postalCode = new SimpleIntegerProperty(1234);\n          this.city = new SimpleStringProperty(\"some city\");\n          this.birthday = new SimpleObjectProperty<LocalDate>(LocalDate.of(1999, 2, 21));\n      }\n\n      public String getFirstName() {\n          return firstName.get();\n      }\n\n      public void setFirstName(String firstName) {\n          this.firstName.set(firstName);\n      }\n\n      public StringProperty firstNameProperty() {\n          return firstName;\n      }\n\n      public String getLastName() {\n          return lastName.get();\n      }\n\n      public void setLastName(String lastName) {\n          this.lastName.set(lastName);\n      }\n\n      public StringProperty lastNameProperty() {\n          return lastName;\n      }\n\n      public String getStreet() {\n          return street.get();\n      }\n\n      public void setStreet(String street) {\n          this.street.set(street);\n      }\n\n      public StringProperty streetProperty() {\n          return street;\n      }\n\n      public int getPostalCode() {\n          return postalCode.get();\n      }\n\n      public void setPostalCode(int postalCode) {\n          this.postalCode.set(postalCode);\n      }\n\n      public IntegerProperty postalCodeProperty() {\n          return postalCode;\n      }\n\n      public String getCity() {\n          return city.get();\n      }\n\n      public void setCity(String city) {\n          this.city.set(city);\n      }\n\n      public StringProperty cityProperty() {\n          return city;\n      }\n\n      public LocalDate getBirthday() {\n          return birthday.get();\n      }\n\n      public void setBirthday(LocalDate birthday) {\n          this.birthday.set(birthday);\n      }\n\n      public ObjectProperty<LocalDate> birthdayProperty() {\n          return birthday;\n      }\n  }\n  ```\n\n- **使用`ObservableList`管理`Person`**\n\n  前一点所述的<u>**后续**</u>操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是`ObservableList`，`ObservableList`继承了`List`类、实现了`Observable`接口，其实现视图和数据同步的方法是在声明`ObservableList`时为方法传递一个监听器，此监听器需要会通过监听`personData`的变化同步改变视图中对应的值，可参考[ObservableList文档](https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html)\n\n  **Main.java:**\n\n  ```java\n\n  public class Main extends Application {\n\n      /*......Other variables......*/\n\n      /**\n       *\n       * The data of a observable list of Persons\n       */\n      private ObservableList<Person> personData = FXCollections.observableArrayList();\n\n      public ObservableList<Person> getPersonData() {\n          return personData;\n      }\n\n      public Main(){\n          personData.add(new Person(\"Tan\", \"Rui\"));\n          personData.add(new Person(\"Chen\", \"Chao\"));\n          personData.add(new Person(\"Liang\", \"Chengwei\"));\n          personData.add(new Person(\"Xiao\", \"Xin\"));\n          personData.add(new Person(\"Li\", \"Yang\"));\n          personData.add(new Person(\"Chen\", \"Runqian\"));\n          personData.add(new Person(\"Liang\", \"Yongchao\"));\n          personData.add(new Person(\"Luo\", \"Jihao\"));\n          personData.add(new Person(\"Chen\", \"Zhi\"));\n          personData.add(new Person(\"Fan\", \"Fan\"));\n\n      }\n\n      /* ......Other function..... */\n  }\n  ```\n\n## Controller\n\n### PersonOverviewController.java\n\n```java\npackage com.tanrui.view;\n\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TableColumn;\nimport javafx.scene.control.TableView;\nimport com.tanrui.Main;\nimport com.tanrui.model.Person;\n\npublic class PersonOverviewController {\n    @FXML\n    private TableView<Person> personTable;\n    @FXML\n    private TableColumn<Person, String> firstNameColumn;\n    @FXML\n    private TableColumn<Person, String> lastNameColumn;\n\n    @FXML\n    private Label firstNameLabel;\n    @FXML\n    private Label lastNameLabel;\n    @FXML\n    private Label streetLabel;\n    @FXML\n    private Label postalCodeLabel;\n    @FXML\n    private Label cityLabel;\n    @FXML\n    private Label birthdayLabel;\n\n    // Reference to the main application.\n    private Main main;\n\n    /**\n     * The constructor.\n     * The constructor is called before the initialize() method.\n     */\n    public PersonOverviewController() {\n    }\n\n    /**\n     * Initializes the controller class. This method is automatically called\n     * after the fxml file has been loaded.\n     */\n    @FXML\n    private void initialize() {\n        // Initialize the person table with the two columns.\n        firstNameColumn.setCellValueFactory(cellData -> cellData.getValue().firstNameProperty());\n        lastNameColumn.setCellValueFactory(cellData -> cellData.getValue().lastNameProperty());\n    }\n\n    /**\n     * Is called by the main application to give a reference back to itself.\n     *\n     * @param main\n     */\n    public void setMain(Main main) {\n        this.main = main;\n\n        // Add observable list data to the table\n        personTable.setItems(main.getPersonData());\n    }\n}\n```\n\n- **`@FXML`注解（Annotation）**\n\n  使用`@FXML`注解可以将操作的属性、方法绑定到`FXML`文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用`@FXML`注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！\n\n- **`initialize()`方法**\n\n  `initialize()`字面意思可知其是用于初始化对应`FXML`文件中的属性，此方法会在加载`FXML`文件时被自动执行，此时，所有的`FXML`属性都应已被初始化\n\n- **`setCellValueFactory(...)`方法**\n\n  我们对表格列上使用`setCellValueFactory(...)`方法来确定为特定列使用前面`Person`的某个属性。`->`表示使用的是[Lambdas](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html)特性；另外一种方法是使用[PropertyValueFactory](https://docs.oracle.com/javase/8/javafx/api/)(待研究…)。\n\n  这里我们之所以可以使用`cellData -> cellData.getValue().firstNameProperty()`，便是因为之前我们将Person的属性都定义为`javafx.beans`中的封装属性，`firstNameProperty()`等方法都会在声明成`Beans`封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便\n\n### 连接Main和PersonOverviewController\n\n- **`showPersonOverview()` 方法**\n\n  **Main.java**\n\n  ```java\n\n      /**\n       * Shows the person overview inside the root layout.\n       */\n      public void showPersonOverview() {\n          try {\n              // Load person overview.\n              FXMLLoader loader = new FXMLLoader();\n              loader.setLocation(Main.class.getResource(\"view/PersonOverview.fxml\"));\n              AnchorPane personOverview = (AnchorPane) loader.load();\n\n              // Set person overview into the center of root layout.\n              rootLayout.setCenter(personOverview);\n\n              // Give the controller access to the main app.\n              PersonOverviewController controller = loader.getController();\n              controller.setMain(this);\n\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  ```\n\n### 将View与Controller绑定\n\n我们还需要为`FXML文件`指定其对应的`Controller`，以及`FXML元素`与`控制器的属性`的对应关系，这是因为FXML文件中的元素只能被对应`Controller`修改更新，若在其他方法中修改会产生运行时错误。例如：在`PersonOverviewController.java`中将某个`Label`返回到`Main.java`中而后在其中修改该`Label`的值，意即在`非FX线程`中执行`FX线程`相关的任务，则会造成当前的线程阻塞，解决方法之一是使用`Platform.runLater()`方法，如下所示，括号中的`FX线程`相关任务便不会阻塞当前进程。\n\n```\nPlatform.runLater(() -> {\n        ………相关FX线程代码………\n});\n```\n\n当然，最好的选择还是讲`FX线程`任务和其他任务区分开来，将特定的`FXML文件`与对应的`Controller`联系起来，当需要建立联系时可通过之前所说的使用`java.beans`、`ObservableList`等方法实现动态更新视图。\n\n- **为`FXML文件`指定`Controller`**\n\n  在Eclipse中好像有图形化界面直接为`FXML文件`选择`Controller`的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。\n\n  **PersonOverview.fxml**\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n  <AnchorPane maxHeight=\"-Infinity\" maxWidth=\"-Infinity\" minHeight=\"-Infinity\" minWidth=\"-Infinity\" prefHeight=\"300.0\" prefWidth=\"600.0\" xmlns=\"http://javafx.com/javafx/8.0.121\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"com.tanrui.view.PersonOverviewController\">\n      <children>\n          <? ... 内容省略 ... ?>\n      </children>\n  </AnchorPane>\n  ```\n\n  如上述代码所述，在顶层节点（此处是`AnchorPane`）标签中添加属性如下：`fx:controller=\"com.tanrui.view.PersonOverviewController”`，以此为`FXML文件`指定`Controller`\n\n- 为`FXML元素`指定`fx:id`，使其绑定对应的`控制器属性`\n\n  ![image-20181023205748006](/img/image-20181023205748006.png)\n\n  如图，选定特定元素，在右侧界面找到`Code`->`fx:id`，将其对应的控制器属性填入即可\n\n### Details界面更新\n\n- **`showPersonDetails(Person person)`方法**\n\n  `showPersonDetails(Person person)`方法用于使用Person实例的数据填写标签。\n\n  **PersonOverviewController.java**\n\n  ```java\n  /**\n   * Fills all text fields to show details about the person.\n   * If the specified person is null, all text fields are cleared.\n   *\n   * @param person the person or null\n   */\n  private void showPersonDetails(Person person) {\n      if (person != null) {\n          // Fill the labels with info from the person object.\n          firstNameLabel.setText(person.getFirstName());\n          lastNameLabel.setText(person.getLastName());\n          streetLabel.setText(person.getStreet());\n          postalCodeLabel.setText(Integer.toString(person.getPostalCode()));\n          cityLabel.setText(person.getCity());\n\n          // TODO: We need a way to convert the birthday into a String!\n          // birthdayLabel.setText(...);\n      } else {\n          // Person is null, remove all the text.\n          firstNameLabel.setText(\"\");\n          lastNameLabel.setText(\"\");\n          streetLabel.setText(\"\");\n          postalCodeLabel.setText(\"\");\n          cityLabel.setText(\"\");\n          birthdayLabel.setText(\"\");\n      }\n  }\n  ```\n\n- **监听用户在人员表中的选择**\n\n  **PersonOverviewController.java**\n\n  ```java\n  @FXML\n  private void initialize() {\n      // Initialize the person table with the two columns.\n      firstNameColumn.setCellValueFactory(\n              cellData -> cellData.getValue().firstNameProperty());\n      lastNameColumn.setCellValueFactory(\n              cellData -> cellData.getValue().lastNameProperty());\n\n      // Clear person details.\n      showPersonDetails(null);\n\n      // Listen for selection changes and show the person details when changed.\n      personTable.getSelectionModel().selectedItemProperty().addListener(\n              (observable, oldValue, newValue) -> showPersonDetails(newValue));\n  }\n  ```\n\n### 删除按钮事件\n\n我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下：\n\n**PersonOverviewController.java**:\n\n```java\n/**\n     * Called when the user clicks on the delete button.\n     */\n    @FXML\n    private void handleDeletePerson() {\n        int selectedIndex = personTable.getSelectionModel().getSelectedIndex();\n        if (selectedIndex >= 0){\n            personTable.getItems().remove(selectedIndex);\n        }\n        else{\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n#### 错误处理\n\n从上述代码可以看到我们使用了条件判断语句来判断`selectedIndex`的值，当其小于0时，正常情况我们应该会让其抛出`ArrayIndexOutOfBoundsException`异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了`controlsfx`包，用于弹出各类提示框（可在[ControlsFX](http://fxexperience.com/controlsfx/)官网获取）。\n\n`controlsfx`有两个主要的版本，同时对于不同的版本，二者的用法也不同：\n\n- 对于Java 8，需要下载[ControlsFX 8.40.14](http://fxexperience.com/downloads/controlsfx-8-40-14/)包\n- 对于Java 9及以上，需要下载[ControlsFX 9.0.0](http://fxexperience.com/downloads/controlsfx-9-0-0/)包\n\n我们这里用到的是Java 10，因此使用`ControlsFX 9.0.0`，使用方法如下：\n\n**ShowDialog.java**:\n\n```java\npackage com.tanrui.util;\n\nimport javafx.scene.control.Alert;\nimport javafx.stage.Stage;\n\n/**\n * Util to create and show Dialog.\n *\n * @author Tan Rui\n */\npublic class ShowDialog {\n\n    private Stage stage;\n    private Alert.AlertType type;\n    private String title;\n    private String message;\n\n    public ShowDialog(Stage stage, Alert.AlertType type, String title, String message){\n        this.stage = stage;\n        this.type = type;\n        this.title = title;\n        this.message = message;\n    }\n\n    public void ShowSpecificDialog(){\n        Alert dlg = new Alert(type);\n        dlg.initOwner(stage);\n        dlg.setTitle(title);\n        dlg.getDialogPane().setContentText(message);\n        dlg.show();\n    }\n}\n```\n\n**PersonOverviewController.java**\n\n```java\n/**\n     * Called when the user clicks on the delete button.\n     */\n    @FXML\n    private void handleDeletePerson() {\n        int selectedIndex = personTable.getSelectionModel().getSelectedIndex();\n        if (selectedIndex >= 0){\n            personTable.getItems().remove(selectedIndex);\n        }\n        else{\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n### 新建和编辑对话框\n\n> Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是：\n>\n> 1. 创建FXML文件，使用SceneBuilder编辑界面；\n> 2. 创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等；\n> 3. 连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性；\n> 4. 在Main函数中加载该控制器\n\n为之前的`New`和`Edit`按钮添加动作，弹出对话框（新的Stage）。\n\n#### 设计对话框\n\n创建`PersonEditDialog.fxml`，完成弹出对话框的设计：\n\n![image-20181027150559447](/img/image-20181027150559447.png)\n\n#### 创建控制器\n\n为对话框创建控制器`PersonEditDialogController.java`。\n\n**PersonEditDialogController.java：**\n\n```java\npackage com.tanrui.view;\n\nimport com.tanrui.util.ShowDialog;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Alert;\nimport javafx.scene.control.TextField;\nimport javafx.stage.Stage;\n\nimport com.tanrui.model.Person;\nimport com.tanrui.util.DateUtil;\n\n\n/**\n * Dialog to edit details of a person.\n *\n * @author Marco Jakob\n */\npublic class PersonEditDialogController {\n\n    @FXML\n    private TextField firstNameField;\n    @FXML\n    private TextField lastNameField;\n    @FXML\n    private TextField streetField;\n    @FXML\n    private TextField postalCodeField;\n    @FXML\n    private TextField cityField;\n    @FXML\n    private TextField birthdayField;\n\n\n    private Stage dialogStage;\n    private Person person;\n    private boolean okClicked = false;\n\n    /**\n     * Initializes the controller class. This method is automatically called\n     * after the fxml file has been loaded.\n     */\n    @FXML\n    private void initialize() {\n    }\n\n    /**\n     * Sets the stage of this dialog.\n     *\n     * @param dialogStage\n     */\n    public void setDialogStage(Stage dialogStage) {\n        this.dialogStage = dialogStage;\n    }\n\n    /**\n     * Sets the person to be edited in the dialog.\n     *\n     * @param person\n     */\n    public void setPerson(Person person) {\n        this.person = person;\n\n        firstNameField.setText(person.getFirstName());\n        lastNameField.setText(person.getLastName());\n        streetField.setText(person.getStreet());\n        postalCodeField.setText(Integer.toString(person.getPostalCode()));\n        cityField.setText(person.getCity());\n        birthdayField.setText(DateUtil.format(person.getBirthday()));\n        birthdayField.setPromptText(\"dd.mm.yyyy\");\n    }\n\n    /**\n     * Returns true if the user clicked OK, false otherwise.\n     *\n     * @return\n     */\n    public boolean isOkClicked() {\n        return okClicked;\n    }\n\n    /**\n     * Called when the user clicks ok.\n     */\n    @FXML\n    private void handleOk() {\n        if (isInputValid()) {\n            person.setFirstName(firstNameField.getText());\n            person.setLastName(lastNameField.getText());\n            person.setStreet(streetField.getText());\n            person.setPostalCode(Integer.parseInt(postalCodeField.getText()));\n            person.setCity(cityField.getText());\n            person.setBirthday(DateUtil.parse(birthdayField.getText()));\n\n            okClicked = true;\n            dialogStage.close();\n        }\n    }\n\n    /**\n     * Called when the user clicks cancel.\n     */\n    @FXML\n    private void handleCancel() {\n        dialogStage.close();\n    }\n\n    /**\n     * Validates the user input in the text fields.\n     *\n     * @return true if the input is valid\n     */\n    private boolean isInputValid() {\n        String errorMessage = \"\";\n\n        if (firstNameField.getText() == null || firstNameField.getText().length() == 0) {\n            errorMessage += \"No valid first name!\\n\";\n        }\n        if (lastNameField.getText() == null || lastNameField.getText().length() == 0) {\n            errorMessage += \"No valid last name!\\n\";\n        }\n        if (streetField.getText() == null || streetField.getText().length() == 0) {\n            errorMessage += \"No valid street!\\n\";\n        }\n\n        if (postalCodeField.getText() == null || postalCodeField.getText().length() == 0) {\n            errorMessage += \"No valid postal code!\\n\";\n        } else {\n            try {\n                Integer.parseInt(postalCodeField.getText());\n            } catch (NumberFormatException e) {\n                errorMessage += \"No valid postal code (must be an integer)!\\n\";\n            }\n        }\n\n        if (cityField.getText() == null || cityField.getText().length() == 0) {\n            errorMessage += \"No valid city!\\n\";\n        }\n\n        if (birthdayField.getText() == null || birthdayField.getText().length() == 0) {\n            errorMessage += \"No valid birthday!\\n\";\n        } else {\n            if (!DateUtil.validDate(birthdayField.getText())) {\n                errorMessage += \"No valid birthday. Use the format dd.mm.yyyy!\\n\";\n            }\n        }\n\n        if (errorMessage.length() == 0) {\n            return true;\n        } else {\n            new ShowDialog(dialogStage, Alert.AlertType.ERROR, \"Invalid Fields\", \"Please correct invalid fields\").ShowSpecificDialog();\n            return false;\n        }\n    }\n}\n```\n\n关于该控制器的一些事情应该注意：\n\n1. `setPerson(…)`方法可以从其它类中调用，用来设置编辑的人员。\n2. 当用户点击OK按钮时，调用`handleOK()`方法。首先，通过调用`isInputValid()`方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给`setPerson(…)`。\n3. 布尔值`okClicked`被使用，以便调用者决定用户是否点击OK或者Cancel按钮。\n\n#### 连接视图和控制器\n\n使用已经创建的视图（FXML）和控制器，需要连接到一起。\n\n1. 使用SceneBuilder打开`PersonEditDialog.fxml`文件\n2. 在左边的*Controller*组中选择`PersonEditDialogController`作为控制器类\n3. 设置所有**TextField**的`fx:id`到相应的控制器字段上。\n4. 设置两个按钮的**onAction**到相应的处理方法上。\n\n#### 在Main中部署该控制器\n\n**Main.java:**\n\n```java\n/**\n * Opens a dialog to edit details for the specified person. If the user\n * clicks OK, the changes are saved into the provided person object and true\n * is returned.\n *\n * @param person the person object to be edited\n * @return true if the user clicked OK, false otherwise.\n */\npublic boolean showPersonEditDialog(Person person) {\n    try {\n        // Load the fxml file and create a new stage for the popup dialog.\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(Main.class.getResource(\"view/PersonEditDialog.fxml\"));\n        AnchorPane page = (AnchorPane) loader.load();\n\n        // Create the dialog Stage.\n        Stage dialogStage = new Stage();\n        dialogStage.setTitle(\"Edit Person\");\n        dialogStage.initModality(Modality.WINDOW_MODAL);\n        dialogStage.initOwner(primaryStage);\n        Scene scene = new Scene(page);\n        dialogStage.setScene(scene);\n\n        // Set the person into the controller.\n        PersonEditDialogController controller = loader.getController();\n        controller.setDialogStage(dialogStage);\n        controller.setPerson(person);\n\n        // Show the dialog and wait until the user closes it\n        dialogStage.showAndWait();\n\n        return controller.isOkClicked();\n    } catch (IOException e) {\n        e.printStackTrace();\n        return false;\n    }\n}\n```\n\n为主界面中`New`和`Edit`按钮创建OnAction方法，这些方法将从`Main`中调用`showPersonEditDialog(…)`方法。\n\n**PersonOverviewController.java:**\n\n```java\n    /**\n     * Called when the user clicks the new button. Opens a dialog to edit\n     * details for a new person.\n     */\n    @FXML\n    private void handleNewPerson() {\n        Person tempPerson = new Person();\n        boolean okClicked = main.showPersonEditDialog(tempPerson);\n        if (okClicked) {\n            main.getPersonData().add(tempPerson);\n        }\n    }\n\n    /**\n     * Called when the user clicks the edit button. Opens a dialog to edit\n     * details for the selected person.\n     */\n    @FXML\n    private void handleEditPerson() {\n        Person selectedPerson = personTable.getSelectionModel().getSelectedItem();\n        if (selectedPerson != null) {\n            boolean okClicked = main.showPersonEditDialog(selectedPerson);\n            if (okClicked) {\n                showPersonDetails(selectedPerson);\n            }\n\n        } else {\n            new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog();\n        }\n    }\n```\n\n而后在`PersonOverview.fxml`中为New和Edit两个按钮绑定对应的OnAction方法：\n\n![image-20181027164439676](/img/image-20181027164439676.png)\n\n### 数据持久化\n\n我们有很多种方法来实现应用数据的持久化，例如：\n\n- 使用数据库存储\n- 使用Json文件存储\n- 使用XML文件存储\n- ……\n\n这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是：\n\n1. 每次打开应用可加载上一次的用户数据\n2. 用户可选择保存当前数据到指定XML文件\n3. 用户可选择从指定XML文件加载数据\n\n#### 使用Preferences保存应用状态\n\n`Java`提供了`Preferences`类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），`Preferences`类底层对各类操作系统进行了封装（实际上是`Windows系统`、`OS X系统`和`类Unix文件系统`三种），用户配置在`Windows系统`上可能保存在注册表中、在`类Unix文件系统`上可能保存在`/tmp`下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道`Preferences`类是用来保存用户配置即可。用法如下：\n\n**Main.java:**\n\n```java\n/**\n     * Returns the person file preference, i.e. the file that was last opened.\n     * The preference is read from the OS specific registry. If no such\n     * preference can be found, null is returned.\n     *\n     * @return\n     */\n    public File getPersonFilePath() {\n        Preferences prefs = Preferences.userNodeForPackage(Main.class);\n        String filePath = prefs.get(\"filePath\", null);\n        if (filePath != null) {\n            return new File(filePath);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Sets the file path of the currently loaded file. The path is persisted in\n     * the OS specific registry.\n     *\n     * @param file the file or null to remove the path\n     */\n    public void setPersonFilePath(File file) {\n        Preferences prefs = Preferences.userNodeForPackage(Main.class);\n        if (file != null) {\n            prefs.put(\"filePath\", file.getPath());\n            // Update the stage title.\n            primaryStage.setTitle(\"AddressApp - \" + file.getName());\n        } else {\n            prefs.remove(\"filePath\");\n            // Update the stage title.\n            primaryStage.setTitle(\"AddressApp\");\n        }\n    }\n```\n\n#### 使用JAXB\n\n`JAXB包`是Java中提供的对数据进行`编列(marshall)`成XML文件以及对XML文件`反编列(unmarshall)`为数据结构的包，`Java SE`中有如下支持类型：`JAXB 2.0`是`JDK 1.6`的组成部分。`JAXB 2.2.3`是`JDK 1.7以上`的组成部分，而实际上在`Java 9`之后就已将`JAXB`包移除，因此使用时需添加额外的lib包，详情可见博客[真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException](https://blog.csdn.net/hadues/article/details/79188793)。\n\n##### JAXB模型类\n\n我们希望持久化的数据应该是`Main`中的`personData`，而`JAXB`有以下要求：\n\n- 使用`@XmlRootElement`定义`XML根元素`的名称\n- 使用`@XmlElement`指定一个`XML元素`，可选\n\n而`Main`中的`personData`是`ObservableList`类型，由于`ObservableList`类型不支持添加注解，因此我们需要创建另外一个能保存`Person`列表同时又能存储为`XML文件`的类，如下。\n\n**PersonListWrapper.java:**\n\n```java\npackage com.tanrui.model;\n\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n/**\n * Helper class to wrap a list of persons. This is used for saving the\n * list of persons to XML.\n */\n@XmlRootElement(name = \"persons\")\npublic class PersonListWrapper {\n\n    private List<Person> persons;\n\n    @XmlElement(name = \"person\")\n    public List<Person> getPersons() {\n        return persons;\n    }\n\n    public void setPersons(List<Person> persons) {\n        this.persons = persons;\n    }\n}\n```\n\n##### 使用JAXB读写数据到XML文件\n\n我们将读写XML文件的逻辑放到`Main类`中，`Controller`在用到相应的逻辑时，直接调用`Main`中的方法即可。\n\n**Main.java:**\n\n```java\n\n    /**\n     * Loads person data from the specified file. The current person data will\n     * be replaced.\n     *\n     * @param file\n     */\n    public void loadPersonDataFromFile(File file) {\n        try {\n            JAXBContext context = JAXBContext\n                    .newInstance(PersonListWrapper.class);\n            Unmarshaller um = context.createUnmarshaller();\n\n            // Reading XML from the file and unmarshalling.\n            PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file);\n\n            personData.clear();\n            personData.addAll(wrapper.getPersons());\n\n            // Save the file path to the registry.\n            setPersonFilePath(file);\n\n        } catch (Exception e) { // catches ANY exception\n            new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog();\n        }\n    }\n\n    /**\n     * Saves the current person data to the specified file.\n     *\n     * @param file\n     */\n    public void savePersonDataToFile(File file) {\n        try {\n            JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class);\n            Marshaller m = context.createMarshaller();\n            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n            // Wrapping our person data.\n            PersonListWrapper wrapper = new PersonListWrapper();\n            wrapper.setPersons(personData);\n\n            // Marshalling and saving XML to the file.\n            m.marshal(wrapper, file);\n\n            // Save the file path to the registry.\n            setPersonFilePath(file);\n        } catch (Exception e) { // catches ANY exception\n            new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog();\n        }\n    }\n```\n\n`编组(marshall):savePersonDataToFile(…)`和`解组(unmarshall):loadPersonDataFromFile(…)`已准备好，下面在界面中使用它。\n\n#### 创建打开和保存菜单\n\n##### 为File菜单添加子项\n\n![image-20181027232418408](/img/image-20181027232418408.png)\n\n##### 处理菜单相应动作\n\n`Controller`中使用`FileChooser`的方法，`FileChooser`同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。\n\n本类中使用了`FileChooser.ExtensionFilter`，对文件系统中文件进行过滤，保留`.xml`结尾的文件。\n\n当用户选择特定文件而后点击`打开`按钮时，会返回该文件，否则返回`Null`。\n\n```java\npackage com.tanrui.view;\n\nimport com.tanrui.Main;\nimport com.tanrui.util.ShowDialog;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Alert;\nimport javafx.stage.FileChooser;\n\nimport java.io.File;\n\n/**\n * The controller for the root layout. The root layout provides the basic\n * application layout containing a menu bar and space where other JavaFX\n * elements can be placed.\n */\npublic class RootLayoutController {\n\n    // Reference to the main application\n    private Main main;\n\n    /**\n     * Is called by the main application to give a reference back to itself.\n     *\n     * @param main\n     */\n    public void setMain(Main main) {\n        this.main = main;\n    }\n\n    /**\n     * Creates an empty address book.\n     */\n    @FXML\n    private void handleNew() {\n        main.getPersonData().clear();\n        main.setPersonFilePath(null);\n    }\n\n    /**\n     * Opens a FileChooser to let the user select an address book to load.\n     */\n    @FXML\n    private void handleOpen() {\n        FileChooser fileChooser = new FileChooser();\n\n        // Set extension filter\n        FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(\n                \"XML files (*.xml)\", \"*.xml\");\n        fileChooser.getExtensionFilters().add(extFilter);\n\n        // Show save file dialog\n        File file = fileChooser.showOpenDialog(main.getPrimaryStage());\n\n        if (file != null) {\n            main.loadPersonDataFromFile(file);\n        }\n    }\n\n    /**\n     * Saves the file to the person file that is currently open. If there is no\n     * open file, the \"save as\" dialog is shown.\n     */\n    @FXML\n    private void handleSave() {\n        File personFile = main.getPersonFilePath();\n        if (personFile != null) {\n            main.savePersonDataToFile(personFile);\n        } else {\n            handleSaveAs();\n        }\n    }\n\n    /**\n     * Opens a FileChooser to let the user select a file to save to.\n     */\n    @FXML\n    private void handleSaveAs() {\n        FileChooser fileChooser = new FileChooser();\n\n        // Set extension filter\n        FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(\n                \"XML files (*.xml)\", \"*.xml\");\n        fileChooser.getExtensionFilters().add(extFilter);\n\n        // Show save file dialog\n        File file = fileChooser.showSaveDialog(main.getPrimaryStage());\n\n        if (file != null) {\n            // Make sure it has the correct extension\n            if (!file.getPath().endsWith(\".xml\")) {\n                file = new File(file.getPath() + \".xml\");\n            }\n            main.savePersonDataToFile(file);\n        }\n    }\n\n    /**\n     * Opens an about dialog.\n     */\n    @FXML\n    private void handleAbout() {\n        new ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, \"About\", \"Author: Tan\\\\nWebsite: https://guitoubing.top\").ShowSpecificDialog();\n    }\n\n    /**\n     * Closes the application.\n     */\n    @FXML\n    private void handleExit() {\n        System.exit(0);\n    }\n\n    /**\n     * Opens the birthday statistics.\n     */\n    @FXML\n    private void handleShowBirthdayStatistics() {\n        main.showBirthdayStatistics();\n    }\n}\n```\n\n##### 连接FXML文件和Controller、绑定菜单和对应动作\n\n![image-20181027233726178](/img/image-20181027233726178.png)\n\n![image-20181027233529314](/img/image-20181027233529314.png)\n\n##### 在Main中部署该控制器\n\n**Main.java:**\n\n```java\n /**\n     * Initializes the root layout.\n     */\n    public void initRootLayout() {\n        try {\n            // Load root layout from fxml file.\n            FXMLLoader loader = new FXMLLoader();\n            loader.setLocation(Main.class.getResource(\"view/RootLayout.fxml\"));\n            rootLayout = (BorderPane) loader.load();\n\n            // Show the scene containing the root layout.\n            Scene scene = new Scene(rootLayout);\n            primaryStage.setScene(scene);\n\n            RootLayoutController controller = loader.getController();\n            controller.setMain(this);\n\n            primaryStage.show();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        File file = getPersonFilePath();\n        if (file != null){\n            loadPersonDataFromFile(file);\n        }\n    }\n```\n\n## 参考资料\n\n1. [code.makery —— JavaFX中文教程](https://code.makery.ch/)\n2. [JavaFX Tutorial](https://www.tutorialspoint.com/javafx/)\n3. [真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException](https://blog.csdn.net/hadues/article/details/79188793)\n4. [fxexperience —— ControlFX](http://fxexperience.com/controlsfx/)\n5. [Java SE8 —— Lambda](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html)\n6. …………\n\n## 写在后面\n\n本博主要是在学习[code.makery —— JavaFX中文教程](https://code.makery.ch/)博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是`JDK 8u40`，我这里使用的是`Java 10 2018-03-20`）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击[JavaFX-Test](http://getme.guitoubing.top/JavaFX_PRE.zip)中获取源码。\n\n希望藉此次`JavaFX`学习开启我的Java源码学习之旅，道阻且长！\n","slug":"JavaFX-学习小记","published":1,"updated":"2021-05-16T10:55:33.577Z","_id":"ckfukja940009szxob08e6w4m","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaFX小记\"><a href=\"#JavaFX小记\" class=\"headerlink\" title=\"JavaFX小记\"></a>JavaFX小记</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><p>JavaFX</p>\n<p><code>JavaFX</code>是由<a href=\"https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8\" target=\"_blank\" rel=\"noopener\">甲骨文(Oracle)公司</a>推出的一系列的产品和技术，主要应用于创建Rich Internet application(<a href=\"https://zh.wikipedia.org/wiki/RIA\" target=\"_blank\" rel=\"noopener\">RIAs</a>)，它是一个跨平台的桌面应用程序开发框架。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>典型的MVC架构</p>\n<ul>\n<li>定义<code>Model</code>，使用<code>javafx.beans</code>封装类型定义属性类型</li>\n<li>使用<code>fxml</code>文件创建<code>View</code>，利用SceneBuilder工具进行布局</li>\n<li>创建<code>Controller</code>实现动作操作以及<code>Model</code>和<code>View</code>的联系</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><ul>\n<li><strong>创建FXML文件，利用SceneBuilder工具进行布局</strong></li>\n</ul>\n<h2 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h2><ul>\n<li><p><strong>定义<code>Model</code>中的<code>Person</code>类，使用<code>Property</code>和<code>Bind</code></strong></p>\n<p><code>java.beans</code>包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，<code>Property</code>和<code>Bind</code>方便我们实现以下功能：当某个属性如<code>First Name</code>被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考<a href=\"https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm\" target=\"_blank\" rel=\"noopener\">JavaFX文档</a>。</p>\n<p><strong>Person.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.IntegerProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.ObjectProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleIntegerProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleObjectProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleStringProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.StringProperty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Model class for a Person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty firstName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty lastName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty street;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IntegerProperty postalCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty city;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ObjectProperty&lt;LocalDate&gt; birthday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Default constructor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructor with some initial data.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> firstName</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lastName</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstName = <span class=\"keyword\">new</span> SimpleStringProperty(firstName);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastName = <span class=\"keyword\">new</span> SimpleStringProperty(lastName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Some initial dummy data, just for convenient testing.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.street = <span class=\"keyword\">new</span> SimpleStringProperty(<span class=\"string\">\"some street\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.postalCode = <span class=\"keyword\">new</span> SimpleIntegerProperty(<span class=\"number\">1234</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city = <span class=\"keyword\">new</span> SimpleStringProperty(<span class=\"string\">\"some city\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday = <span class=\"keyword\">new</span> SimpleObjectProperty&lt;LocalDate&gt;(LocalDate.of(<span class=\"number\">1999</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFirstName</span><span class=\"params\">(String firstName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstName.set(firstName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">firstNameProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastName.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastName.set(lastName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">lastNameProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getStreet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> street.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStreet</span><span class=\"params\">(String street)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.street.set(street);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">streetProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> street;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPostalCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> postalCode.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPostalCode</span><span class=\"params\">(<span class=\"keyword\">int</span> postalCode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.postalCode.set(postalCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntegerProperty <span class=\"title\">postalCodeProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> postalCode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> city.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCity</span><span class=\"params\">(String city)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city.set(city);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">cityProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalDate <span class=\"title\">getBirthday</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirthday</span><span class=\"params\">(LocalDate birthday)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday.set(birthday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObjectProperty&lt;LocalDate&gt; <span class=\"title\">birthdayProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用<code>ObservableList</code>管理<code>Person</code></strong></p>\n<p>前一点所述的<u><strong>后续</strong></u>操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是<code>ObservableList</code>，<code>ObservableList</code>继承了<code>List</code>类、实现了<code>Observable</code>接口，其实现视图和数据同步的方法是在声明<code>ObservableList</code>时为方法传递一个监听器，此监听器需要会通过监听<code>personData</code>的变化同步改变视图中对应的值，可参考<a href=\"https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html\" target=\"_blank\" rel=\"noopener\">ObservableList文档</a></p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*......Other variables......*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * The data of a observable list of Persons</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ObservableList&lt;Person&gt; personData = FXCollections.observableArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObservableList&lt;Person&gt; <span class=\"title\">getPersonData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Tan\"</span>, <span class=\"string\">\"Rui\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Chao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Liang\"</span>, <span class=\"string\">\"Chengwei\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Xiao\"</span>, <span class=\"string\">\"Xin\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Li\"</span>, <span class=\"string\">\"Yang\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Runqian\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Liang\"</span>, <span class=\"string\">\"Yongchao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Luo\"</span>, <span class=\"string\">\"Jihao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Zhi\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Fan\"</span>, <span class=\"string\">\"Fan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* ......Other function..... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><h3 id=\"PersonOverviewController-java\"><a href=\"#PersonOverviewController-java\" class=\"headerlink\" title=\"PersonOverviewController.java\"></a>PersonOverviewController.java</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Label;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TableColumn;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TableView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.Main;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.model.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonOverviewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableView&lt;Person&gt; personTable;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableColumn&lt;Person, String&gt; firstNameColumn;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableColumn&lt;Person, String&gt; lastNameColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label firstNameLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label lastNameLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label streetLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label postalCodeLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label cityLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label birthdayLabel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Reference to the main application.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Main main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The constructor.</span></span><br><span class=\"line\"><span class=\"comment\">     * The constructor is called before the initialize() method.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PersonOverviewController</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Initializes the controller class. This method is automatically called</span></span><br><span class=\"line\"><span class=\"comment\">     * after the fxml file has been loaded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialize the person table with the two columns.</span></span><br><span class=\"line\">        firstNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class=\"line\">        lastNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Is called by the main application to give a reference back to itself.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> main</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMain</span><span class=\"params\">(Main main)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.main = main;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Add observable list data to the table</span></span><br><span class=\"line\">        personTable.setItems(main.getPersonData());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>@FXML</code>注解（Annotation）</strong></p>\n<p>使用<code>@FXML</code>注解可以将操作的属性、方法绑定到<code>FXML</code>文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用<code>@FXML</code>注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！</p>\n</li>\n<li><p><strong><code>initialize()</code>方法</strong></p>\n<p><code>initialize()</code>字面意思可知其是用于初始化对应<code>FXML</code>文件中的属性，此方法会在加载<code>FXML</code>文件时被自动执行，此时，所有的<code>FXML</code>属性都应已被初始化</p>\n</li>\n<li><p><strong><code>setCellValueFactory(...)</code>方法</strong></p>\n<p>我们对表格列上使用<code>setCellValueFactory(...)</code>方法来确定为特定列使用前面<code>Person</code>的某个属性。<code>-&gt;</code>表示使用的是<a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" target=\"_blank\" rel=\"noopener\">Lambdas</a>特性；另外一种方法是使用<a href=\"https://docs.oracle.com/javase/8/javafx/api/\" target=\"_blank\" rel=\"noopener\">PropertyValueFactory</a>(待研究…)。</p>\n<p>这里我们之所以可以使用<code>cellData -&gt; cellData.getValue().firstNameProperty()</code>，便是因为之前我们将Person的属性都定义为<code>javafx.beans</code>中的封装属性，<code>firstNameProperty()</code>等方法都会在声明成<code>Beans</code>封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便</p>\n</li>\n</ul>\n<h3 id=\"连接Main和PersonOverviewController\"><a href=\"#连接Main和PersonOverviewController\" class=\"headerlink\" title=\"连接Main和PersonOverviewController\"></a>连接Main和PersonOverviewController</h3><ul>\n<li><p><strong><code>showPersonOverview()</code> 方法</strong></p>\n<p><strong>Main.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Shows the person overview inside the root layout.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showPersonOverview</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Load person overview.</span></span><br><span class=\"line\">        FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">        loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/PersonOverview.fxml\"</span>));</span><br><span class=\"line\">        AnchorPane personOverview = (AnchorPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set person overview into the center of root layout.</span></span><br><span class=\"line\">        rootLayout.setCenter(personOverview);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Give the controller access to the main app.</span></span><br><span class=\"line\">        PersonOverviewController controller = loader.getController();</span><br><span class=\"line\">        controller.setMain(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"将View与Controller绑定\"><a href=\"#将View与Controller绑定\" class=\"headerlink\" title=\"将View与Controller绑定\"></a>将View与Controller绑定</h3><p>我们还需要为<code>FXML文件</code>指定其对应的<code>Controller</code>，以及<code>FXML元素</code>与<code>控制器的属性</code>的对应关系，这是因为FXML文件中的元素只能被对应<code>Controller</code>修改更新，若在其他方法中修改会产生运行时错误。例如：在<code>PersonOverviewController.java</code>中将某个<code>Label</code>返回到<code>Main.java</code>中而后在其中修改该<code>Label</code>的值，意即在<code>非FX线程</code>中执行<code>FX线程</code>相关的任务，则会造成当前的线程阻塞，解决方法之一是使用<code>Platform.runLater()</code>方法，如下所示，括号中的<code>FX线程</code>相关任务便不会阻塞当前进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Platform.runLater(() -&gt; &#123;</span><br><span class=\"line\">        ………相关FX线程代码………</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当然，最好的选择还是讲<code>FX线程</code>任务和其他任务区分开来，将特定的<code>FXML文件</code>与对应的<code>Controller</code>联系起来，当需要建立联系时可通过之前所说的使用<code>java.beans</code>、<code>ObservableList</code>等方法实现动态更新视图。</p>\n<ul>\n<li><p><strong>为<code>FXML文件</code>指定<code>Controller</code></strong></p>\n<p>在Eclipse中好像有图形化界面直接为<code>FXML文件</code>选择<code>Controller</code>的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。</p>\n<p><strong>PersonOverview.fxml</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">AnchorPane</span> <span class=\"attr\">maxHeight</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">maxWidth</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">minHeight</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">minWidth</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">prefHeight</span>=<span class=\"string\">\"300.0\"</span> <span class=\"attr\">prefWidth</span>=<span class=\"string\">\"600.0\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://javafx.com/javafx/8.0.121\"</span> <span class=\"attr\">xmlns:fx</span>=<span class=\"string\">\"http://javafx.com/fxml/1\"</span> <span class=\"attr\">fx:controller</span>=<span class=\"string\">\"com.tanrui.view.PersonOverviewController\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">children</span>&gt;</span></span><br><span class=\"line\">        &lt;? ... 内容省略 ... ?&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">children</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">AnchorPane</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如上述代码所述，在顶层节点（此处是<code>AnchorPane</code>）标签中添加属性如下：<code>fx:controller=&quot;com.tanrui.view.PersonOverviewController”</code>，以此为<code>FXML文件</code>指定<code>Controller</code></p>\n</li>\n<li><p>为<code>FXML元素</code>指定<code>fx:id</code>，使其绑定对应的<code>控制器属性</code></p>\n<p><img src=\"/img/image-20181023205748006.png\" alt=\"image-20181023205748006\"></p>\n<p>如图，选定特定元素，在右侧界面找到<code>Code</code>-&gt;<code>fx:id</code>，将其对应的控制器属性填入即可</p>\n</li>\n</ul>\n<h3 id=\"Details界面更新\"><a href=\"#Details界面更新\" class=\"headerlink\" title=\"Details界面更新\"></a>Details界面更新</h3><ul>\n<li><p><strong><code>showPersonDetails(Person person)</code>方法</strong></p>\n<p><code>showPersonDetails(Person person)</code>方法用于使用Person实例的数据填写标签。</p>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fills all text fields to show details about the person.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the specified person is null, all text fields are cleared.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> person the person or null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">showPersonDetails</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (person != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Fill the labels with info from the person object.</span></span><br><span class=\"line\">        firstNameLabel.setText(person.getFirstName());</span><br><span class=\"line\">        lastNameLabel.setText(person.getLastName());</span><br><span class=\"line\">        streetLabel.setText(person.getStreet());</span><br><span class=\"line\">        postalCodeLabel.setText(Integer.toString(person.getPostalCode()));</span><br><span class=\"line\">        cityLabel.setText(person.getCity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We need a way to convert the birthday into a String!</span></span><br><span class=\"line\">        <span class=\"comment\">// birthdayLabel.setText(...);</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Person is null, remove all the text.</span></span><br><span class=\"line\">        firstNameLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        lastNameLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        streetLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        postalCodeLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        cityLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        birthdayLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监听用户在人员表中的选择</strong></p>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Initialize the person table with the two columns.</span></span><br><span class=\"line\">    firstNameColumn.setCellValueFactory(</span><br><span class=\"line\">            cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class=\"line\">    lastNameColumn.setCellValueFactory(</span><br><span class=\"line\">            cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear person details.</span></span><br><span class=\"line\">    showPersonDetails(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Listen for selection changes and show the person details when changed.</span></span><br><span class=\"line\">    personTable.getSelectionModel().selectedItemProperty().addListener(</span><br><span class=\"line\">            (observable, oldValue, newValue) -&gt; showPersonDetails(newValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"删除按钮事件\"><a href=\"#删除按钮事件\" class=\"headerlink\" title=\"删除按钮事件\"></a>删除按钮事件</h3><p>我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下：</p>\n<p><strong>PersonOverviewController.java</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks on the delete button.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDeletePerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedIndex &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            personTable.getItems().remove(selectedIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>从上述代码可以看到我们使用了条件判断语句来判断<code>selectedIndex</code>的值，当其小于0时，正常情况我们应该会让其抛出<code>ArrayIndexOutOfBoundsException</code>异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了<code>controlsfx</code>包，用于弹出各类提示框（可在<a href=\"http://fxexperience.com/controlsfx/\" target=\"_blank\" rel=\"noopener\">ControlsFX</a>官网获取）。</p>\n<p><code>controlsfx</code>有两个主要的版本，同时对于不同的版本，二者的用法也不同：</p>\n<ul>\n<li>对于Java 8，需要下载<a href=\"http://fxexperience.com/downloads/controlsfx-8-40-14/\" target=\"_blank\" rel=\"noopener\">ControlsFX 8.40.14</a>包</li>\n<li>对于Java 9及以上，需要下载<a href=\"http://fxexperience.com/downloads/controlsfx-9-0-0/\" target=\"_blank\" rel=\"noopener\">ControlsFX 9.0.0</a>包</li>\n</ul>\n<p>我们这里用到的是Java 10，因此使用<code>ControlsFX 9.0.0</code>，使用方法如下：</p>\n<p><strong>ShowDialog.java</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.Stage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Util to create and show Dialog.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Tan Rui</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShowDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stage stage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Alert.AlertType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShowDialog</span><span class=\"params\">(Stage stage, Alert.AlertType type, String title, String message)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stage = stage;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ShowSpecificDialog</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Alert dlg = <span class=\"keyword\">new</span> Alert(type);</span><br><span class=\"line\">        dlg.initOwner(stage);</span><br><span class=\"line\">        dlg.setTitle(title);</span><br><span class=\"line\">        dlg.getDialogPane().setContentText(message);</span><br><span class=\"line\">        dlg.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks on the delete button.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDeletePerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedIndex &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            personTable.getItems().remove(selectedIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建和编辑对话框\"><a href=\"#新建和编辑对话框\" class=\"headerlink\" title=\"新建和编辑对话框\"></a>新建和编辑对话框</h3><blockquote>\n<p>Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是：</p>\n<ol>\n<li>创建FXML文件，使用SceneBuilder编辑界面；</li>\n<li>创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等；</li>\n<li>连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性；</li>\n<li>在Main函数中加载该控制器</li>\n</ol>\n</blockquote>\n<p>为之前的<code>New</code>和<code>Edit</code>按钮添加动作，弹出对话框（新的Stage）。</p>\n<h4 id=\"设计对话框\"><a href=\"#设计对话框\" class=\"headerlink\" title=\"设计对话框\"></a>设计对话框</h4><p>创建<code>PersonEditDialog.fxml</code>，完成弹出对话框的设计：</p>\n<p><img src=\"/img/image-20181027150559447.png\" alt=\"image-20181027150559447\"></p>\n<h4 id=\"创建控制器\"><a href=\"#创建控制器\" class=\"headerlink\" title=\"创建控制器\"></a>创建控制器</h4><p>为对话框创建控制器<code>PersonEditDialogController.java</code>。</p>\n<p><strong>PersonEditDialogController.java：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.ShowDialog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TextField;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.Stage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.model.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.DateUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Dialog to edit details of a person.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Marco Jakob</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonEditDialogController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField firstNameField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField lastNameField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField streetField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField postalCodeField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField cityField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField birthdayField;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stage dialogStage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person person;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> okClicked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Initializes the controller class. This method is automatically called</span></span><br><span class=\"line\"><span class=\"comment\">     * after the fxml file has been loaded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the stage of this dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dialogStage</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDialogStage</span><span class=\"params\">(Stage dialogStage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dialogStage = dialogStage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the person to be edited in the dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> person</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPerson</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.person = person;</span><br><span class=\"line\"></span><br><span class=\"line\">        firstNameField.setText(person.getFirstName());</span><br><span class=\"line\">        lastNameField.setText(person.getLastName());</span><br><span class=\"line\">        streetField.setText(person.getStreet());</span><br><span class=\"line\">        postalCodeField.setText(Integer.toString(person.getPostalCode()));</span><br><span class=\"line\">        cityField.setText(person.getCity());</span><br><span class=\"line\">        birthdayField.setText(DateUtil.format(person.getBirthday()));</span><br><span class=\"line\">        birthdayField.setPromptText(<span class=\"string\">\"dd.mm.yyyy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns true if the user clicked OK, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOkClicked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> okClicked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks ok.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOk</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInputValid()) &#123;</span><br><span class=\"line\">            person.setFirstName(firstNameField.getText());</span><br><span class=\"line\">            person.setLastName(lastNameField.getText());</span><br><span class=\"line\">            person.setStreet(streetField.getText());</span><br><span class=\"line\">            person.setPostalCode(Integer.parseInt(postalCodeField.getText()));</span><br><span class=\"line\">            person.setCity(cityField.getText());</span><br><span class=\"line\">            person.setBirthday(DateUtil.parse(birthdayField.getText()));</span><br><span class=\"line\"></span><br><span class=\"line\">            okClicked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            dialogStage.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks cancel.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        dialogStage.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Validates the user input in the text fields.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true if the input is valid</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInputValid</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String errorMessage = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstNameField.getText() == <span class=\"keyword\">null</span> || firstNameField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid first name!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastNameField.getText() == <span class=\"keyword\">null</span> || lastNameField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid last name!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (streetField.getText() == <span class=\"keyword\">null</span> || streetField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid street!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (postalCodeField.getText() == <span class=\"keyword\">null</span> || postalCodeField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid postal code!\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Integer.parseInt(postalCodeField.getText());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">                errorMessage += <span class=\"string\">\"No valid postal code (must be an integer)!\\n\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cityField.getText() == <span class=\"keyword\">null</span> || cityField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid city!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (birthdayField.getText() == <span class=\"keyword\">null</span> || birthdayField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid birthday!\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!DateUtil.validDate(birthdayField.getText())) &#123;</span><br><span class=\"line\">                errorMessage += <span class=\"string\">\"No valid birthday. Use the format dd.mm.yyyy!\\n\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorMessage.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(dialogStage, Alert.AlertType.ERROR, <span class=\"string\">\"Invalid Fields\"</span>, <span class=\"string\">\"Please correct invalid fields\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于该控制器的一些事情应该注意：</p>\n<ol>\n<li><code>setPerson(…)</code>方法可以从其它类中调用，用来设置编辑的人员。</li>\n<li>当用户点击OK按钮时，调用<code>handleOK()</code>方法。首先，通过调用<code>isInputValid()</code>方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给<code>setPerson(…)</code>。</li>\n<li>布尔值<code>okClicked</code>被使用，以便调用者决定用户是否点击OK或者Cancel按钮。</li>\n</ol>\n<h4 id=\"连接视图和控制器\"><a href=\"#连接视图和控制器\" class=\"headerlink\" title=\"连接视图和控制器\"></a>连接视图和控制器</h4><p>使用已经创建的视图（FXML）和控制器，需要连接到一起。</p>\n<ol>\n<li>使用SceneBuilder打开<code>PersonEditDialog.fxml</code>文件</li>\n<li>在左边的<em>Controller</em>组中选择<code>PersonEditDialogController</code>作为控制器类</li>\n<li>设置所有<strong>TextField</strong>的<code>fx:id</code>到相应的控制器字段上。</li>\n<li>设置两个按钮的<strong>onAction</strong>到相应的处理方法上。</li>\n</ol>\n<h4 id=\"在Main中部署该控制器\"><a href=\"#在Main中部署该控制器\" class=\"headerlink\" title=\"在Main中部署该控制器\"></a>在Main中部署该控制器</h4><p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Opens a dialog to edit details for the specified person. If the user</span></span><br><span class=\"line\"><span class=\"comment\"> * clicks OK, the changes are saved into the provided person object and true</span></span><br><span class=\"line\"><span class=\"comment\"> * is returned.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> person the person object to be edited</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the user clicked OK, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">showPersonEditDialog</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Load the fxml file and create a new stage for the popup dialog.</span></span><br><span class=\"line\">        FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">        loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/PersonEditDialog.fxml\"</span>));</span><br><span class=\"line\">        AnchorPane page = (AnchorPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the dialog Stage.</span></span><br><span class=\"line\">        Stage dialogStage = <span class=\"keyword\">new</span> Stage();</span><br><span class=\"line\">        dialogStage.setTitle(<span class=\"string\">\"Edit Person\"</span>);</span><br><span class=\"line\">        dialogStage.initModality(Modality.WINDOW_MODAL);</span><br><span class=\"line\">        dialogStage.initOwner(primaryStage);</span><br><span class=\"line\">        Scene scene = <span class=\"keyword\">new</span> Scene(page);</span><br><span class=\"line\">        dialogStage.setScene(scene);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set the person into the controller.</span></span><br><span class=\"line\">        PersonEditDialogController controller = loader.getController();</span><br><span class=\"line\">        controller.setDialogStage(dialogStage);</span><br><span class=\"line\">        controller.setPerson(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show the dialog and wait until the user closes it</span></span><br><span class=\"line\">        dialogStage.showAndWait();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.isOkClicked();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为主界面中<code>New</code>和<code>Edit</code>按钮创建OnAction方法，这些方法将从<code>Main</code>中调用<code>showPersonEditDialog(…)</code>方法。</p>\n<p><strong>PersonOverviewController.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the user clicks the new button. Opens a dialog to edit</span></span><br><span class=\"line\"><span class=\"comment\"> * details for a new person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleNewPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Person tempPerson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> okClicked = main.showPersonEditDialog(tempPerson);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (okClicked) &#123;</span><br><span class=\"line\">        main.getPersonData().add(tempPerson);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the user clicks the edit button. Opens a dialog to edit</span></span><br><span class=\"line\"><span class=\"comment\"> * details for the selected person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleEditPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Person selectedPerson = personTable.getSelectionModel().getSelectedItem();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedPerson != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> okClicked = main.showPersonEditDialog(selectedPerson);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (okClicked) &#123;</span><br><span class=\"line\">            showPersonDetails(selectedPerson);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而后在<code>PersonOverview.fxml</code>中为New和Edit两个按钮绑定对应的OnAction方法：</p>\n<p><img src=\"/img/image-20181027164439676.png\" alt=\"image-20181027164439676\"></p>\n<h3 id=\"数据持久化\"><a href=\"#数据持久化\" class=\"headerlink\" title=\"数据持久化\"></a>数据持久化</h3><p>我们有很多种方法来实现应用数据的持久化，例如：</p>\n<ul>\n<li>使用数据库存储</li>\n<li>使用Json文件存储</li>\n<li>使用XML文件存储</li>\n<li>……</li>\n</ul>\n<p>这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是：</p>\n<ol>\n<li>每次打开应用可加载上一次的用户数据</li>\n<li>用户可选择保存当前数据到指定XML文件</li>\n<li>用户可选择从指定XML文件加载数据</li>\n</ol>\n<h4 id=\"使用Preferences保存应用状态\"><a href=\"#使用Preferences保存应用状态\" class=\"headerlink\" title=\"使用Preferences保存应用状态\"></a>使用Preferences保存应用状态</h4><p><code>Java</code>提供了<code>Preferences</code>类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），<code>Preferences</code>类底层对各类操作系统进行了封装（实际上是<code>Windows系统</code>、<code>OS X系统</code>和<code>类Unix文件系统</code>三种），用户配置在<code>Windows系统</code>上可能保存在注册表中、在<code>类Unix文件系统</code>上可能保存在<code>/tmp</code>下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道<code>Preferences</code>类是用来保存用户配置即可。用法如下：</p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the person file preference, i.e. the file that was last opened.</span></span><br><span class=\"line\"><span class=\"comment\">     * The preference is read from the OS specific registry. If no such</span></span><br><span class=\"line\"><span class=\"comment\">     * preference can be found, null is returned.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getPersonFilePath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class=\"line\">        String filePath = prefs.get(<span class=\"string\">\"filePath\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filePath != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the file path of the currently loaded file. The path is persisted in</span></span><br><span class=\"line\"><span class=\"comment\">     * the OS specific registry.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file the file or null to remove the path</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPersonFilePath</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prefs.put(<span class=\"string\">\"filePath\"</span>, file.getPath());</span><br><span class=\"line\">            <span class=\"comment\">// Update the stage title.</span></span><br><span class=\"line\">            primaryStage.setTitle(<span class=\"string\">\"AddressApp - \"</span> + file.getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prefs.remove(<span class=\"string\">\"filePath\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Update the stage title.</span></span><br><span class=\"line\">            primaryStage.setTitle(<span class=\"string\">\"AddressApp\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用JAXB\"><a href=\"#使用JAXB\" class=\"headerlink\" title=\"使用JAXB\"></a>使用JAXB</h4><p><code>JAXB包</code>是Java中提供的对数据进行<code>编列(marshall)</code>成XML文件以及对XML文件<code>反编列(unmarshall)</code>为数据结构的包，<code>Java SE</code>中有如下支持类型：<code>JAXB 2.0</code>是<code>JDK 1.6</code>的组成部分。<code>JAXB 2.2.3</code>是<code>JDK 1.7以上</code>的组成部分，而实际上在<code>Java 9</code>之后就已将<code>JAXB</code>包移除，因此使用时需添加额外的lib包，详情可见博客<a href=\"https://blog.csdn.net/hadues/article/details/79188793\" target=\"_blank\" rel=\"noopener\">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a>。</p>\n<h5 id=\"JAXB模型类\"><a href=\"#JAXB模型类\" class=\"headerlink\" title=\"JAXB模型类\"></a>JAXB模型类</h5><p>我们希望持久化的数据应该是<code>Main</code>中的<code>personData</code>，而<code>JAXB</code>有以下要求：</p>\n<ul>\n<li>使用<code>@XmlRootElement</code>定义<code>XML根元素</code>的名称</li>\n<li>使用<code>@XmlElement</code>指定一个<code>XML元素</code>，可选</li>\n</ul>\n<p>而<code>Main</code>中的<code>personData</code>是<code>ObservableList</code>类型，由于<code>ObservableList</code>类型不支持添加注解，因此我们需要创建另外一个能保存<code>Person</code>列表同时又能存储为<code>XML文件</code>的类，如下。</p>\n<p><strong>PersonListWrapper.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.bind.annotation.XmlElement;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Helper class to wrap a list of persons. This is used for saving the</span></span><br><span class=\"line\"><span class=\"comment\"> * list of persons to XML.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@XmlRootElement</span>(name = <span class=\"string\">\"persons\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonListWrapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@XmlElement</span>(name = <span class=\"string\">\"person\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">getPersons</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> persons;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPersons</span><span class=\"params\">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.persons = persons;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用JAXB读写数据到XML文件\"><a href=\"#使用JAXB读写数据到XML文件\" class=\"headerlink\" title=\"使用JAXB读写数据到XML文件\"></a>使用JAXB读写数据到XML文件</h5><p>我们将读写XML文件的逻辑放到<code>Main类</code>中，<code>Controller</code>在用到相应的逻辑时，直接调用<code>Main</code>中的方法即可。</p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Loads person data from the specified file. The current person data will</span></span><br><span class=\"line\"><span class=\"comment\"> * be replaced.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadPersonDataFromFile</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        JAXBContext context = JAXBContext</span><br><span class=\"line\">                .newInstance(PersonListWrapper.class);</span><br><span class=\"line\">        Unmarshaller um = context.createUnmarshaller();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reading XML from the file and unmarshalling.</span></span><br><span class=\"line\">        PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file);</span><br><span class=\"line\"></span><br><span class=\"line\">        personData.clear();</span><br><span class=\"line\">        personData.addAll(wrapper.getPersons());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Save the file path to the registry.</span></span><br><span class=\"line\">        setPersonFilePath(file);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// catches ANY exception</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(<span class=\"keyword\">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class=\"string\">\"Error\"</span>, <span class=\"string\">\"Could not save data to file:\\n\"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Saves the current person data to the specified file.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">savePersonDataToFile</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class);</span><br><span class=\"line\">        Marshaller m = context.createMarshaller();</span><br><span class=\"line\">        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Wrapping our person data.</span></span><br><span class=\"line\">        PersonListWrapper wrapper = <span class=\"keyword\">new</span> PersonListWrapper();</span><br><span class=\"line\">        wrapper.setPersons(personData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Marshalling and saving XML to the file.</span></span><br><span class=\"line\">        m.marshal(wrapper, file);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Save the file path to the registry.</span></span><br><span class=\"line\">        setPersonFilePath(file);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// catches ANY exception</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(<span class=\"keyword\">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class=\"string\">\"Error\"</span>, <span class=\"string\">\"Could not save data to file:\\n\"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>编组(marshall):savePersonDataToFile(…)</code>和<code>解组(unmarshall):loadPersonDataFromFile(…)</code>已准备好，下面在界面中使用它。</p>\n<h4 id=\"创建打开和保存菜单\"><a href=\"#创建打开和保存菜单\" class=\"headerlink\" title=\"创建打开和保存菜单\"></a>创建打开和保存菜单</h4><h5 id=\"为File菜单添加子项\"><a href=\"#为File菜单添加子项\" class=\"headerlink\" title=\"为File菜单添加子项\"></a>为File菜单添加子项</h5><p><img src=\"/img/image-20181027232418408.png\" alt=\"image-20181027232418408\"></p>\n<h5 id=\"处理菜单相应动作\"><a href=\"#处理菜单相应动作\" class=\"headerlink\" title=\"处理菜单相应动作\"></a>处理菜单相应动作</h5><p><code>Controller</code>中使用<code>FileChooser</code>的方法，<code>FileChooser</code>同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。</p>\n<p>本类中使用了<code>FileChooser.ExtensionFilter</code>，对文件系统中文件进行过滤，保留<code>.xml</code>结尾的文件。</p>\n<p>当用户选择特定文件而后点击<code>打开</code>按钮时，会返回该文件，否则返回<code>Null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.Main;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.ShowDialog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.FileChooser;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The controller for the root layout. The root layout provides the basic</span></span><br><span class=\"line\"><span class=\"comment\"> * application layout containing a menu bar and space where other JavaFX</span></span><br><span class=\"line\"><span class=\"comment\"> * elements can be placed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootLayoutController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Reference to the main application</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Main main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Is called by the main application to give a reference back to itself.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> main</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMain</span><span class=\"params\">(Main main)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.main = main;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates an empty address book.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleNew</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        main.getPersonData().clear();</span><br><span class=\"line\">        main.setPersonFilePath(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens a FileChooser to let the user select an address book to load.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOpen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileChooser fileChooser = <span class=\"keyword\">new</span> FileChooser();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set extension filter</span></span><br><span class=\"line\">        FileChooser.ExtensionFilter extFilter = <span class=\"keyword\">new</span> FileChooser.ExtensionFilter(</span><br><span class=\"line\">                <span class=\"string\">\"XML files (*.xml)\"</span>, <span class=\"string\">\"*.xml\"</span>);</span><br><span class=\"line\">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show save file dialog</span></span><br><span class=\"line\">        File file = fileChooser.showOpenDialog(main.getPrimaryStage());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            main.loadPersonDataFromFile(file);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Saves the file to the person file that is currently open. If there is no</span></span><br><span class=\"line\"><span class=\"comment\">     * open file, the \"save as\" dialog is shown.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSave</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        File personFile = main.getPersonFilePath();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (personFile != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            main.savePersonDataToFile(personFile);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handleSaveAs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens a FileChooser to let the user select a file to save to.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSaveAs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileChooser fileChooser = <span class=\"keyword\">new</span> FileChooser();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set extension filter</span></span><br><span class=\"line\">        FileChooser.ExtensionFilter extFilter = <span class=\"keyword\">new</span> FileChooser.ExtensionFilter(</span><br><span class=\"line\">                <span class=\"string\">\"XML files (*.xml)\"</span>, <span class=\"string\">\"*.xml\"</span>);</span><br><span class=\"line\">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show save file dialog</span></span><br><span class=\"line\">        File file = fileChooser.showSaveDialog(main.getPrimaryStage());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Make sure it has the correct extension</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!file.getPath().endsWith(<span class=\"string\">\".xml\"</span>)) &#123;</span><br><span class=\"line\">                file = <span class=\"keyword\">new</span> File(file.getPath() + <span class=\"string\">\".xml\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            main.savePersonDataToFile(file);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens an about dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAbout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, <span class=\"string\">\"About\"</span>, <span class=\"string\">\"Author: Tan\\\\nWebsite: https://guitoubing.top\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Closes the application.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleExit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens the birthday statistics.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleShowBirthdayStatistics</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        main.showBirthdayStatistics();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"连接FXML文件和Controller、绑定菜单和对应动作\"><a href=\"#连接FXML文件和Controller、绑定菜单和对应动作\" class=\"headerlink\" title=\"连接FXML文件和Controller、绑定菜单和对应动作\"></a>连接FXML文件和Controller、绑定菜单和对应动作</h5><p><img src=\"/img/image-20181027233726178.png\" alt=\"image-20181027233726178\"></p>\n<p><img src=\"/img/image-20181027233529314.png\" alt=\"image-20181027233529314\"></p>\n<h5 id=\"在Main中部署该控制器-1\"><a href=\"#在Main中部署该控制器-1\" class=\"headerlink\" title=\"在Main中部署该控制器\"></a>在Main中部署该控制器</h5><p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Initializes the root layout.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initRootLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Load root layout from fxml file.</span></span><br><span class=\"line\">           FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">           loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/RootLayout.fxml\"</span>));</span><br><span class=\"line\">           rootLayout = (BorderPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Show the scene containing the root layout.</span></span><br><span class=\"line\">           Scene scene = <span class=\"keyword\">new</span> Scene(rootLayout);</span><br><span class=\"line\">           primaryStage.setScene(scene);</span><br><span class=\"line\"></span><br><span class=\"line\">           RootLayoutController controller = loader.getController();</span><br><span class=\"line\">           controller.setMain(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           primaryStage.show();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       File file = getPersonFilePath();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           loadPersonDataFromFile(file);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://code.makery.ch/\" target=\"_blank\" rel=\"noopener\">code.makery —— JavaFX中文教程</a></li>\n<li><a href=\"https://www.tutorialspoint.com/javafx/\" target=\"_blank\" rel=\"noopener\">JavaFX Tutorial</a></li>\n<li><a href=\"https://blog.csdn.net/hadues/article/details/79188793\" target=\"_blank\" rel=\"noopener\">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a></li>\n<li><a href=\"http://fxexperience.com/controlsfx/\" target=\"_blank\" rel=\"noopener\">fxexperience —— ControlFX</a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" target=\"_blank\" rel=\"noopener\">Java SE8 —— Lambda</a></li>\n<li>…………</li>\n</ol>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>本博主要是在学习<a href=\"https://code.makery.ch/\" target=\"_blank\" rel=\"noopener\">code.makery —— JavaFX中文教程</a>博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是<code>JDK 8u40</code>，我这里使用的是<code>Java 10 2018-03-20</code>）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击<a href=\"http://getme.guitoubing.top/JavaFX_PRE.zip\" target=\"_blank\" rel=\"noopener\">JavaFX-Test</a>中获取源码。</p>\n<p>希望藉此次<code>JavaFX</code>学习开启我的Java源码学习之旅，道阻且长！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JavaFX小记\"><a href=\"#JavaFX小记\" class=\"headerlink\" title=\"JavaFX小记\"></a>JavaFX小记</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><p>JavaFX</p>\n<p><code>JavaFX</code>是由<a href=\"https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8\" target=\"_blank\" rel=\"noopener\">甲骨文(Oracle)公司</a>推出的一系列的产品和技术，主要应用于创建Rich Internet application(<a href=\"https://zh.wikipedia.org/wiki/RIA\" target=\"_blank\" rel=\"noopener\">RIAs</a>)，它是一个跨平台的桌面应用程序开发框架。</p>\n</li>\n</ul>","more":"<ul>\n<li><p>典型的MVC架构</p>\n<ul>\n<li>定义<code>Model</code>，使用<code>javafx.beans</code>封装类型定义属性类型</li>\n<li>使用<code>fxml</code>文件创建<code>View</code>，利用SceneBuilder工具进行布局</li>\n<li>创建<code>Controller</code>实现动作操作以及<code>Model</code>和<code>View</code>的联系</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><ul>\n<li><strong>创建FXML文件，利用SceneBuilder工具进行布局</strong></li>\n</ul>\n<h2 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h2><ul>\n<li><p><strong>定义<code>Model</code>中的<code>Person</code>类，使用<code>Property</code>和<code>Bind</code></strong></p>\n<p><code>java.beans</code>包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，<code>Property</code>和<code>Bind</code>方便我们实现以下功能：当某个属性如<code>First Name</code>被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考<a href=\"https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm\" target=\"_blank\" rel=\"noopener\">JavaFX文档</a>。</p>\n<p><strong>Person.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.IntegerProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.ObjectProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleIntegerProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleObjectProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.SimpleStringProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.beans.property.StringProperty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Model class for a Person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty firstName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty lastName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty street;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IntegerProperty postalCode;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringProperty city;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ObjectProperty&lt;LocalDate&gt; birthday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Default constructor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructor with some initial data.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> firstName</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lastName</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String firstName, String lastName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstName = <span class=\"keyword\">new</span> SimpleStringProperty(firstName);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastName = <span class=\"keyword\">new</span> SimpleStringProperty(lastName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Some initial dummy data, just for convenient testing.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.street = <span class=\"keyword\">new</span> SimpleStringProperty(<span class=\"string\">\"some street\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.postalCode = <span class=\"keyword\">new</span> SimpleIntegerProperty(<span class=\"number\">1234</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city = <span class=\"keyword\">new</span> SimpleStringProperty(<span class=\"string\">\"some city\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday = <span class=\"keyword\">new</span> SimpleObjectProperty&lt;LocalDate&gt;(LocalDate.of(<span class=\"number\">1999</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFirstName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFirstName</span><span class=\"params\">(String firstName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstName.set(firstName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">firstNameProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastName.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastName.set(lastName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">lastNameProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getStreet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> street.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStreet</span><span class=\"params\">(String street)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.street.set(street);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">streetProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> street;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPostalCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> postalCode.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPostalCode</span><span class=\"params\">(<span class=\"keyword\">int</span> postalCode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.postalCode.set(postalCode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntegerProperty <span class=\"title\">postalCodeProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> postalCode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> city.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCity</span><span class=\"params\">(String city)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city.set(city);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringProperty <span class=\"title\">cityProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalDate <span class=\"title\">getBirthday</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirthday</span><span class=\"params\">(LocalDate birthday)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday.set(birthday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObjectProperty&lt;LocalDate&gt; <span class=\"title\">birthdayProperty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用<code>ObservableList</code>管理<code>Person</code></strong></p>\n<p>前一点所述的<u><strong>后续</strong></u>操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是<code>ObservableList</code>，<code>ObservableList</code>继承了<code>List</code>类、实现了<code>Observable</code>接口，其实现视图和数据同步的方法是在声明<code>ObservableList</code>时为方法传递一个监听器，此监听器需要会通过监听<code>personData</code>的变化同步改变视图中对应的值，可参考<a href=\"https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html\" target=\"_blank\" rel=\"noopener\">ObservableList文档</a></p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*......Other variables......*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * The data of a observable list of Persons</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ObservableList&lt;Person&gt; personData = FXCollections.observableArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ObservableList&lt;Person&gt; <span class=\"title\">getPersonData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Tan\"</span>, <span class=\"string\">\"Rui\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Chao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Liang\"</span>, <span class=\"string\">\"Chengwei\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Xiao\"</span>, <span class=\"string\">\"Xin\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Li\"</span>, <span class=\"string\">\"Yang\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Runqian\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Liang\"</span>, <span class=\"string\">\"Yongchao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Luo\"</span>, <span class=\"string\">\"Jihao\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Chen\"</span>, <span class=\"string\">\"Zhi\"</span>));</span><br><span class=\"line\">        personData.add(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Fan\"</span>, <span class=\"string\">\"Fan\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* ......Other function..... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><h3 id=\"PersonOverviewController-java\"><a href=\"#PersonOverviewController-java\" class=\"headerlink\" title=\"PersonOverviewController.java\"></a>PersonOverviewController.java</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Label;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TableColumn;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TableView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.Main;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.model.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonOverviewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableView&lt;Person&gt; personTable;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableColumn&lt;Person, String&gt; firstNameColumn;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TableColumn&lt;Person, String&gt; lastNameColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label firstNameLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label lastNameLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label streetLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label postalCodeLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label cityLabel;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Label birthdayLabel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Reference to the main application.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Main main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The constructor.</span></span><br><span class=\"line\"><span class=\"comment\">     * The constructor is called before the initialize() method.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PersonOverviewController</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Initializes the controller class. This method is automatically called</span></span><br><span class=\"line\"><span class=\"comment\">     * after the fxml file has been loaded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialize the person table with the two columns.</span></span><br><span class=\"line\">        firstNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class=\"line\">        lastNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Is called by the main application to give a reference back to itself.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> main</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMain</span><span class=\"params\">(Main main)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.main = main;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Add observable list data to the table</span></span><br><span class=\"line\">        personTable.setItems(main.getPersonData());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>@FXML</code>注解（Annotation）</strong></p>\n<p>使用<code>@FXML</code>注解可以将操作的属性、方法绑定到<code>FXML</code>文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用<code>@FXML</code>注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！</p>\n</li>\n<li><p><strong><code>initialize()</code>方法</strong></p>\n<p><code>initialize()</code>字面意思可知其是用于初始化对应<code>FXML</code>文件中的属性，此方法会在加载<code>FXML</code>文件时被自动执行，此时，所有的<code>FXML</code>属性都应已被初始化</p>\n</li>\n<li><p><strong><code>setCellValueFactory(...)</code>方法</strong></p>\n<p>我们对表格列上使用<code>setCellValueFactory(...)</code>方法来确定为特定列使用前面<code>Person</code>的某个属性。<code>-&gt;</code>表示使用的是<a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" target=\"_blank\" rel=\"noopener\">Lambdas</a>特性；另外一种方法是使用<a href=\"https://docs.oracle.com/javase/8/javafx/api/\" target=\"_blank\" rel=\"noopener\">PropertyValueFactory</a>(待研究…)。</p>\n<p>这里我们之所以可以使用<code>cellData -&gt; cellData.getValue().firstNameProperty()</code>，便是因为之前我们将Person的属性都定义为<code>javafx.beans</code>中的封装属性，<code>firstNameProperty()</code>等方法都会在声明成<code>Beans</code>封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便</p>\n</li>\n</ul>\n<h3 id=\"连接Main和PersonOverviewController\"><a href=\"#连接Main和PersonOverviewController\" class=\"headerlink\" title=\"连接Main和PersonOverviewController\"></a>连接Main和PersonOverviewController</h3><ul>\n<li><p><strong><code>showPersonOverview()</code> 方法</strong></p>\n<p><strong>Main.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Shows the person overview inside the root layout.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showPersonOverview</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Load person overview.</span></span><br><span class=\"line\">        FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">        loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/PersonOverview.fxml\"</span>));</span><br><span class=\"line\">        AnchorPane personOverview = (AnchorPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set person overview into the center of root layout.</span></span><br><span class=\"line\">        rootLayout.setCenter(personOverview);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Give the controller access to the main app.</span></span><br><span class=\"line\">        PersonOverviewController controller = loader.getController();</span><br><span class=\"line\">        controller.setMain(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"将View与Controller绑定\"><a href=\"#将View与Controller绑定\" class=\"headerlink\" title=\"将View与Controller绑定\"></a>将View与Controller绑定</h3><p>我们还需要为<code>FXML文件</code>指定其对应的<code>Controller</code>，以及<code>FXML元素</code>与<code>控制器的属性</code>的对应关系，这是因为FXML文件中的元素只能被对应<code>Controller</code>修改更新，若在其他方法中修改会产生运行时错误。例如：在<code>PersonOverviewController.java</code>中将某个<code>Label</code>返回到<code>Main.java</code>中而后在其中修改该<code>Label</code>的值，意即在<code>非FX线程</code>中执行<code>FX线程</code>相关的任务，则会造成当前的线程阻塞，解决方法之一是使用<code>Platform.runLater()</code>方法，如下所示，括号中的<code>FX线程</code>相关任务便不会阻塞当前进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Platform.runLater(() -&gt; &#123;</span><br><span class=\"line\">        ………相关FX线程代码………</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当然，最好的选择还是讲<code>FX线程</code>任务和其他任务区分开来，将特定的<code>FXML文件</code>与对应的<code>Controller</code>联系起来，当需要建立联系时可通过之前所说的使用<code>java.beans</code>、<code>ObservableList</code>等方法实现动态更新视图。</p>\n<ul>\n<li><p><strong>为<code>FXML文件</code>指定<code>Controller</code></strong></p>\n<p>在Eclipse中好像有图形化界面直接为<code>FXML文件</code>选择<code>Controller</code>的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。</p>\n<p><strong>PersonOverview.fxml</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">AnchorPane</span> <span class=\"attr\">maxHeight</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">maxWidth</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">minHeight</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">minWidth</span>=<span class=\"string\">\"-Infinity\"</span> <span class=\"attr\">prefHeight</span>=<span class=\"string\">\"300.0\"</span> <span class=\"attr\">prefWidth</span>=<span class=\"string\">\"600.0\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://javafx.com/javafx/8.0.121\"</span> <span class=\"attr\">xmlns:fx</span>=<span class=\"string\">\"http://javafx.com/fxml/1\"</span> <span class=\"attr\">fx:controller</span>=<span class=\"string\">\"com.tanrui.view.PersonOverviewController\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">children</span>&gt;</span></span><br><span class=\"line\">        &lt;? ... 内容省略 ... ?&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">children</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">AnchorPane</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如上述代码所述，在顶层节点（此处是<code>AnchorPane</code>）标签中添加属性如下：<code>fx:controller=&quot;com.tanrui.view.PersonOverviewController”</code>，以此为<code>FXML文件</code>指定<code>Controller</code></p>\n</li>\n<li><p>为<code>FXML元素</code>指定<code>fx:id</code>，使其绑定对应的<code>控制器属性</code></p>\n<p><img src=\"/img/image-20181023205748006.png\" alt=\"image-20181023205748006\"></p>\n<p>如图，选定特定元素，在右侧界面找到<code>Code</code>-&gt;<code>fx:id</code>，将其对应的控制器属性填入即可</p>\n</li>\n</ul>\n<h3 id=\"Details界面更新\"><a href=\"#Details界面更新\" class=\"headerlink\" title=\"Details界面更新\"></a>Details界面更新</h3><ul>\n<li><p><strong><code>showPersonDetails(Person person)</code>方法</strong></p>\n<p><code>showPersonDetails(Person person)</code>方法用于使用Person实例的数据填写标签。</p>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fills all text fields to show details about the person.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the specified person is null, all text fields are cleared.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> person the person or null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">showPersonDetails</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (person != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Fill the labels with info from the person object.</span></span><br><span class=\"line\">        firstNameLabel.setText(person.getFirstName());</span><br><span class=\"line\">        lastNameLabel.setText(person.getLastName());</span><br><span class=\"line\">        streetLabel.setText(person.getStreet());</span><br><span class=\"line\">        postalCodeLabel.setText(Integer.toString(person.getPostalCode()));</span><br><span class=\"line\">        cityLabel.setText(person.getCity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We need a way to convert the birthday into a String!</span></span><br><span class=\"line\">        <span class=\"comment\">// birthdayLabel.setText(...);</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Person is null, remove all the text.</span></span><br><span class=\"line\">        firstNameLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        lastNameLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        streetLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        postalCodeLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        cityLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        birthdayLabel.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监听用户在人员表中的选择</strong></p>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Initialize the person table with the two columns.</span></span><br><span class=\"line\">    firstNameColumn.setCellValueFactory(</span><br><span class=\"line\">            cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class=\"line\">    lastNameColumn.setCellValueFactory(</span><br><span class=\"line\">            cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear person details.</span></span><br><span class=\"line\">    showPersonDetails(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Listen for selection changes and show the person details when changed.</span></span><br><span class=\"line\">    personTable.getSelectionModel().selectedItemProperty().addListener(</span><br><span class=\"line\">            (observable, oldValue, newValue) -&gt; showPersonDetails(newValue));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"删除按钮事件\"><a href=\"#删除按钮事件\" class=\"headerlink\" title=\"删除按钮事件\"></a>删除按钮事件</h3><p>我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下：</p>\n<p><strong>PersonOverviewController.java</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks on the delete button.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDeletePerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedIndex &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            personTable.getItems().remove(selectedIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>从上述代码可以看到我们使用了条件判断语句来判断<code>selectedIndex</code>的值，当其小于0时，正常情况我们应该会让其抛出<code>ArrayIndexOutOfBoundsException</code>异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了<code>controlsfx</code>包，用于弹出各类提示框（可在<a href=\"http://fxexperience.com/controlsfx/\" target=\"_blank\" rel=\"noopener\">ControlsFX</a>官网获取）。</p>\n<p><code>controlsfx</code>有两个主要的版本，同时对于不同的版本，二者的用法也不同：</p>\n<ul>\n<li>对于Java 8，需要下载<a href=\"http://fxexperience.com/downloads/controlsfx-8-40-14/\" target=\"_blank\" rel=\"noopener\">ControlsFX 8.40.14</a>包</li>\n<li>对于Java 9及以上，需要下载<a href=\"http://fxexperience.com/downloads/controlsfx-9-0-0/\" target=\"_blank\" rel=\"noopener\">ControlsFX 9.0.0</a>包</li>\n</ul>\n<p>我们这里用到的是Java 10，因此使用<code>ControlsFX 9.0.0</code>，使用方法如下：</p>\n<p><strong>ShowDialog.java</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.Stage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Util to create and show Dialog.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Tan Rui</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShowDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stage stage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Alert.AlertType type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShowDialog</span><span class=\"params\">(Stage stage, Alert.AlertType type, String title, String message)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stage = stage;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ShowSpecificDialog</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Alert dlg = <span class=\"keyword\">new</span> Alert(type);</span><br><span class=\"line\">        dlg.initOwner(stage);</span><br><span class=\"line\">        dlg.setTitle(title);</span><br><span class=\"line\">        dlg.getDialogPane().setContentText(message);</span><br><span class=\"line\">        dlg.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>PersonOverviewController.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks on the delete button.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDeletePerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedIndex &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            personTable.getItems().remove(selectedIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建和编辑对话框\"><a href=\"#新建和编辑对话框\" class=\"headerlink\" title=\"新建和编辑对话框\"></a>新建和编辑对话框</h3><blockquote>\n<p>Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是：</p>\n<ol>\n<li>创建FXML文件，使用SceneBuilder编辑界面；</li>\n<li>创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等；</li>\n<li>连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性；</li>\n<li>在Main函数中加载该控制器</li>\n</ol>\n</blockquote>\n<p>为之前的<code>New</code>和<code>Edit</code>按钮添加动作，弹出对话框（新的Stage）。</p>\n<h4 id=\"设计对话框\"><a href=\"#设计对话框\" class=\"headerlink\" title=\"设计对话框\"></a>设计对话框</h4><p>创建<code>PersonEditDialog.fxml</code>，完成弹出对话框的设计：</p>\n<p><img src=\"/img/image-20181027150559447.png\" alt=\"image-20181027150559447\"></p>\n<h4 id=\"创建控制器\"><a href=\"#创建控制器\" class=\"headerlink\" title=\"创建控制器\"></a>创建控制器</h4><p>为对话框创建控制器<code>PersonEditDialogController.java</code>。</p>\n<p><strong>PersonEditDialogController.java：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.ShowDialog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.TextField;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.Stage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.model.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.DateUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Dialog to edit details of a person.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Marco Jakob</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonEditDialogController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField firstNameField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField lastNameField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField streetField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField postalCodeField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField cityField;</span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextField birthdayField;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stage dialogStage;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person person;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> okClicked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Initializes the controller class. This method is automatically called</span></span><br><span class=\"line\"><span class=\"comment\">     * after the fxml file has been loaded.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the stage of this dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dialogStage</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDialogStage</span><span class=\"params\">(Stage dialogStage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dialogStage = dialogStage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the person to be edited in the dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> person</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPerson</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.person = person;</span><br><span class=\"line\"></span><br><span class=\"line\">        firstNameField.setText(person.getFirstName());</span><br><span class=\"line\">        lastNameField.setText(person.getLastName());</span><br><span class=\"line\">        streetField.setText(person.getStreet());</span><br><span class=\"line\">        postalCodeField.setText(Integer.toString(person.getPostalCode()));</span><br><span class=\"line\">        cityField.setText(person.getCity());</span><br><span class=\"line\">        birthdayField.setText(DateUtil.format(person.getBirthday()));</span><br><span class=\"line\">        birthdayField.setPromptText(<span class=\"string\">\"dd.mm.yyyy\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns true if the user clicked OK, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOkClicked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> okClicked;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks ok.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOk</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInputValid()) &#123;</span><br><span class=\"line\">            person.setFirstName(firstNameField.getText());</span><br><span class=\"line\">            person.setLastName(lastNameField.getText());</span><br><span class=\"line\">            person.setStreet(streetField.getText());</span><br><span class=\"line\">            person.setPostalCode(Integer.parseInt(postalCodeField.getText()));</span><br><span class=\"line\">            person.setCity(cityField.getText());</span><br><span class=\"line\">            person.setBirthday(DateUtil.parse(birthdayField.getText()));</span><br><span class=\"line\"></span><br><span class=\"line\">            okClicked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            dialogStage.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when the user clicks cancel.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        dialogStage.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Validates the user input in the text fields.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true if the input is valid</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInputValid</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String errorMessage = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstNameField.getText() == <span class=\"keyword\">null</span> || firstNameField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid first name!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastNameField.getText() == <span class=\"keyword\">null</span> || lastNameField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid last name!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (streetField.getText() == <span class=\"keyword\">null</span> || streetField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid street!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (postalCodeField.getText() == <span class=\"keyword\">null</span> || postalCodeField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid postal code!\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Integer.parseInt(postalCodeField.getText());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">                errorMessage += <span class=\"string\">\"No valid postal code (must be an integer)!\\n\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cityField.getText() == <span class=\"keyword\">null</span> || cityField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid city!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (birthdayField.getText() == <span class=\"keyword\">null</span> || birthdayField.getText().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            errorMessage += <span class=\"string\">\"No valid birthday!\\n\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!DateUtil.validDate(birthdayField.getText())) &#123;</span><br><span class=\"line\">                errorMessage += <span class=\"string\">\"No valid birthday. Use the format dd.mm.yyyy!\\n\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errorMessage.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ShowDialog(dialogStage, Alert.AlertType.ERROR, <span class=\"string\">\"Invalid Fields\"</span>, <span class=\"string\">\"Please correct invalid fields\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于该控制器的一些事情应该注意：</p>\n<ol>\n<li><code>setPerson(…)</code>方法可以从其它类中调用，用来设置编辑的人员。</li>\n<li>当用户点击OK按钮时，调用<code>handleOK()</code>方法。首先，通过调用<code>isInputValid()</code>方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给<code>setPerson(…)</code>。</li>\n<li>布尔值<code>okClicked</code>被使用，以便调用者决定用户是否点击OK或者Cancel按钮。</li>\n</ol>\n<h4 id=\"连接视图和控制器\"><a href=\"#连接视图和控制器\" class=\"headerlink\" title=\"连接视图和控制器\"></a>连接视图和控制器</h4><p>使用已经创建的视图（FXML）和控制器，需要连接到一起。</p>\n<ol>\n<li>使用SceneBuilder打开<code>PersonEditDialog.fxml</code>文件</li>\n<li>在左边的<em>Controller</em>组中选择<code>PersonEditDialogController</code>作为控制器类</li>\n<li>设置所有<strong>TextField</strong>的<code>fx:id</code>到相应的控制器字段上。</li>\n<li>设置两个按钮的<strong>onAction</strong>到相应的处理方法上。</li>\n</ol>\n<h4 id=\"在Main中部署该控制器\"><a href=\"#在Main中部署该控制器\" class=\"headerlink\" title=\"在Main中部署该控制器\"></a>在Main中部署该控制器</h4><p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Opens a dialog to edit details for the specified person. If the user</span></span><br><span class=\"line\"><span class=\"comment\"> * clicks OK, the changes are saved into the provided person object and true</span></span><br><span class=\"line\"><span class=\"comment\"> * is returned.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> person the person object to be edited</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the user clicked OK, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">showPersonEditDialog</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Load the fxml file and create a new stage for the popup dialog.</span></span><br><span class=\"line\">        FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">        loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/PersonEditDialog.fxml\"</span>));</span><br><span class=\"line\">        AnchorPane page = (AnchorPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create the dialog Stage.</span></span><br><span class=\"line\">        Stage dialogStage = <span class=\"keyword\">new</span> Stage();</span><br><span class=\"line\">        dialogStage.setTitle(<span class=\"string\">\"Edit Person\"</span>);</span><br><span class=\"line\">        dialogStage.initModality(Modality.WINDOW_MODAL);</span><br><span class=\"line\">        dialogStage.initOwner(primaryStage);</span><br><span class=\"line\">        Scene scene = <span class=\"keyword\">new</span> Scene(page);</span><br><span class=\"line\">        dialogStage.setScene(scene);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set the person into the controller.</span></span><br><span class=\"line\">        PersonEditDialogController controller = loader.getController();</span><br><span class=\"line\">        controller.setDialogStage(dialogStage);</span><br><span class=\"line\">        controller.setPerson(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show the dialog and wait until the user closes it</span></span><br><span class=\"line\">        dialogStage.showAndWait();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> controller.isOkClicked();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为主界面中<code>New</code>和<code>Edit</code>按钮创建OnAction方法，这些方法将从<code>Main</code>中调用<code>showPersonEditDialog(…)</code>方法。</p>\n<p><strong>PersonOverviewController.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the user clicks the new button. Opens a dialog to edit</span></span><br><span class=\"line\"><span class=\"comment\"> * details for a new person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleNewPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Person tempPerson = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> okClicked = main.showPersonEditDialog(tempPerson);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (okClicked) &#123;</span><br><span class=\"line\">        main.getPersonData().add(tempPerson);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the user clicks the edit button. Opens a dialog to edit</span></span><br><span class=\"line\"><span class=\"comment\"> * details for the selected person.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FXML</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleEditPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Person selectedPerson = personTable.getSelectionModel().getSelectedItem();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedPerson != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> okClicked = main.showPersonEditDialog(selectedPerson);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (okClicked) &#123;</span><br><span class=\"line\">            showPersonDetails(selectedPerson);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class=\"string\">\"No Person Selected\"</span>, <span class=\"string\">\"Please select a person in the table.\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而后在<code>PersonOverview.fxml</code>中为New和Edit两个按钮绑定对应的OnAction方法：</p>\n<p><img src=\"/img/image-20181027164439676.png\" alt=\"image-20181027164439676\"></p>\n<h3 id=\"数据持久化\"><a href=\"#数据持久化\" class=\"headerlink\" title=\"数据持久化\"></a>数据持久化</h3><p>我们有很多种方法来实现应用数据的持久化，例如：</p>\n<ul>\n<li>使用数据库存储</li>\n<li>使用Json文件存储</li>\n<li>使用XML文件存储</li>\n<li>……</li>\n</ul>\n<p>这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是：</p>\n<ol>\n<li>每次打开应用可加载上一次的用户数据</li>\n<li>用户可选择保存当前数据到指定XML文件</li>\n<li>用户可选择从指定XML文件加载数据</li>\n</ol>\n<h4 id=\"使用Preferences保存应用状态\"><a href=\"#使用Preferences保存应用状态\" class=\"headerlink\" title=\"使用Preferences保存应用状态\"></a>使用Preferences保存应用状态</h4><p><code>Java</code>提供了<code>Preferences</code>类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），<code>Preferences</code>类底层对各类操作系统进行了封装（实际上是<code>Windows系统</code>、<code>OS X系统</code>和<code>类Unix文件系统</code>三种），用户配置在<code>Windows系统</code>上可能保存在注册表中、在<code>类Unix文件系统</code>上可能保存在<code>/tmp</code>下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道<code>Preferences</code>类是用来保存用户配置即可。用法如下：</p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the person file preference, i.e. the file that was last opened.</span></span><br><span class=\"line\"><span class=\"comment\">     * The preference is read from the OS specific registry. If no such</span></span><br><span class=\"line\"><span class=\"comment\">     * preference can be found, null is returned.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getPersonFilePath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class=\"line\">        String filePath = prefs.get(<span class=\"string\">\"filePath\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filePath != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Sets the file path of the currently loaded file. The path is persisted in</span></span><br><span class=\"line\"><span class=\"comment\">     * the OS specific registry.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file the file or null to remove the path</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPersonFilePath</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prefs.put(<span class=\"string\">\"filePath\"</span>, file.getPath());</span><br><span class=\"line\">            <span class=\"comment\">// Update the stage title.</span></span><br><span class=\"line\">            primaryStage.setTitle(<span class=\"string\">\"AddressApp - \"</span> + file.getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prefs.remove(<span class=\"string\">\"filePath\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Update the stage title.</span></span><br><span class=\"line\">            primaryStage.setTitle(<span class=\"string\">\"AddressApp\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用JAXB\"><a href=\"#使用JAXB\" class=\"headerlink\" title=\"使用JAXB\"></a>使用JAXB</h4><p><code>JAXB包</code>是Java中提供的对数据进行<code>编列(marshall)</code>成XML文件以及对XML文件<code>反编列(unmarshall)</code>为数据结构的包，<code>Java SE</code>中有如下支持类型：<code>JAXB 2.0</code>是<code>JDK 1.6</code>的组成部分。<code>JAXB 2.2.3</code>是<code>JDK 1.7以上</code>的组成部分，而实际上在<code>Java 9</code>之后就已将<code>JAXB</code>包移除，因此使用时需添加额外的lib包，详情可见博客<a href=\"https://blog.csdn.net/hadues/article/details/79188793\" target=\"_blank\" rel=\"noopener\">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a>。</p>\n<h5 id=\"JAXB模型类\"><a href=\"#JAXB模型类\" class=\"headerlink\" title=\"JAXB模型类\"></a>JAXB模型类</h5><p>我们希望持久化的数据应该是<code>Main</code>中的<code>personData</code>，而<code>JAXB</code>有以下要求：</p>\n<ul>\n<li>使用<code>@XmlRootElement</code>定义<code>XML根元素</code>的名称</li>\n<li>使用<code>@XmlElement</code>指定一个<code>XML元素</code>，可选</li>\n</ul>\n<p>而<code>Main</code>中的<code>personData</code>是<code>ObservableList</code>类型，由于<code>ObservableList</code>类型不支持添加注解，因此我们需要创建另外一个能保存<code>Person</code>列表同时又能存储为<code>XML文件</code>的类，如下。</p>\n<p><strong>PersonListWrapper.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.bind.annotation.XmlElement;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Helper class to wrap a list of persons. This is used for saving the</span></span><br><span class=\"line\"><span class=\"comment\"> * list of persons to XML.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@XmlRootElement</span>(name = <span class=\"string\">\"persons\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonListWrapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@XmlElement</span>(name = <span class=\"string\">\"person\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">getPersons</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> persons;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPersons</span><span class=\"params\">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.persons = persons;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用JAXB读写数据到XML文件\"><a href=\"#使用JAXB读写数据到XML文件\" class=\"headerlink\" title=\"使用JAXB读写数据到XML文件\"></a>使用JAXB读写数据到XML文件</h5><p>我们将读写XML文件的逻辑放到<code>Main类</code>中，<code>Controller</code>在用到相应的逻辑时，直接调用<code>Main</code>中的方法即可。</p>\n<p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Loads person data from the specified file. The current person data will</span></span><br><span class=\"line\"><span class=\"comment\"> * be replaced.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadPersonDataFromFile</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        JAXBContext context = JAXBContext</span><br><span class=\"line\">                .newInstance(PersonListWrapper.class);</span><br><span class=\"line\">        Unmarshaller um = context.createUnmarshaller();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reading XML from the file and unmarshalling.</span></span><br><span class=\"line\">        PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file);</span><br><span class=\"line\"></span><br><span class=\"line\">        personData.clear();</span><br><span class=\"line\">        personData.addAll(wrapper.getPersons());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Save the file path to the registry.</span></span><br><span class=\"line\">        setPersonFilePath(file);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// catches ANY exception</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(<span class=\"keyword\">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class=\"string\">\"Error\"</span>, <span class=\"string\">\"Could not save data to file:\\n\"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Saves the current person data to the specified file.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">savePersonDataToFile</span><span class=\"params\">(File file)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class);</span><br><span class=\"line\">        Marshaller m = context.createMarshaller();</span><br><span class=\"line\">        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Wrapping our person data.</span></span><br><span class=\"line\">        PersonListWrapper wrapper = <span class=\"keyword\">new</span> PersonListWrapper();</span><br><span class=\"line\">        wrapper.setPersons(personData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Marshalling and saving XML to the file.</span></span><br><span class=\"line\">        m.marshal(wrapper, file);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Save the file path to the registry.</span></span><br><span class=\"line\">        setPersonFilePath(file);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// catches ANY exception</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(<span class=\"keyword\">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class=\"string\">\"Error\"</span>, <span class=\"string\">\"Could not save data to file:\\n\"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>编组(marshall):savePersonDataToFile(…)</code>和<code>解组(unmarshall):loadPersonDataFromFile(…)</code>已准备好，下面在界面中使用它。</p>\n<h4 id=\"创建打开和保存菜单\"><a href=\"#创建打开和保存菜单\" class=\"headerlink\" title=\"创建打开和保存菜单\"></a>创建打开和保存菜单</h4><h5 id=\"为File菜单添加子项\"><a href=\"#为File菜单添加子项\" class=\"headerlink\" title=\"为File菜单添加子项\"></a>为File菜单添加子项</h5><p><img src=\"/img/image-20181027232418408.png\" alt=\"image-20181027232418408\"></p>\n<h5 id=\"处理菜单相应动作\"><a href=\"#处理菜单相应动作\" class=\"headerlink\" title=\"处理菜单相应动作\"></a>处理菜单相应动作</h5><p><code>Controller</code>中使用<code>FileChooser</code>的方法，<code>FileChooser</code>同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。</p>\n<p>本类中使用了<code>FileChooser.ExtensionFilter</code>，对文件系统中文件进行过滤，保留<code>.xml</code>结尾的文件。</p>\n<p>当用户选择特定文件而后点击<code>打开</code>按钮时，会返回该文件，否则返回<code>Null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tanrui.view;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.Main;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.tanrui.util.ShowDialog;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.fxml.FXML;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.scene.control.Alert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javafx.stage.FileChooser;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The controller for the root layout. The root layout provides the basic</span></span><br><span class=\"line\"><span class=\"comment\"> * application layout containing a menu bar and space where other JavaFX</span></span><br><span class=\"line\"><span class=\"comment\"> * elements can be placed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootLayoutController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Reference to the main application</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Main main;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Is called by the main application to give a reference back to itself.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> main</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMain</span><span class=\"params\">(Main main)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.main = main;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates an empty address book.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleNew</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        main.getPersonData().clear();</span><br><span class=\"line\">        main.setPersonFilePath(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens a FileChooser to let the user select an address book to load.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOpen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileChooser fileChooser = <span class=\"keyword\">new</span> FileChooser();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set extension filter</span></span><br><span class=\"line\">        FileChooser.ExtensionFilter extFilter = <span class=\"keyword\">new</span> FileChooser.ExtensionFilter(</span><br><span class=\"line\">                <span class=\"string\">\"XML files (*.xml)\"</span>, <span class=\"string\">\"*.xml\"</span>);</span><br><span class=\"line\">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show save file dialog</span></span><br><span class=\"line\">        File file = fileChooser.showOpenDialog(main.getPrimaryStage());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            main.loadPersonDataFromFile(file);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Saves the file to the person file that is currently open. If there is no</span></span><br><span class=\"line\"><span class=\"comment\">     * open file, the \"save as\" dialog is shown.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSave</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        File personFile = main.getPersonFilePath();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (personFile != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            main.savePersonDataToFile(personFile);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handleSaveAs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens a FileChooser to let the user select a file to save to.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSaveAs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileChooser fileChooser = <span class=\"keyword\">new</span> FileChooser();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set extension filter</span></span><br><span class=\"line\">        FileChooser.ExtensionFilter extFilter = <span class=\"keyword\">new</span> FileChooser.ExtensionFilter(</span><br><span class=\"line\">                <span class=\"string\">\"XML files (*.xml)\"</span>, <span class=\"string\">\"*.xml\"</span>);</span><br><span class=\"line\">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Show save file dialog</span></span><br><span class=\"line\">        File file = fileChooser.showSaveDialog(main.getPrimaryStage());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Make sure it has the correct extension</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!file.getPath().endsWith(<span class=\"string\">\".xml\"</span>)) &#123;</span><br><span class=\"line\">                file = <span class=\"keyword\">new</span> File(file.getPath() + <span class=\"string\">\".xml\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            main.savePersonDataToFile(file);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens an about dialog.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAbout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, <span class=\"string\">\"About\"</span>, <span class=\"string\">\"Author: Tan\\\\nWebsite: https://guitoubing.top\"</span>).ShowSpecificDialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Closes the application.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleExit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Opens the birthday statistics.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@FXML</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleShowBirthdayStatistics</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        main.showBirthdayStatistics();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"连接FXML文件和Controller、绑定菜单和对应动作\"><a href=\"#连接FXML文件和Controller、绑定菜单和对应动作\" class=\"headerlink\" title=\"连接FXML文件和Controller、绑定菜单和对应动作\"></a>连接FXML文件和Controller、绑定菜单和对应动作</h5><p><img src=\"/img/image-20181027233726178.png\" alt=\"image-20181027233726178\"></p>\n<p><img src=\"/img/image-20181027233529314.png\" alt=\"image-20181027233529314\"></p>\n<h5 id=\"在Main中部署该控制器-1\"><a href=\"#在Main中部署该控制器-1\" class=\"headerlink\" title=\"在Main中部署该控制器\"></a>在Main中部署该控制器</h5><p><strong>Main.java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Initializes the root layout.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initRootLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Load root layout from fxml file.</span></span><br><span class=\"line\">           FXMLLoader loader = <span class=\"keyword\">new</span> FXMLLoader();</span><br><span class=\"line\">           loader.setLocation(Main.class.getResource(<span class=\"string\">\"view/RootLayout.fxml\"</span>));</span><br><span class=\"line\">           rootLayout = (BorderPane) loader.load();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Show the scene containing the root layout.</span></span><br><span class=\"line\">           Scene scene = <span class=\"keyword\">new</span> Scene(rootLayout);</span><br><span class=\"line\">           primaryStage.setScene(scene);</span><br><span class=\"line\"></span><br><span class=\"line\">           RootLayoutController controller = loader.getController();</span><br><span class=\"line\">           controller.setMain(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           primaryStage.show();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       File file = getPersonFilePath();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (file != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           loadPersonDataFromFile(file);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://code.makery.ch/\" target=\"_blank\" rel=\"noopener\">code.makery —— JavaFX中文教程</a></li>\n<li><a href=\"https://www.tutorialspoint.com/javafx/\" target=\"_blank\" rel=\"noopener\">JavaFX Tutorial</a></li>\n<li><a href=\"https://blog.csdn.net/hadues/article/details/79188793\" target=\"_blank\" rel=\"noopener\">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a></li>\n<li><a href=\"http://fxexperience.com/controlsfx/\" target=\"_blank\" rel=\"noopener\">fxexperience —— ControlFX</a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" target=\"_blank\" rel=\"noopener\">Java SE8 —— Lambda</a></li>\n<li>…………</li>\n</ol>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>本博主要是在学习<a href=\"https://code.makery.ch/\" target=\"_blank\" rel=\"noopener\">code.makery —— JavaFX中文教程</a>博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是<code>JDK 8u40</code>，我这里使用的是<code>Java 10 2018-03-20</code>）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击<a href=\"http://getme.guitoubing.top/JavaFX_PRE.zip\" target=\"_blank\" rel=\"noopener\">JavaFX-Test</a>中获取源码。</p>\n<p>希望藉此次<code>JavaFX</code>学习开启我的Java源码学习之旅，道阻且长！</p>"},{"title":"C# - ADO.NET配置说明","date":"2019-04-18T03:04:15.000Z","_content":"\n## 概述\n\n`ADO.NET`提供对数据库如`MySQL`和`XML`这样的数据源以及通过`OLE DB`和`ODBC`公开的数据源的一致访问。共享数据的使用方应用程序可以使用`ADO.NET`连接到这些数据源，并可以检索、处理和更新其中包含的数据。\n\n<!-- more -->\n\n## 安装MySQL数据库\n\n### 创建数据库\n\n```shell\nPS A:\\> cd .\\MySQL\\mysql-5.7.25-winx64\\bin\\\n\n# 安装MySQL服务\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> .\\mysqld install\n\n# 初始化MySQL数据库，创建无root密码的root用户\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysqld --initialize-insecure\n\n# 启动MySQL服务\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> net start mysql\nMySQL 服务正在启动 .\nMySQL 服务已经启动成功。\n\n# 创建用户，设置密码并赋予权限\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysql -uroot\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 2\nServer version: 5.7.25 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n# 创建用户并设置密码\nmysql> create user 'tanrui'@'localhost' identified by 'tanrui';\nQuery OK, 0 rows affected (0.00 sec)\n# 赋予权限\nmysql> grant all privileges on *.* to 'tanrui'@'localhost';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> exit\nBye\n# 以新用户登录数据库\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysql -utanrui -ptanrui\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 7\nServer version: 5.7.25 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n# 创建数据库\nmysql> create database Assignment4;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| assignment4        |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n```\n\n### 使用DataGrip连接数据库\n\n设置连接参数如下，点击`OK`完成连接：\n\n![1555227842703](/images/1555227842703.png)\n\n右键`assignment4`数据库点击`New`->`Table`创建`Student`和`Score`新表：\n\n![1555227964411](/images/1555227964411.png)\n\n![1555228253075](/images/1555228253075.png)\n\n![1555228331186](/images/1555228331186.png)\n\n## Visual Studio Nuget包管理\n\n本次实验需要用到`MySQL`一些操作，因此需要在`Visual Studio`中添加相应的包，如下：\n\n![image-20190414160931753](/images/image-20190414160931753.png)\n\n打开`Nuget包管理器`，下载`Mysql.Data`和`System.Data.DataSetExtensions`两个包，前者提供`MySQL`连接驱动，后者主要是提供`C#`中对于数据库表操作的一些语法支持。\n\n![image-20190414161020200](/images/image-20190414161020200.png)\n\n## ADONET基础编程\n\n### 一个小示例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Data;\nusing MySql.Data.MySqlClient;\n\nnamespace ADONET\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            //ADO.NET 几个关键对象\n            //(1) Connection对象 用于连接数据库\n            //(2) Command对象 对数据源执行命令\n            //(3) DataReader对象 用户从数据源读取数据\n            //(4) DataAdapter对象 从数据源读取数据并且填充数据集对象 \n            //(5) DataSet对象 相当于内存数据库\n            //(6) DataTable对象 相当于内存数据库中的表格\n            string connString = \"server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4\";\n            MySqlConnection conn = new MySqlConnection(connString);\n            conn.Open();\n\n            MySqlCommand cmd = new MySqlCommand();\n            cmd.Connection = conn;\n            //ExecuteNonQuery的简单使用\n                        cmd.CommandText = \"insert into Student values (1,'zhangsan1',20)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Student values (2,'zhangsan2',19)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Student values (3,'zhangsan3',22)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (1,80,85)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (2,90,95)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (3,86,75)\";\n                        cmd.ExecuteNonQuery();\n                       \n            //参数化查询的使用，是目前唯一可以预防SQL Injection的方法\n            cmd.CommandText = @\"INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)\";\n                        cmd.Parameters.Add(new MySqlParameter(\"@Id\", 100));\n                        cmd.Parameters.Add(new MySqlParameter(\"@Name\",\n            \"newstudent\"));\n                        cmd.Parameters.Add(new MySqlParameter(\"@Age\", 18));\n                        cmd.ExecuteNonQuery();\n            //ExecuteReader的简单使用\n            cmd.CommandText = \"select Count(*) from Student\";\n            object nRows = cmd.ExecuteScalar();\n            Console.WriteLine(\"nRows: {0}\", nRows);\n\ncmd.CommandText = \"select * from Student\";\n            MySqlDataReader dr = cmd.ExecuteReader();\n            while(dr.Read())\n            {\n                 Console.WriteLine(\"One Row: {0},{1},{2}\",\ndr.GetValue(0), dr[\"Name\"], dr.GetValue( dr.GetOrdinal(\"Age\") ));\n            }\n            dr.Close();\n            //使用MySqlDataAdapter填充DataSet\n            DataSet ds = new DataSet();\n            MySqlDataAdapter adapter = new MySqlDataAdapter(cmd);\n            cmd.CommandText = \"select * from Student\";\n            adapter.Fill(ds, \"Student\");\n            cmd.CommandText = \"select * from Score\";\n            adapter.Fill(ds, \"Score\");\n            DataTable Student = ds.Tables[\"Student\"];\n            DataTable Score = ds.Tables[\"Score\"];\n            //LINQ与DataTable的结合\n            var qry = from s in Student.AsEnumerable()\n                      join c in Score.AsEnumerable() on s.Field<int>(\"Id\") equals c.Field<int>(\"StudentId\")\n                      where c.Field<int>(\"English\") > 80\n                      select new\n                      {\n                          Name = s.Field<string>(\"Name\"),\n                          English = c.Field<int>(\"English\"),\n                          Maths = c.Field<int>(\"Maths\")\n                      };\n            foreach (var item in qry)\n            {\n                Console.WriteLine(item);\n            }\n            //可以使用using模式进行资源的释放\n            conn.Close();\n        }\n    }\n}\n/* Output:\nHello World!\nnRows: 4\nOne Row: 1,zhangsan1,20\nOne Row: 2,zhangsan2,19\nOne Row: 3,zhangsan3,22\nOne Row: 100,newstudent,18\n{ Name = zhangsan2, English = 90, Maths = 95 }\n{ Name = zhangsan3, English = 86, Maths = 75 }\n*/~\n```\n\n上述例子将ADONET中几个主要对象综合到了一起，下面逐一介绍各个对象的功能及用法。\n\n### Connection\n\n`Connection对象`用于和数据库交互，若要操作数据库必须与其连接。创建连接时需要指定`数据库服务器`、`数据库名`、`用户名`、`密码`以及`其他所需参数`。例如本例中的`connString`：\n\n```c#\nstring connString = \"server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = \tTrue; database = assignment4\";\n```\n\n每一种数据源都有特定的`Connection类`，例如本例中的`MySqlConnection`：\n\n```c#\nMySqlConnection conn = new MySqlConnection(connString);\n```\n\n与`Java`不同，`C#`中创建的`Connection对象`是使用正常的构造函数创建一个连接，而`Java`中使用的是**单例模式**创建数据库连接。\n\n### Command\n\n`Command对象`针对`Connection对象`指定的数据源执行SQL语句和存储过程及函数。这个对象是架构在`Connection对象`上的，也就是说`Command对象`通过`Connection对象`操作数据源。\n\n同样，对于每一种数据源都有特定的`Command类`，例如本例中：\n\n```c#\nMySqlCommand cmd = new MySqlCommand();\ncmd.Connection = conn;\n```\n\n在创建了`MySqlCommand对象`后还需为其指定对应的`Connection对象`。\n\n#### 增删改操作\n\n`ExecuteNonQuery()`方法主要用于`Command对象`的`增删改`操作。\n\n`Command对象`的基本使用方法如例中所示：\n\n```c#\ncmd.CommandText = \"insert into Student values (1,'zhangsan1',20)\";\ncmd.ExecuteNonQuery();\n```\n\n先指定其`CommandText`即SQL语句，而后调用`ExecuteNonQuery()`方法完成query。\n\n上述SQL操作方法很容易被非法分子通过字符串拼接等方式进行`SQL注入攻击`，我们可以使用`Parameters`修饰SQL语句，以防止`SQL注入攻击`：\n\n```c#\ncmd.CommandText = @\"INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)\";\ncmd.Parameters.Add(new MySqlParameter(\"@Id\", 100));\ncmd.Parameters.Add(new MySqlParameter(\"@Name\", \"newstudent\"));\ncmd.Parameters.Add(new MySqlParameter(\"@Age\", 18));\ncmd.ExecuteNonQuery();\n```\n\n#### 查询操作\n\n查询由于返回的结果的复杂性，一般有`ExecuteScalar()`和`ExecuteReader()`两种方法。\n\n`ExecuteScalar()`主要用于**SQL查询语句只返回一个数据**，例如`Count操作`、`Max操作`等的返回值：\n\n```c#\ncmd.CommandText = \"select Count(*) from Student\";\nobject nRows = cmd.ExecuteScalar();\nConsole.WriteLine(\"nRows: {0}\", nRows);\n```\n\n`ExecuteReader()`返回一个`DataReader对象`，即结果集，下面会重点讨论该对象。\n\n### DataReader\n\n`DataReader对象`是对数据源的查询结果的**基于流的、仅向前的只读检索**，它不会更新数据。\n\n它是基于`Command对象`的，意即只能通过调用`特定Command对象`的`ExecuteReader()`方法以获取`DataReader对象`：\n\n```c#\nMySqlDataReader dr = cmd.ExecuteReader();\nwhile(dr.Read())\n{\n         Console.WriteLine(\"One Row: {0},{1},{2}\",\n         \t\t\t\t\t\t\t\t\t\tdr.GetValue(0),\n         \t\t\t\t\t\t\t\t\t\tdr[\"Name\"],\n         \t\t\t\t\t\t\t\t\t\tdr.GetValue(dr.GetOrdinal(\"Age\") \n         \t\t\t\t\t\t\t\t\t));\n}\ndr.Close();\n```\n\n同样，特定的数据源也是有特定类型的`DataReader类`，其都是通过继承`DbDataReader类`实现的。\n\n由于`Read()`方法返回是否有下一行的布尔值，因此很适合使用`while循环`遍历结果。\n\n从代码中易知，`DataReader对象`的`Read()`方法是通过循环从数据源中每次获取一行数据，类似于plsql中的游标，他除了读取效率很高之外，牺牲了很多其他特性，例如对结果的排序、更改等。\n\n### DataSet和DataAdapter\n\n`DataSet类`包含数据的数据表集合。它用于在**不与数据源交互**的情况下获取数据，这就是为什么它也被称为`断开数据访问方法`。这是一个**内存数据存储**，可以**同时容纳多个表**。可以使用`DataRelation`对象来关联这些表。 `DataSet`也可以用来读写`XML文档`中的数据。\n\n`DataAdapter`是`ADO.NET`数据提供程序的一部分。`DataAdapter`提供**数据集和数据源之间的通信**。我们可以将`DataAdapter`与`DataSet`对象结合使用。注意`DataAdapter类`也是**各个数据源有各自的实现方法**。\n\n`DataAdapter`通过映射`Fill()`方法提供此组合，该方法更改`DataSet`中的数据以匹配数据源中的数据。也就是说，这两个对象组合起来以实现`数据访问`和`数据操作`功能：\n\n```c#\nDataSet ds = new DataSet();\nSqlDataAdapter adapter = new SqlDataAdapter(cmd); cmd.CommandText = \"select * from Student\"; adapter.Fill(ds, \"Student\");\ncmd.CommandText = \"select * from Score\"; adapter.Fill(ds, \"Score\");\nDataTable Student = ds.Tables[\"Student\"]; DataTable Score = ds.Tables[\"Score\"];\n```\n\n通过代码，我们可以看到`DataSet`是**独立于数据源的数据集**，即**对于任何数据源，都提供一致的关系编程模型**。\n\n相比于`DataReader`，`DataSet`**一次性将所有数据放入内存中**，同时还提供了很多额外的数据集操作方法，因此**速度很快且很方便**，但是**对内存资源会有很大的消耗**。\n\n### DataTable\n\n`DataTable`类将关系数据表示为表格形式。`ADO.NET`提供了一个`DataTable`类来独立创建和使用数据表。一般与`DataSet`一起使用。 \n\n在创建`DataTable`之前，**必须包含`System.Data`名称空间**。同时由于本例中使用了`AsEnumerable()`方法，因此还**必须使用`Nuget`添加`System.Data.DataSetExtensions`包**，**否则会报错**。\n\n我们可以使用LINQ语法对DataTable进行查询，实现代码如下：\n\n```c#\nvar qry = from s in Student.AsEnumerable()\n\t\t\t\t\tjoin c in Score.AsEnumerable() on s.Field<int>(\"Id\") equals c.Field<int>(\"StudentId\")\n\t\t\t\t\twhere c.Field<int>(\"English\") > 80\n          select new\n          {\n                Name = s.Field<string>(\"Name\"),\n                English = c.Field<int>(\"English\"),\n                Maths = c.Field<int>(\"Maths\")\n          };\nforeach (var item in qry)\n{\n\t\tConsole.WriteLine(item);\n}\n/* Output:\n{ Name = zhangsan2, English = 90, Maths = 95 }\n{ Name = zhangsan3, English = 86, Maths = 75 }\n**//~\n```\n","source":"_posts/Framework.md","raw":"---\ntitle: C# - ADO.NET配置说明\ndate: 2019-04-18 11:04:15\ntags:\n    - .NET\n    - ADO.NET\ncategories:\n    - C#\n---\n\n## 概述\n\n`ADO.NET`提供对数据库如`MySQL`和`XML`这样的数据源以及通过`OLE DB`和`ODBC`公开的数据源的一致访问。共享数据的使用方应用程序可以使用`ADO.NET`连接到这些数据源，并可以检索、处理和更新其中包含的数据。\n\n<!-- more -->\n\n## 安装MySQL数据库\n\n### 创建数据库\n\n```shell\nPS A:\\> cd .\\MySQL\\mysql-5.7.25-winx64\\bin\\\n\n# 安装MySQL服务\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> .\\mysqld install\n\n# 初始化MySQL数据库，创建无root密码的root用户\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysqld --initialize-insecure\n\n# 启动MySQL服务\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> net start mysql\nMySQL 服务正在启动 .\nMySQL 服务已经启动成功。\n\n# 创建用户，设置密码并赋予权限\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysql -uroot\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 2\nServer version: 5.7.25 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n# 创建用户并设置密码\nmysql> create user 'tanrui'@'localhost' identified by 'tanrui';\nQuery OK, 0 rows affected (0.00 sec)\n# 赋予权限\nmysql> grant all privileges on *.* to 'tanrui'@'localhost';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> exit\nBye\n# 以新用户登录数据库\nPS A:\\MySQL\\mysql-5.7.25-winx64\\bin> mysql -utanrui -ptanrui\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 7\nServer version: 5.7.25 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n# 创建数据库\nmysql> create database Assignment4;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| assignment4        |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n```\n\n### 使用DataGrip连接数据库\n\n设置连接参数如下，点击`OK`完成连接：\n\n![1555227842703](/images/1555227842703.png)\n\n右键`assignment4`数据库点击`New`->`Table`创建`Student`和`Score`新表：\n\n![1555227964411](/images/1555227964411.png)\n\n![1555228253075](/images/1555228253075.png)\n\n![1555228331186](/images/1555228331186.png)\n\n## Visual Studio Nuget包管理\n\n本次实验需要用到`MySQL`一些操作，因此需要在`Visual Studio`中添加相应的包，如下：\n\n![image-20190414160931753](/images/image-20190414160931753.png)\n\n打开`Nuget包管理器`，下载`Mysql.Data`和`System.Data.DataSetExtensions`两个包，前者提供`MySQL`连接驱动，后者主要是提供`C#`中对于数据库表操作的一些语法支持。\n\n![image-20190414161020200](/images/image-20190414161020200.png)\n\n## ADONET基础编程\n\n### 一个小示例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Data;\nusing MySql.Data.MySqlClient;\n\nnamespace ADONET\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            //ADO.NET 几个关键对象\n            //(1) Connection对象 用于连接数据库\n            //(2) Command对象 对数据源执行命令\n            //(3) DataReader对象 用户从数据源读取数据\n            //(4) DataAdapter对象 从数据源读取数据并且填充数据集对象 \n            //(5) DataSet对象 相当于内存数据库\n            //(6) DataTable对象 相当于内存数据库中的表格\n            string connString = \"server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4\";\n            MySqlConnection conn = new MySqlConnection(connString);\n            conn.Open();\n\n            MySqlCommand cmd = new MySqlCommand();\n            cmd.Connection = conn;\n            //ExecuteNonQuery的简单使用\n                        cmd.CommandText = \"insert into Student values (1,'zhangsan1',20)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Student values (2,'zhangsan2',19)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Student values (3,'zhangsan3',22)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (1,80,85)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (2,90,95)\";\n                        cmd.ExecuteNonQuery();\n                        cmd.CommandText = \"insert into Score values (3,86,75)\";\n                        cmd.ExecuteNonQuery();\n                       \n            //参数化查询的使用，是目前唯一可以预防SQL Injection的方法\n            cmd.CommandText = @\"INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)\";\n                        cmd.Parameters.Add(new MySqlParameter(\"@Id\", 100));\n                        cmd.Parameters.Add(new MySqlParameter(\"@Name\",\n            \"newstudent\"));\n                        cmd.Parameters.Add(new MySqlParameter(\"@Age\", 18));\n                        cmd.ExecuteNonQuery();\n            //ExecuteReader的简单使用\n            cmd.CommandText = \"select Count(*) from Student\";\n            object nRows = cmd.ExecuteScalar();\n            Console.WriteLine(\"nRows: {0}\", nRows);\n\ncmd.CommandText = \"select * from Student\";\n            MySqlDataReader dr = cmd.ExecuteReader();\n            while(dr.Read())\n            {\n                 Console.WriteLine(\"One Row: {0},{1},{2}\",\ndr.GetValue(0), dr[\"Name\"], dr.GetValue( dr.GetOrdinal(\"Age\") ));\n            }\n            dr.Close();\n            //使用MySqlDataAdapter填充DataSet\n            DataSet ds = new DataSet();\n            MySqlDataAdapter adapter = new MySqlDataAdapter(cmd);\n            cmd.CommandText = \"select * from Student\";\n            adapter.Fill(ds, \"Student\");\n            cmd.CommandText = \"select * from Score\";\n            adapter.Fill(ds, \"Score\");\n            DataTable Student = ds.Tables[\"Student\"];\n            DataTable Score = ds.Tables[\"Score\"];\n            //LINQ与DataTable的结合\n            var qry = from s in Student.AsEnumerable()\n                      join c in Score.AsEnumerable() on s.Field<int>(\"Id\") equals c.Field<int>(\"StudentId\")\n                      where c.Field<int>(\"English\") > 80\n                      select new\n                      {\n                          Name = s.Field<string>(\"Name\"),\n                          English = c.Field<int>(\"English\"),\n                          Maths = c.Field<int>(\"Maths\")\n                      };\n            foreach (var item in qry)\n            {\n                Console.WriteLine(item);\n            }\n            //可以使用using模式进行资源的释放\n            conn.Close();\n        }\n    }\n}\n/* Output:\nHello World!\nnRows: 4\nOne Row: 1,zhangsan1,20\nOne Row: 2,zhangsan2,19\nOne Row: 3,zhangsan3,22\nOne Row: 100,newstudent,18\n{ Name = zhangsan2, English = 90, Maths = 95 }\n{ Name = zhangsan3, English = 86, Maths = 75 }\n*/~\n```\n\n上述例子将ADONET中几个主要对象综合到了一起，下面逐一介绍各个对象的功能及用法。\n\n### Connection\n\n`Connection对象`用于和数据库交互，若要操作数据库必须与其连接。创建连接时需要指定`数据库服务器`、`数据库名`、`用户名`、`密码`以及`其他所需参数`。例如本例中的`connString`：\n\n```c#\nstring connString = \"server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = \tTrue; database = assignment4\";\n```\n\n每一种数据源都有特定的`Connection类`，例如本例中的`MySqlConnection`：\n\n```c#\nMySqlConnection conn = new MySqlConnection(connString);\n```\n\n与`Java`不同，`C#`中创建的`Connection对象`是使用正常的构造函数创建一个连接，而`Java`中使用的是**单例模式**创建数据库连接。\n\n### Command\n\n`Command对象`针对`Connection对象`指定的数据源执行SQL语句和存储过程及函数。这个对象是架构在`Connection对象`上的，也就是说`Command对象`通过`Connection对象`操作数据源。\n\n同样，对于每一种数据源都有特定的`Command类`，例如本例中：\n\n```c#\nMySqlCommand cmd = new MySqlCommand();\ncmd.Connection = conn;\n```\n\n在创建了`MySqlCommand对象`后还需为其指定对应的`Connection对象`。\n\n#### 增删改操作\n\n`ExecuteNonQuery()`方法主要用于`Command对象`的`增删改`操作。\n\n`Command对象`的基本使用方法如例中所示：\n\n```c#\ncmd.CommandText = \"insert into Student values (1,'zhangsan1',20)\";\ncmd.ExecuteNonQuery();\n```\n\n先指定其`CommandText`即SQL语句，而后调用`ExecuteNonQuery()`方法完成query。\n\n上述SQL操作方法很容易被非法分子通过字符串拼接等方式进行`SQL注入攻击`，我们可以使用`Parameters`修饰SQL语句，以防止`SQL注入攻击`：\n\n```c#\ncmd.CommandText = @\"INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)\";\ncmd.Parameters.Add(new MySqlParameter(\"@Id\", 100));\ncmd.Parameters.Add(new MySqlParameter(\"@Name\", \"newstudent\"));\ncmd.Parameters.Add(new MySqlParameter(\"@Age\", 18));\ncmd.ExecuteNonQuery();\n```\n\n#### 查询操作\n\n查询由于返回的结果的复杂性，一般有`ExecuteScalar()`和`ExecuteReader()`两种方法。\n\n`ExecuteScalar()`主要用于**SQL查询语句只返回一个数据**，例如`Count操作`、`Max操作`等的返回值：\n\n```c#\ncmd.CommandText = \"select Count(*) from Student\";\nobject nRows = cmd.ExecuteScalar();\nConsole.WriteLine(\"nRows: {0}\", nRows);\n```\n\n`ExecuteReader()`返回一个`DataReader对象`，即结果集，下面会重点讨论该对象。\n\n### DataReader\n\n`DataReader对象`是对数据源的查询结果的**基于流的、仅向前的只读检索**，它不会更新数据。\n\n它是基于`Command对象`的，意即只能通过调用`特定Command对象`的`ExecuteReader()`方法以获取`DataReader对象`：\n\n```c#\nMySqlDataReader dr = cmd.ExecuteReader();\nwhile(dr.Read())\n{\n         Console.WriteLine(\"One Row: {0},{1},{2}\",\n         \t\t\t\t\t\t\t\t\t\tdr.GetValue(0),\n         \t\t\t\t\t\t\t\t\t\tdr[\"Name\"],\n         \t\t\t\t\t\t\t\t\t\tdr.GetValue(dr.GetOrdinal(\"Age\") \n         \t\t\t\t\t\t\t\t\t));\n}\ndr.Close();\n```\n\n同样，特定的数据源也是有特定类型的`DataReader类`，其都是通过继承`DbDataReader类`实现的。\n\n由于`Read()`方法返回是否有下一行的布尔值，因此很适合使用`while循环`遍历结果。\n\n从代码中易知，`DataReader对象`的`Read()`方法是通过循环从数据源中每次获取一行数据，类似于plsql中的游标，他除了读取效率很高之外，牺牲了很多其他特性，例如对结果的排序、更改等。\n\n### DataSet和DataAdapter\n\n`DataSet类`包含数据的数据表集合。它用于在**不与数据源交互**的情况下获取数据，这就是为什么它也被称为`断开数据访问方法`。这是一个**内存数据存储**，可以**同时容纳多个表**。可以使用`DataRelation`对象来关联这些表。 `DataSet`也可以用来读写`XML文档`中的数据。\n\n`DataAdapter`是`ADO.NET`数据提供程序的一部分。`DataAdapter`提供**数据集和数据源之间的通信**。我们可以将`DataAdapter`与`DataSet`对象结合使用。注意`DataAdapter类`也是**各个数据源有各自的实现方法**。\n\n`DataAdapter`通过映射`Fill()`方法提供此组合，该方法更改`DataSet`中的数据以匹配数据源中的数据。也就是说，这两个对象组合起来以实现`数据访问`和`数据操作`功能：\n\n```c#\nDataSet ds = new DataSet();\nSqlDataAdapter adapter = new SqlDataAdapter(cmd); cmd.CommandText = \"select * from Student\"; adapter.Fill(ds, \"Student\");\ncmd.CommandText = \"select * from Score\"; adapter.Fill(ds, \"Score\");\nDataTable Student = ds.Tables[\"Student\"]; DataTable Score = ds.Tables[\"Score\"];\n```\n\n通过代码，我们可以看到`DataSet`是**独立于数据源的数据集**，即**对于任何数据源，都提供一致的关系编程模型**。\n\n相比于`DataReader`，`DataSet`**一次性将所有数据放入内存中**，同时还提供了很多额外的数据集操作方法，因此**速度很快且很方便**，但是**对内存资源会有很大的消耗**。\n\n### DataTable\n\n`DataTable`类将关系数据表示为表格形式。`ADO.NET`提供了一个`DataTable`类来独立创建和使用数据表。一般与`DataSet`一起使用。 \n\n在创建`DataTable`之前，**必须包含`System.Data`名称空间**。同时由于本例中使用了`AsEnumerable()`方法，因此还**必须使用`Nuget`添加`System.Data.DataSetExtensions`包**，**否则会报错**。\n\n我们可以使用LINQ语法对DataTable进行查询，实现代码如下：\n\n```c#\nvar qry = from s in Student.AsEnumerable()\n\t\t\t\t\tjoin c in Score.AsEnumerable() on s.Field<int>(\"Id\") equals c.Field<int>(\"StudentId\")\n\t\t\t\t\twhere c.Field<int>(\"English\") > 80\n          select new\n          {\n                Name = s.Field<string>(\"Name\"),\n                English = c.Field<int>(\"English\"),\n                Maths = c.Field<int>(\"Maths\")\n          };\nforeach (var item in qry)\n{\n\t\tConsole.WriteLine(item);\n}\n/* Output:\n{ Name = zhangsan2, English = 90, Maths = 95 }\n{ Name = zhangsan3, English = 86, Maths = 75 }\n**//~\n```\n","slug":"Framework","published":1,"updated":"2021-05-16T10:54:47.622Z","_id":"ckfukja95000aszxo7xv6d5vq","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>ADO.NET</code>提供对数据库如<code>MySQL</code>和<code>XML</code>这样的数据源以及通过<code>OLE DB</code>和<code>ODBC</code>公开的数据源的一致访问。共享数据的使用方应用程序可以使用<code>ADO.NET</code>连接到这些数据源，并可以检索、处理和更新其中包含的数据。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装MySQL数据库\"><a href=\"#安装MySQL数据库\" class=\"headerlink\" title=\"安装MySQL数据库\"></a>安装MySQL数据库</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS A:\\&gt; cd .\\MySQL\\mysql-5.7.25-winx64\\bin\\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装MySQL服务</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; .\\mysqld install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 初始化MySQL数据库，创建无root密码的root用户</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysqld --initialize-insecure</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 启动MySQL服务</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 .</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 创建用户，设置密码并赋予权限</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysql -uroot</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 2</span><br><span class=\"line\">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.</span><br><span class=\"line\"><span class=\"meta\">#</span> 创建用户并设置密码</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> create user 'tanrui'@'localhost' identified by 'tanrui';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"><span class=\"meta\">#</span> 赋予权限</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> grant all privileges on *.* to 'tanrui'@'localhost';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\"><span class=\"meta\">#</span> 以新用户登录数据库</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysql -utanrui -ptanrui</span><br><span class=\"line\">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 7</span><br><span class=\"line\">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.</span><br><span class=\"line\"><span class=\"meta\">#</span> 创建数据库</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> create database Assignment4;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> show databases;</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| Database           |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| information_schema |</span><br><span class=\"line\">| assignment4        |</span><br><span class=\"line\">| mysql              |</span><br><span class=\"line\">| performance_schema |</span><br><span class=\"line\">| sys                |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DataGrip连接数据库\"><a href=\"#使用DataGrip连接数据库\" class=\"headerlink\" title=\"使用DataGrip连接数据库\"></a>使用DataGrip连接数据库</h3><p>设置连接参数如下，点击<code>OK</code>完成连接：</p>\n<p><img src=\"/images/1555227842703.png\" alt=\"1555227842703\"></p>\n<p>右键<code>assignment4</code>数据库点击<code>New</code>-&gt;<code>Table</code>创建<code>Student</code>和<code>Score</code>新表：</p>\n<p><img src=\"/images/1555227964411.png\" alt=\"1555227964411\"></p>\n<p><img src=\"/images/1555228253075.png\" alt=\"1555228253075\"></p>\n<p><img src=\"/images/1555228331186.png\" alt=\"1555228331186\"></p>\n<h2 id=\"Visual-Studio-Nuget包管理\"><a href=\"#Visual-Studio-Nuget包管理\" class=\"headerlink\" title=\"Visual Studio Nuget包管理\"></a>Visual Studio Nuget包管理</h2><p>本次实验需要用到<code>MySQL</code>一些操作，因此需要在<code>Visual Studio</code>中添加相应的包，如下：</p>\n<p><img src=\"/images/image-20190414160931753.png\" alt=\"image-20190414160931753\"></p>\n<p>打开<code>Nuget包管理器</code>，下载<code>Mysql.Data</code>和<code>System.Data.DataSetExtensions</code>两个包，前者提供<code>MySQL</code>连接驱动，后者主要是提供<code>C#</code>中对于数据库表操作的一些语法支持。</p>\n<p><img src=\"/images/image-20190414161020200.png\" alt=\"image-20190414161020200\"></p>\n<h2 id=\"ADONET基础编程\"><a href=\"#ADONET基础编程\" class=\"headerlink\" title=\"ADONET基础编程\"></a>ADONET基础编程</h2><h3 id=\"一个小示例\"><a href=\"#一个小示例\" class=\"headerlink\" title=\"一个小示例\"></a>一个小示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Data;</span><br><span class=\"line\">using MySql.Data.MySqlClient;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ADONET</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(&quot;Hello World!&quot;);</span><br><span class=\"line\">            //ADO.NET 几个关键对象</span><br><span class=\"line\">            //(1) Connection对象 用于连接数据库</span><br><span class=\"line\">            //(2) Command对象 对数据源执行命令</span><br><span class=\"line\">            //(3) DataReader对象 用户从数据源读取数据</span><br><span class=\"line\">            //(4) DataAdapter对象 从数据源读取数据并且填充数据集对象 </span><br><span class=\"line\">            //(5) DataSet对象 相当于内存数据库</span><br><span class=\"line\">            //(6) DataTable对象 相当于内存数据库中的表格</span><br><span class=\"line\">            string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4&quot;;</span><br><span class=\"line\">            MySqlConnection conn = new MySqlConnection(connString);</span><br><span class=\"line\">            conn.Open();</span><br><span class=\"line\"></span><br><span class=\"line\">            MySqlCommand cmd = new MySqlCommand();</span><br><span class=\"line\">            cmd.Connection = conn;</span><br><span class=\"line\">            //ExecuteNonQuery的简单使用</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (2,&apos;zhangsan2&apos;,19)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (3,&apos;zhangsan3&apos;,22)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (1,80,85)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (2,90,95)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (3,86,75)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                       </span><br><span class=\"line\">            //参数化查询的使用，是目前唯一可以预防SQL Injection的方法</span><br><span class=\"line\">            cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;,</span><br><span class=\"line\">            &quot;newstudent&quot;));</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">            //ExecuteReader的简单使用</span><br><span class=\"line\">            cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class=\"line\">            object nRows = cmd.ExecuteScalar();</span><br><span class=\"line\">            Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br><span class=\"line\"></span><br><span class=\"line\">cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class=\"line\">            MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class=\"line\">            while(dr.Read())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class=\"line\">dr.GetValue(0), dr[&quot;Name&quot;], dr.GetValue( dr.GetOrdinal(&quot;Age&quot;) ));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dr.Close();</span><br><span class=\"line\">            //使用MySqlDataAdapter填充DataSet</span><br><span class=\"line\">            DataSet ds = new DataSet();</span><br><span class=\"line\">            MySqlDataAdapter adapter = new MySqlDataAdapter(cmd);</span><br><span class=\"line\">            cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class=\"line\">            adapter.Fill(ds, &quot;Student&quot;);</span><br><span class=\"line\">            cmd.CommandText = &quot;select * from Score&quot;;</span><br><span class=\"line\">            adapter.Fill(ds, &quot;Score&quot;);</span><br><span class=\"line\">            DataTable Student = ds.Tables[&quot;Student&quot;];</span><br><span class=\"line\">            DataTable Score = ds.Tables[&quot;Score&quot;];</span><br><span class=\"line\">            //LINQ与DataTable的结合</span><br><span class=\"line\">            var qry = from s in Student.AsEnumerable()</span><br><span class=\"line\">                      join c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class=\"line\">                      where c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class=\"line\">                      select new</span><br><span class=\"line\">                      &#123;</span><br><span class=\"line\">                          Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class=\"line\">                          English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class=\"line\">                          Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class=\"line\">                      &#125;;</span><br><span class=\"line\">            foreach (var item in qry)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //可以使用using模式进行资源的释放</span><br><span class=\"line\">            conn.Close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* Output:</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">nRows: 4</span><br><span class=\"line\">One Row: 1,zhangsan1,20</span><br><span class=\"line\">One Row: 2,zhangsan2,19</span><br><span class=\"line\">One Row: 3,zhangsan3,22</span><br><span class=\"line\">One Row: 100,newstudent,18</span><br><span class=\"line\">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class=\"line\">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class=\"line\">*/~</span><br></pre></td></tr></table></figure>\n<p>上述例子将ADONET中几个主要对象综合到了一起，下面逐一介绍各个对象的功能及用法。</p>\n<h3 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h3><p><code>Connection对象</code>用于和数据库交互，若要操作数据库必须与其连接。创建连接时需要指定<code>数据库服务器</code>、<code>数据库名</code>、<code>用户名</code>、<code>密码</code>以及<code>其他所需参数</code>。例如本例中的<code>connString</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = \tTrue; database = assignment4&quot;;</span><br></pre></td></tr></table></figure>\n<p>每一种数据源都有特定的<code>Connection类</code>，例如本例中的<code>MySqlConnection</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlConnection conn = new MySqlConnection(connString);</span><br></pre></td></tr></table></figure>\n<p>与<code>Java</code>不同，<code>C#</code>中创建的<code>Connection对象</code>是使用正常的构造函数创建一个连接，而<code>Java</code>中使用的是<strong>单例模式</strong>创建数据库连接。</p>\n<h3 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h3><p><code>Command对象</code>针对<code>Connection对象</code>指定的数据源执行SQL语句和存储过程及函数。这个对象是架构在<code>Connection对象</code>上的，也就是说<code>Command对象</code>通过<code>Connection对象</code>操作数据源。</p>\n<p>同样，对于每一种数据源都有特定的<code>Command类</code>，例如本例中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlCommand cmd = new MySqlCommand();</span><br><span class=\"line\">cmd.Connection = conn;</span><br></pre></td></tr></table></figure>\n<p>在创建了<code>MySqlCommand对象</code>后还需为其指定对应的<code>Connection对象</code>。</p>\n<h4 id=\"增删改操作\"><a href=\"#增删改操作\" class=\"headerlink\" title=\"增删改操作\"></a>增删改操作</h4><p><code>ExecuteNonQuery()</code>方法主要用于<code>Command对象</code>的<code>增删改</code>操作。</p>\n<p><code>Command对象</code>的基本使用方法如例中所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class=\"line\">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>\n<p>先指定其<code>CommandText</code>即SQL语句，而后调用<code>ExecuteNonQuery()</code>方法完成query。</p>\n<p>上述SQL操作方法很容易被非法分子通过字符串拼接等方式进行<code>SQL注入攻击</code>，我们可以使用<code>Parameters</code>修饰SQL语句，以防止<code>SQL注入攻击</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;, &quot;newstudent&quot;));</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class=\"line\">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h4><p>查询由于返回的结果的复杂性，一般有<code>ExecuteScalar()</code>和<code>ExecuteReader()</code>两种方法。</p>\n<p><code>ExecuteScalar()</code>主要用于<strong>SQL查询语句只返回一个数据</strong>，例如<code>Count操作</code>、<code>Max操作</code>等的返回值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class=\"line\">object nRows = cmd.ExecuteScalar();</span><br><span class=\"line\">Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br></pre></td></tr></table></figure>\n<p><code>ExecuteReader()</code>返回一个<code>DataReader对象</code>，即结果集，下面会重点讨论该对象。</p>\n<h3 id=\"DataReader\"><a href=\"#DataReader\" class=\"headerlink\" title=\"DataReader\"></a>DataReader</h3><p><code>DataReader对象</code>是对数据源的查询结果的<strong>基于流的、仅向前的只读检索</strong>，它不会更新数据。</p>\n<p>它是基于<code>Command对象</code>的，意即只能通过调用<code>特定Command对象</code>的<code>ExecuteReader()</code>方法以获取<code>DataReader对象</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class=\"line\">while(dr.Read())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">         Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr.GetValue(0),</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr[&quot;Name&quot;],</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr.GetValue(dr.GetOrdinal(&quot;Age&quot;) </span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dr.Close();</span><br></pre></td></tr></table></figure>\n<p>同样，特定的数据源也是有特定类型的<code>DataReader类</code>，其都是通过继承<code>DbDataReader类</code>实现的。</p>\n<p>由于<code>Read()</code>方法返回是否有下一行的布尔值，因此很适合使用<code>while循环</code>遍历结果。</p>\n<p>从代码中易知，<code>DataReader对象</code>的<code>Read()</code>方法是通过循环从数据源中每次获取一行数据，类似于plsql中的游标，他除了读取效率很高之外，牺牲了很多其他特性，例如对结果的排序、更改等。</p>\n<h3 id=\"DataSet和DataAdapter\"><a href=\"#DataSet和DataAdapter\" class=\"headerlink\" title=\"DataSet和DataAdapter\"></a>DataSet和DataAdapter</h3><p><code>DataSet类</code>包含数据的数据表集合。它用于在<strong>不与数据源交互</strong>的情况下获取数据，这就是为什么它也被称为<code>断开数据访问方法</code>。这是一个<strong>内存数据存储</strong>，可以<strong>同时容纳多个表</strong>。可以使用<code>DataRelation</code>对象来关联这些表。 <code>DataSet</code>也可以用来读写<code>XML文档</code>中的数据。</p>\n<p><code>DataAdapter</code>是<code>ADO.NET</code>数据提供程序的一部分。<code>DataAdapter</code>提供<strong>数据集和数据源之间的通信</strong>。我们可以将<code>DataAdapter</code>与<code>DataSet</code>对象结合使用。注意<code>DataAdapter类</code>也是<strong>各个数据源有各自的实现方法</strong>。</p>\n<p><code>DataAdapter</code>通过映射<code>Fill()</code>方法提供此组合，该方法更改<code>DataSet</code>中的数据以匹配数据源中的数据。也就是说，这两个对象组合起来以实现<code>数据访问</code>和<code>数据操作</code>功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataSet ds = new DataSet();</span><br><span class=\"line\">SqlDataAdapter adapter = new SqlDataAdapter(cmd); cmd.CommandText = &quot;select * from Student&quot;; adapter.Fill(ds, &quot;Student&quot;);</span><br><span class=\"line\">cmd.CommandText = &quot;select * from Score&quot;; adapter.Fill(ds, &quot;Score&quot;);</span><br><span class=\"line\">DataTable Student = ds.Tables[&quot;Student&quot;]; DataTable Score = ds.Tables[&quot;Score&quot;];</span><br></pre></td></tr></table></figure>\n<p>通过代码，我们可以看到<code>DataSet</code>是<strong>独立于数据源的数据集</strong>，即<strong>对于任何数据源，都提供一致的关系编程模型</strong>。</p>\n<p>相比于<code>DataReader</code>，<code>DataSet</code><strong>一次性将所有数据放入内存中</strong>，同时还提供了很多额外的数据集操作方法，因此<strong>速度很快且很方便</strong>，但是<strong>对内存资源会有很大的消耗</strong>。</p>\n<h3 id=\"DataTable\"><a href=\"#DataTable\" class=\"headerlink\" title=\"DataTable\"></a>DataTable</h3><p><code>DataTable</code>类将关系数据表示为表格形式。<code>ADO.NET</code>提供了一个<code>DataTable</code>类来独立创建和使用数据表。一般与<code>DataSet</code>一起使用。 </p>\n<p>在创建<code>DataTable</code>之前，<strong>必须包含<code>System.Data</code>名称空间</strong>。同时由于本例中使用了<code>AsEnumerable()</code>方法，因此还<strong>必须使用<code>Nuget</code>添加<code>System.Data.DataSetExtensions</code>包</strong>，<strong>否则会报错</strong>。</p>\n<p>我们可以使用LINQ语法对DataTable进行查询，实现代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var qry = from s in Student.AsEnumerable()</span><br><span class=\"line\">\t\t\t\t\tjoin c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class=\"line\">\t\t\t\t\twhere c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class=\"line\">          select new</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">                Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class=\"line\">                English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class=\"line\">                Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">foreach (var item in qry)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\tConsole.WriteLine(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* Output:</span><br><span class=\"line\">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class=\"line\">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class=\"line\">**//~</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>ADO.NET</code>提供对数据库如<code>MySQL</code>和<code>XML</code>这样的数据源以及通过<code>OLE DB</code>和<code>ODBC</code>公开的数据源的一致访问。共享数据的使用方应用程序可以使用<code>ADO.NET</code>连接到这些数据源，并可以检索、处理和更新其中包含的数据。</p>","more":"<h2 id=\"安装MySQL数据库\"><a href=\"#安装MySQL数据库\" class=\"headerlink\" title=\"安装MySQL数据库\"></a>安装MySQL数据库</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS A:\\&gt; cd .\\MySQL\\mysql-5.7.25-winx64\\bin\\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装MySQL服务</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; .\\mysqld install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 初始化MySQL数据库，创建无root密码的root用户</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysqld --initialize-insecure</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 启动MySQL服务</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 .</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 创建用户，设置密码并赋予权限</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysql -uroot</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 2</span><br><span class=\"line\">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.</span><br><span class=\"line\"><span class=\"meta\">#</span> 创建用户并设置密码</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> create user 'tanrui'@'localhost' identified by 'tanrui';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"><span class=\"meta\">#</span> 赋予权限</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> grant all privileges on *.* to 'tanrui'@'localhost';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\"><span class=\"meta\">#</span> 以新用户登录数据库</span><br><span class=\"line\">PS A:\\MySQL\\mysql-5.7.25-winx64\\bin&gt; mysql -utanrui -ptanrui</span><br><span class=\"line\">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 7</span><br><span class=\"line\">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.</span><br><span class=\"line\"><span class=\"meta\">#</span> 创建数据库</span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> create database Assignment4;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span> show databases;</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| Database           |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| information_schema |</span><br><span class=\"line\">| assignment4        |</span><br><span class=\"line\">| mysql              |</span><br><span class=\"line\">| performance_schema |</span><br><span class=\"line\">| sys                |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DataGrip连接数据库\"><a href=\"#使用DataGrip连接数据库\" class=\"headerlink\" title=\"使用DataGrip连接数据库\"></a>使用DataGrip连接数据库</h3><p>设置连接参数如下，点击<code>OK</code>完成连接：</p>\n<p><img src=\"/images/1555227842703.png\" alt=\"1555227842703\"></p>\n<p>右键<code>assignment4</code>数据库点击<code>New</code>-&gt;<code>Table</code>创建<code>Student</code>和<code>Score</code>新表：</p>\n<p><img src=\"/images/1555227964411.png\" alt=\"1555227964411\"></p>\n<p><img src=\"/images/1555228253075.png\" alt=\"1555228253075\"></p>\n<p><img src=\"/images/1555228331186.png\" alt=\"1555228331186\"></p>\n<h2 id=\"Visual-Studio-Nuget包管理\"><a href=\"#Visual-Studio-Nuget包管理\" class=\"headerlink\" title=\"Visual Studio Nuget包管理\"></a>Visual Studio Nuget包管理</h2><p>本次实验需要用到<code>MySQL</code>一些操作，因此需要在<code>Visual Studio</code>中添加相应的包，如下：</p>\n<p><img src=\"/images/image-20190414160931753.png\" alt=\"image-20190414160931753\"></p>\n<p>打开<code>Nuget包管理器</code>，下载<code>Mysql.Data</code>和<code>System.Data.DataSetExtensions</code>两个包，前者提供<code>MySQL</code>连接驱动，后者主要是提供<code>C#</code>中对于数据库表操作的一些语法支持。</p>\n<p><img src=\"/images/image-20190414161020200.png\" alt=\"image-20190414161020200\"></p>\n<h2 id=\"ADONET基础编程\"><a href=\"#ADONET基础编程\" class=\"headerlink\" title=\"ADONET基础编程\"></a>ADONET基础编程</h2><h3 id=\"一个小示例\"><a href=\"#一个小示例\" class=\"headerlink\" title=\"一个小示例\"></a>一个小示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Data;</span><br><span class=\"line\">using MySql.Data.MySqlClient;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ADONET</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(&quot;Hello World!&quot;);</span><br><span class=\"line\">            //ADO.NET 几个关键对象</span><br><span class=\"line\">            //(1) Connection对象 用于连接数据库</span><br><span class=\"line\">            //(2) Command对象 对数据源执行命令</span><br><span class=\"line\">            //(3) DataReader对象 用户从数据源读取数据</span><br><span class=\"line\">            //(4) DataAdapter对象 从数据源读取数据并且填充数据集对象 </span><br><span class=\"line\">            //(5) DataSet对象 相当于内存数据库</span><br><span class=\"line\">            //(6) DataTable对象 相当于内存数据库中的表格</span><br><span class=\"line\">            string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4&quot;;</span><br><span class=\"line\">            MySqlConnection conn = new MySqlConnection(connString);</span><br><span class=\"line\">            conn.Open();</span><br><span class=\"line\"></span><br><span class=\"line\">            MySqlCommand cmd = new MySqlCommand();</span><br><span class=\"line\">            cmd.Connection = conn;</span><br><span class=\"line\">            //ExecuteNonQuery的简单使用</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (2,&apos;zhangsan2&apos;,19)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Student values (3,&apos;zhangsan3&apos;,22)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (1,80,85)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (2,90,95)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                        cmd.CommandText = &quot;insert into Score values (3,86,75)&quot;;</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">                       </span><br><span class=\"line\">            //参数化查询的使用，是目前唯一可以预防SQL Injection的方法</span><br><span class=\"line\">            cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;,</span><br><span class=\"line\">            &quot;newstudent&quot;));</span><br><span class=\"line\">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class=\"line\">                        cmd.ExecuteNonQuery();</span><br><span class=\"line\">            //ExecuteReader的简单使用</span><br><span class=\"line\">            cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class=\"line\">            object nRows = cmd.ExecuteScalar();</span><br><span class=\"line\">            Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br><span class=\"line\"></span><br><span class=\"line\">cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class=\"line\">            MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class=\"line\">            while(dr.Read())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class=\"line\">dr.GetValue(0), dr[&quot;Name&quot;], dr.GetValue( dr.GetOrdinal(&quot;Age&quot;) ));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dr.Close();</span><br><span class=\"line\">            //使用MySqlDataAdapter填充DataSet</span><br><span class=\"line\">            DataSet ds = new DataSet();</span><br><span class=\"line\">            MySqlDataAdapter adapter = new MySqlDataAdapter(cmd);</span><br><span class=\"line\">            cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class=\"line\">            adapter.Fill(ds, &quot;Student&quot;);</span><br><span class=\"line\">            cmd.CommandText = &quot;select * from Score&quot;;</span><br><span class=\"line\">            adapter.Fill(ds, &quot;Score&quot;);</span><br><span class=\"line\">            DataTable Student = ds.Tables[&quot;Student&quot;];</span><br><span class=\"line\">            DataTable Score = ds.Tables[&quot;Score&quot;];</span><br><span class=\"line\">            //LINQ与DataTable的结合</span><br><span class=\"line\">            var qry = from s in Student.AsEnumerable()</span><br><span class=\"line\">                      join c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class=\"line\">                      where c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class=\"line\">                      select new</span><br><span class=\"line\">                      &#123;</span><br><span class=\"line\">                          Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class=\"line\">                          English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class=\"line\">                          Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class=\"line\">                      &#125;;</span><br><span class=\"line\">            foreach (var item in qry)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //可以使用using模式进行资源的释放</span><br><span class=\"line\">            conn.Close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* Output:</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">nRows: 4</span><br><span class=\"line\">One Row: 1,zhangsan1,20</span><br><span class=\"line\">One Row: 2,zhangsan2,19</span><br><span class=\"line\">One Row: 3,zhangsan3,22</span><br><span class=\"line\">One Row: 100,newstudent,18</span><br><span class=\"line\">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class=\"line\">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class=\"line\">*/~</span><br></pre></td></tr></table></figure>\n<p>上述例子将ADONET中几个主要对象综合到了一起，下面逐一介绍各个对象的功能及用法。</p>\n<h3 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h3><p><code>Connection对象</code>用于和数据库交互，若要操作数据库必须与其连接。创建连接时需要指定<code>数据库服务器</code>、<code>数据库名</code>、<code>用户名</code>、<code>密码</code>以及<code>其他所需参数</code>。例如本例中的<code>connString</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = \tTrue; database = assignment4&quot;;</span><br></pre></td></tr></table></figure>\n<p>每一种数据源都有特定的<code>Connection类</code>，例如本例中的<code>MySqlConnection</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlConnection conn = new MySqlConnection(connString);</span><br></pre></td></tr></table></figure>\n<p>与<code>Java</code>不同，<code>C#</code>中创建的<code>Connection对象</code>是使用正常的构造函数创建一个连接，而<code>Java</code>中使用的是<strong>单例模式</strong>创建数据库连接。</p>\n<h3 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h3><p><code>Command对象</code>针对<code>Connection对象</code>指定的数据源执行SQL语句和存储过程及函数。这个对象是架构在<code>Connection对象</code>上的，也就是说<code>Command对象</code>通过<code>Connection对象</code>操作数据源。</p>\n<p>同样，对于每一种数据源都有特定的<code>Command类</code>，例如本例中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlCommand cmd = new MySqlCommand();</span><br><span class=\"line\">cmd.Connection = conn;</span><br></pre></td></tr></table></figure>\n<p>在创建了<code>MySqlCommand对象</code>后还需为其指定对应的<code>Connection对象</code>。</p>\n<h4 id=\"增删改操作\"><a href=\"#增删改操作\" class=\"headerlink\" title=\"增删改操作\"></a>增删改操作</h4><p><code>ExecuteNonQuery()</code>方法主要用于<code>Command对象</code>的<code>增删改</code>操作。</p>\n<p><code>Command对象</code>的基本使用方法如例中所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class=\"line\">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>\n<p>先指定其<code>CommandText</code>即SQL语句，而后调用<code>ExecuteNonQuery()</code>方法完成query。</p>\n<p>上述SQL操作方法很容易被非法分子通过字符串拼接等方式进行<code>SQL注入攻击</code>，我们可以使用<code>Parameters</code>修饰SQL语句，以防止<code>SQL注入攻击</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;, &quot;newstudent&quot;));</span><br><span class=\"line\">cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class=\"line\">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h4><p>查询由于返回的结果的复杂性，一般有<code>ExecuteScalar()</code>和<code>ExecuteReader()</code>两种方法。</p>\n<p><code>ExecuteScalar()</code>主要用于<strong>SQL查询语句只返回一个数据</strong>，例如<code>Count操作</code>、<code>Max操作</code>等的返回值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class=\"line\">object nRows = cmd.ExecuteScalar();</span><br><span class=\"line\">Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br></pre></td></tr></table></figure>\n<p><code>ExecuteReader()</code>返回一个<code>DataReader对象</code>，即结果集，下面会重点讨论该对象。</p>\n<h3 id=\"DataReader\"><a href=\"#DataReader\" class=\"headerlink\" title=\"DataReader\"></a>DataReader</h3><p><code>DataReader对象</code>是对数据源的查询结果的<strong>基于流的、仅向前的只读检索</strong>，它不会更新数据。</p>\n<p>它是基于<code>Command对象</code>的，意即只能通过调用<code>特定Command对象</code>的<code>ExecuteReader()</code>方法以获取<code>DataReader对象</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class=\"line\">while(dr.Read())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">         Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr.GetValue(0),</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr[&quot;Name&quot;],</span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t\tdr.GetValue(dr.GetOrdinal(&quot;Age&quot;) </span><br><span class=\"line\">         \t\t\t\t\t\t\t\t\t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dr.Close();</span><br></pre></td></tr></table></figure>\n<p>同样，特定的数据源也是有特定类型的<code>DataReader类</code>，其都是通过继承<code>DbDataReader类</code>实现的。</p>\n<p>由于<code>Read()</code>方法返回是否有下一行的布尔值，因此很适合使用<code>while循环</code>遍历结果。</p>\n<p>从代码中易知，<code>DataReader对象</code>的<code>Read()</code>方法是通过循环从数据源中每次获取一行数据，类似于plsql中的游标，他除了读取效率很高之外，牺牲了很多其他特性，例如对结果的排序、更改等。</p>\n<h3 id=\"DataSet和DataAdapter\"><a href=\"#DataSet和DataAdapter\" class=\"headerlink\" title=\"DataSet和DataAdapter\"></a>DataSet和DataAdapter</h3><p><code>DataSet类</code>包含数据的数据表集合。它用于在<strong>不与数据源交互</strong>的情况下获取数据，这就是为什么它也被称为<code>断开数据访问方法</code>。这是一个<strong>内存数据存储</strong>，可以<strong>同时容纳多个表</strong>。可以使用<code>DataRelation</code>对象来关联这些表。 <code>DataSet</code>也可以用来读写<code>XML文档</code>中的数据。</p>\n<p><code>DataAdapter</code>是<code>ADO.NET</code>数据提供程序的一部分。<code>DataAdapter</code>提供<strong>数据集和数据源之间的通信</strong>。我们可以将<code>DataAdapter</code>与<code>DataSet</code>对象结合使用。注意<code>DataAdapter类</code>也是<strong>各个数据源有各自的实现方法</strong>。</p>\n<p><code>DataAdapter</code>通过映射<code>Fill()</code>方法提供此组合，该方法更改<code>DataSet</code>中的数据以匹配数据源中的数据。也就是说，这两个对象组合起来以实现<code>数据访问</code>和<code>数据操作</code>功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataSet ds = new DataSet();</span><br><span class=\"line\">SqlDataAdapter adapter = new SqlDataAdapter(cmd); cmd.CommandText = &quot;select * from Student&quot;; adapter.Fill(ds, &quot;Student&quot;);</span><br><span class=\"line\">cmd.CommandText = &quot;select * from Score&quot;; adapter.Fill(ds, &quot;Score&quot;);</span><br><span class=\"line\">DataTable Student = ds.Tables[&quot;Student&quot;]; DataTable Score = ds.Tables[&quot;Score&quot;];</span><br></pre></td></tr></table></figure>\n<p>通过代码，我们可以看到<code>DataSet</code>是<strong>独立于数据源的数据集</strong>，即<strong>对于任何数据源，都提供一致的关系编程模型</strong>。</p>\n<p>相比于<code>DataReader</code>，<code>DataSet</code><strong>一次性将所有数据放入内存中</strong>，同时还提供了很多额外的数据集操作方法，因此<strong>速度很快且很方便</strong>，但是<strong>对内存资源会有很大的消耗</strong>。</p>\n<h3 id=\"DataTable\"><a href=\"#DataTable\" class=\"headerlink\" title=\"DataTable\"></a>DataTable</h3><p><code>DataTable</code>类将关系数据表示为表格形式。<code>ADO.NET</code>提供了一个<code>DataTable</code>类来独立创建和使用数据表。一般与<code>DataSet</code>一起使用。 </p>\n<p>在创建<code>DataTable</code>之前，<strong>必须包含<code>System.Data</code>名称空间</strong>。同时由于本例中使用了<code>AsEnumerable()</code>方法，因此还<strong>必须使用<code>Nuget</code>添加<code>System.Data.DataSetExtensions</code>包</strong>，<strong>否则会报错</strong>。</p>\n<p>我们可以使用LINQ语法对DataTable进行查询，实现代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var qry = from s in Student.AsEnumerable()</span><br><span class=\"line\">\t\t\t\t\tjoin c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class=\"line\">\t\t\t\t\twhere c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class=\"line\">          select new</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">                Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class=\"line\">                English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class=\"line\">                Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">foreach (var item in qry)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\tConsole.WriteLine(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* Output:</span><br><span class=\"line\">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class=\"line\">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class=\"line\">**//~</span><br></pre></td></tr></table></figure>"},{"title":"C# - .NETFramework及EntityFramework","date":"2019-04-18T03:07:39.000Z","_content":"\n## 概述\n\n`EntityFramework`是一种对象关系映射器`ORM`，它使`.NET`开发人员能够使用`.NET`对象处理数据库。它消除了开发人员通常需要编写的大多数数据访问代码的需要。\n\n<!-- more -->\n\n## 环境配置\n\n本次实验我使用最新的`Microsoft Visual Studio Community 2019 `版本进行实验，环境配置过程中也是历经坎坷，在此记录如下。\n\n### VS2019连接MySQL\n\n使用VS2019连接MySQL时需要两个必备的程序：\n\n- [mysql-for-visualstudio-1.2.8.msi](https://cdn.mysql.com//Downloads/MySQL-for-VisualStudio/mysql-for-visualstudio-1.2.8.msi)：`MySQL for Visual Studio`是`MySQL`提供给`Microsoft Visual Studio`的驱动，用来实现对MySQL对象和数据的访问。\n\n- [mysql-connector-net-6.10.8.msi](https://cdn.mysql.com//Downloads/Connector-Net/mysql-connector-net-6.10.8.msi)：`MySQL Connector / NET`能够开发需要与`MySQL`进行安全，高性能数据连接的.NET应用程序。它实现了所需的`ADO.NET`接口，并集成到`ADO.NET`感知工具中。\n\n下载并安装完成之后，启动`VS2019`，选择`工具`->`连接到数据库`：\n\n![1555337368613](/images/1555337368613.png)\n\n选择`MySQL Database`数据源：\n\n![1555337410546](/images/1555337410546.png)\n\n填入我在`ADO.NET实验`中创建的数据库参数如下：\n\n![1555337487973](/images/1555337487973.png)\n\n至此，关于`VS2019`连接`MySQL`的配置已经完成。\n\n### 关于创建的项目类型\n\n在`.NET`家族中有`.NET Core`和`.NET Framework`两大平台，他们的区别如下：\n\n**.NET Framework**：支持`Windows`和`Web`应用程序。今天，您可以使用`Windows`窗体，`WPF`和`UWP`在`.NET Framework`中构建`Windows`应用程序。`ASP.NET MVC`用于在`.NET Framework`中构建`Web应用程序`。\n\n**.NET Core**：是一种新的开源和跨平台框架，用于为包括`Windows`，`Mac`和`Linux`在内的所有操作系统构建应用程序。`.NET Core`仅支持`UWP`和`ASP.NET Core`。`UWP`用于构建`Windows 10`目标`Windows`和移动应用程序。`ASP.NET Core`用于构建基于浏览器的`Web应用程序`。 \n\n而在`VS2019`中也有两大类项目类型：\n\n- .NET Core应用\n\n  ![1555335982957](/images/1555335982957.png)\n\n- .NET Framework应用\n\n  ![1555336042119](/images/1555336042119.png)\n\n而我们本次实验一定要选择`.NET Framework`应用，否则无法通过`EntityFramework`创建实体数据模型。\n\n### 创建项目\n\n这里我选择的是`控制台应用(.NET Framework)`：\n\n![1555336181441](/images/1555336181441.png)\n\n注意最后一项`框架`最好选择`4.6.0`以上的框架，这里我选择最新版本`4.7.2`。\n\n### NuGet添加程序包\n\n![1555336839432](/images/1555336839432.png)\n\n使用NuGet添加程序包时最要紧的就是程序包的版本问题。\n\n**注意！！！：**在前面安装MySQL Connector / NET时，选择的版本是6.10.8，因此我们这里的MySql.Data和MySql.Data.Entity两个程序包的版本也需要一致为`v6.10.8`，否则会出现各式各样的错误，我遇到的错误有以下两个：\n\n1. ![1555337786084](/images/1555337786084.png)\n\n2. 在1问题解决后，点击下一步会闪退。\n\n至此环境配置已完成，下面针对EntityFramework三种模型来说明。\n\n## DB First（来自数据库的EF设计器）\n\n右键项目解决方案，选择`添加`->`新建项`：\n\n![1555338066598](/images/1555338066598.png)\n\n选择`ADO.NET实体数据模型`，单击`下一步`：\n\n![1555338108853](/images/1555338108853.png)\n\n选择`来自数据库的EF设计器`，单击`下一步`：\n\n![1555338141910](/images/1555338141910.png)\n\n点击`是，在连接字符串中包含敏感数据`，单击`下一步`：\n\n![1555338199372](/images/1555338199372.png)\n\n在`表`选项前打勾，单击完成：\n\n![1555338281068](/images/1555338281068.png)\n\n完成后会发现，项目解决方案中出现了`Model1.edmx`文件，里面有两种主要的类`DBContext`和`DBSet`：\n\n![1555338670472](/images/1555338670472.png)\n\n### DbSet\n\n`DbSet`对应于数据库中的表，意即每个实体表对应一个`DbSet`实体类，相当于数据的集合，可通过此类间接对数据库表进行`ACID操作`再通过`DbContext`关联到数据库。具体操作再介绍完`DbContext`后一齐举例。\n\n### DbContext\n\n `DbContext`类是实体框架的重要组成部分。它是您的域或实体类与数据库之间的桥梁。\n\n![1555338761379](/images/1555338761379.png)\n\n`DbContext`是负责与数据交互作为对象的主要类。`DbContext`负责以下活动：\n\n1. `EntitySet`： `DbContext`包含映射到数据库表的所有实体的实体集（`DbSet <TEntity>`）。\n2. 查询（Querying）： `DbContext`将`LINQ-to-Entities`查询转换为`SQL查询`并将其发送到数据库。\n3. 更改跟踪（Change Tracking）：跟踪实体在从数据库查询后发生的更改。\n4. 持久数据（Persisting Data）：它还根据实体的状态对数据库执行插入，更新和删除操作。\n5. 缓存（Caching）： DbContext默认进行一级缓存。它存储在上下文类生命周期中已经被检索的实体。\n6. 管理关系（Manage Relationship）： `DbContext`还使用`DB-First`或`Model-First`方法使用`CSDL`，`MSL`和`SSDL`或者使用`Code-First`方法使用流利的`API`来管理关系。\n7. 对象实现（Object Materialization）： `DbContext`将原始表数据转换为实体对象。\n\n下面是使用`DBContext`的示例：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EF\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            assignment4Entities entities = new assignment4Entities();\n\n            // 增\n            student student = new student\n            {\n                Id = 4,\n                Name = \"Tanrui\",\n                Age = 23\n            };\n            entities.student.Add(student);\n            student = new student\n            {\n                Id = 5,\n                Name = \"TanRui\",\n                Age = 23\n            };\n            entities.student.Add(student);\n            entities.SaveChanges();\n\n            // 删\n            foreach (var stu in entities.student.Where(stu => stu.Name == \"Tanrui1\"))\n            {\n                entities.student.Remove(stu);\n            }\n            entities.SaveChanges();\n\n            // 改\n            foreach ( var stu in entities.student.Where(stu => stu.Name == \"TanRui\") )\n            {\n                stu.Age = 25;\n            }\n            entities.SaveChanges();\n\n            // 查（使用Linq）\n            var query = from s in entities.student\n                        select new\n                        {\n                            Name = s.Name,\n                            Age = s.Age\n                        };\n            foreach(var item in query)\n            {\n                Console.WriteLine(item);\n            }\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n可通过数据库查看数据变化情况如期望一样。\n\n## Code First（空Code First模型）\n\n创建步骤和`DB First`类似，区别如下：\n\n在选择`实体数据模型内容`时选择`空Code First模型`，直接点击完成即可：\n\n![1555348366529](/images/1555348366529.png)\n\n点击完成后我们发现解决方案中出现了`Model1.cs`文件，同时查看`App.Config`文件发现多了下面内容：\n\n```xml\n<connectionStrings>\n    <add name=\"Model1\" connectionString=\"data source=(LocalDb)\\MSSQLLocalDB;initial catalog=EF.Model1;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework\" providerName=\"System.Data.SqlClient\" />\n  </connectionStrings>\n```\n\n`VS2019`默认使用`SQLserver数据库文件`格式存储`Code First`生成的数据模型，而此处我们要使用的是`MySQL数据库`，因此需要更改`connectionStrings`参数如下：\n\n```xml\n<connectionStrings>\n    <add name=\"Model1\" providerName=\"MySql.Data.MySqlClient\" connectionString=\"server=localhost;userid=tanrui;password=tanrui;database=assignment4;persistsecurityinfo=True\" />\n  </connectionStrings>\n```\n\n配置文件修改好之后，我们还需要修改`Model1.cs`文件，先看自动生成的内容：\n\n```c#\nnamespace EF\n{\n    using System;\n    using System.Data.Entity;\n    using System.Linq;\n    [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]\n    public class Model1 : DbContext\n    {\n        //您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)\n        //使用“Model1”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的\n        //“EF.Model1”数据库。\n        // \n        //如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“Model1”\n        //连接字符串。\n        public Model1()\n            : base(\"name=Model1\")\n        {\n        }\n\n        //为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型\n        //的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。\n\n        public virtual DbSet<MyEntity> MyEntities { get; set; }\n    }\n\n    public class MyEntity\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n    }\n}\n```\n\n`VS2019`为我们自动生成的`Model1.cs`中已经给出了最基本的`Code First范例`，这里为了简便起见，我们没有新建`MyEntity.cs文件`，而是直接在`Model1.cs`中声明此`Model类`，并在`Model1类`中定义对应的`DbSet对象`。\n\n注意，上述代码中第6行的 `[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]`内容需要手动添加，自动生成时不会自动添加。\n\n至此我们假设已经创建了一个简单的逻辑表，现在需要将其同步到数据库中：\n\n![1555348996560](/images/1555348996560.png)\n\n如图，打开`程序包管理器控制台`，输入如下代码：\n\n```\n# 为项目启用迁移\nPM> Enable-Migrations\n# 为当前设计器代码模型生成一次快照，在搭建迁移基架时会使用最近一次的快照，意即更改代码后，需要重新执行此命令\nPM> Add-Migration AddMyEntity\n# 将更改迁移到数据库\nPM> Update-Database -Verbose\n```\n\n可能出现的错误：\n\n```\n未为提供程序“MySql.Data.MySqlClient”找到任何 MigrationSqlGenerator。请在目标迁移配置类中使用 SetSqlGenerator 方法以注册其他 SQL 生成器。\n```\n\n原因：在Model1类定义前未手动添加`[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]`。\n\n当上述迁移成功完成后，就可以测试数据库是否真正生效了，测试代码如下：\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EF\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Model1 model = new Model1();\n            MyEntity entity = new MyEntity\n            {\n                Id = 1,\n                Name = \"Tanrui\"\n            };\n            model.MyEntities.Add(entity);\n            model.SaveChanges();\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n运行完之后查看数据库：\n\n![1555349943322](/images/1555349943322.png)\n\n可以看到，`myentities表`已成功添加到数据库中，一行数据也成功插入到表中了。\n\n> Tips: 注意到Code First还有个来自数据库的Code First，它实际上是根据现有的表生成对应的代码设计器，用户需要修改表结构时可通过修改设计器，而后更新迁移再更新到数据库中，个人感觉这和DB First没什么区别，而且不如DB First来的灵活。\n>\n> ![1555350134801](/images/1555350134801.png)","source":"_posts/NET-Framework及EntityFramework.md","raw":"---\ntitle: C# - .NETFramework及EntityFramework\ndate: 2019-04-18 11:07:39\ntags:\n    - .NET Framework\n    - EntityFramework\ncategories:\n    - C#\n---\n\n## 概述\n\n`EntityFramework`是一种对象关系映射器`ORM`，它使`.NET`开发人员能够使用`.NET`对象处理数据库。它消除了开发人员通常需要编写的大多数数据访问代码的需要。\n\n<!-- more -->\n\n## 环境配置\n\n本次实验我使用最新的`Microsoft Visual Studio Community 2019 `版本进行实验，环境配置过程中也是历经坎坷，在此记录如下。\n\n### VS2019连接MySQL\n\n使用VS2019连接MySQL时需要两个必备的程序：\n\n- [mysql-for-visualstudio-1.2.8.msi](https://cdn.mysql.com//Downloads/MySQL-for-VisualStudio/mysql-for-visualstudio-1.2.8.msi)：`MySQL for Visual Studio`是`MySQL`提供给`Microsoft Visual Studio`的驱动，用来实现对MySQL对象和数据的访问。\n\n- [mysql-connector-net-6.10.8.msi](https://cdn.mysql.com//Downloads/Connector-Net/mysql-connector-net-6.10.8.msi)：`MySQL Connector / NET`能够开发需要与`MySQL`进行安全，高性能数据连接的.NET应用程序。它实现了所需的`ADO.NET`接口，并集成到`ADO.NET`感知工具中。\n\n下载并安装完成之后，启动`VS2019`，选择`工具`->`连接到数据库`：\n\n![1555337368613](/images/1555337368613.png)\n\n选择`MySQL Database`数据源：\n\n![1555337410546](/images/1555337410546.png)\n\n填入我在`ADO.NET实验`中创建的数据库参数如下：\n\n![1555337487973](/images/1555337487973.png)\n\n至此，关于`VS2019`连接`MySQL`的配置已经完成。\n\n### 关于创建的项目类型\n\n在`.NET`家族中有`.NET Core`和`.NET Framework`两大平台，他们的区别如下：\n\n**.NET Framework**：支持`Windows`和`Web`应用程序。今天，您可以使用`Windows`窗体，`WPF`和`UWP`在`.NET Framework`中构建`Windows`应用程序。`ASP.NET MVC`用于在`.NET Framework`中构建`Web应用程序`。\n\n**.NET Core**：是一种新的开源和跨平台框架，用于为包括`Windows`，`Mac`和`Linux`在内的所有操作系统构建应用程序。`.NET Core`仅支持`UWP`和`ASP.NET Core`。`UWP`用于构建`Windows 10`目标`Windows`和移动应用程序。`ASP.NET Core`用于构建基于浏览器的`Web应用程序`。 \n\n而在`VS2019`中也有两大类项目类型：\n\n- .NET Core应用\n\n  ![1555335982957](/images/1555335982957.png)\n\n- .NET Framework应用\n\n  ![1555336042119](/images/1555336042119.png)\n\n而我们本次实验一定要选择`.NET Framework`应用，否则无法通过`EntityFramework`创建实体数据模型。\n\n### 创建项目\n\n这里我选择的是`控制台应用(.NET Framework)`：\n\n![1555336181441](/images/1555336181441.png)\n\n注意最后一项`框架`最好选择`4.6.0`以上的框架，这里我选择最新版本`4.7.2`。\n\n### NuGet添加程序包\n\n![1555336839432](/images/1555336839432.png)\n\n使用NuGet添加程序包时最要紧的就是程序包的版本问题。\n\n**注意！！！：**在前面安装MySQL Connector / NET时，选择的版本是6.10.8，因此我们这里的MySql.Data和MySql.Data.Entity两个程序包的版本也需要一致为`v6.10.8`，否则会出现各式各样的错误，我遇到的错误有以下两个：\n\n1. ![1555337786084](/images/1555337786084.png)\n\n2. 在1问题解决后，点击下一步会闪退。\n\n至此环境配置已完成，下面针对EntityFramework三种模型来说明。\n\n## DB First（来自数据库的EF设计器）\n\n右键项目解决方案，选择`添加`->`新建项`：\n\n![1555338066598](/images/1555338066598.png)\n\n选择`ADO.NET实体数据模型`，单击`下一步`：\n\n![1555338108853](/images/1555338108853.png)\n\n选择`来自数据库的EF设计器`，单击`下一步`：\n\n![1555338141910](/images/1555338141910.png)\n\n点击`是，在连接字符串中包含敏感数据`，单击`下一步`：\n\n![1555338199372](/images/1555338199372.png)\n\n在`表`选项前打勾，单击完成：\n\n![1555338281068](/images/1555338281068.png)\n\n完成后会发现，项目解决方案中出现了`Model1.edmx`文件，里面有两种主要的类`DBContext`和`DBSet`：\n\n![1555338670472](/images/1555338670472.png)\n\n### DbSet\n\n`DbSet`对应于数据库中的表，意即每个实体表对应一个`DbSet`实体类，相当于数据的集合，可通过此类间接对数据库表进行`ACID操作`再通过`DbContext`关联到数据库。具体操作再介绍完`DbContext`后一齐举例。\n\n### DbContext\n\n `DbContext`类是实体框架的重要组成部分。它是您的域或实体类与数据库之间的桥梁。\n\n![1555338761379](/images/1555338761379.png)\n\n`DbContext`是负责与数据交互作为对象的主要类。`DbContext`负责以下活动：\n\n1. `EntitySet`： `DbContext`包含映射到数据库表的所有实体的实体集（`DbSet <TEntity>`）。\n2. 查询（Querying）： `DbContext`将`LINQ-to-Entities`查询转换为`SQL查询`并将其发送到数据库。\n3. 更改跟踪（Change Tracking）：跟踪实体在从数据库查询后发生的更改。\n4. 持久数据（Persisting Data）：它还根据实体的状态对数据库执行插入，更新和删除操作。\n5. 缓存（Caching）： DbContext默认进行一级缓存。它存储在上下文类生命周期中已经被检索的实体。\n6. 管理关系（Manage Relationship）： `DbContext`还使用`DB-First`或`Model-First`方法使用`CSDL`，`MSL`和`SSDL`或者使用`Code-First`方法使用流利的`API`来管理关系。\n7. 对象实现（Object Materialization）： `DbContext`将原始表数据转换为实体对象。\n\n下面是使用`DBContext`的示例：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EF\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            assignment4Entities entities = new assignment4Entities();\n\n            // 增\n            student student = new student\n            {\n                Id = 4,\n                Name = \"Tanrui\",\n                Age = 23\n            };\n            entities.student.Add(student);\n            student = new student\n            {\n                Id = 5,\n                Name = \"TanRui\",\n                Age = 23\n            };\n            entities.student.Add(student);\n            entities.SaveChanges();\n\n            // 删\n            foreach (var stu in entities.student.Where(stu => stu.Name == \"Tanrui1\"))\n            {\n                entities.student.Remove(stu);\n            }\n            entities.SaveChanges();\n\n            // 改\n            foreach ( var stu in entities.student.Where(stu => stu.Name == \"TanRui\") )\n            {\n                stu.Age = 25;\n            }\n            entities.SaveChanges();\n\n            // 查（使用Linq）\n            var query = from s in entities.student\n                        select new\n                        {\n                            Name = s.Name,\n                            Age = s.Age\n                        };\n            foreach(var item in query)\n            {\n                Console.WriteLine(item);\n            }\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n可通过数据库查看数据变化情况如期望一样。\n\n## Code First（空Code First模型）\n\n创建步骤和`DB First`类似，区别如下：\n\n在选择`实体数据模型内容`时选择`空Code First模型`，直接点击完成即可：\n\n![1555348366529](/images/1555348366529.png)\n\n点击完成后我们发现解决方案中出现了`Model1.cs`文件，同时查看`App.Config`文件发现多了下面内容：\n\n```xml\n<connectionStrings>\n    <add name=\"Model1\" connectionString=\"data source=(LocalDb)\\MSSQLLocalDB;initial catalog=EF.Model1;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework\" providerName=\"System.Data.SqlClient\" />\n  </connectionStrings>\n```\n\n`VS2019`默认使用`SQLserver数据库文件`格式存储`Code First`生成的数据模型，而此处我们要使用的是`MySQL数据库`，因此需要更改`connectionStrings`参数如下：\n\n```xml\n<connectionStrings>\n    <add name=\"Model1\" providerName=\"MySql.Data.MySqlClient\" connectionString=\"server=localhost;userid=tanrui;password=tanrui;database=assignment4;persistsecurityinfo=True\" />\n  </connectionStrings>\n```\n\n配置文件修改好之后，我们还需要修改`Model1.cs`文件，先看自动生成的内容：\n\n```c#\nnamespace EF\n{\n    using System;\n    using System.Data.Entity;\n    using System.Linq;\n    [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]\n    public class Model1 : DbContext\n    {\n        //您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)\n        //使用“Model1”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的\n        //“EF.Model1”数据库。\n        // \n        //如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“Model1”\n        //连接字符串。\n        public Model1()\n            : base(\"name=Model1\")\n        {\n        }\n\n        //为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型\n        //的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。\n\n        public virtual DbSet<MyEntity> MyEntities { get; set; }\n    }\n\n    public class MyEntity\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n    }\n}\n```\n\n`VS2019`为我们自动生成的`Model1.cs`中已经给出了最基本的`Code First范例`，这里为了简便起见，我们没有新建`MyEntity.cs文件`，而是直接在`Model1.cs`中声明此`Model类`，并在`Model1类`中定义对应的`DbSet对象`。\n\n注意，上述代码中第6行的 `[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]`内容需要手动添加，自动生成时不会自动添加。\n\n至此我们假设已经创建了一个简单的逻辑表，现在需要将其同步到数据库中：\n\n![1555348996560](/images/1555348996560.png)\n\n如图，打开`程序包管理器控制台`，输入如下代码：\n\n```\n# 为项目启用迁移\nPM> Enable-Migrations\n# 为当前设计器代码模型生成一次快照，在搭建迁移基架时会使用最近一次的快照，意即更改代码后，需要重新执行此命令\nPM> Add-Migration AddMyEntity\n# 将更改迁移到数据库\nPM> Update-Database -Verbose\n```\n\n可能出现的错误：\n\n```\n未为提供程序“MySql.Data.MySqlClient”找到任何 MigrationSqlGenerator。请在目标迁移配置类中使用 SetSqlGenerator 方法以注册其他 SQL 生成器。\n```\n\n原因：在Model1类定义前未手动添加`[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]`。\n\n当上述迁移成功完成后，就可以测试数据库是否真正生效了，测试代码如下：\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EF\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Model1 model = new Model1();\n            MyEntity entity = new MyEntity\n            {\n                Id = 1,\n                Name = \"Tanrui\"\n            };\n            model.MyEntities.Add(entity);\n            model.SaveChanges();\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n运行完之后查看数据库：\n\n![1555349943322](/images/1555349943322.png)\n\n可以看到，`myentities表`已成功添加到数据库中，一行数据也成功插入到表中了。\n\n> Tips: 注意到Code First还有个来自数据库的Code First，它实际上是根据现有的表生成对应的代码设计器，用户需要修改表结构时可通过修改设计器，而后更新迁移再更新到数据库中，个人感觉这和DB First没什么区别，而且不如DB First来的灵活。\n>\n> ![1555350134801](/images/1555350134801.png)","slug":"NET-Framework及EntityFramework","published":1,"updated":"2021-05-16T10:55:48.167Z","_id":"ckfukja97000eszxo9f0lygyj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>EntityFramework</code>是一种对象关系映射器<code>ORM</code>，它使<code>.NET</code>开发人员能够使用<code>.NET</code>对象处理数据库。它消除了开发人员通常需要编写的大多数数据访问代码的需要。</p>\n<a id=\"more\"></a>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>本次实验我使用最新的<code>Microsoft Visual Studio Community 2019</code>版本进行实验，环境配置过程中也是历经坎坷，在此记录如下。</p>\n<h3 id=\"VS2019连接MySQL\"><a href=\"#VS2019连接MySQL\" class=\"headerlink\" title=\"VS2019连接MySQL\"></a>VS2019连接MySQL</h3><p>使用VS2019连接MySQL时需要两个必备的程序：</p>\n<ul>\n<li><p><a href=\"https://cdn.mysql.com//Downloads/MySQL-for-VisualStudio/mysql-for-visualstudio-1.2.8.msi\" target=\"_blank\" rel=\"noopener\">mysql-for-visualstudio-1.2.8.msi</a>：<code>MySQL for Visual Studio</code>是<code>MySQL</code>提供给<code>Microsoft Visual Studio</code>的驱动，用来实现对MySQL对象和数据的访问。</p>\n</li>\n<li><p><a href=\"https://cdn.mysql.com//Downloads/Connector-Net/mysql-connector-net-6.10.8.msi\" target=\"_blank\" rel=\"noopener\">mysql-connector-net-6.10.8.msi</a>：<code>MySQL Connector / NET</code>能够开发需要与<code>MySQL</code>进行安全，高性能数据连接的.NET应用程序。它实现了所需的<code>ADO.NET</code>接口，并集成到<code>ADO.NET</code>感知工具中。</p>\n</li>\n</ul>\n<p>下载并安装完成之后，启动<code>VS2019</code>，选择<code>工具</code>-&gt;<code>连接到数据库</code>：</p>\n<p><img src=\"/images/1555337368613.png\" alt=\"1555337368613\"></p>\n<p>选择<code>MySQL Database</code>数据源：</p>\n<p><img src=\"/images/1555337410546.png\" alt=\"1555337410546\"></p>\n<p>填入我在<code>ADO.NET实验</code>中创建的数据库参数如下：</p>\n<p><img src=\"/images/1555337487973.png\" alt=\"1555337487973\"></p>\n<p>至此，关于<code>VS2019</code>连接<code>MySQL</code>的配置已经完成。</p>\n<h3 id=\"关于创建的项目类型\"><a href=\"#关于创建的项目类型\" class=\"headerlink\" title=\"关于创建的项目类型\"></a>关于创建的项目类型</h3><p>在<code>.NET</code>家族中有<code>.NET Core</code>和<code>.NET Framework</code>两大平台，他们的区别如下：</p>\n<p><strong>.NET Framework</strong>：支持<code>Windows</code>和<code>Web</code>应用程序。今天，您可以使用<code>Windows</code>窗体，<code>WPF</code>和<code>UWP</code>在<code>.NET Framework</code>中构建<code>Windows</code>应用程序。<code>ASP.NET MVC</code>用于在<code>.NET Framework</code>中构建<code>Web应用程序</code>。</p>\n<p><strong>.NET Core</strong>：是一种新的开源和跨平台框架，用于为包括<code>Windows</code>，<code>Mac</code>和<code>Linux</code>在内的所有操作系统构建应用程序。<code>.NET Core</code>仅支持<code>UWP</code>和<code>ASP.NET Core</code>。<code>UWP</code>用于构建<code>Windows 10</code>目标<code>Windows</code>和移动应用程序。<code>ASP.NET Core</code>用于构建基于浏览器的<code>Web应用程序</code>。 </p>\n<p>而在<code>VS2019</code>中也有两大类项目类型：</p>\n<ul>\n<li><p>.NET Core应用</p>\n<p><img src=\"/images/1555335982957.png\" alt=\"1555335982957\"></p>\n</li>\n<li><p>.NET Framework应用</p>\n<p><img src=\"/images/1555336042119.png\" alt=\"1555336042119\"></p>\n</li>\n</ul>\n<p>而我们本次实验一定要选择<code>.NET Framework</code>应用，否则无法通过<code>EntityFramework</code>创建实体数据模型。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>这里我选择的是<code>控制台应用(.NET Framework)</code>：</p>\n<p><img src=\"/images/1555336181441.png\" alt=\"1555336181441\"></p>\n<p>注意最后一项<code>框架</code>最好选择<code>4.6.0</code>以上的框架，这里我选择最新版本<code>4.7.2</code>。</p>\n<h3 id=\"NuGet添加程序包\"><a href=\"#NuGet添加程序包\" class=\"headerlink\" title=\"NuGet添加程序包\"></a>NuGet添加程序包</h3><p><img src=\"/images/1555336839432.png\" alt=\"1555336839432\"></p>\n<p>使用NuGet添加程序包时最要紧的就是程序包的版本问题。</p>\n<p><strong>注意！！！：</strong>在前面安装MySQL Connector / NET时，选择的版本是6.10.8，因此我们这里的MySql.Data和MySql.Data.Entity两个程序包的版本也需要一致为<code>v6.10.8</code>，否则会出现各式各样的错误，我遇到的错误有以下两个：</p>\n<ol>\n<li><p><img src=\"/images/1555337786084.png\" alt=\"1555337786084\"></p>\n</li>\n<li><p>在1问题解决后，点击下一步会闪退。</p>\n</li>\n</ol>\n<p>至此环境配置已完成，下面针对EntityFramework三种模型来说明。</p>\n<h2 id=\"DB-First（来自数据库的EF设计器）\"><a href=\"#DB-First（来自数据库的EF设计器）\" class=\"headerlink\" title=\"DB First（来自数据库的EF设计器）\"></a>DB First（来自数据库的EF设计器）</h2><p>右键项目解决方案，选择<code>添加</code>-&gt;<code>新建项</code>：</p>\n<p><img src=\"/images/1555338066598.png\" alt=\"1555338066598\"></p>\n<p>选择<code>ADO.NET实体数据模型</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338108853.png\" alt=\"1555338108853\"></p>\n<p>选择<code>来自数据库的EF设计器</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338141910.png\" alt=\"1555338141910\"></p>\n<p>点击<code>是，在连接字符串中包含敏感数据</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338199372.png\" alt=\"1555338199372\"></p>\n<p>在<code>表</code>选项前打勾，单击完成：</p>\n<p><img src=\"/images/1555338281068.png\" alt=\"1555338281068\"></p>\n<p>完成后会发现，项目解决方案中出现了<code>Model1.edmx</code>文件，里面有两种主要的类<code>DBContext</code>和<code>DBSet</code>：</p>\n<p><img src=\"/images/1555338670472.png\" alt=\"1555338670472\"></p>\n<h3 id=\"DbSet\"><a href=\"#DbSet\" class=\"headerlink\" title=\"DbSet\"></a>DbSet</h3><p><code>DbSet</code>对应于数据库中的表，意即每个实体表对应一个<code>DbSet</code>实体类，相当于数据的集合，可通过此类间接对数据库表进行<code>ACID操作</code>再通过<code>DbContext</code>关联到数据库。具体操作再介绍完<code>DbContext</code>后一齐举例。</p>\n<h3 id=\"DbContext\"><a href=\"#DbContext\" class=\"headerlink\" title=\"DbContext\"></a>DbContext</h3><p> <code>DbContext</code>类是实体框架的重要组成部分。它是您的域或实体类与数据库之间的桥梁。</p>\n<p><img src=\"/images/1555338761379.png\" alt=\"1555338761379\"></p>\n<p><code>DbContext</code>是负责与数据交互作为对象的主要类。<code>DbContext</code>负责以下活动：</p>\n<ol>\n<li><code>EntitySet</code>： <code>DbContext</code>包含映射到数据库表的所有实体的实体集（<code>DbSet &lt;TEntity&gt;</code>）。</li>\n<li>查询（Querying）： <code>DbContext</code>将<code>LINQ-to-Entities</code>查询转换为<code>SQL查询</code>并将其发送到数据库。</li>\n<li>更改跟踪（Change Tracking）：跟踪实体在从数据库查询后发生的更改。</li>\n<li>持久数据（Persisting Data）：它还根据实体的状态对数据库执行插入，更新和删除操作。</li>\n<li>缓存（Caching）： DbContext默认进行一级缓存。它存储在上下文类生命周期中已经被检索的实体。</li>\n<li>管理关系（Manage Relationship）： <code>DbContext</code>还使用<code>DB-First</code>或<code>Model-First</code>方法使用<code>CSDL</code>，<code>MSL</code>和<code>SSDL</code>或者使用<code>Code-First</code>方法使用流利的<code>API</code>来管理关系。</li>\n<li>对象实现（Object Materialization）： <code>DbContext</code>将原始表数据转换为实体对象。</li>\n</ol>\n<p>下面是使用<code>DBContext</code>的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assignment4Entities entities = new assignment4Entities();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 增</span><br><span class=\"line\">            student student = new student</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 4,</span><br><span class=\"line\">                Name = &quot;Tanrui&quot;,</span><br><span class=\"line\">                Age = 23</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            entities.student.Add(student);</span><br><span class=\"line\">            student = new student</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 5,</span><br><span class=\"line\">                Name = &quot;TanRui&quot;,</span><br><span class=\"line\">                Age = 23</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            entities.student.Add(student);</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 删</span><br><span class=\"line\">            foreach (var stu in entities.student.Where(stu =&gt; stu.Name == &quot;Tanrui1&quot;))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entities.student.Remove(stu);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 改</span><br><span class=\"line\">            foreach ( var stu in entities.student.Where(stu =&gt; stu.Name == &quot;TanRui&quot;) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                stu.Age = 25;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 查（使用Linq）</span><br><span class=\"line\">            var query = from s in entities.student</span><br><span class=\"line\">                        select new</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            Name = s.Name,</span><br><span class=\"line\">                            Age = s.Age</span><br><span class=\"line\">                        &#125;;</span><br><span class=\"line\">            foreach(var item in query)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过数据库查看数据变化情况如期望一样。</p>\n<h2 id=\"Code-First（空Code-First模型）\"><a href=\"#Code-First（空Code-First模型）\" class=\"headerlink\" title=\"Code First（空Code First模型）\"></a>Code First（空Code First模型）</h2><p>创建步骤和<code>DB First</code>类似，区别如下：</p>\n<p>在选择<code>实体数据模型内容</code>时选择<code>空Code First模型</code>，直接点击完成即可：</p>\n<p><img src=\"/images/1555348366529.png\" alt=\"1555348366529\"></p>\n<p>点击完成后我们发现解决方案中出现了<code>Model1.cs</code>文件，同时查看<code>App.Config</code>文件发现多了下面内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Model1\"</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">\"data source=(LocalDb)\\MSSQLLocalDB;initial catalog=EF.Model1;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework\"</span> <span class=\"attr\">providerName</span>=<span class=\"string\">\"System.Data.SqlClient\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>VS2019</code>默认使用<code>SQLserver数据库文件</code>格式存储<code>Code First</code>生成的数据模型，而此处我们要使用的是<code>MySQL数据库</code>，因此需要更改<code>connectionStrings</code>参数如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Model1\"</span> <span class=\"attr\">providerName</span>=<span class=\"string\">\"MySql.Data.MySqlClient\"</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">\"server=localhost;userid=tanrui;password=tanrui;database=assignment4;persistsecurityinfo=True\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置文件修改好之后，我们还需要修改<code>Model1.cs</code>文件，先看自动生成的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    using System;</span><br><span class=\"line\">    using System.Data.Entity;</span><br><span class=\"line\">    using System.Linq;</span><br><span class=\"line\">    [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</span><br><span class=\"line\">    public class Model1 : DbContext</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)</span><br><span class=\"line\">        //使用“Model1”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的</span><br><span class=\"line\">        //“EF.Model1”数据库。</span><br><span class=\"line\">        // </span><br><span class=\"line\">        //如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“Model1”</span><br><span class=\"line\">        //连接字符串。</span><br><span class=\"line\">        public Model1()</span><br><span class=\"line\">            : base(&quot;name=Model1&quot;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型</span><br><span class=\"line\">        //的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。</span><br><span class=\"line\"></span><br><span class=\"line\">        public virtual DbSet&lt;MyEntity&gt; MyEntities &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class MyEntity</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>VS2019</code>为我们自动生成的<code>Model1.cs</code>中已经给出了最基本的<code>Code First范例</code>，这里为了简便起见，我们没有新建<code>MyEntity.cs文件</code>，而是直接在<code>Model1.cs</code>中声明此<code>Model类</code>，并在<code>Model1类</code>中定义对应的<code>DbSet对象</code>。</p>\n<p>注意，上述代码中第6行的 <code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>内容需要手动添加，自动生成时不会自动添加。</p>\n<p>至此我们假设已经创建了一个简单的逻辑表，现在需要将其同步到数据库中：</p>\n<p><img src=\"/images/1555348996560.png\" alt=\"1555348996560\"></p>\n<p>如图，打开<code>程序包管理器控制台</code>，输入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 为项目启用迁移</span><br><span class=\"line\">PM&gt; Enable-Migrations</span><br><span class=\"line\"># 为当前设计器代码模型生成一次快照，在搭建迁移基架时会使用最近一次的快照，意即更改代码后，需要重新执行此命令</span><br><span class=\"line\">PM&gt; Add-Migration AddMyEntity</span><br><span class=\"line\"># 将更改迁移到数据库</span><br><span class=\"line\">PM&gt; Update-Database -Verbose</span><br></pre></td></tr></table></figure>\n<p>可能出现的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">未为提供程序“MySql.Data.MySqlClient”找到任何 MigrationSqlGenerator。请在目标迁移配置类中使用 SetSqlGenerator 方法以注册其他 SQL 生成器。</span><br></pre></td></tr></table></figure>\n<p>原因：在Model1类定义前未手动添加<code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>。</p>\n<p>当上述迁移成功完成后，就可以测试数据库是否真正生效了，测试代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Model1 model = new Model1();</span><br><span class=\"line\">            MyEntity entity = new MyEntity</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 1,</span><br><span class=\"line\">                Name = &quot;Tanrui&quot;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            model.MyEntities.Add(entity);</span><br><span class=\"line\">            model.SaveChanges();</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行完之后查看数据库：</p>\n<p><img src=\"/images/1555349943322.png\" alt=\"1555349943322\"></p>\n<p>可以看到，<code>myentities表</code>已成功添加到数据库中，一行数据也成功插入到表中了。</p>\n<blockquote>\n<p>Tips: 注意到Code First还有个来自数据库的Code First，它实际上是根据现有的表生成对应的代码设计器，用户需要修改表结构时可通过修改设计器，而后更新迁移再更新到数据库中，个人感觉这和DB First没什么区别，而且不如DB First来的灵活。</p>\n<p><img src=\"/images/1555350134801.png\" alt=\"1555350134801\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>EntityFramework</code>是一种对象关系映射器<code>ORM</code>，它使<code>.NET</code>开发人员能够使用<code>.NET</code>对象处理数据库。它消除了开发人员通常需要编写的大多数数据访问代码的需要。</p>","more":"<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>本次实验我使用最新的<code>Microsoft Visual Studio Community 2019</code>版本进行实验，环境配置过程中也是历经坎坷，在此记录如下。</p>\n<h3 id=\"VS2019连接MySQL\"><a href=\"#VS2019连接MySQL\" class=\"headerlink\" title=\"VS2019连接MySQL\"></a>VS2019连接MySQL</h3><p>使用VS2019连接MySQL时需要两个必备的程序：</p>\n<ul>\n<li><p><a href=\"https://cdn.mysql.com//Downloads/MySQL-for-VisualStudio/mysql-for-visualstudio-1.2.8.msi\" target=\"_blank\" rel=\"noopener\">mysql-for-visualstudio-1.2.8.msi</a>：<code>MySQL for Visual Studio</code>是<code>MySQL</code>提供给<code>Microsoft Visual Studio</code>的驱动，用来实现对MySQL对象和数据的访问。</p>\n</li>\n<li><p><a href=\"https://cdn.mysql.com//Downloads/Connector-Net/mysql-connector-net-6.10.8.msi\" target=\"_blank\" rel=\"noopener\">mysql-connector-net-6.10.8.msi</a>：<code>MySQL Connector / NET</code>能够开发需要与<code>MySQL</code>进行安全，高性能数据连接的.NET应用程序。它实现了所需的<code>ADO.NET</code>接口，并集成到<code>ADO.NET</code>感知工具中。</p>\n</li>\n</ul>\n<p>下载并安装完成之后，启动<code>VS2019</code>，选择<code>工具</code>-&gt;<code>连接到数据库</code>：</p>\n<p><img src=\"/images/1555337368613.png\" alt=\"1555337368613\"></p>\n<p>选择<code>MySQL Database</code>数据源：</p>\n<p><img src=\"/images/1555337410546.png\" alt=\"1555337410546\"></p>\n<p>填入我在<code>ADO.NET实验</code>中创建的数据库参数如下：</p>\n<p><img src=\"/images/1555337487973.png\" alt=\"1555337487973\"></p>\n<p>至此，关于<code>VS2019</code>连接<code>MySQL</code>的配置已经完成。</p>\n<h3 id=\"关于创建的项目类型\"><a href=\"#关于创建的项目类型\" class=\"headerlink\" title=\"关于创建的项目类型\"></a>关于创建的项目类型</h3><p>在<code>.NET</code>家族中有<code>.NET Core</code>和<code>.NET Framework</code>两大平台，他们的区别如下：</p>\n<p><strong>.NET Framework</strong>：支持<code>Windows</code>和<code>Web</code>应用程序。今天，您可以使用<code>Windows</code>窗体，<code>WPF</code>和<code>UWP</code>在<code>.NET Framework</code>中构建<code>Windows</code>应用程序。<code>ASP.NET MVC</code>用于在<code>.NET Framework</code>中构建<code>Web应用程序</code>。</p>\n<p><strong>.NET Core</strong>：是一种新的开源和跨平台框架，用于为包括<code>Windows</code>，<code>Mac</code>和<code>Linux</code>在内的所有操作系统构建应用程序。<code>.NET Core</code>仅支持<code>UWP</code>和<code>ASP.NET Core</code>。<code>UWP</code>用于构建<code>Windows 10</code>目标<code>Windows</code>和移动应用程序。<code>ASP.NET Core</code>用于构建基于浏览器的<code>Web应用程序</code>。 </p>\n<p>而在<code>VS2019</code>中也有两大类项目类型：</p>\n<ul>\n<li><p>.NET Core应用</p>\n<p><img src=\"/images/1555335982957.png\" alt=\"1555335982957\"></p>\n</li>\n<li><p>.NET Framework应用</p>\n<p><img src=\"/images/1555336042119.png\" alt=\"1555336042119\"></p>\n</li>\n</ul>\n<p>而我们本次实验一定要选择<code>.NET Framework</code>应用，否则无法通过<code>EntityFramework</code>创建实体数据模型。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>这里我选择的是<code>控制台应用(.NET Framework)</code>：</p>\n<p><img src=\"/images/1555336181441.png\" alt=\"1555336181441\"></p>\n<p>注意最后一项<code>框架</code>最好选择<code>4.6.0</code>以上的框架，这里我选择最新版本<code>4.7.2</code>。</p>\n<h3 id=\"NuGet添加程序包\"><a href=\"#NuGet添加程序包\" class=\"headerlink\" title=\"NuGet添加程序包\"></a>NuGet添加程序包</h3><p><img src=\"/images/1555336839432.png\" alt=\"1555336839432\"></p>\n<p>使用NuGet添加程序包时最要紧的就是程序包的版本问题。</p>\n<p><strong>注意！！！：</strong>在前面安装MySQL Connector / NET时，选择的版本是6.10.8，因此我们这里的MySql.Data和MySql.Data.Entity两个程序包的版本也需要一致为<code>v6.10.8</code>，否则会出现各式各样的错误，我遇到的错误有以下两个：</p>\n<ol>\n<li><p><img src=\"/images/1555337786084.png\" alt=\"1555337786084\"></p>\n</li>\n<li><p>在1问题解决后，点击下一步会闪退。</p>\n</li>\n</ol>\n<p>至此环境配置已完成，下面针对EntityFramework三种模型来说明。</p>\n<h2 id=\"DB-First（来自数据库的EF设计器）\"><a href=\"#DB-First（来自数据库的EF设计器）\" class=\"headerlink\" title=\"DB First（来自数据库的EF设计器）\"></a>DB First（来自数据库的EF设计器）</h2><p>右键项目解决方案，选择<code>添加</code>-&gt;<code>新建项</code>：</p>\n<p><img src=\"/images/1555338066598.png\" alt=\"1555338066598\"></p>\n<p>选择<code>ADO.NET实体数据模型</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338108853.png\" alt=\"1555338108853\"></p>\n<p>选择<code>来自数据库的EF设计器</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338141910.png\" alt=\"1555338141910\"></p>\n<p>点击<code>是，在连接字符串中包含敏感数据</code>，单击<code>下一步</code>：</p>\n<p><img src=\"/images/1555338199372.png\" alt=\"1555338199372\"></p>\n<p>在<code>表</code>选项前打勾，单击完成：</p>\n<p><img src=\"/images/1555338281068.png\" alt=\"1555338281068\"></p>\n<p>完成后会发现，项目解决方案中出现了<code>Model1.edmx</code>文件，里面有两种主要的类<code>DBContext</code>和<code>DBSet</code>：</p>\n<p><img src=\"/images/1555338670472.png\" alt=\"1555338670472\"></p>\n<h3 id=\"DbSet\"><a href=\"#DbSet\" class=\"headerlink\" title=\"DbSet\"></a>DbSet</h3><p><code>DbSet</code>对应于数据库中的表，意即每个实体表对应一个<code>DbSet</code>实体类，相当于数据的集合，可通过此类间接对数据库表进行<code>ACID操作</code>再通过<code>DbContext</code>关联到数据库。具体操作再介绍完<code>DbContext</code>后一齐举例。</p>\n<h3 id=\"DbContext\"><a href=\"#DbContext\" class=\"headerlink\" title=\"DbContext\"></a>DbContext</h3><p> <code>DbContext</code>类是实体框架的重要组成部分。它是您的域或实体类与数据库之间的桥梁。</p>\n<p><img src=\"/images/1555338761379.png\" alt=\"1555338761379\"></p>\n<p><code>DbContext</code>是负责与数据交互作为对象的主要类。<code>DbContext</code>负责以下活动：</p>\n<ol>\n<li><code>EntitySet</code>： <code>DbContext</code>包含映射到数据库表的所有实体的实体集（<code>DbSet &lt;TEntity&gt;</code>）。</li>\n<li>查询（Querying）： <code>DbContext</code>将<code>LINQ-to-Entities</code>查询转换为<code>SQL查询</code>并将其发送到数据库。</li>\n<li>更改跟踪（Change Tracking）：跟踪实体在从数据库查询后发生的更改。</li>\n<li>持久数据（Persisting Data）：它还根据实体的状态对数据库执行插入，更新和删除操作。</li>\n<li>缓存（Caching）： DbContext默认进行一级缓存。它存储在上下文类生命周期中已经被检索的实体。</li>\n<li>管理关系（Manage Relationship）： <code>DbContext</code>还使用<code>DB-First</code>或<code>Model-First</code>方法使用<code>CSDL</code>，<code>MSL</code>和<code>SSDL</code>或者使用<code>Code-First</code>方法使用流利的<code>API</code>来管理关系。</li>\n<li>对象实现（Object Materialization）： <code>DbContext</code>将原始表数据转换为实体对象。</li>\n</ol>\n<p>下面是使用<code>DBContext</code>的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            assignment4Entities entities = new assignment4Entities();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 增</span><br><span class=\"line\">            student student = new student</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 4,</span><br><span class=\"line\">                Name = &quot;Tanrui&quot;,</span><br><span class=\"line\">                Age = 23</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            entities.student.Add(student);</span><br><span class=\"line\">            student = new student</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 5,</span><br><span class=\"line\">                Name = &quot;TanRui&quot;,</span><br><span class=\"line\">                Age = 23</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            entities.student.Add(student);</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 删</span><br><span class=\"line\">            foreach (var stu in entities.student.Where(stu =&gt; stu.Name == &quot;Tanrui1&quot;))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entities.student.Remove(stu);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 改</span><br><span class=\"line\">            foreach ( var stu in entities.student.Where(stu =&gt; stu.Name == &quot;TanRui&quot;) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                stu.Age = 25;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entities.SaveChanges();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 查（使用Linq）</span><br><span class=\"line\">            var query = from s in entities.student</span><br><span class=\"line\">                        select new</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            Name = s.Name,</span><br><span class=\"line\">                            Age = s.Age</span><br><span class=\"line\">                        &#125;;</span><br><span class=\"line\">            foreach(var item in query)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可通过数据库查看数据变化情况如期望一样。</p>\n<h2 id=\"Code-First（空Code-First模型）\"><a href=\"#Code-First（空Code-First模型）\" class=\"headerlink\" title=\"Code First（空Code First模型）\"></a>Code First（空Code First模型）</h2><p>创建步骤和<code>DB First</code>类似，区别如下：</p>\n<p>在选择<code>实体数据模型内容</code>时选择<code>空Code First模型</code>，直接点击完成即可：</p>\n<p><img src=\"/images/1555348366529.png\" alt=\"1555348366529\"></p>\n<p>点击完成后我们发现解决方案中出现了<code>Model1.cs</code>文件，同时查看<code>App.Config</code>文件发现多了下面内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Model1\"</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">\"data source=(LocalDb)\\MSSQLLocalDB;initial catalog=EF.Model1;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework\"</span> <span class=\"attr\">providerName</span>=<span class=\"string\">\"System.Data.SqlClient\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>VS2019</code>默认使用<code>SQLserver数据库文件</code>格式存储<code>Code First</code>生成的数据模型，而此处我们要使用的是<code>MySQL数据库</code>，因此需要更改<code>connectionStrings</code>参数如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">connectionStrings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Model1\"</span> <span class=\"attr\">providerName</span>=<span class=\"string\">\"MySql.Data.MySqlClient\"</span> <span class=\"attr\">connectionString</span>=<span class=\"string\">\"server=localhost;userid=tanrui;password=tanrui;database=assignment4;persistsecurityinfo=True\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置文件修改好之后，我们还需要修改<code>Model1.cs</code>文件，先看自动生成的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    using System;</span><br><span class=\"line\">    using System.Data.Entity;</span><br><span class=\"line\">    using System.Linq;</span><br><span class=\"line\">    [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</span><br><span class=\"line\">    public class Model1 : DbContext</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)</span><br><span class=\"line\">        //使用“Model1”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的</span><br><span class=\"line\">        //“EF.Model1”数据库。</span><br><span class=\"line\">        // </span><br><span class=\"line\">        //如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“Model1”</span><br><span class=\"line\">        //连接字符串。</span><br><span class=\"line\">        public Model1()</span><br><span class=\"line\">            : base(&quot;name=Model1&quot;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型</span><br><span class=\"line\">        //的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。</span><br><span class=\"line\"></span><br><span class=\"line\">        public virtual DbSet&lt;MyEntity&gt; MyEntities &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class MyEntity</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>VS2019</code>为我们自动生成的<code>Model1.cs</code>中已经给出了最基本的<code>Code First范例</code>，这里为了简便起见，我们没有新建<code>MyEntity.cs文件</code>，而是直接在<code>Model1.cs</code>中声明此<code>Model类</code>，并在<code>Model1类</code>中定义对应的<code>DbSet对象</code>。</p>\n<p>注意，上述代码中第6行的 <code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>内容需要手动添加，自动生成时不会自动添加。</p>\n<p>至此我们假设已经创建了一个简单的逻辑表，现在需要将其同步到数据库中：</p>\n<p><img src=\"/images/1555348996560.png\" alt=\"1555348996560\"></p>\n<p>如图，打开<code>程序包管理器控制台</code>，输入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 为项目启用迁移</span><br><span class=\"line\">PM&gt; Enable-Migrations</span><br><span class=\"line\"># 为当前设计器代码模型生成一次快照，在搭建迁移基架时会使用最近一次的快照，意即更改代码后，需要重新执行此命令</span><br><span class=\"line\">PM&gt; Add-Migration AddMyEntity</span><br><span class=\"line\"># 将更改迁移到数据库</span><br><span class=\"line\">PM&gt; Update-Database -Verbose</span><br></pre></td></tr></table></figure>\n<p>可能出现的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">未为提供程序“MySql.Data.MySqlClient”找到任何 MigrationSqlGenerator。请在目标迁移配置类中使用 SetSqlGenerator 方法以注册其他 SQL 生成器。</span><br></pre></td></tr></table></figure>\n<p>原因：在Model1类定义前未手动添加<code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>。</p>\n<p>当上述迁移成功完成后，就可以测试数据库是否真正生效了，测试代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace EF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Model1 model = new Model1();</span><br><span class=\"line\">            MyEntity entity = new MyEntity</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Id = 1,</span><br><span class=\"line\">                Name = &quot;Tanrui&quot;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            model.MyEntities.Add(entity);</span><br><span class=\"line\">            model.SaveChanges();</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行完之后查看数据库：</p>\n<p><img src=\"/images/1555349943322.png\" alt=\"1555349943322\"></p>\n<p>可以看到，<code>myentities表</code>已成功添加到数据库中，一行数据也成功插入到表中了。</p>\n<blockquote>\n<p>Tips: 注意到Code First还有个来自数据库的Code First，它实际上是根据现有的表生成对应的代码设计器，用户需要修改表结构时可通过修改设计器，而后更新迁移再更新到数据库中，个人感觉这和DB First没什么区别，而且不如DB First来的灵活。</p>\n<p><img src=\"/images/1555350134801.png\" alt=\"1555350134801\"></p>\n</blockquote>"},{"title":"Hadoop-Tags","date":"2018-12-11T16:33:02.000Z","_content":"\n\n# Hadoop Tags\n\n## HDFS\n\n<!-- more -->\n\n1. NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等）\n\n2. 文件分块默认最小块128M\n\n3. `jps`命令查看NameNode/DataNode是否启动\n\n   1. ~~jps在jdk8u191中好像不适用，暂未找到解决方法~~\n\n4. `ip:9870`利用web界面查看Hadoop节点信息（Mac上端口号为`50070`）\n\n5. 进入用户目录下的`.ssh`目录，执行`ssh-keygen -t rsa`创建公钥私钥，使用`ssh-copy-id ${hostname}`将公钥传给每个节点（NameNode和DataNode都需要）\n\n6. 使用`hadoop fs -ls /`查看Hadoop上所有文件，使用`hadoop fs -put ${filename} /`上传文件…\n\n7. `hdfs-site.xml`中修改`dfs.replication`配置可修改文件备份份数（默认为3），修改`dfs.namenode.heartbead.recheck-interval`指定Hadoop检查机器运行情况的时间间隔（默认3000000ms）\n\n   注意：\n\n   1. 例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   2. 当使用java访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n8. `分鱼展`:分块、冗余、可扩展\n\n## Yarn\n\n1. ResourceManage\n\n2. NodeManage一般与DataNode放一起 \n\n3. Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用\n\n4. `yarn-site.xml`的配置\n\n   **注意：master与slaves都需要进行配置。**\n\n   ```xml\n    <property>\n        <name>yarn.resourcemanager.hostname</name>\n        <value>master</value>\n    </property>\n   ```\n\n5. `mapred-site.xml`的配置\n\n   **注意：**\n\n   - 仅NameNode需要配置\n   - MapReduce不一定需要Yarn\n   - 若不配MapReduce，其会仅在单机跑\n\n   ```xml\n   <property>\n       <name>mapreduce.framework.name</name>\n       <value>yarn</value>\n   </property>\n   ```\n\n# Hive\n\n1. 创建Hive、Hadoop环境变量，方便敲命令\n\n2. 修改`hive-site.xml`\n\n   1. hive的conf目录下刚初始化时没有\bhive-site.xml，需要将`hive-default.xml.template`复制一份更名为hive-site.xml\n   2. 将hive-site.xml中所有的(4个)`${system:java.io.tmpdir}`替换为`/usr/local/hive/tmp`，将所有的(4个)`${system:user.name}`替换为`root`\n\n3. 进入hive根目录，执行\n\n    ```shell\n    schematool -initSchema -dbType derby\n    ```\n    - 上述命令执行完毕后会在对应目录下新建metastore_db目录，用于存储数据目录\n    - derby是hive自带的小数据库，后续需要将derby更换成mysql(TODO)\n\n4. \b在该目录下启动\b执行`hive`\n\n   **注意：**\n   - hive命令执行时，必须与metastore_db在同一目录下\n   - hive启动前需要将hdfs也启动，不然会报错\n\n5. hive连接mysql\n\n    - 关于\b虚拟机安装了mysql数据库，主机无法连接的问题如下：\n\n    ```plsql\n    mysql> use mysql;\n    Database changed\n    mysql> select 'host' from user where user='root'\n        -> ;\n    +------+\n    | host |\n    +------+\n    | localhost |\n    +------+\n    1 row in set (0.00 sec)\n\n    mysql> update user set host = '%' where user ='root';\n    Query OK, 1 row affected (0.00 sec)\n    Rows matched: 1  Changed: 1  Warnings: 0\n\n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n\n    mysql> select 'host'   from user where user='root';\n    +------+\n    | host |\n    +------+\n    |  %   |\n    +------+\n    1 row in set (0.00 sec)\n    ```\n\n    - 解决jdbc连接hive时出现`Open Session Error`\n\n    ```xml\n    <property>\n        <name>hadoop.proxyuser.hadoop.hosts</name>\n        <value>*</value>\n    </property>\n    <property>\n        <name>hadoop.proxyuser.hadoop.groups</name>\n        <value>*</value>\n    </property>\n    ```\n\n6. hive表存储格式\n\n   1. TextFile\n   2. SequenceFile\n   3. RCFile\n   4. ORCFile\n\n# HA的实现\n\n## 集群环境\n\n- Hadoop 2.9.2\n- \bHive 2.3.4\n- MySQL 5.7\n- Zookeeper 3.4.10\n- JDK 8u191\n\n## 集群结构图\n\n> 共9台机器，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），1台应用服务器\n\n| 主机名 | IP | 软件 | 运行进程 |\n| :--------: | :--------:| :--: | :--: |\n| node0 | 192.168.137.200 | ZooKeeper | QuorumPeerMain |\n| node1 | 192.168.137.201 | ZooKeeper | QuorumPeerMain |\n| node2 | 192.168.137.202 | ZooKeeper | QuorumPeerMain |\n| master | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 | 192.168.137.10 | Hadoop,Hive | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1 | 192.168.137.101 | Hadoop | JournalNode,DataNode,NodeManager |\n| slave2 | 192.168.137.102 | Hadoop | DataNode,NodeManager |\n| slave3 | 192.168.137.103 | Hadoop | DataNode,NodeManager |\n| host | 192.168.137.1 | 应用服务器 | |\n\n## 集群启动步骤\n\n```shell\n# 在三台zookeeper上启动zkServer\nzkServer.sh start\n\n# master上执行hdfs和yarn集群的启动\nstart-dfs.sh\nstart-yarn.sh\n\n# master1上的ResourceManager不知道为何不会自动启动，因此手动\nyarn-daemon.sh start resourcemanager\n\n# master和master1上\b都要启动hiveserver2\nhiveserver2\n```\n\n## 关于[二级缓存](http://www.datanucleus.org/products/accessplatform_3_0/jpa/cache.html)的若干事宜\n\n在集群启动完毕之后，我在master的hive中使用`create table test(...)`语句创建了一个表并导入了一些数据，而后通过应用执行该表的相关查询后，发现时不时提示表`test`不存在，通过hive查看master和master1的表结构，发现master1中竟然没有表test，查阅资料后看到一篇博文[《hive datanucleus cache 不一致问题》](https://blog.csdn.net/lalaguozhe/article/details/9184593)，是关于hive中的DataNucleus二级缓存的设置，`datanucleus.cache.level2.type`的设置(`none`,`soft`,`weak`)直接影响二级缓存是否启用，关于二级缓存的具体机制我还没弄清楚，之后我又在[Hortonworks](https://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.6.5/bk_command-line-installation/content/set_up_hive_hcat_configuration_files.html)的文档中看到下面的话：\n\n> **Important**:\n> Hortonworks recommends that deployments <font color=red>**disable the DataNucleus cache**</font> by setting the value of the datanucleus.cache.level2.type configuration parameter to none. The datanucleus.cache.level2 configuration parameter is ignored, and assigning a value of none to this parameter does not have the desired effect.\n\n可能是\bHiveserver2本身在HA的层面就不建议修改库、表结构，因此若要更改表结构或者创建新表同时实现数据同步，我试了以下两种方式均可实现：\n\n1. 第一种关闭并重新初始化集群，启动master和所有的DataNode，在master上执行建库建表导入数据，而后启动master1将其作为standby初始化，这时master1会同步master的数据，最后启动master和master1的hiveserver2\n\n2. 第二种是同时在master和master1的hive客户端上执行同样的建表语句，而后在master(或者master1)上执行`load`命令加载数据，即可同步数据\n\n    > \b第二种方法又出现了个有趣的问题：导入数据完成后，在两台机器上分别执行`count`操作会发现由于加载数据的机器count正常，另一台机器count结果为0，但是执行`select *`又确实能发现数据存在，就很玄学。\n\n# TODO List\n\n- 安全与权限（kerberos）\n- Secondary NameNode（check point NameNode）\n- HA（High Ability）实现\n- Federation，超大规模数据中心","source":"_posts/Hadoop-Tags.md","raw":"---\ntitle: Hadoop-Tags\ndate: 2018-12-12 00:33:02\ntags:\n    - Hadoop配置记录\ncategories:\n    - 分布式与云计算\n---\n\n\n# Hadoop Tags\n\n## HDFS\n\n<!-- more -->\n\n1. NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等）\n\n2. 文件分块默认最小块128M\n\n3. `jps`命令查看NameNode/DataNode是否启动\n\n   1. ~~jps在jdk8u191中好像不适用，暂未找到解决方法~~\n\n4. `ip:9870`利用web界面查看Hadoop节点信息（Mac上端口号为`50070`）\n\n5. 进入用户目录下的`.ssh`目录，执行`ssh-keygen -t rsa`创建公钥私钥，使用`ssh-copy-id ${hostname}`将公钥传给每个节点（NameNode和DataNode都需要）\n\n6. 使用`hadoop fs -ls /`查看Hadoop上所有文件，使用`hadoop fs -put ${filename} /`上传文件…\n\n7. `hdfs-site.xml`中修改`dfs.replication`配置可修改文件备份份数（默认为3），修改`dfs.namenode.heartbead.recheck-interval`指定Hadoop检查机器运行情况的时间间隔（默认3000000ms）\n\n   注意：\n\n   1. 例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   2. 当使用java访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n8. `分鱼展`:分块、冗余、可扩展\n\n## Yarn\n\n1. ResourceManage\n\n2. NodeManage一般与DataNode放一起 \n\n3. Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用\n\n4. `yarn-site.xml`的配置\n\n   **注意：master与slaves都需要进行配置。**\n\n   ```xml\n    <property>\n        <name>yarn.resourcemanager.hostname</name>\n        <value>master</value>\n    </property>\n   ```\n\n5. `mapred-site.xml`的配置\n\n   **注意：**\n\n   - 仅NameNode需要配置\n   - MapReduce不一定需要Yarn\n   - 若不配MapReduce，其会仅在单机跑\n\n   ```xml\n   <property>\n       <name>mapreduce.framework.name</name>\n       <value>yarn</value>\n   </property>\n   ```\n\n# Hive\n\n1. 创建Hive、Hadoop环境变量，方便敲命令\n\n2. 修改`hive-site.xml`\n\n   1. hive的conf目录下刚初始化时没有\bhive-site.xml，需要将`hive-default.xml.template`复制一份更名为hive-site.xml\n   2. 将hive-site.xml中所有的(4个)`${system:java.io.tmpdir}`替换为`/usr/local/hive/tmp`，将所有的(4个)`${system:user.name}`替换为`root`\n\n3. 进入hive根目录，执行\n\n    ```shell\n    schematool -initSchema -dbType derby\n    ```\n    - 上述命令执行完毕后会在对应目录下新建metastore_db目录，用于存储数据目录\n    - derby是hive自带的小数据库，后续需要将derby更换成mysql(TODO)\n\n4. \b在该目录下启动\b执行`hive`\n\n   **注意：**\n   - hive命令执行时，必须与metastore_db在同一目录下\n   - hive启动前需要将hdfs也启动，不然会报错\n\n5. hive连接mysql\n\n    - 关于\b虚拟机安装了mysql数据库，主机无法连接的问题如下：\n\n    ```plsql\n    mysql> use mysql;\n    Database changed\n    mysql> select 'host' from user where user='root'\n        -> ;\n    +------+\n    | host |\n    +------+\n    | localhost |\n    +------+\n    1 row in set (0.00 sec)\n\n    mysql> update user set host = '%' where user ='root';\n    Query OK, 1 row affected (0.00 sec)\n    Rows matched: 1  Changed: 1  Warnings: 0\n\n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n\n    mysql> select 'host'   from user where user='root';\n    +------+\n    | host |\n    +------+\n    |  %   |\n    +------+\n    1 row in set (0.00 sec)\n    ```\n\n    - 解决jdbc连接hive时出现`Open Session Error`\n\n    ```xml\n    <property>\n        <name>hadoop.proxyuser.hadoop.hosts</name>\n        <value>*</value>\n    </property>\n    <property>\n        <name>hadoop.proxyuser.hadoop.groups</name>\n        <value>*</value>\n    </property>\n    ```\n\n6. hive表存储格式\n\n   1. TextFile\n   2. SequenceFile\n   3. RCFile\n   4. ORCFile\n\n# HA的实现\n\n## 集群环境\n\n- Hadoop 2.9.2\n- \bHive 2.3.4\n- MySQL 5.7\n- Zookeeper 3.4.10\n- JDK 8u191\n\n## 集群结构图\n\n> 共9台机器，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），1台应用服务器\n\n| 主机名 | IP | 软件 | 运行进程 |\n| :--------: | :--------:| :--: | :--: |\n| node0 | 192.168.137.200 | ZooKeeper | QuorumPeerMain |\n| node1 | 192.168.137.201 | ZooKeeper | QuorumPeerMain |\n| node2 | 192.168.137.202 | ZooKeeper | QuorumPeerMain |\n| master | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 | 192.168.137.10 | Hadoop,Hive | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1 | 192.168.137.101 | Hadoop | JournalNode,DataNode,NodeManager |\n| slave2 | 192.168.137.102 | Hadoop | DataNode,NodeManager |\n| slave3 | 192.168.137.103 | Hadoop | DataNode,NodeManager |\n| host | 192.168.137.1 | 应用服务器 | |\n\n## 集群启动步骤\n\n```shell\n# 在三台zookeeper上启动zkServer\nzkServer.sh start\n\n# master上执行hdfs和yarn集群的启动\nstart-dfs.sh\nstart-yarn.sh\n\n# master1上的ResourceManager不知道为何不会自动启动，因此手动\nyarn-daemon.sh start resourcemanager\n\n# master和master1上\b都要启动hiveserver2\nhiveserver2\n```\n\n## 关于[二级缓存](http://www.datanucleus.org/products/accessplatform_3_0/jpa/cache.html)的若干事宜\n\n在集群启动完毕之后，我在master的hive中使用`create table test(...)`语句创建了一个表并导入了一些数据，而后通过应用执行该表的相关查询后，发现时不时提示表`test`不存在，通过hive查看master和master1的表结构，发现master1中竟然没有表test，查阅资料后看到一篇博文[《hive datanucleus cache 不一致问题》](https://blog.csdn.net/lalaguozhe/article/details/9184593)，是关于hive中的DataNucleus二级缓存的设置，`datanucleus.cache.level2.type`的设置(`none`,`soft`,`weak`)直接影响二级缓存是否启用，关于二级缓存的具体机制我还没弄清楚，之后我又在[Hortonworks](https://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.6.5/bk_command-line-installation/content/set_up_hive_hcat_configuration_files.html)的文档中看到下面的话：\n\n> **Important**:\n> Hortonworks recommends that deployments <font color=red>**disable the DataNucleus cache**</font> by setting the value of the datanucleus.cache.level2.type configuration parameter to none. The datanucleus.cache.level2 configuration parameter is ignored, and assigning a value of none to this parameter does not have the desired effect.\n\n可能是\bHiveserver2本身在HA的层面就不建议修改库、表结构，因此若要更改表结构或者创建新表同时实现数据同步，我试了以下两种方式均可实现：\n\n1. 第一种关闭并重新初始化集群，启动master和所有的DataNode，在master上执行建库建表导入数据，而后启动master1将其作为standby初始化，这时master1会同步master的数据，最后启动master和master1的hiveserver2\n\n2. 第二种是同时在master和master1的hive客户端上执行同样的建表语句，而后在master(或者master1)上执行`load`命令加载数据，即可同步数据\n\n    > \b第二种方法又出现了个有趣的问题：导入数据完成后，在两台机器上分别执行`count`操作会发现由于加载数据的机器count正常，另一台机器count结果为0，但是执行`select *`又确实能发现数据存在，就很玄学。\n\n# TODO List\n\n- 安全与权限（kerberos）\n- Secondary NameNode（check point NameNode）\n- HA（High Ability）实现\n- Federation，超大规模数据中心","slug":"Hadoop-Tags","published":1,"updated":"2021-05-16T10:55:03.721Z","_id":"ckfukja9b000fszxoyswtcdf2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Hadoop-Tags\"><a href=\"#Hadoop-Tags\" class=\"headerlink\" title=\"Hadoop Tags\"></a>Hadoop Tags</h1><h2 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h2><a id=\"more\"></a>\n<ol>\n<li><p>NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等）</p>\n</li>\n<li><p>文件分块默认最小块128M</p>\n</li>\n<li><p><code>jps</code>命令查看NameNode/DataNode是否启动</p>\n<ol>\n<li><del>jps在jdk8u191中好像不适用，暂未找到解决方法</del></li>\n</ol>\n</li>\n<li><p><code>ip:9870</code>利用web界面查看Hadoop节点信息（Mac上端口号为<code>50070</code>）</p>\n</li>\n<li><p>进入用户目录下的<code>.ssh</code>目录，执行<code>ssh-keygen -t rsa</code>创建公钥私钥，使用<code>ssh-copy-id ${hostname}</code>将公钥传给每个节点（NameNode和DataNode都需要）</p>\n</li>\n<li><p>使用<code>hadoop fs -ls /</code>查看Hadoop上所有文件，使用<code>hadoop fs -put ${filename} /</code>上传文件…</p>\n</li>\n<li><p><code>hdfs-site.xml</code>中修改<code>dfs.replication</code>配置可修改文件备份份数（默认为3），修改<code>dfs.namenode.heartbead.recheck-interval</code>指定Hadoop检查机器运行情况的时间间隔（默认3000000ms）</p>\n<p>注意：</p>\n<ol>\n<li>例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用java访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ol>\n</li>\n<li><p><code>分鱼展</code>:分块、冗余、可扩展</p>\n</li>\n</ol>\n<h2 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h2><ol>\n<li><p>ResourceManage</p>\n</li>\n<li><p>NodeManage一般与DataNode放一起 </p>\n</li>\n<li><p>Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用</p>\n</li>\n<li><p><code>yarn-site.xml</code>的配置</p>\n<p><strong>注意：master与slaves都需要进行配置。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>mapred-site.xml</code>的配置</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>仅NameNode需要配置</li>\n<li>MapReduce不一定需要Yarn</li>\n<li>若不配MapReduce，其会仅在单机跑</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h1><ol>\n<li><p>创建Hive、Hadoop环境变量，方便敲命令</p>\n</li>\n<li><p>修改<code>hive-site.xml</code></p>\n<ol>\n<li>hive的conf目录下刚初始化时没有\bhive-site.xml，需要将<code>hive-default.xml.template</code>复制一份更名为hive-site.xml</li>\n<li>将hive-site.xml中所有的(4个)<code>${system:java.io.tmpdir}</code>替换为<code>/usr/local/hive/tmp</code>，将所有的(4个)<code>${system:user.name}</code>替换为<code>root</code></li>\n</ol>\n</li>\n<li><p>进入hive根目录，执行</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">schematool -initSchema -dbType derby</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述命令执行完毕后会在对应目录下新建metastore_db目录，用于存储数据目录</li>\n<li>derby是hive自带的小数据库，后续需要将derby更换成mysql(TODO)</li>\n</ul>\n</li>\n<li><p>\b在该目录下启动\b执行<code>hive</code></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>hive命令执行时，必须与metastore_db在同一目录下</li>\n<li>hive启动前需要将hdfs也启动，不然会报错</li>\n</ul>\n</li>\n<li><p>hive连接mysql</p>\n<ul>\n<li><p>关于\b虚拟机安装了mysql数据库，主机无法连接的问题如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; use mysql;</span><br><span class=\"line\">Database changed</span><br><span class=\"line\">mysql&gt; select &apos;host&apos; from user where user=&apos;root&apos;</span><br><span class=\"line\">    -&gt; ;</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| host |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| localhost |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update user set host = &apos;%&apos; where user =&apos;root&apos;;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; flush privileges;</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select &apos;host&apos;   from user where user=&apos;root&apos;;</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| host |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">|  %   |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决jdbc连接hive时出现<code>Open Session Error</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>hive表存储格式</p>\n<ol>\n<li>TextFile</li>\n<li>SequenceFile</li>\n<li>RCFile</li>\n<li>ORCFile</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"HA的实现\"><a href=\"#HA的实现\" class=\"headerlink\" title=\"HA的实现\"></a>HA的实现</h1><h2 id=\"集群环境\"><a href=\"#集群环境\" class=\"headerlink\" title=\"集群环境\"></a>集群环境</h2><ul>\n<li>Hadoop 2.9.2</li>\n<li>\bHive 2.3.4</li>\n<li>MySQL 5.7</li>\n<li>Zookeeper 3.4.10</li>\n<li>JDK 8u191</li>\n</ul>\n<h2 id=\"集群结构图\"><a href=\"#集群结构图\" class=\"headerlink\" title=\"集群结构图\"></a>集群结构图</h2><blockquote>\n<p>共9台机器，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），1台应用服务器</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集群启动步骤\"><a href=\"#集群启动步骤\" class=\"headerlink\" title=\"集群启动步骤\"></a>集群启动步骤</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 在三台zookeeper上启动zkServer</span><br><span class=\"line\">zkServer.sh start</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master上执行hdfs和yarn集群的启动</span><br><span class=\"line\">start-dfs.sh</span><br><span class=\"line\">start-yarn.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master1上的ResourceManager不知道为何不会自动启动，因此手动</span><br><span class=\"line\">yarn-daemon.sh start resourcemanager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master和master1上\b都要启动hiveserver2</span><br><span class=\"line\">hiveserver2</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于二级缓存的若干事宜\"><a href=\"#关于二级缓存的若干事宜\" class=\"headerlink\" title=\"关于二级缓存的若干事宜\"></a>关于<a href=\"http://www.datanucleus.org/products/accessplatform_3_0/jpa/cache.html\" target=\"_blank\" rel=\"noopener\">二级缓存</a>的若干事宜</h2><p>在集群启动完毕之后，我在master的hive中使用<code>create table test(...)</code>语句创建了一个表并导入了一些数据，而后通过应用执行该表的相关查询后，发现时不时提示表<code>test</code>不存在，通过hive查看master和master1的表结构，发现master1中竟然没有表test，查阅资料后看到一篇博文<a href=\"https://blog.csdn.net/lalaguozhe/article/details/9184593\" target=\"_blank\" rel=\"noopener\">《hive datanucleus cache 不一致问题》</a>，是关于hive中的DataNucleus二级缓存的设置，<code>datanucleus.cache.level2.type</code>的设置(<code>none</code>,<code>soft</code>,<code>weak</code>)直接影响二级缓存是否启用，关于二级缓存的具体机制我还没弄清楚，之后我又在<a href=\"https://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.6.5/bk_command-line-installation/content/set_up_hive_hcat_configuration_files.html\" target=\"_blank\" rel=\"noopener\">Hortonworks</a>的文档中看到下面的话：</p>\n<blockquote>\n<p><strong>Important</strong>:<br>Hortonworks recommends that deployments <font color=\"red\"><strong>disable the DataNucleus cache</strong></font> by setting the value of the datanucleus.cache.level2.type configuration parameter to none. The datanucleus.cache.level2 configuration parameter is ignored, and assigning a value of none to this parameter does not have the desired effect.</p>\n</blockquote>\n<p>可能是\bHiveserver2本身在HA的层面就不建议修改库、表结构，因此若要更改表结构或者创建新表同时实现数据同步，我试了以下两种方式均可实现：</p>\n<ol>\n<li><p>第一种关闭并重新初始化集群，启动master和所有的DataNode，在master上执行建库建表导入数据，而后启动master1将其作为standby初始化，这时master1会同步master的数据，最后启动master和master1的hiveserver2</p>\n</li>\n<li><p>第二种是同时在master和master1的hive客户端上执行同样的建表语句，而后在master(或者master1)上执行<code>load</code>命令加载数据，即可同步数据</p>\n<blockquote>\n<p>\b第二种方法又出现了个有趣的问题：导入数据完成后，在两台机器上分别执行<code>count</code>操作会发现由于加载数据的机器count正常，另一台机器count结果为0，但是执行<code>select *</code>又确实能发现数据存在，就很玄学。</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"TODO-List\"><a href=\"#TODO-List\" class=\"headerlink\" title=\"TODO List\"></a>TODO List</h1><ul>\n<li>安全与权限（kerberos）</li>\n<li>Secondary NameNode（check point NameNode）</li>\n<li>HA（High Ability）实现</li>\n<li>Federation，超大规模数据中心</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Hadoop-Tags\"><a href=\"#Hadoop-Tags\" class=\"headerlink\" title=\"Hadoop Tags\"></a>Hadoop Tags</h1><h2 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h2>","more":"<ol>\n<li><p>NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等）</p>\n</li>\n<li><p>文件分块默认最小块128M</p>\n</li>\n<li><p><code>jps</code>命令查看NameNode/DataNode是否启动</p>\n<ol>\n<li><del>jps在jdk8u191中好像不适用，暂未找到解决方法</del></li>\n</ol>\n</li>\n<li><p><code>ip:9870</code>利用web界面查看Hadoop节点信息（Mac上端口号为<code>50070</code>）</p>\n</li>\n<li><p>进入用户目录下的<code>.ssh</code>目录，执行<code>ssh-keygen -t rsa</code>创建公钥私钥，使用<code>ssh-copy-id ${hostname}</code>将公钥传给每个节点（NameNode和DataNode都需要）</p>\n</li>\n<li><p>使用<code>hadoop fs -ls /</code>查看Hadoop上所有文件，使用<code>hadoop fs -put ${filename} /</code>上传文件…</p>\n</li>\n<li><p><code>hdfs-site.xml</code>中修改<code>dfs.replication</code>配置可修改文件备份份数（默认为3），修改<code>dfs.namenode.heartbead.recheck-interval</code>指定Hadoop检查机器运行情况的时间间隔（默认3000000ms）</p>\n<p>注意：</p>\n<ol>\n<li>例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用java访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ol>\n</li>\n<li><p><code>分鱼展</code>:分块、冗余、可扩展</p>\n</li>\n</ol>\n<h2 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h2><ol>\n<li><p>ResourceManage</p>\n</li>\n<li><p>NodeManage一般与DataNode放一起 </p>\n</li>\n<li><p>Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用</p>\n</li>\n<li><p><code>yarn-site.xml</code>的配置</p>\n<p><strong>注意：master与slaves都需要进行配置。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>mapred-site.xml</code>的配置</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>仅NameNode需要配置</li>\n<li>MapReduce不一定需要Yarn</li>\n<li>若不配MapReduce，其会仅在单机跑</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h1><ol>\n<li><p>创建Hive、Hadoop环境变量，方便敲命令</p>\n</li>\n<li><p>修改<code>hive-site.xml</code></p>\n<ol>\n<li>hive的conf目录下刚初始化时没有\bhive-site.xml，需要将<code>hive-default.xml.template</code>复制一份更名为hive-site.xml</li>\n<li>将hive-site.xml中所有的(4个)<code>${system:java.io.tmpdir}</code>替换为<code>/usr/local/hive/tmp</code>，将所有的(4个)<code>${system:user.name}</code>替换为<code>root</code></li>\n</ol>\n</li>\n<li><p>进入hive根目录，执行</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">schematool -initSchema -dbType derby</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上述命令执行完毕后会在对应目录下新建metastore_db目录，用于存储数据目录</li>\n<li>derby是hive自带的小数据库，后续需要将derby更换成mysql(TODO)</li>\n</ul>\n</li>\n<li><p>\b在该目录下启动\b执行<code>hive</code></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>hive命令执行时，必须与metastore_db在同一目录下</li>\n<li>hive启动前需要将hdfs也启动，不然会报错</li>\n</ul>\n</li>\n<li><p>hive连接mysql</p>\n<ul>\n<li><p>关于\b虚拟机安装了mysql数据库，主机无法连接的问题如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; use mysql;</span><br><span class=\"line\">Database changed</span><br><span class=\"line\">mysql&gt; select &apos;host&apos; from user where user=&apos;root&apos;</span><br><span class=\"line\">    -&gt; ;</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| host |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| localhost |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update user set host = &apos;%&apos; where user =&apos;root&apos;;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; flush privileges;</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select &apos;host&apos;   from user where user=&apos;root&apos;;</span><br><span class=\"line\">+------+</span><br><span class=\"line\">| host |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">|  %   |</span><br><span class=\"line\">+------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决jdbc连接hive时出现<code>Open Session Error</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>hive表存储格式</p>\n<ol>\n<li>TextFile</li>\n<li>SequenceFile</li>\n<li>RCFile</li>\n<li>ORCFile</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"HA的实现\"><a href=\"#HA的实现\" class=\"headerlink\" title=\"HA的实现\"></a>HA的实现</h1><h2 id=\"集群环境\"><a href=\"#集群环境\" class=\"headerlink\" title=\"集群环境\"></a>集群环境</h2><ul>\n<li>Hadoop 2.9.2</li>\n<li>\bHive 2.3.4</li>\n<li>MySQL 5.7</li>\n<li>Zookeeper 3.4.10</li>\n<li>JDK 8u191</li>\n</ul>\n<h2 id=\"集群结构图\"><a href=\"#集群结构图\" class=\"headerlink\" title=\"集群结构图\"></a>集群结构图</h2><blockquote>\n<p>共9台机器，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），1台应用服务器</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集群启动步骤\"><a href=\"#集群启动步骤\" class=\"headerlink\" title=\"集群启动步骤\"></a>集群启动步骤</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 在三台zookeeper上启动zkServer</span><br><span class=\"line\">zkServer.sh start</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master上执行hdfs和yarn集群的启动</span><br><span class=\"line\">start-dfs.sh</span><br><span class=\"line\">start-yarn.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master1上的ResourceManager不知道为何不会自动启动，因此手动</span><br><span class=\"line\">yarn-daemon.sh start resourcemanager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> master和master1上\b都要启动hiveserver2</span><br><span class=\"line\">hiveserver2</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于二级缓存的若干事宜\"><a href=\"#关于二级缓存的若干事宜\" class=\"headerlink\" title=\"关于二级缓存的若干事宜\"></a>关于<a href=\"http://www.datanucleus.org/products/accessplatform_3_0/jpa/cache.html\" target=\"_blank\" rel=\"noopener\">二级缓存</a>的若干事宜</h2><p>在集群启动完毕之后，我在master的hive中使用<code>create table test(...)</code>语句创建了一个表并导入了一些数据，而后通过应用执行该表的相关查询后，发现时不时提示表<code>test</code>不存在，通过hive查看master和master1的表结构，发现master1中竟然没有表test，查阅资料后看到一篇博文<a href=\"https://blog.csdn.net/lalaguozhe/article/details/9184593\" target=\"_blank\" rel=\"noopener\">《hive datanucleus cache 不一致问题》</a>，是关于hive中的DataNucleus二级缓存的设置，<code>datanucleus.cache.level2.type</code>的设置(<code>none</code>,<code>soft</code>,<code>weak</code>)直接影响二级缓存是否启用，关于二级缓存的具体机制我还没弄清楚，之后我又在<a href=\"https://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.6.5/bk_command-line-installation/content/set_up_hive_hcat_configuration_files.html\" target=\"_blank\" rel=\"noopener\">Hortonworks</a>的文档中看到下面的话：</p>\n<blockquote>\n<p><strong>Important</strong>:<br>Hortonworks recommends that deployments <font color=\"red\"><strong>disable the DataNucleus cache</strong></font> by setting the value of the datanucleus.cache.level2.type configuration parameter to none. The datanucleus.cache.level2 configuration parameter is ignored, and assigning a value of none to this parameter does not have the desired effect.</p>\n</blockquote>\n<p>可能是\bHiveserver2本身在HA的层面就不建议修改库、表结构，因此若要更改表结构或者创建新表同时实现数据同步，我试了以下两种方式均可实现：</p>\n<ol>\n<li><p>第一种关闭并重新初始化集群，启动master和所有的DataNode，在master上执行建库建表导入数据，而后启动master1将其作为standby初始化，这时master1会同步master的数据，最后启动master和master1的hiveserver2</p>\n</li>\n<li><p>第二种是同时在master和master1的hive客户端上执行同样的建表语句，而后在master(或者master1)上执行<code>load</code>命令加载数据，即可同步数据</p>\n<blockquote>\n<p>\b第二种方法又出现了个有趣的问题：导入数据完成后，在两台机器上分别执行<code>count</code>操作会发现由于加载数据的机器count正常，另一台机器count结果为0，但是执行<code>select *</code>又确实能发现数据存在，就很玄学。</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"TODO-List\"><a href=\"#TODO-List\" class=\"headerlink\" title=\"TODO List\"></a>TODO List</h1><ul>\n<li>安全与权限（kerberos）</li>\n<li>Secondary NameNode（check point NameNode）</li>\n<li>HA（High Ability）实现</li>\n<li>Federation，超大规模数据中心</li>\n</ul>"},{"title":"Java - Java类与类加载器","date":"2019-03-27T15:54:46.000Z","_content":"\n## 类加载机制\n\n类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。\n\n<!-- more -->\n\n### 阶段\n\n![image-20190327204927833](/images/类加载机制.png)\n\n其中`解析`可能会发生在`初始化`之后，`使用`可能不会被使用。\n\n上述流程指的是**开始时间**的顺序，**比如说`加载`未结束可能`验证`就会开始**。\n\n### 类加载时机\n\n虚拟机严格规定了5种情况**必须立即**对类进行**初始化**(不是上述流程中的初始化，指的是初始化类对象)：\n\n1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这4条字节码指令时，如果类没有进行初始化则需要先触发其初始化。\n\n2. 对类进行反射调用；\n3. 当初始化一个类时，若父类还没有被初始化需要先触发其父类的初始化；\n4. 当虚拟机启动时，包含`main()`方法的那个类需要被初始化；\n5. 当使用动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果是`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且句柄对应的类没有被初始化。\n\n**不会触发**类的初始化的**可能操作**：\n\n- **通过子类调用父类的静态字段**，不会导致**子类**初始化\n- **通过数组定义来引用类**，不会触发该类的初始化\n- **引用类的静态常量域或字段**，不会导致该类的初始化\n\n注意，接口也是会有初始化的过程，与类唯一不同的是上述`第3点`：接口在初始化时，**并不要求其父接口全部都完成了初始化**(原因应该是接口`<clinit>()`方法不需要调用父类的`<clinit>()`方法)，只有**在真正使用到父接口的时候**(如引用接口中定义的常量时)才会初始化。\n\n### 加载\n\n加载阶段的3件事情：\n\n1. 通过一个类的**全限定名**来获取**定义此类的二进制字节流**\n2. 将这个**字节流所代表的静态存储结构**转化为**方法区**的**运行时数据结构**\n3. 在内存中**生成一个代表这个类的`Class对象`**，作为方法区这个类的各种数据的访问入口\n\n第1件事情中的`二进制字节流`不一定是本地文件，可能是从**ZIP获取**、**从网络获取(Applet)**、**动态代理**、**JSP生成**、**数据库读取**等。\n\n### 验证\n\n验证主要是为了虚拟机对自身保护的一项重要工作，大致会完成以下4个阶段的检验动作：\n\n1. 文件格式验证：检测字节流是否符合Class文件格式规范\n2. 元数据验证：语义分析，保证信息符合Java语言规范的要求，主要是**数据类型**\n3. 字节码验证：最复杂的一部分，主要是对**类的方法体**进行校验(控制流、跳转等)\n4. 符号引用验证：发生在`解析`阶段，主要是对**符号引用进行匹配性校验**(能否找到、是否可达等)\n\n### 准备\n\n准备阶段是为类变量(静态变量)分配初始值的过程。\n\n注意两点：\n\n1. 初始值**通常情况**下是**数据类型的零值**，比如语句`public static int value = 123;`会在准备阶段给`value`初始化为`int`的零值即`0`，而`123`会在**后续的初始化阶段被赋值**给`value`；\n2. **特殊情况**下，常量类型会在**准备阶段被赋值**，比如语句`public static final int value = 123;`\n\n### 解析\n\n解析阶段是**将常量池内的符号引用替换为直接引用的过程**。\n\n#### 符号引用\n\n是指**以一组符号来描述所引用的目标**，符号引用在使用时能无歧义地定位到目标。\n\n#### 直接引用\n\n是指**可以直接指向目标的指针**、**相对偏移量**或**一个句柄**。\n\n### 初始化\n\n正式开始执行类中定义的Java代码(或者说是字节码)。记得准备阶段有为变量赋予初始值，这里就会为其赋予程序中制定的初始值。\n\n初始化主要的过程是执行`<clinit>()`方法。\n\n### 类与类加载器\n\n对于任意一个类，都需要由**加载它的类加载器**和**类本身**一同确立其在JVM中的唯一性。\n\n在使用`instanceof`关键字、Class对象的`equal()`、`isAssignableFrom()`、`isInstance()`方法时，都需要判定上述两方面是否相等。**自定义的类加载器**和**系统自带的类加载器**加载的**同一个类生成的对象使用相等方法验证是得不到相等结果的**。\n\n### 双亲委派模型\n\n类加载器划分：\n\n- 启动类加载器：负责将`<JAVA_HOME>\\lib`目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序无法直接引用。\n- 扩展类加载器：负责将`<JAVA_HOME>\\lib\\ext`目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序可直接使用。\n- 应用程序类加载器：负责加载用户类路径(ClassPath)上的类库，程序可直接使用。\n\n双亲委派模型如下图所示：\n\n![image-20190327234320380](/images/双亲委派模型.png)\n\n其中每一层与其父层关系一般**不是继承(Inheritance)**而是**组合(Composition)**来复用父加载器的代码。\n\n**工作过程：**如果一个类加载器收到了类加载的请求，它**首先不会尝试加载这个类**，而是**把这个请求委派给父类加载器去加载**，**每个层次都是这样**，直到请求被传递到**顶层的启动类加载器**中；而**只有父加载器反馈自己无法完成此请求时，子加载器才回去尝试加载**。\n\n双亲委托模型在`ClassLoader`类中的`loadClass()`方法中实现。","source":"_posts/Java类与类加载器.md","raw":"---\ntitle: Java - Java类与类加载器\ndate: 2019-03-27 23:54:46\ntags:\n    - ClassLoader\ncategories:\n    - Java\n---\n\n## 类加载机制\n\n类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。\n\n<!-- more -->\n\n### 阶段\n\n![image-20190327204927833](/images/类加载机制.png)\n\n其中`解析`可能会发生在`初始化`之后，`使用`可能不会被使用。\n\n上述流程指的是**开始时间**的顺序，**比如说`加载`未结束可能`验证`就会开始**。\n\n### 类加载时机\n\n虚拟机严格规定了5种情况**必须立即**对类进行**初始化**(不是上述流程中的初始化，指的是初始化类对象)：\n\n1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这4条字节码指令时，如果类没有进行初始化则需要先触发其初始化。\n\n2. 对类进行反射调用；\n3. 当初始化一个类时，若父类还没有被初始化需要先触发其父类的初始化；\n4. 当虚拟机启动时，包含`main()`方法的那个类需要被初始化；\n5. 当使用动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果是`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且句柄对应的类没有被初始化。\n\n**不会触发**类的初始化的**可能操作**：\n\n- **通过子类调用父类的静态字段**，不会导致**子类**初始化\n- **通过数组定义来引用类**，不会触发该类的初始化\n- **引用类的静态常量域或字段**，不会导致该类的初始化\n\n注意，接口也是会有初始化的过程，与类唯一不同的是上述`第3点`：接口在初始化时，**并不要求其父接口全部都完成了初始化**(原因应该是接口`<clinit>()`方法不需要调用父类的`<clinit>()`方法)，只有**在真正使用到父接口的时候**(如引用接口中定义的常量时)才会初始化。\n\n### 加载\n\n加载阶段的3件事情：\n\n1. 通过一个类的**全限定名**来获取**定义此类的二进制字节流**\n2. 将这个**字节流所代表的静态存储结构**转化为**方法区**的**运行时数据结构**\n3. 在内存中**生成一个代表这个类的`Class对象`**，作为方法区这个类的各种数据的访问入口\n\n第1件事情中的`二进制字节流`不一定是本地文件，可能是从**ZIP获取**、**从网络获取(Applet)**、**动态代理**、**JSP生成**、**数据库读取**等。\n\n### 验证\n\n验证主要是为了虚拟机对自身保护的一项重要工作，大致会完成以下4个阶段的检验动作：\n\n1. 文件格式验证：检测字节流是否符合Class文件格式规范\n2. 元数据验证：语义分析，保证信息符合Java语言规范的要求，主要是**数据类型**\n3. 字节码验证：最复杂的一部分，主要是对**类的方法体**进行校验(控制流、跳转等)\n4. 符号引用验证：发生在`解析`阶段，主要是对**符号引用进行匹配性校验**(能否找到、是否可达等)\n\n### 准备\n\n准备阶段是为类变量(静态变量)分配初始值的过程。\n\n注意两点：\n\n1. 初始值**通常情况**下是**数据类型的零值**，比如语句`public static int value = 123;`会在准备阶段给`value`初始化为`int`的零值即`0`，而`123`会在**后续的初始化阶段被赋值**给`value`；\n2. **特殊情况**下，常量类型会在**准备阶段被赋值**，比如语句`public static final int value = 123;`\n\n### 解析\n\n解析阶段是**将常量池内的符号引用替换为直接引用的过程**。\n\n#### 符号引用\n\n是指**以一组符号来描述所引用的目标**，符号引用在使用时能无歧义地定位到目标。\n\n#### 直接引用\n\n是指**可以直接指向目标的指针**、**相对偏移量**或**一个句柄**。\n\n### 初始化\n\n正式开始执行类中定义的Java代码(或者说是字节码)。记得准备阶段有为变量赋予初始值，这里就会为其赋予程序中制定的初始值。\n\n初始化主要的过程是执行`<clinit>()`方法。\n\n### 类与类加载器\n\n对于任意一个类，都需要由**加载它的类加载器**和**类本身**一同确立其在JVM中的唯一性。\n\n在使用`instanceof`关键字、Class对象的`equal()`、`isAssignableFrom()`、`isInstance()`方法时，都需要判定上述两方面是否相等。**自定义的类加载器**和**系统自带的类加载器**加载的**同一个类生成的对象使用相等方法验证是得不到相等结果的**。\n\n### 双亲委派模型\n\n类加载器划分：\n\n- 启动类加载器：负责将`<JAVA_HOME>\\lib`目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序无法直接引用。\n- 扩展类加载器：负责将`<JAVA_HOME>\\lib\\ext`目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序可直接使用。\n- 应用程序类加载器：负责加载用户类路径(ClassPath)上的类库，程序可直接使用。\n\n双亲委派模型如下图所示：\n\n![image-20190327234320380](/images/双亲委派模型.png)\n\n其中每一层与其父层关系一般**不是继承(Inheritance)**而是**组合(Composition)**来复用父加载器的代码。\n\n**工作过程：**如果一个类加载器收到了类加载的请求，它**首先不会尝试加载这个类**，而是**把这个请求委派给父类加载器去加载**，**每个层次都是这样**，直到请求被传递到**顶层的启动类加载器**中；而**只有父加载器反馈自己无法完成此请求时，子加载器才回去尝试加载**。\n\n双亲委托模型在`ClassLoader`类中的`loadClass()`方法中实现。","slug":"Java类与类加载器","published":1,"updated":"2021-05-16T10:55:21.675Z","_id":"ckfukja9e000jszxo6jsbjbfb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。</p>\n<a id=\"more\"></a>\n<h3 id=\"阶段\"><a href=\"#阶段\" class=\"headerlink\" title=\"阶段\"></a>阶段</h3><p><img src=\"/images/类加载机制.png\" alt=\"image-20190327204927833\"></p>\n<p>其中<code>解析</code>可能会发生在<code>初始化</code>之后，<code>使用</code>可能不会被使用。</p>\n<p>上述流程指的是<strong>开始时间</strong>的顺序，<strong>比如说<code>加载</code>未结束可能<code>验证</code>就会开始</strong>。</p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><p>虚拟机严格规定了5种情况<strong>必须立即</strong>对类进行<strong>初始化</strong>(不是上述流程中的初始化，指的是初始化类对象)：</p>\n<ol>\n<li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这4条字节码指令时，如果类没有进行初始化则需要先触发其初始化。</p>\n</li>\n<li><p>对类进行反射调用；</p>\n</li>\n<li>当初始化一个类时，若父类还没有被初始化需要先触发其父类的初始化；</li>\n<li>当虚拟机启动时，包含<code>main()</code>方法的那个类需要被初始化；</li>\n<li>当使用动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且句柄对应的类没有被初始化。</li>\n</ol>\n<p><strong>不会触发</strong>类的初始化的<strong>可能操作</strong>：</p>\n<ul>\n<li><strong>通过子类调用父类的静态字段</strong>，不会导致<strong>子类</strong>初始化</li>\n<li><strong>通过数组定义来引用类</strong>，不会触发该类的初始化</li>\n<li><strong>引用类的静态常量域或字段</strong>，不会导致该类的初始化</li>\n</ul>\n<p>注意，接口也是会有初始化的过程，与类唯一不同的是上述<code>第3点</code>：接口在初始化时，<strong>并不要求其父接口全部都完成了初始化</strong>(原因应该是接口<code>&lt;clinit&gt;()</code>方法不需要调用父类的<code>&lt;clinit&gt;()</code>方法)，只有<strong>在真正使用到父接口的时候</strong>(如引用接口中定义的常量时)才会初始化。</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载阶段的3件事情：</p>\n<ol>\n<li>通过一个类的<strong>全限定名</strong>来获取<strong>定义此类的二进制字节流</strong></li>\n<li>将这个<strong>字节流所代表的静态存储结构</strong>转化为<strong>方法区</strong>的<strong>运行时数据结构</strong></li>\n<li>在内存中<strong>生成一个代表这个类的<code>Class对象</code></strong>，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>第1件事情中的<code>二进制字节流</code>不一定是本地文件，可能是从<strong>ZIP获取</strong>、<strong>从网络获取(Applet)</strong>、<strong>动态代理</strong>、<strong>JSP生成</strong>、<strong>数据库读取</strong>等。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证主要是为了虚拟机对自身保护的一项重要工作，大致会完成以下4个阶段的检验动作：</p>\n<ol>\n<li>文件格式验证：检测字节流是否符合Class文件格式规范</li>\n<li>元数据验证：语义分析，保证信息符合Java语言规范的要求，主要是<strong>数据类型</strong></li>\n<li>字节码验证：最复杂的一部分，主要是对<strong>类的方法体</strong>进行校验(控制流、跳转等)</li>\n<li>符号引用验证：发生在<code>解析</code>阶段，主要是对<strong>符号引用进行匹配性校验</strong>(能否找到、是否可达等)</li>\n</ol>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是为类变量(静态变量)分配初始值的过程。</p>\n<p>注意两点：</p>\n<ol>\n<li>初始值<strong>通常情况</strong>下是<strong>数据类型的零值</strong>，比如语句<code>public static int value = 123;</code>会在准备阶段给<code>value</code>初始化为<code>int</code>的零值即<code>0</code>，而<code>123</code>会在<strong>后续的初始化阶段被赋值</strong>给<code>value</code>；</li>\n<li><strong>特殊情况</strong>下，常量类型会在<strong>准备阶段被赋值</strong>，比如语句<code>public static final int value = 123;</code></li>\n</ol>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段是<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p>\n<h4 id=\"符号引用\"><a href=\"#符号引用\" class=\"headerlink\" title=\"符号引用\"></a>符号引用</h4><p>是指<strong>以一组符号来描述所引用的目标</strong>，符号引用在使用时能无歧义地定位到目标。</p>\n<h4 id=\"直接引用\"><a href=\"#直接引用\" class=\"headerlink\" title=\"直接引用\"></a>直接引用</h4><p>是指<strong>可以直接指向目标的指针</strong>、<strong>相对偏移量</strong>或<strong>一个句柄</strong>。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>正式开始执行类中定义的Java代码(或者说是字节码)。记得准备阶段有为变量赋予初始值，这里就会为其赋予程序中制定的初始值。</p>\n<p>初始化主要的过程是执行<code>&lt;clinit&gt;()</code>方法。</p>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和<strong>类本身</strong>一同确立其在JVM中的唯一性。</p>\n<p>在使用<code>instanceof</code>关键字、Class对象的<code>equal()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>方法时，都需要判定上述两方面是否相等。<strong>自定义的类加载器</strong>和<strong>系统自带的类加载器</strong>加载的<strong>同一个类生成的对象使用相等方法验证是得不到相等结果的</strong>。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>类加载器划分：</p>\n<ul>\n<li>启动类加载器：负责将<code>&lt;JAVA_HOME&gt;\\lib</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序无法直接引用。</li>\n<li>扩展类加载器：负责将<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序可直接使用。</li>\n<li>应用程序类加载器：负责加载用户类路径(ClassPath)上的类库，程序可直接使用。</li>\n</ul>\n<p>双亲委派模型如下图所示：</p>\n<p><img src=\"/images/双亲委派模型.png\" alt=\"image-20190327234320380\"></p>\n<p>其中每一层与其父层关系一般<strong>不是继承(Inheritance)</strong>而是<strong>组合(Composition)</strong>来复用父加载器的代码。</p>\n<p><strong>工作过程：</strong>如果一个类加载器收到了类加载的请求，它<strong>首先不会尝试加载这个类</strong>，而是<strong>把这个请求委派给父类加载器去加载</strong>，<strong>每个层次都是这样</strong>，直到请求被传递到<strong>顶层的启动类加载器</strong>中；而<strong>只有父加载器反馈自己无法完成此请求时，子加载器才回去尝试加载</strong>。</p>\n<p>双亲委托模型在<code>ClassLoader</code>类中的<code>loadClass()</code>方法中实现。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。</p>","more":"<h3 id=\"阶段\"><a href=\"#阶段\" class=\"headerlink\" title=\"阶段\"></a>阶段</h3><p><img src=\"/images/类加载机制.png\" alt=\"image-20190327204927833\"></p>\n<p>其中<code>解析</code>可能会发生在<code>初始化</code>之后，<code>使用</code>可能不会被使用。</p>\n<p>上述流程指的是<strong>开始时间</strong>的顺序，<strong>比如说<code>加载</code>未结束可能<code>验证</code>就会开始</strong>。</p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><p>虚拟机严格规定了5种情况<strong>必须立即</strong>对类进行<strong>初始化</strong>(不是上述流程中的初始化，指的是初始化类对象)：</p>\n<ol>\n<li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这4条字节码指令时，如果类没有进行初始化则需要先触发其初始化。</p>\n</li>\n<li><p>对类进行反射调用；</p>\n</li>\n<li>当初始化一个类时，若父类还没有被初始化需要先触发其父类的初始化；</li>\n<li>当虚拟机启动时，包含<code>main()</code>方法的那个类需要被初始化；</li>\n<li>当使用动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且句柄对应的类没有被初始化。</li>\n</ol>\n<p><strong>不会触发</strong>类的初始化的<strong>可能操作</strong>：</p>\n<ul>\n<li><strong>通过子类调用父类的静态字段</strong>，不会导致<strong>子类</strong>初始化</li>\n<li><strong>通过数组定义来引用类</strong>，不会触发该类的初始化</li>\n<li><strong>引用类的静态常量域或字段</strong>，不会导致该类的初始化</li>\n</ul>\n<p>注意，接口也是会有初始化的过程，与类唯一不同的是上述<code>第3点</code>：接口在初始化时，<strong>并不要求其父接口全部都完成了初始化</strong>(原因应该是接口<code>&lt;clinit&gt;()</code>方法不需要调用父类的<code>&lt;clinit&gt;()</code>方法)，只有<strong>在真正使用到父接口的时候</strong>(如引用接口中定义的常量时)才会初始化。</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载阶段的3件事情：</p>\n<ol>\n<li>通过一个类的<strong>全限定名</strong>来获取<strong>定义此类的二进制字节流</strong></li>\n<li>将这个<strong>字节流所代表的静态存储结构</strong>转化为<strong>方法区</strong>的<strong>运行时数据结构</strong></li>\n<li>在内存中<strong>生成一个代表这个类的<code>Class对象</code></strong>，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>第1件事情中的<code>二进制字节流</code>不一定是本地文件，可能是从<strong>ZIP获取</strong>、<strong>从网络获取(Applet)</strong>、<strong>动态代理</strong>、<strong>JSP生成</strong>、<strong>数据库读取</strong>等。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证主要是为了虚拟机对自身保护的一项重要工作，大致会完成以下4个阶段的检验动作：</p>\n<ol>\n<li>文件格式验证：检测字节流是否符合Class文件格式规范</li>\n<li>元数据验证：语义分析，保证信息符合Java语言规范的要求，主要是<strong>数据类型</strong></li>\n<li>字节码验证：最复杂的一部分，主要是对<strong>类的方法体</strong>进行校验(控制流、跳转等)</li>\n<li>符号引用验证：发生在<code>解析</code>阶段，主要是对<strong>符号引用进行匹配性校验</strong>(能否找到、是否可达等)</li>\n</ol>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是为类变量(静态变量)分配初始值的过程。</p>\n<p>注意两点：</p>\n<ol>\n<li>初始值<strong>通常情况</strong>下是<strong>数据类型的零值</strong>，比如语句<code>public static int value = 123;</code>会在准备阶段给<code>value</code>初始化为<code>int</code>的零值即<code>0</code>，而<code>123</code>会在<strong>后续的初始化阶段被赋值</strong>给<code>value</code>；</li>\n<li><strong>特殊情况</strong>下，常量类型会在<strong>准备阶段被赋值</strong>，比如语句<code>public static final int value = 123;</code></li>\n</ol>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段是<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p>\n<h4 id=\"符号引用\"><a href=\"#符号引用\" class=\"headerlink\" title=\"符号引用\"></a>符号引用</h4><p>是指<strong>以一组符号来描述所引用的目标</strong>，符号引用在使用时能无歧义地定位到目标。</p>\n<h4 id=\"直接引用\"><a href=\"#直接引用\" class=\"headerlink\" title=\"直接引用\"></a>直接引用</h4><p>是指<strong>可以直接指向目标的指针</strong>、<strong>相对偏移量</strong>或<strong>一个句柄</strong>。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>正式开始执行类中定义的Java代码(或者说是字节码)。记得准备阶段有为变量赋予初始值，这里就会为其赋予程序中制定的初始值。</p>\n<p>初始化主要的过程是执行<code>&lt;clinit&gt;()</code>方法。</p>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和<strong>类本身</strong>一同确立其在JVM中的唯一性。</p>\n<p>在使用<code>instanceof</code>关键字、Class对象的<code>equal()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>方法时，都需要判定上述两方面是否相等。<strong>自定义的类加载器</strong>和<strong>系统自带的类加载器</strong>加载的<strong>同一个类生成的对象使用相等方法验证是得不到相等结果的</strong>。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>类加载器划分：</p>\n<ul>\n<li>启动类加载器：负责将<code>&lt;JAVA_HOME&gt;\\lib</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序无法直接引用。</li>\n<li>扩展类加载器：负责将<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序可直接使用。</li>\n<li>应用程序类加载器：负责加载用户类路径(ClassPath)上的类库，程序可直接使用。</li>\n</ul>\n<p>双亲委派模型如下图所示：</p>\n<p><img src=\"/images/双亲委派模型.png\" alt=\"image-20190327234320380\"></p>\n<p>其中每一层与其父层关系一般<strong>不是继承(Inheritance)</strong>而是<strong>组合(Composition)</strong>来复用父加载器的代码。</p>\n<p><strong>工作过程：</strong>如果一个类加载器收到了类加载的请求，它<strong>首先不会尝试加载这个类</strong>，而是<strong>把这个请求委派给父类加载器去加载</strong>，<strong>每个层次都是这样</strong>，直到请求被传递到<strong>顶层的启动类加载器</strong>中；而<strong>只有父加载器反馈自己无法完成此请求时，子加载器才回去尝试加载</strong>。</p>\n<p>双亲委托模型在<code>ClassLoader</code>类中的<code>loadClass()</code>方法中实现。</p>"},{"title":"Java - Spring学习笔记","date":"2019-10-19T11:12:29.000Z","_content":"\n> 理解DIP、IOC、DI及IOC容器\n\n<!-- more -->\n\n## DIP\n\nDIP(Dependence Inversion Principle)即依赖倒置原则，是一种抽象的软件架构设计的原则，其有两个特点：\n\n- 高层模块不应依赖于低层模块，两者应该依赖于抽象\n- 抽象不应该依赖于实现，实现应该依赖于抽象\n\n举例子对比一下依赖倒置与依赖无倒置，代码使用SpringBoot风格：\n\n### 依赖无倒置\n\n![依赖无倒置](assets/依赖无倒置2.png)\n\n这种明显高层模块已经依赖于低层模块，不满足`高层模块不应依赖于低层模块，两者应该依赖于抽象`的特点。\n\n示例代码如下：\n\n\ncontroller层使用\n\n![依赖无倒置](assets/依赖无倒置.png)\n\n\n\n\n### 依赖倒置\n\n![依赖倒置](assets/依赖倒置.png)\n\n","source":"_posts/Spring学习笔记.md","raw":"---\ntitle: Java - Spring学习笔记\ndate: 2019-10-19 19:12:29\ntags:\n    - Spring\ncategories:\n    - Java\n---\n\n> 理解DIP、IOC、DI及IOC容器\n\n<!-- more -->\n\n## DIP\n\nDIP(Dependence Inversion Principle)即依赖倒置原则，是一种抽象的软件架构设计的原则，其有两个特点：\n\n- 高层模块不应依赖于低层模块，两者应该依赖于抽象\n- 抽象不应该依赖于实现，实现应该依赖于抽象\n\n举例子对比一下依赖倒置与依赖无倒置，代码使用SpringBoot风格：\n\n### 依赖无倒置\n\n![依赖无倒置](assets/依赖无倒置2.png)\n\n这种明显高层模块已经依赖于低层模块，不满足`高层模块不应依赖于低层模块，两者应该依赖于抽象`的特点。\n\n示例代码如下：\n\n\ncontroller层使用\n\n![依赖无倒置](assets/依赖无倒置.png)\n\n\n\n\n### 依赖倒置\n\n![依赖倒置](assets/依赖倒置.png)\n\n","slug":"Spring学习笔记","published":1,"updated":"2021-05-16T10:56:33.611Z","_id":"ckfukja9j000kszxok1vvgery","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>理解DIP、IOC、DI及IOC容器</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"DIP\"><a href=\"#DIP\" class=\"headerlink\" title=\"DIP\"></a>DIP</h2><p>DIP(Dependence Inversion Principle)即依赖倒置原则，是一种抽象的软件架构设计的原则，其有两个特点：</p>\n<ul>\n<li>高层模块不应依赖于低层模块，两者应该依赖于抽象</li>\n<li>抽象不应该依赖于实现，实现应该依赖于抽象</li>\n</ul>\n<p>举例子对比一下依赖倒置与依赖无倒置，代码使用SpringBoot风格：</p>\n<h3 id=\"依赖无倒置\"><a href=\"#依赖无倒置\" class=\"headerlink\" title=\"依赖无倒置\"></a>依赖无倒置</h3><p><img src=\"assets/依赖无倒置2.png\" alt=\"依赖无倒置\"></p>\n<p>这种明显高层模块已经依赖于低层模块，不满足<code>高层模块不应依赖于低层模块，两者应该依赖于抽象</code>的特点。</p>\n<p>示例代码如下：</p>\n<p>controller层使用</p>\n<p><img src=\"assets/依赖无倒置.png\" alt=\"依赖无倒置\"></p>\n<h3 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h3><p><img src=\"assets/依赖倒置.png\" alt=\"依赖倒置\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>理解DIP、IOC、DI及IOC容器</p>\n</blockquote>","more":"<h2 id=\"DIP\"><a href=\"#DIP\" class=\"headerlink\" title=\"DIP\"></a>DIP</h2><p>DIP(Dependence Inversion Principle)即依赖倒置原则，是一种抽象的软件架构设计的原则，其有两个特点：</p>\n<ul>\n<li>高层模块不应依赖于低层模块，两者应该依赖于抽象</li>\n<li>抽象不应该依赖于实现，实现应该依赖于抽象</li>\n</ul>\n<p>举例子对比一下依赖倒置与依赖无倒置，代码使用SpringBoot风格：</p>\n<h3 id=\"依赖无倒置\"><a href=\"#依赖无倒置\" class=\"headerlink\" title=\"依赖无倒置\"></a>依赖无倒置</h3><p><img src=\"assets/依赖无倒置2.png\" alt=\"依赖无倒置\"></p>\n<p>这种明显高层模块已经依赖于低层模块，不满足<code>高层模块不应依赖于低层模块，两者应该依赖于抽象</code>的特点。</p>\n<p>示例代码如下：</p>\n<p>controller层使用</p>\n<p><img src=\"assets/依赖无倒置.png\" alt=\"依赖无倒置\"></p>\n<h3 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h3><p><img src=\"assets/依赖倒置.png\" alt=\"依赖倒置\"></p>"},{"title":"Tensorflow多GPU并行计算","date":"2020-10-02T15:33:40.000Z","_content":"\n> 笔者本科毕设做的是遥感图像分割相关的研究，当时采用的Potsdam数据集由于所有图像GSD(对地观测距离)固定且适中，因此将训练时的batch_size设置为了16，基本能满足每个批次中都包含所有地表要素的需求。然而[NAIC2020](https://naic.pcl.ac.cn/)数据集中包含的数据的GSD从0.1m-4m不等，0.1m的GSD意味着一张256x256的影像切片中甚至能够看到一根树干的轮廓，然而这也使得该切片包含的要素种类很少！以致于一个batch中的16张切片可能也无法包含所有的要素。\n> 一旦batch训练数据无法包含所有要素，就使得当次训练结果对于未被包含的要素基本不具备识别能力，表现为第n次训练和第n+1次训练结果梯度变化很大，有点像拆了东墙补西墙；而限制了batch_size的最根本原因是GPU限制，本模型完全跑起来需要约9G显存(输入大小为[16,256,256,3]，即16张256x256大小的RGB图像)，服务器上的GPU仅有11G，虽然显存不大，但是GPU多呀，4块2080Ti现在只用了一块。\n> 因此笔者考虑使用多GPU来增大batch_size，以此来使得每个batch训练的参数结果对所有要素都较为适配。\n\n<!-- more -->\n\n## 并行计算\n\n深度学习方法采用并行计算的方法一般包括两种：`数据并行`和`模型并行`。\n\n### 数据并行\n\n考虑一个事实：深度学习方法在使用随机梯度下降法进行训练时，每次训练我们会尝试随机取出`n`个数据点去计算当前这个批次的梯度，然而当前这个批次计算出的梯度相对于整个数据集的真实梯度来说很不准确，同时GPU显存通常不足以容下我们所有的训练数据，因此随机梯度下降法通常需要`①增大每个批次的数据点数量`、`②使用更多的训练轮次`来更快、更准地进行模型的收敛。\n\nNAIC2020数据集中包含了数十万张切片，由于multi-scale特性的存在，每个切片可能包含1-8个要素不等。由于先前训练时的batch_size为16，很难在每个batch里得到包含所有8个要素的16张切片，而由于GPU显存的限制，16已经达到了极限，因此考虑使用多GPU来解决batch_size这一瓶颈。\n\n数据并行方法在操作时，允许输入模型的批次数量更大，而后将大批次分割为很多`小批次`，而后在每个GPU上计算一个小批次，每个GPU的梯度估计结果进行汇总后，进行`加权平均`，最终`求和`就得到了大批次的梯度估计结果。\n\n> [证明过程](https://blog.csdn.net/LoseInVain/article/details/105808818)：\n> ![数据并行有效性证明过程](http://imgbed.guitoubing.top/20201003001646.png)\n> \n> 当每个小批次是由大批次平均分配时，那么：\n> m1=m2=···=mk=n/k\n\n下图解释了数据并行的[流程](https://www.zhihu.com/question/53851014)：\n![数据并行模型](http://imgbed.guitoubing.top/20201003001716.png)\n\n每个节点输入不同的`Data Shards`，即一个小批次，通过节点上的模型训练得到各自的梯度，而节点中的模型参数是相同的，这样的一个节点通常称作`worker`；而后每个`worker`会把各自计算得到的梯度送到`ps server`进行汇总操作（加权平均）并传回到各个节点进行模型的更新。\n\n### 模型并行\n\n待更新\n\n## 实际操作\n\n笔者代码使用的是`TensorFlow-GPU 2.0`+`Keras 2.3`，采用数据并行的方式增大`batch_size`；训练时，首先需要进行如下设置：\n\n```python\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = '0,1,2,3'\n```\n\n这句话是让4块GPU都对程序**可见**，然而可见并不是指**成功调用**了。\n\n当设置`os.environ[\"CUDA_VISIBLE_DEVICES\"] = '0,1,2,3'`变量时，程序仍然可以正常训练，但是没有达到预期的多GPU效果，各GPU占用如下：\n\n|        | GPU0 | GPU1 | GPU2 | GPU3 |\n| :------------- | :----------: | :-----------: | :----------: | :----------: |\n| 显存占用(MB) | 10870 | 155 | 155 | 155 |\n| GPU占用(%) | 87 | 0 | 0 | 0 |\n\n可以看到，还是GPU1-3虽然有显存占用，但是GPU基本无占用，说明这三个GPU仅加载了模型，并没有执行实际的计算任务；因此当增大batch_size时，程序并没有自动唤醒GPU1-3来帮助分担计算任务，而是报出`内存不足`的错误，即使GPU1-3均有空余容量。\n\n在TensorFlow里，需要自行指定操作对应的`device`即GPU：\n\n```python\n# image:[64,256,256,3], label:[64,256,256]\n# small_batch_size = batch_size/N_GPUs = 64/4 = 16\nwith tf.variable_scope(tf.get_variable_scope()):\n    for i in tqdm(range(args.N_GPUs)):\n        with tf.device('/gpu:%d' % i):\n            start = i * small_batch_size\n            end = (i + 1) * small_batch_size\n            x = image[start:end, :, :, :]\n            y = label[start:end, :, :]\n            logits = model.forward(x)\n            ……\n            # calc loss with logits\n            ……\n            grads = optimizer.compute_gradients(loss=loss, var_list=tf.trainable_variables())\n            all_grads.append(grads)\n# merge gradients\ngrads = average_gradients(all_grads)\n```\n\n上述代码中，我将batch_size设置为64，并将每个batch平均分配给4个GPU来进行计算任务，每个GPU需要前向传递更新自己的参数。一个训练伦次中，当4个GPU都计算完了梯度后，会传给主GPU(也可以是CPU，这里我使用GPU0为主GPU)进行梯度的合并，而后反向传递回并更新4个GPU的模型参数。训练过程中，GPU占用如下：\n\n|        | GPU0 | GPU1 | GPU2 | GPU3 |\n| :------------- | :----------: | :-----------: | :----------: | :----------: |\n| 显存占用(MB) | 8793 | 8787 | 8787 | 8787 |\n| GPU占用(%) | 30-55 | 30-50 | 30-50 | 30-50 |\n\n可见，由于GPU0是主GPU，需要完成梯度的合并工作，因此需要占用稍微多一点的内存和GPU。\n\n当增加了GPU数量以进行并行计算时，通常会由于GPU之间的通信、梯度汇总等原因导致批次的训练速度变慢：本机4个GPU并行计算时，训练速度约为`1.2次/s`，单GPU训练速度约为`2次/s`；然而由于4GPU每轮次输入了64个切片，是单GPU的4倍之多，因此4GPU1.25w次训练就能达到单GPU5w次的训练效果，总体训练时间还是缩短了。","source":"_posts/Tensorflow-multi-GPU.md","raw":"---\ntitle: Tensorflow多GPU并行计算\ndate: 2020-10-02 23:33:40\ntags:\n    - TensorFlow\n    - 图像分割\n    - 遥感影像\ncategories:\n    - 深度学习\n---\n\n> 笔者本科毕设做的是遥感图像分割相关的研究，当时采用的Potsdam数据集由于所有图像GSD(对地观测距离)固定且适中，因此将训练时的batch_size设置为了16，基本能满足每个批次中都包含所有地表要素的需求。然而[NAIC2020](https://naic.pcl.ac.cn/)数据集中包含的数据的GSD从0.1m-4m不等，0.1m的GSD意味着一张256x256的影像切片中甚至能够看到一根树干的轮廓，然而这也使得该切片包含的要素种类很少！以致于一个batch中的16张切片可能也无法包含所有的要素。\n> 一旦batch训练数据无法包含所有要素，就使得当次训练结果对于未被包含的要素基本不具备识别能力，表现为第n次训练和第n+1次训练结果梯度变化很大，有点像拆了东墙补西墙；而限制了batch_size的最根本原因是GPU限制，本模型完全跑起来需要约9G显存(输入大小为[16,256,256,3]，即16张256x256大小的RGB图像)，服务器上的GPU仅有11G，虽然显存不大，但是GPU多呀，4块2080Ti现在只用了一块。\n> 因此笔者考虑使用多GPU来增大batch_size，以此来使得每个batch训练的参数结果对所有要素都较为适配。\n\n<!-- more -->\n\n## 并行计算\n\n深度学习方法采用并行计算的方法一般包括两种：`数据并行`和`模型并行`。\n\n### 数据并行\n\n考虑一个事实：深度学习方法在使用随机梯度下降法进行训练时，每次训练我们会尝试随机取出`n`个数据点去计算当前这个批次的梯度，然而当前这个批次计算出的梯度相对于整个数据集的真实梯度来说很不准确，同时GPU显存通常不足以容下我们所有的训练数据，因此随机梯度下降法通常需要`①增大每个批次的数据点数量`、`②使用更多的训练轮次`来更快、更准地进行模型的收敛。\n\nNAIC2020数据集中包含了数十万张切片，由于multi-scale特性的存在，每个切片可能包含1-8个要素不等。由于先前训练时的batch_size为16，很难在每个batch里得到包含所有8个要素的16张切片，而由于GPU显存的限制，16已经达到了极限，因此考虑使用多GPU来解决batch_size这一瓶颈。\n\n数据并行方法在操作时，允许输入模型的批次数量更大，而后将大批次分割为很多`小批次`，而后在每个GPU上计算一个小批次，每个GPU的梯度估计结果进行汇总后，进行`加权平均`，最终`求和`就得到了大批次的梯度估计结果。\n\n> [证明过程](https://blog.csdn.net/LoseInVain/article/details/105808818)：\n> ![数据并行有效性证明过程](http://imgbed.guitoubing.top/20201003001646.png)\n> \n> 当每个小批次是由大批次平均分配时，那么：\n> m1=m2=···=mk=n/k\n\n下图解释了数据并行的[流程](https://www.zhihu.com/question/53851014)：\n![数据并行模型](http://imgbed.guitoubing.top/20201003001716.png)\n\n每个节点输入不同的`Data Shards`，即一个小批次，通过节点上的模型训练得到各自的梯度，而节点中的模型参数是相同的，这样的一个节点通常称作`worker`；而后每个`worker`会把各自计算得到的梯度送到`ps server`进行汇总操作（加权平均）并传回到各个节点进行模型的更新。\n\n### 模型并行\n\n待更新\n\n## 实际操作\n\n笔者代码使用的是`TensorFlow-GPU 2.0`+`Keras 2.3`，采用数据并行的方式增大`batch_size`；训练时，首先需要进行如下设置：\n\n```python\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = '0,1,2,3'\n```\n\n这句话是让4块GPU都对程序**可见**，然而可见并不是指**成功调用**了。\n\n当设置`os.environ[\"CUDA_VISIBLE_DEVICES\"] = '0,1,2,3'`变量时，程序仍然可以正常训练，但是没有达到预期的多GPU效果，各GPU占用如下：\n\n|        | GPU0 | GPU1 | GPU2 | GPU3 |\n| :------------- | :----------: | :-----------: | :----------: | :----------: |\n| 显存占用(MB) | 10870 | 155 | 155 | 155 |\n| GPU占用(%) | 87 | 0 | 0 | 0 |\n\n可以看到，还是GPU1-3虽然有显存占用，但是GPU基本无占用，说明这三个GPU仅加载了模型，并没有执行实际的计算任务；因此当增大batch_size时，程序并没有自动唤醒GPU1-3来帮助分担计算任务，而是报出`内存不足`的错误，即使GPU1-3均有空余容量。\n\n在TensorFlow里，需要自行指定操作对应的`device`即GPU：\n\n```python\n# image:[64,256,256,3], label:[64,256,256]\n# small_batch_size = batch_size/N_GPUs = 64/4 = 16\nwith tf.variable_scope(tf.get_variable_scope()):\n    for i in tqdm(range(args.N_GPUs)):\n        with tf.device('/gpu:%d' % i):\n            start = i * small_batch_size\n            end = (i + 1) * small_batch_size\n            x = image[start:end, :, :, :]\n            y = label[start:end, :, :]\n            logits = model.forward(x)\n            ……\n            # calc loss with logits\n            ……\n            grads = optimizer.compute_gradients(loss=loss, var_list=tf.trainable_variables())\n            all_grads.append(grads)\n# merge gradients\ngrads = average_gradients(all_grads)\n```\n\n上述代码中，我将batch_size设置为64，并将每个batch平均分配给4个GPU来进行计算任务，每个GPU需要前向传递更新自己的参数。一个训练伦次中，当4个GPU都计算完了梯度后，会传给主GPU(也可以是CPU，这里我使用GPU0为主GPU)进行梯度的合并，而后反向传递回并更新4个GPU的模型参数。训练过程中，GPU占用如下：\n\n|        | GPU0 | GPU1 | GPU2 | GPU3 |\n| :------------- | :----------: | :-----------: | :----------: | :----------: |\n| 显存占用(MB) | 8793 | 8787 | 8787 | 8787 |\n| GPU占用(%) | 30-55 | 30-50 | 30-50 | 30-50 |\n\n可见，由于GPU0是主GPU，需要完成梯度的合并工作，因此需要占用稍微多一点的内存和GPU。\n\n当增加了GPU数量以进行并行计算时，通常会由于GPU之间的通信、梯度汇总等原因导致批次的训练速度变慢：本机4个GPU并行计算时，训练速度约为`1.2次/s`，单GPU训练速度约为`2次/s`；然而由于4GPU每轮次输入了64个切片，是单GPU的4倍之多，因此4GPU1.25w次训练就能达到单GPU5w次的训练效果，总体训练时间还是缩短了。","slug":"Tensorflow-multi-GPU","published":1,"updated":"2021-05-16T10:56:52.708Z","_id":"ckfukja9l000oszxo8fj9bmj7","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>笔者本科毕设做的是遥感图像分割相关的研究，当时采用的Potsdam数据集由于所有图像GSD(对地观测距离)固定且适中，因此将训练时的batch_size设置为了16，基本能满足每个批次中都包含所有地表要素的需求。然而<a href=\"https://naic.pcl.ac.cn/\" target=\"_blank\" rel=\"noopener\">NAIC2020</a>数据集中包含的数据的GSD从0.1m-4m不等，0.1m的GSD意味着一张256x256的影像切片中甚至能够看到一根树干的轮廓，然而这也使得该切片包含的要素种类很少！以致于一个batch中的16张切片可能也无法包含所有的要素。<br>一旦batch训练数据无法包含所有要素，就使得当次训练结果对于未被包含的要素基本不具备识别能力，表现为第n次训练和第n+1次训练结果梯度变化很大，有点像拆了东墙补西墙；而限制了batch_size的最根本原因是GPU限制，本模型完全跑起来需要约9G显存(输入大小为[16,256,256,3]，即16张256x256大小的RGB图像)，服务器上的GPU仅有11G，虽然显存不大，但是GPU多呀，4块2080Ti现在只用了一块。<br>因此笔者考虑使用多GPU来增大batch_size，以此来使得每个batch训练的参数结果对所有要素都较为适配。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"并行计算\"><a href=\"#并行计算\" class=\"headerlink\" title=\"并行计算\"></a>并行计算</h2><p>深度学习方法采用并行计算的方法一般包括两种：<code>数据并行</code>和<code>模型并行</code>。</p>\n<h3 id=\"数据并行\"><a href=\"#数据并行\" class=\"headerlink\" title=\"数据并行\"></a>数据并行</h3><p>考虑一个事实：深度学习方法在使用随机梯度下降法进行训练时，每次训练我们会尝试随机取出<code>n</code>个数据点去计算当前这个批次的梯度，然而当前这个批次计算出的梯度相对于整个数据集的真实梯度来说很不准确，同时GPU显存通常不足以容下我们所有的训练数据，因此随机梯度下降法通常需要<code>①增大每个批次的数据点数量</code>、<code>②使用更多的训练轮次</code>来更快、更准地进行模型的收敛。</p>\n<p>NAIC2020数据集中包含了数十万张切片，由于multi-scale特性的存在，每个切片可能包含1-8个要素不等。由于先前训练时的batch_size为16，很难在每个batch里得到包含所有8个要素的16张切片，而由于GPU显存的限制，16已经达到了极限，因此考虑使用多GPU来解决batch_size这一瓶颈。</p>\n<p>数据并行方法在操作时，允许输入模型的批次数量更大，而后将大批次分割为很多<code>小批次</code>，而后在每个GPU上计算一个小批次，每个GPU的梯度估计结果进行汇总后，进行<code>加权平均</code>，最终<code>求和</code>就得到了大批次的梯度估计结果。</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/LoseInVain/article/details/105808818\" target=\"_blank\" rel=\"noopener\">证明过程</a>：<br><img src=\"http://imgbed.guitoubing.top/20201003001646.png\" alt=\"数据并行有效性证明过程\"></p>\n<p>当每个小批次是由大批次平均分配时，那么：<br>m1=m2=···=mk=n/k</p>\n</blockquote>\n<p>下图解释了数据并行的<a href=\"https://www.zhihu.com/question/53851014\" target=\"_blank\" rel=\"noopener\">流程</a>：<br><img src=\"http://imgbed.guitoubing.top/20201003001716.png\" alt=\"数据并行模型\"></p>\n<p>每个节点输入不同的<code>Data Shards</code>，即一个小批次，通过节点上的模型训练得到各自的梯度，而节点中的模型参数是相同的，这样的一个节点通常称作<code>worker</code>；而后每个<code>worker</code>会把各自计算得到的梯度送到<code>ps server</code>进行汇总操作（加权平均）并传回到各个节点进行模型的更新。</p>\n<h3 id=\"模型并行\"><a href=\"#模型并行\" class=\"headerlink\" title=\"模型并行\"></a>模型并行</h3><p>待更新</p>\n<h2 id=\"实际操作\"><a href=\"#实际操作\" class=\"headerlink\" title=\"实际操作\"></a>实际操作</h2><p>笔者代码使用的是<code>TensorFlow-GPU 2.0</code>+<code>Keras 2.3</code>，采用数据并行的方式增大<code>batch_size</code>；训练时，首先需要进行如下设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">os.environ[<span class=\"string\">\"CUDA_VISIBLE_DEVICES\"</span>] = <span class=\"string\">'0,1,2,3'</span></span><br></pre></td></tr></table></figure>\n<p>这句话是让4块GPU都对程序<strong>可见</strong>，然而可见并不是指<strong>成功调用</strong>了。</p>\n<p>当设置<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0,1,2,3&#39;</code>变量时，程序仍然可以正常训练，但是没有达到预期的多GPU效果，各GPU占用如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:center\">GPU0</th>\n<th style=\"text-align:center\">GPU1</th>\n<th style=\"text-align:center\">GPU2</th>\n<th style=\"text-align:center\">GPU3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">显存占用(MB)</td>\n<td style=\"text-align:center\">10870</td>\n<td style=\"text-align:center\">155</td>\n<td style=\"text-align:center\">155</td>\n<td style=\"text-align:center\">155</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GPU占用(%)</td>\n<td style=\"text-align:center\">87</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，还是GPU1-3虽然有显存占用，但是GPU基本无占用，说明这三个GPU仅加载了模型，并没有执行实际的计算任务；因此当增大batch_size时，程序并没有自动唤醒GPU1-3来帮助分担计算任务，而是报出<code>内存不足</code>的错误，即使GPU1-3均有空余容量。</p>\n<p>在TensorFlow里，需要自行指定操作对应的<code>device</code>即GPU：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># image:[64,256,256,3], label:[64,256,256]</span></span><br><span class=\"line\"><span class=\"comment\"># small_batch_size = batch_size/N_GPUs = 64/4 = 16</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.variable_scope(tf.get_variable_scope()):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tqdm(range(args.N_GPUs)):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.device(<span class=\"string\">'/gpu:%d'</span> % i):</span><br><span class=\"line\">            start = i * small_batch_size</span><br><span class=\"line\">            end = (i + <span class=\"number\">1</span>) * small_batch_size</span><br><span class=\"line\">            x = image[start:end, :, :, :]</span><br><span class=\"line\">            y = label[start:end, :, :]</span><br><span class=\"line\">            logits = model.forward(x)</span><br><span class=\"line\">            ……</span><br><span class=\"line\">            <span class=\"comment\"># calc loss with logits</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">            grads = optimizer.compute_gradients(loss=loss, var_list=tf.trainable_variables())</span><br><span class=\"line\">            all_grads.append(grads)</span><br><span class=\"line\"><span class=\"comment\"># merge gradients</span></span><br><span class=\"line\">grads = average_gradients(all_grads)</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我将batch_size设置为64，并将每个batch平均分配给4个GPU来进行计算任务，每个GPU需要前向传递更新自己的参数。一个训练伦次中，当4个GPU都计算完了梯度后，会传给主GPU(也可以是CPU，这里我使用GPU0为主GPU)进行梯度的合并，而后反向传递回并更新4个GPU的模型参数。训练过程中，GPU占用如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:center\">GPU0</th>\n<th style=\"text-align:center\">GPU1</th>\n<th style=\"text-align:center\">GPU2</th>\n<th style=\"text-align:center\">GPU3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">显存占用(MB)</td>\n<td style=\"text-align:center\">8793</td>\n<td style=\"text-align:center\">8787</td>\n<td style=\"text-align:center\">8787</td>\n<td style=\"text-align:center\">8787</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GPU占用(%)</td>\n<td style=\"text-align:center\">30-55</td>\n<td style=\"text-align:center\">30-50</td>\n<td style=\"text-align:center\">30-50</td>\n<td style=\"text-align:center\">30-50</td>\n</tr>\n</tbody>\n</table>\n<p>可见，由于GPU0是主GPU，需要完成梯度的合并工作，因此需要占用稍微多一点的内存和GPU。</p>\n<p>当增加了GPU数量以进行并行计算时，通常会由于GPU之间的通信、梯度汇总等原因导致批次的训练速度变慢：本机4个GPU并行计算时，训练速度约为<code>1.2次/s</code>，单GPU训练速度约为<code>2次/s</code>；然而由于4GPU每轮次输入了64个切片，是单GPU的4倍之多，因此4GPU1.25w次训练就能达到单GPU5w次的训练效果，总体训练时间还是缩短了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>笔者本科毕设做的是遥感图像分割相关的研究，当时采用的Potsdam数据集由于所有图像GSD(对地观测距离)固定且适中，因此将训练时的batch_size设置为了16，基本能满足每个批次中都包含所有地表要素的需求。然而<a href=\"https://naic.pcl.ac.cn/\" target=\"_blank\" rel=\"noopener\">NAIC2020</a>数据集中包含的数据的GSD从0.1m-4m不等，0.1m的GSD意味着一张256x256的影像切片中甚至能够看到一根树干的轮廓，然而这也使得该切片包含的要素种类很少！以致于一个batch中的16张切片可能也无法包含所有的要素。<br>一旦batch训练数据无法包含所有要素，就使得当次训练结果对于未被包含的要素基本不具备识别能力，表现为第n次训练和第n+1次训练结果梯度变化很大，有点像拆了东墙补西墙；而限制了batch_size的最根本原因是GPU限制，本模型完全跑起来需要约9G显存(输入大小为[16,256,256,3]，即16张256x256大小的RGB图像)，服务器上的GPU仅有11G，虽然显存不大，但是GPU多呀，4块2080Ti现在只用了一块。<br>因此笔者考虑使用多GPU来增大batch_size，以此来使得每个batch训练的参数结果对所有要素都较为适配。</p>\n</blockquote>","more":"<h2 id=\"并行计算\"><a href=\"#并行计算\" class=\"headerlink\" title=\"并行计算\"></a>并行计算</h2><p>深度学习方法采用并行计算的方法一般包括两种：<code>数据并行</code>和<code>模型并行</code>。</p>\n<h3 id=\"数据并行\"><a href=\"#数据并行\" class=\"headerlink\" title=\"数据并行\"></a>数据并行</h3><p>考虑一个事实：深度学习方法在使用随机梯度下降法进行训练时，每次训练我们会尝试随机取出<code>n</code>个数据点去计算当前这个批次的梯度，然而当前这个批次计算出的梯度相对于整个数据集的真实梯度来说很不准确，同时GPU显存通常不足以容下我们所有的训练数据，因此随机梯度下降法通常需要<code>①增大每个批次的数据点数量</code>、<code>②使用更多的训练轮次</code>来更快、更准地进行模型的收敛。</p>\n<p>NAIC2020数据集中包含了数十万张切片，由于multi-scale特性的存在，每个切片可能包含1-8个要素不等。由于先前训练时的batch_size为16，很难在每个batch里得到包含所有8个要素的16张切片，而由于GPU显存的限制，16已经达到了极限，因此考虑使用多GPU来解决batch_size这一瓶颈。</p>\n<p>数据并行方法在操作时，允许输入模型的批次数量更大，而后将大批次分割为很多<code>小批次</code>，而后在每个GPU上计算一个小批次，每个GPU的梯度估计结果进行汇总后，进行<code>加权平均</code>，最终<code>求和</code>就得到了大批次的梯度估计结果。</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/LoseInVain/article/details/105808818\" target=\"_blank\" rel=\"noopener\">证明过程</a>：<br><img src=\"http://imgbed.guitoubing.top/20201003001646.png\" alt=\"数据并行有效性证明过程\"></p>\n<p>当每个小批次是由大批次平均分配时，那么：<br>m1=m2=···=mk=n/k</p>\n</blockquote>\n<p>下图解释了数据并行的<a href=\"https://www.zhihu.com/question/53851014\" target=\"_blank\" rel=\"noopener\">流程</a>：<br><img src=\"http://imgbed.guitoubing.top/20201003001716.png\" alt=\"数据并行模型\"></p>\n<p>每个节点输入不同的<code>Data Shards</code>，即一个小批次，通过节点上的模型训练得到各自的梯度，而节点中的模型参数是相同的，这样的一个节点通常称作<code>worker</code>；而后每个<code>worker</code>会把各自计算得到的梯度送到<code>ps server</code>进行汇总操作（加权平均）并传回到各个节点进行模型的更新。</p>\n<h3 id=\"模型并行\"><a href=\"#模型并行\" class=\"headerlink\" title=\"模型并行\"></a>模型并行</h3><p>待更新</p>\n<h2 id=\"实际操作\"><a href=\"#实际操作\" class=\"headerlink\" title=\"实际操作\"></a>实际操作</h2><p>笔者代码使用的是<code>TensorFlow-GPU 2.0</code>+<code>Keras 2.3</code>，采用数据并行的方式增大<code>batch_size</code>；训练时，首先需要进行如下设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">os.environ[<span class=\"string\">\"CUDA_VISIBLE_DEVICES\"</span>] = <span class=\"string\">'0,1,2,3'</span></span><br></pre></td></tr></table></figure>\n<p>这句话是让4块GPU都对程序<strong>可见</strong>，然而可见并不是指<strong>成功调用</strong>了。</p>\n<p>当设置<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0,1,2,3&#39;</code>变量时，程序仍然可以正常训练，但是没有达到预期的多GPU效果，各GPU占用如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:center\">GPU0</th>\n<th style=\"text-align:center\">GPU1</th>\n<th style=\"text-align:center\">GPU2</th>\n<th style=\"text-align:center\">GPU3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">显存占用(MB)</td>\n<td style=\"text-align:center\">10870</td>\n<td style=\"text-align:center\">155</td>\n<td style=\"text-align:center\">155</td>\n<td style=\"text-align:center\">155</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GPU占用(%)</td>\n<td style=\"text-align:center\">87</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，还是GPU1-3虽然有显存占用，但是GPU基本无占用，说明这三个GPU仅加载了模型，并没有执行实际的计算任务；因此当增大batch_size时，程序并没有自动唤醒GPU1-3来帮助分担计算任务，而是报出<code>内存不足</code>的错误，即使GPU1-3均有空余容量。</p>\n<p>在TensorFlow里，需要自行指定操作对应的<code>device</code>即GPU：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># image:[64,256,256,3], label:[64,256,256]</span></span><br><span class=\"line\"><span class=\"comment\"># small_batch_size = batch_size/N_GPUs = 64/4 = 16</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.variable_scope(tf.get_variable_scope()):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tqdm(range(args.N_GPUs)):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.device(<span class=\"string\">'/gpu:%d'</span> % i):</span><br><span class=\"line\">            start = i * small_batch_size</span><br><span class=\"line\">            end = (i + <span class=\"number\">1</span>) * small_batch_size</span><br><span class=\"line\">            x = image[start:end, :, :, :]</span><br><span class=\"line\">            y = label[start:end, :, :]</span><br><span class=\"line\">            logits = model.forward(x)</span><br><span class=\"line\">            ……</span><br><span class=\"line\">            <span class=\"comment\"># calc loss with logits</span></span><br><span class=\"line\">            ……</span><br><span class=\"line\">            grads = optimizer.compute_gradients(loss=loss, var_list=tf.trainable_variables())</span><br><span class=\"line\">            all_grads.append(grads)</span><br><span class=\"line\"><span class=\"comment\"># merge gradients</span></span><br><span class=\"line\">grads = average_gradients(all_grads)</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我将batch_size设置为64，并将每个batch平均分配给4个GPU来进行计算任务，每个GPU需要前向传递更新自己的参数。一个训练伦次中，当4个GPU都计算完了梯度后，会传给主GPU(也可以是CPU，这里我使用GPU0为主GPU)进行梯度的合并，而后反向传递回并更新4个GPU的模型参数。训练过程中，GPU占用如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:center\">GPU0</th>\n<th style=\"text-align:center\">GPU1</th>\n<th style=\"text-align:center\">GPU2</th>\n<th style=\"text-align:center\">GPU3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">显存占用(MB)</td>\n<td style=\"text-align:center\">8793</td>\n<td style=\"text-align:center\">8787</td>\n<td style=\"text-align:center\">8787</td>\n<td style=\"text-align:center\">8787</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GPU占用(%)</td>\n<td style=\"text-align:center\">30-55</td>\n<td style=\"text-align:center\">30-50</td>\n<td style=\"text-align:center\">30-50</td>\n<td style=\"text-align:center\">30-50</td>\n</tr>\n</tbody>\n</table>\n<p>可见，由于GPU0是主GPU，需要完成梯度的合并工作，因此需要占用稍微多一点的内存和GPU。</p>\n<p>当增加了GPU数量以进行并行计算时，通常会由于GPU之间的通信、梯度汇总等原因导致批次的训练速度变慢：本机4个GPU并行计算时，训练速度约为<code>1.2次/s</code>，单GPU训练速度约为<code>2次/s</code>；然而由于4GPU每轮次输入了64个切片，是单GPU的4倍之多，因此4GPU1.25w次训练就能达到单GPU5w次的训练效果，总体训练时间还是缩短了。</p>"},{"title":"感谢Docker,让我远离环境配置","date":"2018-11-12T15:26:45.000Z","_content":"\n## Why Docker\n\n自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。\n\n这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。\n\n偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。\n\n<!-- more -->\n\n## 正题\n\n#### Docker安装并启动Oracle 12c\n\n##### 安装\n\n```sh\n# 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的\ndocker search oracle\ndocker pull sath89/oracle-12c\n# 查看已安装的镜像\ndocker images\n```\n\n> 由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：[Docker切换国内镜像下载源](https://blog.csdn.net/huludan/article/details/52713799)\n\n##### 初始化\n\n```shell\n# 使用log记录oracle启动的容器号\nlog=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)\n# 显示当前容器初始化进程\ndocker logs -f $log\n# 显示docker中当前运行的容器(可查看到容器ID)\nsudo docker ps\n```\n\n> 正常情况下，第一次创建容器应称之为`初始化`，而以后创建的容器都应基于上次的历史数据，称作`容器的数据持久化`，在上述命令中`-v`后的`:`之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，`:`后面是在容器中想要访问`当前系统的共享文件`的路径。\n>\n> 因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^：\n>\n\n```shell\nsudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c\n```\n\n>\n> 至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。\n>\n> 同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。\n\n##### 进入容器\n\n```shell\n# 进入特定的容器，${ContainerID}为上述查看到的容器ID\n# env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)\nsudo docker exec -it ${ContainerID} env LANG=C.UTF-8 /bin/bash\n```\n\n##### 连接oracle数据库\n\n```sh\nroot@1386ef844664:/# su oracle\noracle@1386ef844664:/$ cd $ORACLE_HOME\noracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba\n```\n##### Oracle数据库设置字符集\n\n```shell\n## 查看数据库编码，结果最下面一行则是目前编码\nSQL> select * from nls_database_parameters where parameter ='NLS_CHARACTERSET';   \n## 关闭数据库\nSQL> shutdown immediate;               \n## 启动到 mount状态，oracle分为4个状态，详情请百度\nSQL> startup mount;                    \n## 设置session ，下同\nSQL> ALTER SYSTEM ENABLE RESTRICTED SESSION;                        \nSQL> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;\nSQL> ALTER SYSTEM SET AQ_TM_PROCESSES=0;\n## 打开oracle到 open状态\nSQL> alter database open;                               \n## 修改编码为 ZHS16GBK\nSQL> ALTER DATABASE character set INTERNAL_USE ZHS16GBK;                \n## 重启oracle ，先关闭，再启动\nSQL> shutdown immediate;                      \nSQL> startup;\n```\n\n\n\n## 升华\n\nDocker真的好用！（俗\n","source":"_posts/使用Docker安装Oracle-12c.md","raw":"---\ntitle: 感谢Docker,让我远离环境配置\ndate: 2018-11-12 23:26:45\ntags:\n    - Docker\n    - Oracle\ncategories:\n    - 数据库\n---\n\n## Why Docker\n\n自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。\n\n这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。\n\n偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。\n\n<!-- more -->\n\n## 正题\n\n#### Docker安装并启动Oracle 12c\n\n##### 安装\n\n```sh\n# 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的\ndocker search oracle\ndocker pull sath89/oracle-12c\n# 查看已安装的镜像\ndocker images\n```\n\n> 由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：[Docker切换国内镜像下载源](https://blog.csdn.net/huludan/article/details/52713799)\n\n##### 初始化\n\n```shell\n# 使用log记录oracle启动的容器号\nlog=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)\n# 显示当前容器初始化进程\ndocker logs -f $log\n# 显示docker中当前运行的容器(可查看到容器ID)\nsudo docker ps\n```\n\n> 正常情况下，第一次创建容器应称之为`初始化`，而以后创建的容器都应基于上次的历史数据，称作`容器的数据持久化`，在上述命令中`-v`后的`:`之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，`:`后面是在容器中想要访问`当前系统的共享文件`的路径。\n>\n> 因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^：\n>\n\n```shell\nsudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c\n```\n\n>\n> 至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。\n>\n> 同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。\n\n##### 进入容器\n\n```shell\n# 进入特定的容器，${ContainerID}为上述查看到的容器ID\n# env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)\nsudo docker exec -it ${ContainerID} env LANG=C.UTF-8 /bin/bash\n```\n\n##### 连接oracle数据库\n\n```sh\nroot@1386ef844664:/# su oracle\noracle@1386ef844664:/$ cd $ORACLE_HOME\noracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba\n```\n##### Oracle数据库设置字符集\n\n```shell\n## 查看数据库编码，结果最下面一行则是目前编码\nSQL> select * from nls_database_parameters where parameter ='NLS_CHARACTERSET';   \n## 关闭数据库\nSQL> shutdown immediate;               \n## 启动到 mount状态，oracle分为4个状态，详情请百度\nSQL> startup mount;                    \n## 设置session ，下同\nSQL> ALTER SYSTEM ENABLE RESTRICTED SESSION;                        \nSQL> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;\nSQL> ALTER SYSTEM SET AQ_TM_PROCESSES=0;\n## 打开oracle到 open状态\nSQL> alter database open;                               \n## 修改编码为 ZHS16GBK\nSQL> ALTER DATABASE character set INTERNAL_USE ZHS16GBK;                \n## 重启oracle ，先关闭，再启动\nSQL> shutdown immediate;                      \nSQL> startup;\n```\n\n\n\n## 升华\n\nDocker真的好用！（俗\n","slug":"使用Docker安装Oracle-12c","published":1,"updated":"2021-05-16T10:42:54.170Z","_id":"ckfukja9m000rszxo5fz1hf7g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Why-Docker\"><a href=\"#Why-Docker\" class=\"headerlink\" title=\"Why Docker\"></a>Why Docker</h2><p>自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。</p>\n<p>这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。</p>\n<p>偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。</p>\n<a id=\"more\"></a>\n<h2 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h2><h4 id=\"Docker安装并启动Oracle-12c\"><a href=\"#Docker安装并启动Oracle-12c\" class=\"headerlink\" title=\"Docker安装并启动Oracle 12c\"></a>Docker安装并启动Oracle 12c</h4><h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的</span></span><br><span class=\"line\">docker search oracle</span><br><span class=\"line\">docker pull sath89/oracle-12c</span><br><span class=\"line\"><span class=\"comment\"># 查看已安装的镜像</span></span><br><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：<a href=\"https://blog.csdn.net/huludan/article/details/52713799\" target=\"_blank\" rel=\"noopener\">Docker切换国内镜像下载源</a></p>\n</blockquote>\n<h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用<span class=\"built_in\">log</span>记录oracle启动的容器号</span></span><br><span class=\"line\">log=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 显示当前容器初始化进程</span></span><br><span class=\"line\">docker logs -f $log</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 显示docker中当前运行的容器(可查看到容器ID)</span></span><br><span class=\"line\">sudo docker ps</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正常情况下，第一次创建容器应称之为<code>初始化</code>，而以后创建的容器都应基于上次的历史数据，称作<code>容器的数据持久化</code>，在上述命令中<code>-v</code>后的<code>:</code>之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，<code>:</code>后面是在容器中想要访问<code>当前系统的共享文件</code>的路径。</p>\n<p>因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。</p>\n<p>同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。</p>\n</blockquote>\n<h5 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 进入特定的容器，<span class=\"variable\">$&#123;ContainerID&#125;</span>为上述查看到的容器ID</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)</span></span><br><span class=\"line\">sudo docker exec -it $&#123;ContainerID&#125; env LANG=C.UTF-8 /bin/bash</span><br></pre></td></tr></table></figure>\n<h5 id=\"连接oracle数据库\"><a href=\"#连接oracle数据库\" class=\"headerlink\" title=\"连接oracle数据库\"></a>连接oracle数据库</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@1386ef844664:/<span class=\"comment\"># su oracle</span></span><br><span class=\"line\">oracle@1386ef844664:/$ <span class=\"built_in\">cd</span> <span class=\"variable\">$ORACLE_HOME</span></span><br><span class=\"line\">oracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba</span><br></pre></td></tr></table></figure>\n<h5 id=\"Oracle数据库设置字符集\"><a href=\"#Oracle数据库设置字符集\" class=\"headerlink\" title=\"Oracle数据库设置字符集\"></a>Oracle数据库设置字符集</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 查看数据库编码，结果最下面一行则是目前编码</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> select * from nls_database_parameters <span class=\"built_in\">where</span> parameter =<span class=\"string\">'NLS_CHARACTERSET'</span>;   </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 关闭数据库</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> shutdown immediate;               </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 启动到 mount状态，oracle分为4个状态，详情请百度</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> startup mount;                    </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 设置session ，下同</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM ENABLE RESTRICTED SESSION;                        </span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;</span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM SET AQ_TM_PROCESSES=0;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 打开oracle到 open状态</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> alter database open;                               </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 修改编码为 ZHS16GBK</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER DATABASE character <span class=\"built_in\">set</span> INTERNAL_USE ZHS16GBK;                </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 重启oracle ，先关闭，再启动</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> shutdown immediate;                      </span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> startup;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"升华\"><a href=\"#升华\" class=\"headerlink\" title=\"升华\"></a>升华</h2><p>Docker真的好用！（俗</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Why-Docker\"><a href=\"#Why-Docker\" class=\"headerlink\" title=\"Why Docker\"></a>Why Docker</h2><p>自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。</p>\n<p>这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。</p>\n<p>偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。</p>","more":"<h2 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h2><h4 id=\"Docker安装并启动Oracle-12c\"><a href=\"#Docker安装并启动Oracle-12c\" class=\"headerlink\" title=\"Docker安装并启动Oracle 12c\"></a>Docker安装并启动Oracle 12c</h4><h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的</span></span><br><span class=\"line\">docker search oracle</span><br><span class=\"line\">docker pull sath89/oracle-12c</span><br><span class=\"line\"><span class=\"comment\"># 查看已安装的镜像</span></span><br><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：<a href=\"https://blog.csdn.net/huludan/article/details/52713799\" target=\"_blank\" rel=\"noopener\">Docker切换国内镜像下载源</a></p>\n</blockquote>\n<h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用<span class=\"built_in\">log</span>记录oracle启动的容器号</span></span><br><span class=\"line\">log=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 显示当前容器初始化进程</span></span><br><span class=\"line\">docker logs -f $log</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 显示docker中当前运行的容器(可查看到容器ID)</span></span><br><span class=\"line\">sudo docker ps</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正常情况下，第一次创建容器应称之为<code>初始化</code>，而以后创建的容器都应基于上次的历史数据，称作<code>容器的数据持久化</code>，在上述命令中<code>-v</code>后的<code>:</code>之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，<code>:</code>后面是在容器中想要访问<code>当前系统的共享文件</code>的路径。</p>\n<p>因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。</p>\n<p>同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。</p>\n</blockquote>\n<h5 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 进入特定的容器，<span class=\"variable\">$&#123;ContainerID&#125;</span>为上述查看到的容器ID</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)</span></span><br><span class=\"line\">sudo docker exec -it $&#123;ContainerID&#125; env LANG=C.UTF-8 /bin/bash</span><br></pre></td></tr></table></figure>\n<h5 id=\"连接oracle数据库\"><a href=\"#连接oracle数据库\" class=\"headerlink\" title=\"连接oracle数据库\"></a>连接oracle数据库</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@1386ef844664:/<span class=\"comment\"># su oracle</span></span><br><span class=\"line\">oracle@1386ef844664:/$ <span class=\"built_in\">cd</span> <span class=\"variable\">$ORACLE_HOME</span></span><br><span class=\"line\">oracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba</span><br></pre></td></tr></table></figure>\n<h5 id=\"Oracle数据库设置字符集\"><a href=\"#Oracle数据库设置字符集\" class=\"headerlink\" title=\"Oracle数据库设置字符集\"></a>Oracle数据库设置字符集</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 查看数据库编码，结果最下面一行则是目前编码</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> select * from nls_database_parameters <span class=\"built_in\">where</span> parameter =<span class=\"string\">'NLS_CHARACTERSET'</span>;   </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 关闭数据库</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> shutdown immediate;               </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 启动到 mount状态，oracle分为4个状态，详情请百度</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> startup mount;                    </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 设置session ，下同</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM ENABLE RESTRICTED SESSION;                        </span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;</span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER SYSTEM SET AQ_TM_PROCESSES=0;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 打开oracle到 open状态</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> alter database open;                               </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 修改编码为 ZHS16GBK</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> ALTER DATABASE character <span class=\"built_in\">set</span> INTERNAL_USE ZHS16GBK;                </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 重启oracle ，先关闭，再启动</span></span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> shutdown immediate;                      </span></span><br><span class=\"line\"><span class=\"meta\">SQL&gt;</span><span class=\"bash\"> startup;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"升华\"><a href=\"#升华\" class=\"headerlink\" title=\"升华\"></a>升华</h2><p>Docker真的好用！（俗</p>"},{"title":"内存数据库 - Best Practice","date":"2018-11-24T06:18:44.000Z","_content":"\n> Oracle专家的三次授课笔记及Best Practice记录。\n\n<!--more-->\n\n# Lesson 1\n\n## 创建用户并分配权限\n\n### 创建测试schema，命名为test\n\n```plsql\ncreate user test identified by test;\n```\n\n### 分配连接资源\n\n```plsql\ngrant connect,resource to test;\ngrant execute on dbms_lock to test;\ngrant execute on UTL_FILE to test;\n```\n\n### 为test用户创建external_data目录以及分配权限\n\n```plsql\ncreate directory external_data as '/home/oracle/data';\ngrant read,write on directory external_data to test;\n```\n\n> 要注意oracle用户必须拥有对这里的external_data路径读写的权限。\n\n### 分配表空间权限\n\n我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间：\n\n- **SYSTEM** - 存储数据字典\n- **SYSAUX** - 存储辅助应用程序的数据\n- **TEMP** - 存储数据库临时对象\n- **USERS** - 存储各个用户创建的对象\n- **UNDOTBS** - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询\n- ……\n\n而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作：\n\n```plsql\n-- DBA下执行：\n-- 查看数据库中的所有表空间\nselect * from v$tablespace;\n-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)\nselect username,default_tablespace from dba_users where username='TEST';\n-- 为用户赋予当前表空间下的权限\nalter user test quota unlimited on users;\n--  或者制定用户可用大小：\nalter user test quota 50M on users;\n```\n\n\n\n## 连接用户，建表，跑存储过程和函数\n\n### 连接test用户\n\n```shell\n-- 在系统命令下连接\ncd $ORACLE_HOME/bin\n./sqlplus test/test\n```\n\n```plsql\n-- 在进入sqlplus后的连接\nconn test/test\n```\n\n### 创建表\n\n```plsql\ncreate table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));\nCOMMENT ON COLUMN T_MOBILES.F_ID IS '主键';\nCOMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS '手机号段';\nCOMMENT ON COLUMN T_MOBILES.F_PROVINCE IS '省份地区';\nCOMMENT ON COLUMN T_MOBILES.F_CITY IS '城市';\nCOMMENT ON COLUMN T_MOBILES.F_PLATFORM IS '运营商';\nCOMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS '固话区号';\nCOMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS '邮政编码';\nCOMMENT ON TABLE T_MOBILES  IS '号段表';\n\ncreate table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);\n--*注：因f_id导入时缺少数据，所有先不设置为PK.\nCOMMENT ON COLUMN T_RECORDS.F_ID IS '主键';\nCOMMENT ON COLUMN T_RECORDS.F_NO IS '通话号码';\nCOMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS '开始时间';\nCOMMENT ON COLUMN T_RECORDS.F_END_TIME IS '结束时间';\nCOMMENT ON COLUMN T_RECORDS.F_DURATION IS '通话时长';\nCOMMENT ON COLUMN T_RECORDS.F_PROVINCE IS '省份地区';\nCOMMENT ON COLUMN T_RECORDS.F_PLATFORM IS '运营商';\nCOMMENT ON COLUMN T_RECORDS.F_MOBILE IS '手机号码标志';\nCOMMENT ON TABLE T_RECORDS  IS '通话清单表';\n```\n\n### 创建ctl文件导入csv数据\n\n进入`external_data`路径下并创建以下文件：\n\n```shell\n$ cd /home/oracle/data\n$ vi control_mobiles.ctl\n$ vi control_records.ctl\n```\n\n`control_mobiles.ctl:`\n\n```ctl\nLOAD DATA\nCHARACTERSET UTF8\nINFILE '/home/oracle/data/mobiles.csv'\nTRUNCATE INTO TABLE t_mobiles\nFIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\nTRAILING NULLCOLS\n(\n\tF_ID,\n\tF_MOBILE_HEAD,\n\tF_PROVINCE,\n\tF_CITY,\n\tF_PLATFORM,\n\tF_TEL_HEAD,\n\tF_ZIPCODE\n)\n```\n\n`control_records.ctl:`\n\n```\nLOAD DATA\nCHARACTERSET UTF8\nINFILE '/home/oracle/data/records.csv'\nTRUNCATE INTO TABLE t_records\nFIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\nTRAILING NULLCOLS\n(\n\tF_NO,\n\tF_BEGIN_TIME DATE \"YYYY-MM-DD HH24:MI:SS\",\n\tF_END_TIME DATE \"YYYY-MM-DD HH24:MI:SS\",\n\tF_DURATION INTEGER EXTERNAL\n)\n```\n\n在该路径下执行导入操作：\n\n```shell\n$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_mobiles.ctl\n$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_records.ctl\n```\n\n> 教程中命令为：\n>\n> ```shell\n> $ sqlldr userid=test/test@orcl control=control_mobiles.ctl\n> ```\n>\n> 即在导入时指定`连接字符串`（这里的orcl实际上是连接字符串的别名），其在`$ORACLE_HOME/network/admin/tnsname.ora`中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。\n>\n> 既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是`连接字符串`和`服务名`的区别，oracle有个默认服务名`XE`，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下：\n>\n> ```\n> jdbc:oracle:thin:@localhost:1521:XE\n> ```\n>\n> 那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全：\n>\n> ```shell\n> # 命令格式：sqlplus username/password@host:port/service_name\n> $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe\n> ```\n>\n\n\n\n## 数据预处理\n\n```plsql\n-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键\ncreate sequence seq_records increment by 1 start with 1 ;\n\n-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键\nupdate t_records set f_id=seq_records.nextval;\nalter table t_records add constraint t_records_pk primary key (f_id);\n\n-- 3、创建并初始化同步锁表，用于多线程同步控制\nCREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));\nCOMMENT ON COLUMN T_LOCK.F_NAME IS '锁名';\nCOMMENT ON COLUMN T_LOCK.F_INDEX IS '锁的当前值';\nCOMMENT ON TABLE T_LOCK  IS '同步锁表';\ninsert into T_LOCK values('_RECORD_INDEX',0);\n\n-- 4、在电话号段表中创建唯一性索引，提高号段检索速度\ncreate unique index uniq_mobile_head on t_mobiles(f_mobile_head);\nupdate t_mobiles set f_province = '内蒙古' where f_province = '内蒙';\n\n-- 5、创建日志表，用于记录程序执行过程中的日志信息。\ncreate table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));\nCOMMENT ON COLUMN T_LOG.F_TIME IS '日志时间';\nCOMMENT ON COLUMN T_LOG.F_HEAD IS '日志类型标志';\nCOMMENT ON COLUMN T_LOG.F_CONTENT IS '日志内容';\nCOMMENT ON TABLE T_LOG  IS '日志表';\n```\n\n\n\n## 创建函数和存储过程\n\n### 声明函数和存储过程\n\n- 函数is_mobile，判断通话号码是否为手机号码\n\n```plsql\n--函数：判断通话号码是否为手机号码\nCREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2)\n    RETURN BOOLEAN IS\n\n    v_phone VARCHAR2(20);\n    v_head VARCHAR2(2);\nBEGIN\n    --检查参数func\n    IF phone IS NULL THEN\n        RETURN FALSE;\n    END IF;\n\n\t--去除前后空格\n    v_phone := TRIM(phone);\n\n\t--去除号码前面的0\n    IF substr(v_phone,0,1) = '0' THEN\n        v_phone := substr(v_phone, 2);\n    END IF;\n\n\t--检查手机号码长度\n    IF substr(v_phone,0,1) <> '1' OR LENGTH(v_phone) <> 11 THEN\n        RETURN FALSE;\n    END IF;\n\n\t--截取号码前两位\n    v_head := substr(v_phone,1,2);\n\n    IF v_head = '13' OR v_head = '14' OR v_head ='15' OR v_head ='17' OR v_head = '18' THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n/\n```\n\n- 存储过程init，清空t_log，同时t_lock置零\n\n```plsql\n--存储过程：初始化测试数据\nCREATE OR REPLACE PROCEDURE init IS\n    CURSOR job_cursor IS SELECT JOB FROM user_jobs;\nBEGIN\n\t--重置处理位置为0\n    EXECUTE IMMEDIATE 'update t_lock set f_index=0';\n\n\t--清除日志表中的记录\n    EXECUTE IMMEDIATE 'truncate table t_log';\n\n\t--重置话单表中的记录\n    EXECUTE IMMEDIATE 'update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1';\n    COMMIT;\n\n    FOR tmp_job IN job_cursor LOOP\n        dbms_job.broken(tmp_job.JOB,TRUE,sysdate);\n        dbms_job.REMOVE(tmp_job.JOB);\n    END LOOP;\nEND;\n/\n```\n\n- 存储过程print，打印日志，存到T_LOG表中\n\n```plsql\n--存储过程：打印日志\nCREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) IS\nBEGIN\n\t--dbms_output.put_line(to_char('yyyy-mm-dd hh24:mi:ss')||','||prefix||','||content);\n\tINSERT INTO t_log VALUES(sysdate,prefix, content);\n\tCOMMIT;\nEXCEPTION\n\tWHEN OTHERS THEN\n\t\tdbms_output.put_line('Error code: '||SQLCODE);\n\t\tdbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程show，显示当前处理情况\n\n```plsql\n--存储过程：显示当前处理情况\nCREATE OR REPLACE PROCEDURE show IS\n\t--待处理记录总数\n    v_record_count NUMBER;\n\n\t--当前日志表记录总数\n    v_log_count NUMBER;\n\n\t--当前数据处理位置\n    v_current_index NUMBER;\n\n\t--用户Job表游标\n    CURSOR job_cursor IS SELECT * FROM user_jobs;\n\nBEGIN\n    SELECT COUNT(1) INTO v_log_count FROM t_log;\n    SELECT f_index INTO v_current_index FROM t_lock;\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n\n\tdbms_output.put_line('log count: '||v_log_count);\n    dbms_output.put_line('record count: '||v_record_count);\n    dbms_output.put_line('current index: '||v_current_index);\n\n\t--清除用户job记录\n    FOR tmp_job IN job_cursor LOOP\n        dbms_output.put_line('job:'||tmp_job.JOB||',broken:'||tmp_job.broken||',total_time:'||tmp_job.total_time||',failures:'||tmp_job.failures||',interval:'||tmp_job.INTERVAL||',last_sec:'||tmp_job.last_sec||',next_sec:'||tmp_job.next_sec);\n\n    END LOOP;\nEND;\n/\n```\n\n- 存储过程process_data，提交一个job处理数据\n\n> **共享锁和排它锁:**\n>\n> - 当某事务对数据添加共享锁时，此时该事务`只能读不能写`，其他事务只能对该数据添加共享锁，而不能添加排它锁\n>\n> - 当某事务对数据添加排它锁时，此时该事务`既能读又能写`，其他事务不能对该数据添加任何锁\n>\n> **autocommit需要关掉:**\n>\n>\n> 假设现在有三个job对T_LOCK表进行并发读写，如下：\n>\n> ![image-20181124202306595](/images/image-20181124202306595.png)\n>\n> 步骤如下：\n>\n> ![锁](/images/锁.png)\n>\n> 阻塞情况：\n>\n> ![锁2](/images/锁2.png)\n\n```plsql\n--存储过程：处理数据\nCREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS\n    --定义常量\n    c_record_index CONSTANT VARCHAR2(20)   :='_RECORD_INDEX';\n    c_process_prefix CONSTANT VARCHAR2(20) := '[  PROCESS ]';\n    c_select_record_sql VARCHAR2(100)  := 'select * from t_records where f_id >= :x and f_id <= :y';\n    c_select_mobile_sql VARCHAR2(100)  := 'select * from t_mobiles where f_mobile_head = :x';\n    c_update_mobile_sql VARCHAR2(100)  := 'update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z';\n    c_update_record_sql VARCHAR2(100)  := 'update t_records set f_mobile = 0 where f_id = :n';\n    v_record_count NUMBER;\n    v_current_index NUMBER;\n    v_begin_index NUMBER;\n    v_end_index NUMBER;\n    v_id NUMBER;\n    v_phone VARCHAR2(20);\n    v_province VARCHAR2(20);\n    v_platform VARCHAR2(20);\n    --定义动态游标\n    TYPE ty_record_cursor IS REF CURSOR;\n    record_cursor ty_record_cursor;\n    mobile_cursor ty_record_cursor;\n    v_record_row t_records%rowtype;\n    v_mobile_row t_mobiles%rowtype;\nBEGIN\n    PRINT(c_process_prefix, 'process['||process_no||'], running...');\n    --获取待处理的记录总数\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n    PRINT(c_process_prefix, 'process['||process_no||'], records count: '||v_record_count);\n    LOOP\n        --获取记录锁\n        SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE;\n        PRINT(c_process_prefix, 'process['||process_no||'], current index: '||v_current_index);\n        IF v_current_index = v_record_count THEN\n            PRINT(c_process_prefix, 'process['||process_no||'], finished.');\n            EXIT;\n        END IF;\n        --记录本次处理的开始和结束记录位置\n        v_end_index := v_current_index + batch_size;\n        IF v_end_index > v_record_count THEN\n            v_end_index := v_record_count;\n        END IF;\n        --提交事务，释放锁\n        UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index;\n        COMMIT;\n        --计算开始位置\n        v_begin_index := v_current_index +1;\n        PRINT(c_process_prefix, 'process['||process_no||'], begin index:'||v_begin_index||', end index:'||v_end_index);\n        --test：dbms_lock.sleep(5);\n        --查询一批记录进行逐个处理\n        OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index;\n        LOOP\n            FETCH record_cursor INTO v_record_row;\n            EXIT WHEN record_cursor%notfound;\n            v_id    := v_record_row.f_id;\n            v_phone := v_record_row.f_no;\n            IF is_mobile(v_phone) THEN\n                v_phone := TRIM(v_phone);\n                IF substr(v_phone,0,1) = '0' THEN\n                    v_phone := substr(v_phone, 2);\n                END IF;\n                --PRINT(c_process_prefix, 'process['||process_no||'], id:'||v_id||', phone:'||v_phone);\n                --更新话单记录中的省份、运营商以及手机类型标志\n                OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7);\n                    FETCH mobile_cursor INTO v_mobile_row;\n                    v_province := v_mobile_row.f_province;\n                    v_platform := v_mobile_row.f_platform;\n                    --FETCH mobile_cursor INTO v_province, v_platform;\n                CLOSE mobile_cursor;\n\t\t\t\t--更新话单记录的运营商、省份地区信息\n                EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id;\n            ELSE\n                --更新话单记录为非移动号码类型\n                EXECUTE IMMEDIATE c_update_record_sql USING v_id;\n            END IF;\n\t\t\t--提交事务\n            COMMIT;\n        END LOOP;\n        CLOSE record_cursor;\n        PRINT(c_process_prefix, 'process['||process_no||'], processed index: '||v_end_index);\n    END LOOP;\nEXCEPTION\n    WHEN OTHERS THEN\n        dbms_output.put_line('Error code: '||SQLCODE);\n        dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程generate_csv_report，生成报表\n\n```plsql\n--存储过程：生成报表\nCREATE OR REPLACE PROCEDURE generate_csv_report IS\n\tc_report_prefix CONSTANT VARCHAR2(20) := '[  REPORT  ]';\n    v_report_1  UTL_FILE.FILE_TYPE;\n    v_report_2  UTL_FILE.FILE_TYPE;\n    CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC;\n    cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;\nBEGIN\n    --生成报表1，根据运营商分类汇总各省份地区的通话量\n    v_report_1 := UTL_FILE.FOPEN( LOCATION => 'EXTERNAL_DATA', filename => 'report1.csv', open_mode => 'w', max_linesize => 32767);\n    FOR cur_tmp IN report_1_cursor LOOP\n        UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || ',' || cur_tmp.f_province || ',' || cur_tmp.total);\n    END LOOP;\n    UTL_FILE.FCLOSE(v_report_1);\n    --生成报表2，根据各省份地区汇总各运营商的通话量\n    v_report_2 := UTL_FILE.FOPEN( LOCATION => 'EXTERNAL_DATA', filename => 'report2.csv', open_mode => 'w', max_linesize => 32767);\n    FOR cur_tmp IN report_2_cursor LOOP\n        UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || ',' || cur_tmp.f_platform || ',' ||  cur_tmp.total);\n    END LOOP;\n    UTL_FILE.FCLOSE(v_report_2);\n    PRINT(c_report_prefix, 'generated reports.');\n    EXCEPTION\n        WHEN OTHERS THEN\n            dbms_output.put_line('Error code: '||SQLCODE);\n            dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量\n\n> **[dbms_job](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_job.htm#BABHCBFD):**\n>\n> 用于管理job的package\n>\n> **oracle限定的job_queue_processes:**\n>\n> oracle中有一个对任务可启动进程的数量进行限制的参数：\n>\n> ```plsql\n> SQL> show parameter job_queue_processes;\n> NAME\t\t\t\t     TYPE\t VALUE\n> ----------------------------------------------------------\n> job_queue_processeses\t\t integer\t 10\n>\n> SQL> alter system set job_queue_processes=0...1000;\n> ```\n>\n> **使用ctrl+c是无法停止job的:**\n>\n> 可使用`top`命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号\n\n```plsql\nCREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS\n    --定义常量\n    c_record_index CONSTANT VARCHAR2(20)\t:='_RECORD_INDEX';\n\t  c_analysis_prefix CONSTANT VARCHAR2(20)\t:= '[ ANALYSIS ]';\n    --当前处理位置\n    v_record_index NUMBER;\n    --待处理的记录总数\n    v_record_count NUMBER;\n    --保存临时创建的job no\n    v_tmp_jobno NUMBER;\n    --开始结束时间\n    v_begin_time NUMBER;\n    v_process_end_time NUMBER;\n    v_analysis_end_time NUMBER;\n    --异常变量\n    e_invalid_input EXCEPTION;\nBEGIN\n    PRINT(c_analysis_prefix, ' start analysis...');\n    --输入参数检查\n    IF job_count < 1 OR batch_size<1 THEN\n        RAISE e_invalid_input;\n    END IF;\n    PRINT(c_analysis_prefix, ' checked input parameters.');\n    --记录开始时间\n    v_begin_time := dbms_utility.get_time;\n    --获取待处理的记录总数\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n    PRINT(c_analysis_prefix, ' records count: '||v_record_count);\n    --开始计算重置为0\n    UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index;\n    COMMIT;\n    PRINT(c_analysis_prefix, ' reset index to zero.');\n    --提交多个job\n    FOR I IN 1.. job_count LOOP\n        dbms_job.submit(v_tmp_jobno,'begin process_data('||I||','||batch_size||'); end;');\n        PRINT(c_analysis_prefix, ' submitted new job, no: '||v_tmp_jobno);\n    END LOOP;\n    PRINT(c_analysis_prefix, ' created '||job_count||' jobs.');\n    --定时检查处理进度\n    LOOP\n        SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index;\n        PRINT(c_analysis_prefix, ' current index: '||v_record_index);\n        IF v_record_index = v_record_count THEN\n            PRINT(c_analysis_prefix, ' processed all records, exiting...');\n            EXIT;\n        ELSE\n            dbms_lock.sleep(5);--暂停等待5秒\n        END IF;\n    END LOOP;\n    v_process_end_time := dbms_utility.get_time;\n    PRINT(c_analysis_prefix, 'process, elapsed time: '||(v_process_end_time-v_begin_time)/100||' seconds.');\n    dbms_output.put_line('process, elapsed time: '||(v_process_end_time-v_begin_time)/100||' seconds.');\n    --分类汇总产生报表\n    generate_csv_report;\n    --结束时间\n    v_analysis_end_time := dbms_utility.get_time;\n    PRINT(c_analysis_prefix, 'report, elapsed time: '||(v_analysis_end_time-v_process_end_time)/100||' seconds.');\n    dbms_output.put_line('report, elapsed time: '||(v_analysis_end_time-v_process_end_time)/100||' seconds.');\n--异常捕获部分\nEXCEPTION\n    WHEN e_invalid_input THEN\n        dbms_output.put_line('Invalid input values, job_count:'||job_count||', batch_size:'||batch_size);\n    WHEN OTHERS THEN\n        dbms_output.put_line('Error code: '||SQLCODE);\n        dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中\n\n```plsql\n-- 调用多次analysis，指定不同的job数和批数\ncreate or replace procedure mul_analysis is\n    -- 最小job数\n    v_begin_job_no NUMBER := 3;\n    -- 最大job数\n    v_end_job_no NUMBER := 8;\n    -- 每次增长的batch数量\n    v_range NUMBER := 2000;\n    -- 最小batch数量\n    v_begin_range NUMBER := 1000;\n    -- 最大batch数量\n    v_end_range NUMBER := 10000;\n    -- 当前range\n    range NUMBER;\n    begin\n        for I in v_begin_job_no..v_end_job_no LOOP\n            range := v_begin_range;\n            LOOP\n                -- 清洗表\n                init();\n                -- 分析\n                analysis(I, range);\n                range := range+v_range;\n\t\t\t\t-- range增长到10000则停止\n                if range > v_end_range then\n                    exit;\n                end if;\n            end loop;\n        end loop;\n    end;\n/\n```\n\n### 执行函数和存储过程\n\n> 在sqlplus中执行函数和存储过程之前需先打开serveroutput，即：\n>\n> ```plsql\n> SQL> set serveroutput on;\n> ```\n>\n> 这是因为存储过程中用到了`dbms_output.put_line`，上述语句是相当于告诉pl/sql引擎将`dbms_output.put_line`传递到缓冲区的内容输出到主控制台上。\n\n```\ncall init();\ncall analysis(4,1000);\n```\n\n\n\n## 结果分析\n\n通过执行`mul_analysis()`对一系列job和batch组合值进行测试，结果如下：\n\n![image-20181124205409162](/images/image-20181124205409162.png)\n\n\n# Lesson 2\n\n## 创建用户并分配权限\n\n### 创建用户\n\n```plsql\ncreate user audittest identified by audittest;\n```\n\n### 分配权限\n\n```plsql\ngrant connect,resource to audittest;\ngrant execute on dbms_lock to audittest;\nalter user audittest quota unlimited on users;\nconn audittest/audittest;\n```\n\n## 创建表及其他对象\n\n### 创建表\n\n> 注意：\n>\n> 这里在创建表时添加了`ENABLE`限制条件，oracle中对表和列的约束有`Enable`/`Disable`(启用/禁用)和`Validate`/`NoValidate`(验证/不验证)\n>\n> 举两个例子：\n>\n> **需更改的错误：**\n>\n> ```plsql\n> -- 创建表，对name字段添加唯一性约束\n> drop table T_TEST;\n> create table T_TEST(\n>   id int primary key ,\n>   name varchar2(10) constraint unique_name unique disable\n> );\n> -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错\n> begin\n>   insert into T_TEST values (1, 'tan');\n>   insert into T_TEST values (2, 'rui');\n>   insert into T_TEST values (3, 'tan');\n> end;\n> select * from T_TEST;\n> -- 修改掉违反唯一性约束的值\n> update T_TEST set name='chen' where id=3;\n> -- 使得唯一性约束生效\n> alter table T_TEST modify constraint unique_name enable;\n> select * from T_TEST;\n>\n> ```\n>\n> **需保留的错误：**\n>\n> ```plsql\n> -- 创建表，无约束\n> drop table T_TEST;\n> create table T_TEST(\n>   id int primary key ,\n>   name varchar2(10)\n> );\n> -- 一些old的记录本身可能存在重复数据\n> begin\n>   insert into T_TEST values (1, 'tan');\n>   insert into T_TEST values (2, 'rui');\n>   insert into T_TEST values (3, 'tan');\n> end;\n> select * from T_TEST;\n> -- 对name列创建非唯一性索引\n> create index i_name on T_TEST(name);\n> -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引\n> alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;\n> -- 此时无法插入name相同的数据了\n> insert into T_TEST values (4, 'tan');\n> ```\n\n```plsql\n--部门表\nCREATE TABLE \"AUDITTEST\".\"T_DEPARTMENT\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_PARENT_ID\" NUMBER(6,0),\n\t\"F_MANAGER\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_DEPARTMENT_PK\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_CODE\" IS '部门编号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_MANAGER\" IS '部门经理';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_DEPARTMENT\"  IS '部门表';\n\n--用户表\nCREATE TABLE \"AUDITTEST\".\"T_USER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(20 BYTE),\n\t\"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n\t\"F_MOBILE\" VARCHAR2(20 BYTE),\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(50 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_USER_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_CODE\" IS '员工编号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_TELEPHONE\" IS '固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_USER\"  IS '用户表';\n\n--客户信息表\nCREATE TABLE \"AUDITTEST\".\"T_CUSTOMER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_FULL_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_CITY\" VARCHAR2(45 BYTE),\n\t\"F_BALANCE\" NUMBER(10,2) NOT NULL ENABLE,\n\t\"F_PARTNER\" VARCHAR2(45 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_SALESMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_DELETED_TAG\" NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_MODIFIED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_MODIFIED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_VERSION\" NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,\n\t PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CODE\" IS '客户编码';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_FULL_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_TELEPHONE\" IS '联系固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CITY\" IS '城市';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_BALANCE\" IS '余额';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_PARTNER\" IS '所属合作伙伴';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_SALESMAN\" IS '业务员';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_DELETED_TAG\" IS '删除标志，0：可用，1：已删除';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MODIFIED_ID\" IS '最后修改人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MODIFIED_TIME\" IS '最后修改时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_VERSION\" IS '版本号';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_CUSTOMER\"  IS '客户信息表';\n\n--\nCREATE TABLE \"AUDITTEST\".\"T_CUSTOMER_HISTORY\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_FULL_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_CITY\" VARCHAR2(45 BYTE),\n\t\"F_BALANCE\" NUMBER(10,2) NOT NULL ENABLE,\n\t\"F_PARTNER\" VARCHAR2(45 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_SALESMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_DELETED_TAG\" NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_MODIFIED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_MODIFIED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_VERSION\" NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,\n\t CONSTRAINT \"T_CUSTOMER_HISTORY_PK\" PRIMARY KEY (\"F_ID\", \"F_VERSION\")\n);\n\n--客户信息历史表\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CODE\" IS '客户编码';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_FULL_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_TELEPHONE\" IS '联系固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CITY\" IS '城市';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_BALANCE\" IS '余额';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_PARTNER\" IS '所属合作伙伴';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_SALESMAN\" IS '业务员';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_DELETED_TAG\" IS '删除标志，0：可用，1：已删除';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MODIFIED_ID\" IS '最后修改人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MODIFIED_TIME\" IS '最后修改时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_VERSION\" IS '版本号';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_CUSTOMER_HISTORY\"  IS '客户信息历史表';\n\n--审计表\nCREATE TABLE \"AUDITTEST\".\"T_AUDIT\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_TABLE_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_ROW_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NEW_VERSION\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_COLUMN_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_OLD_VALUE\" VARCHAR2(200 BYTE),\n\t\"F_NEW_VALUE\" VARCHAR2(200 BYTE),\n\t\"F_OPERATOR_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_OPERATION_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t CONSTRAINT \"T_AUDIT_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_TABLE_NAME\" IS '表名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_ROW_ID\" IS '业务数据主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_NEW_VERSION\" IS '新的版本号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_COLUMN_NAME\" IS '字段';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OLD_VALUE\" IS '原值';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_NEW_VALUE\" IS '新值';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OPERATOR_ID\" IS '操作用户';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OPERATION_TIME\" IS '操作时间';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_AUDIT\"  IS '审计表';\n```\n\n### 创建索引、序列\n\n```plsql\n-- 创建复合索引\nCREATE INDEX \"AUDITTEST\".\"IDX_TABLE_ROWID\" ON \"AUDITTEST\".\"T_AUDIT\" (\"F_TABLE_NAME\", \"F_ROW_ID\") ;\n-- 创建序列\nCREATE SEQUENCE  SEQ_AUDIT_PK  INCREMENT BY 1 START WITH 1;\n```\n\n### 创建触发器\n\n```plsql\n--创建触发器\ncreate or replace trigger trg_customer_audit\nbefore update on t_customer\nfor each row\ndeclare\n    c_insert_sql constant varchar2(100) := 'insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)';\n    c_table_name constant varchar2(20)  := 'T_CUSTOMER';\n    v_column_name varchar2(20);\nbegin\n    --记录当前数据到历史表\n    insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version);\n\n    --递增记录的版本号\n    :new.f_version := :old.f_version+1;\n\n    --判断字段变化\n    if updating('F_LINKMAN') then\n        v_column_name := '联系人';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id;\n    end if;\n\n    if updating('F_MOBILE') then\n        v_column_name := '手机号码';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id;\n    end if;\n\n    if updating('F_TELEPHONE') then\n        v_column_name := '固定电话';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id;\n    end if;\n\n    if updating('F_EMAIL') then\n        v_column_name := '电子邮箱';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id;\n    end if;\n\n    if updating('F_ADDRESS') then\n        v_column_name := '联系地址';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id;\n    end if;\n\n    if updating('F_BALANCE') then\n        v_column_name := '余额';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id;\n    end if;\nend;\n/\n\n--创建过程\n--过程：重设序列值\ncreate or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )\nIS\n    v_val NUMBER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY -' || v_val ||' MINVALUE 0';\n\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY 1 MINVALUE 0';\nend;\n/\n```\n\n### 创建过程\n\n#### 过程reset_seq\n\n> 将序列为输入参数seq_name的值重置\n\n```plsql\n--过程：重设序列值\ncreate or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )\nIS\n    v_val NUMBER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY -' || v_val ||' MINVALUE 0';\n\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY 1 MINVALUE 0';\nend;\n/\n```\n\n#### 过程init\n\n> truncate(截断)所有表，重设序列，并添加初始值\n>\n> 注意：\n>\n> **`truncate`与`delete`的区别**：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。\n>\n> truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。\n>\n> 但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例：\n>\n> ```plsql\n> -- 创建表，f_id字段引用T_TEST的主码id\n> drop table T_TEST2;\n> create table T_TEST2(\n>   id1 int primary key ,\n>   f_id int,\n>   constraint fk\n>   foreign key (f_id)\n>     references T_TEST(id) on delete cascade\n> );\n> select *\n> from T_TEST2;\n> insert into T_TEST2 values(1, 1);\n> -- 可级联删除\n> delete from T_TEST;\n> -- 将外码置为禁用\n> alter table T_TEST2 modify constraint fk disable validate ;\n> -- 可截断（当不禁用外码时无法截断）\n> truncate table T_TEST;\n> ```\n>\n> 可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。\n\n```plsql\n--过程：数据初始化\ncreate or replace procedure init is\nbegin\n    --清除数据\n    execute immediate 'truncate table t_audit';\n    execute immediate 'truncate table t_customer_history';\n    execute immediate 'truncate table t_customer';\n    execute immediate 'truncate table t_user';\n    execute immediate 'truncate table t_department';\n    --重调序列\n    reset_seq('seq_audit_pk');\n\n    --插入部门\n    insert into t_department values(1,'销售部','D01',NULL,'李明','备注1...');\n    insert into t_department values(2,'销售部-北京分部','D0101',1,'赵军','备注2...');\n    insert into t_department values(3,'销售部-上海分部','D0102',1,'张华','备注3...');\n    insert into t_department values(4,'销售部-深圳分部','D0103',1,'王兵','备注4...');\n\n    --插入用户\n    insert into t_user values(1,1,'仲芳芳','U8201','女','13771234101','02131231011','use1@samtech.com','备注1...');\n    insert into t_user values(2,1,'李明申','U8202','男','13771234102','02131231012','use2@samtech.com','备注2...');\n    insert into t_user values(3,2,'张雪', 'U8203','女','13771234103','02131231013','use3@samtech.com','备注3...');\n    insert into t_user values(4,2,'王刚', 'U8204','男','13771234104','02131231014','use4@samtech.com','备注4...');\n    insert into t_user values(5,3,'赵昌日','U8205','男','13771234105','02131231015','use5@samtech.com','备注5...');\n    insert into t_user values(6,3,'孙晓华','U8206','男','13771234106','02131231016','use6@samtech.com','备注6...');\n    insert into t_user values(7,4,'陈亚男','U8207','女','13771234107','02131231017','use7@samtech.com','备注7...');\n    insert into t_user values(8,4,'刘兵超','U8208','男','13771234108','02131231018','use8@samtech.com','备注8...');\n\n    --插入客户\n    insert into t_customer\n    values(1,'C1808001','上海市永辉电子股份有限公司','张明升','15352678121','02135681589','ming@google.com','上海市静安区城区安泰路1108号','上海市',12082,'上海中远','备注...','张娜',0,1,sysdate,1,sysdate,1);\n    commit;\nend;\n/\n```\n\n#### 修改客户信息过程\n\n```plsql\n--过程：修改客户地址\ncreate or replace procedure modify_address\n(p_row_id in number,p_address in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_address,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated address successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户余额\ncreate or replace procedure modify_balance\n(p_row_id in number,p_balance in number, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_balance,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated balance successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户电子邮箱\ncreate or replace procedure modify_email\n(p_row_id in number,p_email in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_email,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated email successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户联系人\ncreate or replace procedure modify_linkman\n(p_row_id in number,p_linkman_name in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_linkman_name,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated linkman name successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户联系人信息\ncreate or replace procedure modify_linkman_info\n(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2,\n p_telephone in varchar2,p_email in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_linkman=:1, f_mobile=:2,\n    f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6'\n    using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated linkman info successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改联系手机\ncreate or replace procedure modify_mobile\n(p_row_id in number,p_mobile in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_mobile,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated mobile successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改联系固话\ncreate or replace procedure modify_telephone\n(p_row_id in number,p_telephone in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_telephone,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated mobile successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n```\n\n### 执行\n\n```plsql\n-- 初始化\ncall init();\n\n-- 更改客户信息\nbegin\n\tmodify_linkman(1,'李明顺',1);\n\tdbms_lock.sleep(1);\n\tmodify_mobile(1,'13771083211',2);\n\tdbms_lock.sleep(1);\n\tmodify_balance(1,20020,3);\n\tdbms_lock.sleep(1);\n\tmodify_address(1,'中国上海市嘉定区xxx路',4);\n\tdbms_lock.sleep(1);\n\tmodify_email(1,'test1@163.com',5);\n\tdbms_lock.sleep(1);\n\tmodify_telephone(1,'02183652145',6);\n\tdbms_lock.sleep(1);\n\tmodify_linkman_info(1,'张雨轩','15332892301','02188881111','zhangyx@gmail.com',7);\nend;\n/\n\n-- 审计\nselect * from T_AUDIT;\n\n-- 回滚客户信息\n-- 方法1：\nupdate t_customer a\nset(\na.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,\na.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,\na.f_modified_id,a.f_modified_time\n)\n=\n(\nselect b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,\nb.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,\nb.f_deleted_tag,5,sysdate\nfrom t_customer_history b where b.f_id=a.f_id and b.f_version=3\n)\nwhere a.f_id=1;\n-- 方法2：\nmerge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)\nwhen matched then\nupdate set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,\na.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,\na.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;\n\n-- 查看验证数据\nselect * from t_customer where f_id=1\nunion\nselect * from t_customer_history where f_id=1 and f_version=3;\n```\n\n# Lesson 3\n\n## 创建用户并分配权限\n\n### 创建用户\n\n```plsql\ncreate user permission identified by permission;\n```\n\n### 分配权限\n\n```plsql\ngrant connect,resource to permission;\nalter user permisson quota unlimited on users;\nconn permission/permission;\n```\n\n## 创建表及其他对象\n\n### 方案一\n\n> 方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。\n\n#### 创建表\n\n```plsql\n\n--方案一\n--部门表\nCREATE TABLE T_DEPARTMENT\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_PARENT_ID\" NUMBER(6,0),\n\t\"F_MANAGER_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_DEPARTMENT_PK\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_MANAGER_ID\" IS '部门经理';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_DEPARTMENT\"  IS '部门表';\n\n--用户表\nCREATE TABLE \"T_USER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n\t\"F_MOBILE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(50 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_USER_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_USER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_USER\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"T_USER\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"T_USER\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"T_USER\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"T_USER\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"T_USER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_USER\"  IS '用户表';\n\n--客户信息表\nCREATE TABLE \"T_CUSTOMER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON TABLE \"T_CUSTOMER\"  IS '客户信息表';\n```\n\n#### 创建过程\n\n##### 初始化\n\n```plsql\n--过程：数据初始化\nCREATE OR REPLACE PROCEDURE INIT IS\nBEGIN\n    --清除数据\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_CUSTOMER';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_DEPARTMENT';\n\n    --插入部门\n    INSERT INTO T_DEPARTMENT VALUES(1,'公司',NULL,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(2,'行政部',1,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(3,'销售部',1,2,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(4,'电销组',3,3,'销售部电销组');\n    INSERT INTO T_DEPARTMENT VALUES(5,'推销组',3,6,'销售部推销组');\n\n    --插入用户\n    INSERT INTO T_USER VALUES(1,1,'管理员','男','13771234101','USE1@SAMTECH.COM','系统管理员');\n    INSERT INTO T_USER VALUES(2,3,'李明申','男','13771234102','USE2@SAMTECH.COM','销售部经理');\n    INSERT INTO T_USER VALUES(3,4,'张雪', '女','13771234103','USE3@SAMTECH.COM','销售部电销组主管');\n    INSERT INTO T_USER VALUES(4,4,'王刚', '男','13771234104','USE4@SAMTECH.COM','销售部电销组业务员1');\n    INSERT INTO T_USER VALUES(5,4,'赵昌日','男','13771234105','USE5@SAMTECH.COM','销售部电销组业务员2');\n    INSERT INTO T_USER VALUES(6,5,'孙晓华','男','13771234106','USE6@SAMTECH.COM','销售部推销组主管');\n    INSERT INTO T_USER VALUES(7,5,'陈亚男','女','13771234107','USE7@SAMTECH.COM','销售部推销组业务员3');\n    INSERT INTO T_USER VALUES(8,5,'刘兵超','男','13771234108','USE8@SAMTECH.COM','销售部推销组业务员4');\n    INSERT INTO T_USER VALUES(9,3,'陈彬','女','13771234109','USE9@SAMTECH.COM','销售部业务员X1');\n    INSERT INTO T_USER VALUES(10,3,'王军','男','13771234110','USE10@SAMTECH.COM','销售部业务员X2');\n\n    --插入客户\n    INSERT INTO T_CUSTOMER VALUES(1,'上海市永辉电子股份有限公司'     ,'张明升','15352678121','MING1@GOOGLE.COM','上海市静安区城区安泰路1108号','电销组主管创建',3,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(2,'上海博运汽车销售有限公司'      ,'朱荣荣' ,'13231289212','MING2@GOOGLE.COM','上海市徐汇区钦江路256号','电销组业务员1创建',4,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(3,'安徽广宏顶管装备制造有限公司'   ,'邱阳阳' ,'15328921231','MING3@GOOGLE.COM','安徽省广德县经济开发区东纬路5号','电销组业务员2创建',5,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(4,'上海定丰霖贸易有限公司'        ,'赵兰'  ,'15532212322','MING4@GOOGLE.COM','上海市浦东新区东延路112号408室','推销组主管创建',6,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(5,'上海东俊科技有限公司'          ,'张军'  ,'15367823660','MING5@GOOGLE.COM','上海市长宁区王安路135号','推销组业务员1创建',7,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(6,'中科创客（深圳）智能工业设备公司','李明'  ,'17723180234','MING6@GOOGLE.COM','深圳市龙岗区富民工业园致康路301号','推销组业务员2创建',8,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(7,'南宁云讯科技有限公司'          ,'王永成','13568932166','MING7@GOOGLE.COM','广东省深圳市福田区长川路102号','销售部业务员X1创建',9,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(8,'沈阳优速家政服务有限公司'       ,'李东升','13392312343','MING8@GOOGLE.COM','辽宁省沈阳市铁西区北二路青年易居东门32号','销售部业务员X2创建',10,SYSDATE);\n    COMMIT;\nEND;\n/\n```\n\n#### 执行\n\n##### 初始化\n\n```\nset serveroutput on;\nexec init;\n```\n\n##### 查询自己的客户\n\n```plsql\nSELECT * FROM t_customer A WHERE A.f_created_id=&id;\n```\n\n> `&id`是所查询人员的ID\n\n##### 查询某领导下属人员的所有客户\n\n```plsql\nselect * from t_user a  where exists(\nSELECT 1 FROM t_department b\nWHERE a.f_dept_id=b.f_id and b.f_manager_id=&id\nCONNECT BY b.F_PARENT_ID = PRIOR b.F_ID\nstart with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&id));\n```\n\n> `&id`是该领导的ID\n\n#### 当部门结构或员工归属调整时，权限编码如何处理？\n\n对于方案一，只需要更改员工直属领导ID即可\n\n### 方案二\n\n> 方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可\n\n#### 创建表\n\n```plsql\n--方案二\n--部门表\nCREATE TABLE T_DEPARTMENT_2\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n    \"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_PARENT_ID\" NUMBER(6,0),\n \"F_MANAGER_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_REMARK\" VARCHAR2(200 BYTE),\n  CONSTRAINT \"T_DEPARTMENT_PK2\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_CODE\" IS '部门编码';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_MANAGER_ID\" IS '部门经理';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_DEPARTMENT_2\"  IS '部门表2';\n\n--用户表\nCREATE TABLE \"T_USER_2\"\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n    \"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n \"F_MOBILE\" VARCHAR2(20 BYTE),\n \"F_EMAIL\" VARCHAR2(50 BYTE),\n \"F_REMARK\" VARCHAR2(200 BYTE),\n  CONSTRAINT \"T_USER_PK2\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_USER_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_CODE\" IS '用户编码';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_USER_2\"  IS '用户表2';\n\n--客户信息表\nCREATE TABLE \"T_CUSTOMER_2\"\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n \"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n \"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n \"F_EMAIL\" VARCHAR2(60 BYTE),\n \"F_ADDRESS\" VARCHAR2(200 BYTE),\n \"F_REMARK\" VARCHAR2(200 BYTE),\n    \"F_ACCESS_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n  PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ACCESS_CODE\" IS '权限编码';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON TABLE \"T_CUSTOMER_2\"  IS '客户信息表2';\n\n-- 创建人员更改历史表\nCREATE TABLE T_USER_HISTORY(\n  ID NUMBER(6,0) PRIMARY KEY ,\n  F_ID NUMBER(6,0) ,\n  O_DEP_ID NUMBER(6,0) ,\n  O_ACCESS_CODE VARCHAR2(50 BYTE) ,\n  N_DEP_ID  NUMBER(6,0),\n  N_ACCESS_CODE VARCHAR2(50 BYTE),\n  TIME DATE\n);\n\nCOMMENT ON COLUMN T_USER_HISTORY.ID IS 'PK';\nCOMMENT ON COLUMN T_USER_HISTORY.F_ID IS '修改的人员ID';\nCOMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS '旧的部门';\nCOMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS '旧的权限';\nCOMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS '新的部门';\nCOMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS '新的权限';\nCOMMENT ON TABLE T_USER_HISTORY IS '用户权限更改历史';\n```\n\n#### 创建过程\n\n##### 初始化\n\n```plsql\n--过程：数据初始化\nCREATE OR REPLACE PROCEDURE INIT2 IS\nBEGIN\n    --清除数据\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_CUSTOMER_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_DEPARTMENT_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER_HISTORY';\n\n    --插入部门\n    INSERT INTO T_DEPARTMENT_2 VALUES(1,'公司','1',NULL,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(2,'行政部','101',1,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(3,'销售部','102',1,2,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(4,'电销组','10201',3,3,'销售部电销组');\n    INSERT INTO T_DEPARTMENT_2 VALUES(5,'推销组','10202',3,6,'销售部推销组');\n\n    --插入用户\n    INSERT INTO T_USER_2 VALUES(1,1,'管理员','1','男','13771234101','USE1@SAMTECH.COM','系统管理员');\n    INSERT INTO T_USER_2 VALUES(2,3,'李明申','102','男','13771234102','USE2@SAMTECH.COM','销售部经理');\n    INSERT INTO T_USER_2 VALUES(3,4,'张雪',  '10201', '女','13771234103','USE3@SAMTECH.COM','销售部电销组主管');\n    INSERT INTO T_USER_2 VALUES(4,4,'王刚',  '1020101', '男','13771234104','USE4@SAMTECH.COM','销售部电销组业务员1');\n    INSERT INTO T_USER_2 VALUES(5,4,'赵昌日','1020102','男','13771234105','USE5@SAMTECH.COM','销售部电销组业务员2');\n    INSERT INTO T_USER_2 VALUES(6,5,'孙晓华','10202','男','13771234106','USE6@SAMTECH.COM','销售部推销组主管');\n    INSERT INTO T_USER_2 VALUES(7,5,'陈亚男','1020201','女','13771234107','USE7@SAMTECH.COM','销售部推销组业务员3');\n    INSERT INTO T_USER_2 VALUES(8,5,'刘兵超','1020202','男','13771234108','USE8@SAMTECH.COM','销售部推销组业务员4');\n    INSERT INTO T_USER_2 VALUES(9,3,'陈彬',  '10203','女','13771234109','USE9@SAMTECH.COM','销售部业务员X1');\n    INSERT INTO T_USER_2 VALUES(10,3,'王军', '10204','男','13771234110','USE10@SAMTECH.COM','销售部业务员X2');\n\n    --插入客户\n    INSERT INTO T_CUSTOMER_2 VALUES(1,'上海市永辉电子股份有限公司'     ,'张明升','15352678121','MING1@GOOGLE.COM','上海市静安区城区安泰路1108号','电销组主管创建','10201',3,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(2,'上海博运汽车销售有限公司'      ,'朱荣荣' ,'13231289212','MING2@GOOGLE.COM','上海市徐汇区钦江路256号','电销组业务员1创建','1020101',4,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(3,'安徽广宏顶管装备制造有限公司'   ,'邱阳阳' ,'15328921231','MING3@GOOGLE.COM','安徽省广德县经济开发区东纬路5号','电销组业务员2创建','1020102',5,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(4,'上海定丰霖贸易有限公司'        ,'赵兰'  ,'15532212322','MING4@GOOGLE.COM','上海市浦东新区东延路112号408室','推销组主管创建','10202',6,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(5,'上海东俊科技有限公司'          ,'张军'  ,'15367823660','MING5@GOOGLE.COM','上海市长宁区王安路135号','推销组业务员1创建','1020201',7,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(6,'中科创客（深圳）智能工业设备公司','李明'  ,'17723180234','MING6@GOOGLE.COM','深圳市龙岗区富民工业园致康路301号','推销组业务员2创建','1020202',8,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(7,'南宁云讯科技有限公司'          ,'王永成','13568932166','MING7@GOOGLE.COM','广东省深圳市福田区长川路102号','销售部业务员X1创建','10203',9,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(8,'沈阳优速家政服务有限公司'       ,'李东升','13392312343','MING8@GOOGLE.COM','辽宁省沈阳市铁西区北二路青年易居东门32号','销售部业务员X2创建','10204',10,SYSDATE);\n    COMMIT;\nEND;\n/\n```\n\n##### 将某员工调换到某部门\n\n![image-20181126025537963](/images/image-20181126025537963.png)\n\n```plsql\n-- 更改用户到特定部门\nCREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS\n  -- 旧部门\n  O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE;\n  -- 旧权限\n  O_ACCESS_CODE T_USER_2.F_CODE%TYPE;\n  -- 部门权限前缀\n  DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE;\n  -- 部门当前人数\n  DEP_USER_COUNT T_USER_2.F_CODE%TYPE;\n  -- 本部门下的部门数\n  DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE;\n  -- 新权限\n  N_ACCESS_CODE T_USER_2.F_CODE%TYPE;\n  -- 更新该员工权限\n  C_UPDATE_USER VARCHAR2(100) := 'UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3';\n  -- 更新所有该员工的客户的ACCESS权限\n  C_UPDATE_CUSTOMER VARCHAR2(100) := 'UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2';\n  -- 插入一条修改记录\n  C_INSERT_HISTORY VARCHAR2(100) := 'INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)';\n  BEGIN\n    -- 旧部门\n    SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;\n    -- 旧权限\n    SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;\n    -- 新部门权限作为前缀\n    SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID;\n    -- 计算该部门人员数量\n    SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID;\n    -- 计算子部门数量\n    SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2;\n    -- 若新部门与旧部门相同，无需更改\n    IF N_DEP_ID=O_DEP_ID THEN\n      RETURN;\n    END IF;\n    -- 新权限CODE\n    IF DEP_DEP_COUNT > DEP_USER_COUNT THEN\n      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1);\n    ELSE\n      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1);\n    end if;\n    -- 输出相关变量\n    dbms_output.put_line('DEP_USER_COUNT : ' || DEP_USER_COUNT);\n    dbms_output.put_line('DEP_DEP_COUNT : ' || DEP_DEP_COUNT);\n    -- 输出相关变量\n    dbms_output.put_line('DEP_ACCESS_CODE_PREFIX : ' || DEP_ACCESS_CODE_PREFIX);\n    dbms_output.put_line('C_F_ID : ' || C_F_ID);\n    dbms_output.put_line('O_ACCESS_CODE : ' || O_ACCESS_CODE);\n    dbms_output.put_line('N_DEP_ID : ' || N_DEP_ID);\n    dbms_output.put_line('N_ACCESS_CODE : ' || N_ACCESS_CODE);\n    -- 更新该员工权限\n    EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID;\n    -- 更新所有该员工的客户的ACCESS权限\n    EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID;\n    -- 插入一条修改记录\n    EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE;\n    -- 提交\n    COMMIT;\n  END;\n  /\n```\n\n#### 创建序列\n\n```plsql\n-- 员工部门历史记录主码序列\nCREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1;\n```\n\n#### 执行\n\n```plsql\nselect * from t_customer_2 where f_access_code like 'xxx%';\n```\n\n> `xxx%`指匹配所有以`xxx`开头的权限码\n\n#### 当部门结构或员工归属调整时，权限编码如何处理？\n\n方案二中，调用新增的过程`CHANGE_TO_DEPARTMENT`即可级联更改权限码。\n","source":"_posts/Practice.md","raw":"---\ntitle: 内存数据库 - Best Practice\ndate: 2018-11-24 14:18:44\ntags:\n    - TimesTen\n    - 内存数据库\ncategories:\n    - 数据库\n---\n\n> Oracle专家的三次授课笔记及Best Practice记录。\n\n<!--more-->\n\n# Lesson 1\n\n## 创建用户并分配权限\n\n### 创建测试schema，命名为test\n\n```plsql\ncreate user test identified by test;\n```\n\n### 分配连接资源\n\n```plsql\ngrant connect,resource to test;\ngrant execute on dbms_lock to test;\ngrant execute on UTL_FILE to test;\n```\n\n### 为test用户创建external_data目录以及分配权限\n\n```plsql\ncreate directory external_data as '/home/oracle/data';\ngrant read,write on directory external_data to test;\n```\n\n> 要注意oracle用户必须拥有对这里的external_data路径读写的权限。\n\n### 分配表空间权限\n\n我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间：\n\n- **SYSTEM** - 存储数据字典\n- **SYSAUX** - 存储辅助应用程序的数据\n- **TEMP** - 存储数据库临时对象\n- **USERS** - 存储各个用户创建的对象\n- **UNDOTBS** - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询\n- ……\n\n而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作：\n\n```plsql\n-- DBA下执行：\n-- 查看数据库中的所有表空间\nselect * from v$tablespace;\n-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)\nselect username,default_tablespace from dba_users where username='TEST';\n-- 为用户赋予当前表空间下的权限\nalter user test quota unlimited on users;\n--  或者制定用户可用大小：\nalter user test quota 50M on users;\n```\n\n\n\n## 连接用户，建表，跑存储过程和函数\n\n### 连接test用户\n\n```shell\n-- 在系统命令下连接\ncd $ORACLE_HOME/bin\n./sqlplus test/test\n```\n\n```plsql\n-- 在进入sqlplus后的连接\nconn test/test\n```\n\n### 创建表\n\n```plsql\ncreate table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));\nCOMMENT ON COLUMN T_MOBILES.F_ID IS '主键';\nCOMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS '手机号段';\nCOMMENT ON COLUMN T_MOBILES.F_PROVINCE IS '省份地区';\nCOMMENT ON COLUMN T_MOBILES.F_CITY IS '城市';\nCOMMENT ON COLUMN T_MOBILES.F_PLATFORM IS '运营商';\nCOMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS '固话区号';\nCOMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS '邮政编码';\nCOMMENT ON TABLE T_MOBILES  IS '号段表';\n\ncreate table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);\n--*注：因f_id导入时缺少数据，所有先不设置为PK.\nCOMMENT ON COLUMN T_RECORDS.F_ID IS '主键';\nCOMMENT ON COLUMN T_RECORDS.F_NO IS '通话号码';\nCOMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS '开始时间';\nCOMMENT ON COLUMN T_RECORDS.F_END_TIME IS '结束时间';\nCOMMENT ON COLUMN T_RECORDS.F_DURATION IS '通话时长';\nCOMMENT ON COLUMN T_RECORDS.F_PROVINCE IS '省份地区';\nCOMMENT ON COLUMN T_RECORDS.F_PLATFORM IS '运营商';\nCOMMENT ON COLUMN T_RECORDS.F_MOBILE IS '手机号码标志';\nCOMMENT ON TABLE T_RECORDS  IS '通话清单表';\n```\n\n### 创建ctl文件导入csv数据\n\n进入`external_data`路径下并创建以下文件：\n\n```shell\n$ cd /home/oracle/data\n$ vi control_mobiles.ctl\n$ vi control_records.ctl\n```\n\n`control_mobiles.ctl:`\n\n```ctl\nLOAD DATA\nCHARACTERSET UTF8\nINFILE '/home/oracle/data/mobiles.csv'\nTRUNCATE INTO TABLE t_mobiles\nFIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\nTRAILING NULLCOLS\n(\n\tF_ID,\n\tF_MOBILE_HEAD,\n\tF_PROVINCE,\n\tF_CITY,\n\tF_PLATFORM,\n\tF_TEL_HEAD,\n\tF_ZIPCODE\n)\n```\n\n`control_records.ctl:`\n\n```\nLOAD DATA\nCHARACTERSET UTF8\nINFILE '/home/oracle/data/records.csv'\nTRUNCATE INTO TABLE t_records\nFIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'\nTRAILING NULLCOLS\n(\n\tF_NO,\n\tF_BEGIN_TIME DATE \"YYYY-MM-DD HH24:MI:SS\",\n\tF_END_TIME DATE \"YYYY-MM-DD HH24:MI:SS\",\n\tF_DURATION INTEGER EXTERNAL\n)\n```\n\n在该路径下执行导入操作：\n\n```shell\n$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_mobiles.ctl\n$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_records.ctl\n```\n\n> 教程中命令为：\n>\n> ```shell\n> $ sqlldr userid=test/test@orcl control=control_mobiles.ctl\n> ```\n>\n> 即在导入时指定`连接字符串`（这里的orcl实际上是连接字符串的别名），其在`$ORACLE_HOME/network/admin/tnsname.ora`中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。\n>\n> 既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是`连接字符串`和`服务名`的区别，oracle有个默认服务名`XE`，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下：\n>\n> ```\n> jdbc:oracle:thin:@localhost:1521:XE\n> ```\n>\n> 那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全：\n>\n> ```shell\n> # 命令格式：sqlplus username/password@host:port/service_name\n> $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe\n> ```\n>\n\n\n\n## 数据预处理\n\n```plsql\n-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键\ncreate sequence seq_records increment by 1 start with 1 ;\n\n-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键\nupdate t_records set f_id=seq_records.nextval;\nalter table t_records add constraint t_records_pk primary key (f_id);\n\n-- 3、创建并初始化同步锁表，用于多线程同步控制\nCREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));\nCOMMENT ON COLUMN T_LOCK.F_NAME IS '锁名';\nCOMMENT ON COLUMN T_LOCK.F_INDEX IS '锁的当前值';\nCOMMENT ON TABLE T_LOCK  IS '同步锁表';\ninsert into T_LOCK values('_RECORD_INDEX',0);\n\n-- 4、在电话号段表中创建唯一性索引，提高号段检索速度\ncreate unique index uniq_mobile_head on t_mobiles(f_mobile_head);\nupdate t_mobiles set f_province = '内蒙古' where f_province = '内蒙';\n\n-- 5、创建日志表，用于记录程序执行过程中的日志信息。\ncreate table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));\nCOMMENT ON COLUMN T_LOG.F_TIME IS '日志时间';\nCOMMENT ON COLUMN T_LOG.F_HEAD IS '日志类型标志';\nCOMMENT ON COLUMN T_LOG.F_CONTENT IS '日志内容';\nCOMMENT ON TABLE T_LOG  IS '日志表';\n```\n\n\n\n## 创建函数和存储过程\n\n### 声明函数和存储过程\n\n- 函数is_mobile，判断通话号码是否为手机号码\n\n```plsql\n--函数：判断通话号码是否为手机号码\nCREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2)\n    RETURN BOOLEAN IS\n\n    v_phone VARCHAR2(20);\n    v_head VARCHAR2(2);\nBEGIN\n    --检查参数func\n    IF phone IS NULL THEN\n        RETURN FALSE;\n    END IF;\n\n\t--去除前后空格\n    v_phone := TRIM(phone);\n\n\t--去除号码前面的0\n    IF substr(v_phone,0,1) = '0' THEN\n        v_phone := substr(v_phone, 2);\n    END IF;\n\n\t--检查手机号码长度\n    IF substr(v_phone,0,1) <> '1' OR LENGTH(v_phone) <> 11 THEN\n        RETURN FALSE;\n    END IF;\n\n\t--截取号码前两位\n    v_head := substr(v_phone,1,2);\n\n    IF v_head = '13' OR v_head = '14' OR v_head ='15' OR v_head ='17' OR v_head = '18' THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n/\n```\n\n- 存储过程init，清空t_log，同时t_lock置零\n\n```plsql\n--存储过程：初始化测试数据\nCREATE OR REPLACE PROCEDURE init IS\n    CURSOR job_cursor IS SELECT JOB FROM user_jobs;\nBEGIN\n\t--重置处理位置为0\n    EXECUTE IMMEDIATE 'update t_lock set f_index=0';\n\n\t--清除日志表中的记录\n    EXECUTE IMMEDIATE 'truncate table t_log';\n\n\t--重置话单表中的记录\n    EXECUTE IMMEDIATE 'update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1';\n    COMMIT;\n\n    FOR tmp_job IN job_cursor LOOP\n        dbms_job.broken(tmp_job.JOB,TRUE,sysdate);\n        dbms_job.REMOVE(tmp_job.JOB);\n    END LOOP;\nEND;\n/\n```\n\n- 存储过程print，打印日志，存到T_LOG表中\n\n```plsql\n--存储过程：打印日志\nCREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) IS\nBEGIN\n\t--dbms_output.put_line(to_char('yyyy-mm-dd hh24:mi:ss')||','||prefix||','||content);\n\tINSERT INTO t_log VALUES(sysdate,prefix, content);\n\tCOMMIT;\nEXCEPTION\n\tWHEN OTHERS THEN\n\t\tdbms_output.put_line('Error code: '||SQLCODE);\n\t\tdbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程show，显示当前处理情况\n\n```plsql\n--存储过程：显示当前处理情况\nCREATE OR REPLACE PROCEDURE show IS\n\t--待处理记录总数\n    v_record_count NUMBER;\n\n\t--当前日志表记录总数\n    v_log_count NUMBER;\n\n\t--当前数据处理位置\n    v_current_index NUMBER;\n\n\t--用户Job表游标\n    CURSOR job_cursor IS SELECT * FROM user_jobs;\n\nBEGIN\n    SELECT COUNT(1) INTO v_log_count FROM t_log;\n    SELECT f_index INTO v_current_index FROM t_lock;\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n\n\tdbms_output.put_line('log count: '||v_log_count);\n    dbms_output.put_line('record count: '||v_record_count);\n    dbms_output.put_line('current index: '||v_current_index);\n\n\t--清除用户job记录\n    FOR tmp_job IN job_cursor LOOP\n        dbms_output.put_line('job:'||tmp_job.JOB||',broken:'||tmp_job.broken||',total_time:'||tmp_job.total_time||',failures:'||tmp_job.failures||',interval:'||tmp_job.INTERVAL||',last_sec:'||tmp_job.last_sec||',next_sec:'||tmp_job.next_sec);\n\n    END LOOP;\nEND;\n/\n```\n\n- 存储过程process_data，提交一个job处理数据\n\n> **共享锁和排它锁:**\n>\n> - 当某事务对数据添加共享锁时，此时该事务`只能读不能写`，其他事务只能对该数据添加共享锁，而不能添加排它锁\n>\n> - 当某事务对数据添加排它锁时，此时该事务`既能读又能写`，其他事务不能对该数据添加任何锁\n>\n> **autocommit需要关掉:**\n>\n>\n> 假设现在有三个job对T_LOCK表进行并发读写，如下：\n>\n> ![image-20181124202306595](/images/image-20181124202306595.png)\n>\n> 步骤如下：\n>\n> ![锁](/images/锁.png)\n>\n> 阻塞情况：\n>\n> ![锁2](/images/锁2.png)\n\n```plsql\n--存储过程：处理数据\nCREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS\n    --定义常量\n    c_record_index CONSTANT VARCHAR2(20)   :='_RECORD_INDEX';\n    c_process_prefix CONSTANT VARCHAR2(20) := '[  PROCESS ]';\n    c_select_record_sql VARCHAR2(100)  := 'select * from t_records where f_id >= :x and f_id <= :y';\n    c_select_mobile_sql VARCHAR2(100)  := 'select * from t_mobiles where f_mobile_head = :x';\n    c_update_mobile_sql VARCHAR2(100)  := 'update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z';\n    c_update_record_sql VARCHAR2(100)  := 'update t_records set f_mobile = 0 where f_id = :n';\n    v_record_count NUMBER;\n    v_current_index NUMBER;\n    v_begin_index NUMBER;\n    v_end_index NUMBER;\n    v_id NUMBER;\n    v_phone VARCHAR2(20);\n    v_province VARCHAR2(20);\n    v_platform VARCHAR2(20);\n    --定义动态游标\n    TYPE ty_record_cursor IS REF CURSOR;\n    record_cursor ty_record_cursor;\n    mobile_cursor ty_record_cursor;\n    v_record_row t_records%rowtype;\n    v_mobile_row t_mobiles%rowtype;\nBEGIN\n    PRINT(c_process_prefix, 'process['||process_no||'], running...');\n    --获取待处理的记录总数\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n    PRINT(c_process_prefix, 'process['||process_no||'], records count: '||v_record_count);\n    LOOP\n        --获取记录锁\n        SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE;\n        PRINT(c_process_prefix, 'process['||process_no||'], current index: '||v_current_index);\n        IF v_current_index = v_record_count THEN\n            PRINT(c_process_prefix, 'process['||process_no||'], finished.');\n            EXIT;\n        END IF;\n        --记录本次处理的开始和结束记录位置\n        v_end_index := v_current_index + batch_size;\n        IF v_end_index > v_record_count THEN\n            v_end_index := v_record_count;\n        END IF;\n        --提交事务，释放锁\n        UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index;\n        COMMIT;\n        --计算开始位置\n        v_begin_index := v_current_index +1;\n        PRINT(c_process_prefix, 'process['||process_no||'], begin index:'||v_begin_index||', end index:'||v_end_index);\n        --test：dbms_lock.sleep(5);\n        --查询一批记录进行逐个处理\n        OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index;\n        LOOP\n            FETCH record_cursor INTO v_record_row;\n            EXIT WHEN record_cursor%notfound;\n            v_id    := v_record_row.f_id;\n            v_phone := v_record_row.f_no;\n            IF is_mobile(v_phone) THEN\n                v_phone := TRIM(v_phone);\n                IF substr(v_phone,0,1) = '0' THEN\n                    v_phone := substr(v_phone, 2);\n                END IF;\n                --PRINT(c_process_prefix, 'process['||process_no||'], id:'||v_id||', phone:'||v_phone);\n                --更新话单记录中的省份、运营商以及手机类型标志\n                OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7);\n                    FETCH mobile_cursor INTO v_mobile_row;\n                    v_province := v_mobile_row.f_province;\n                    v_platform := v_mobile_row.f_platform;\n                    --FETCH mobile_cursor INTO v_province, v_platform;\n                CLOSE mobile_cursor;\n\t\t\t\t--更新话单记录的运营商、省份地区信息\n                EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id;\n            ELSE\n                --更新话单记录为非移动号码类型\n                EXECUTE IMMEDIATE c_update_record_sql USING v_id;\n            END IF;\n\t\t\t--提交事务\n            COMMIT;\n        END LOOP;\n        CLOSE record_cursor;\n        PRINT(c_process_prefix, 'process['||process_no||'], processed index: '||v_end_index);\n    END LOOP;\nEXCEPTION\n    WHEN OTHERS THEN\n        dbms_output.put_line('Error code: '||SQLCODE);\n        dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程generate_csv_report，生成报表\n\n```plsql\n--存储过程：生成报表\nCREATE OR REPLACE PROCEDURE generate_csv_report IS\n\tc_report_prefix CONSTANT VARCHAR2(20) := '[  REPORT  ]';\n    v_report_1  UTL_FILE.FILE_TYPE;\n    v_report_2  UTL_FILE.FILE_TYPE;\n    CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC;\n    cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;\nBEGIN\n    --生成报表1，根据运营商分类汇总各省份地区的通话量\n    v_report_1 := UTL_FILE.FOPEN( LOCATION => 'EXTERNAL_DATA', filename => 'report1.csv', open_mode => 'w', max_linesize => 32767);\n    FOR cur_tmp IN report_1_cursor LOOP\n        UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || ',' || cur_tmp.f_province || ',' || cur_tmp.total);\n    END LOOP;\n    UTL_FILE.FCLOSE(v_report_1);\n    --生成报表2，根据各省份地区汇总各运营商的通话量\n    v_report_2 := UTL_FILE.FOPEN( LOCATION => 'EXTERNAL_DATA', filename => 'report2.csv', open_mode => 'w', max_linesize => 32767);\n    FOR cur_tmp IN report_2_cursor LOOP\n        UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || ',' || cur_tmp.f_platform || ',' ||  cur_tmp.total);\n    END LOOP;\n    UTL_FILE.FCLOSE(v_report_2);\n    PRINT(c_report_prefix, 'generated reports.');\n    EXCEPTION\n        WHEN OTHERS THEN\n            dbms_output.put_line('Error code: '||SQLCODE);\n            dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量\n\n> **[dbms_job](https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_job.htm#BABHCBFD):**\n>\n> 用于管理job的package\n>\n> **oracle限定的job_queue_processes:**\n>\n> oracle中有一个对任务可启动进程的数量进行限制的参数：\n>\n> ```plsql\n> SQL> show parameter job_queue_processes;\n> NAME\t\t\t\t     TYPE\t VALUE\n> ----------------------------------------------------------\n> job_queue_processeses\t\t integer\t 10\n>\n> SQL> alter system set job_queue_processes=0...1000;\n> ```\n>\n> **使用ctrl+c是无法停止job的:**\n>\n> 可使用`top`命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号\n\n```plsql\nCREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS\n    --定义常量\n    c_record_index CONSTANT VARCHAR2(20)\t:='_RECORD_INDEX';\n\t  c_analysis_prefix CONSTANT VARCHAR2(20)\t:= '[ ANALYSIS ]';\n    --当前处理位置\n    v_record_index NUMBER;\n    --待处理的记录总数\n    v_record_count NUMBER;\n    --保存临时创建的job no\n    v_tmp_jobno NUMBER;\n    --开始结束时间\n    v_begin_time NUMBER;\n    v_process_end_time NUMBER;\n    v_analysis_end_time NUMBER;\n    --异常变量\n    e_invalid_input EXCEPTION;\nBEGIN\n    PRINT(c_analysis_prefix, ' start analysis...');\n    --输入参数检查\n    IF job_count < 1 OR batch_size<1 THEN\n        RAISE e_invalid_input;\n    END IF;\n    PRINT(c_analysis_prefix, ' checked input parameters.');\n    --记录开始时间\n    v_begin_time := dbms_utility.get_time;\n    --获取待处理的记录总数\n    SELECT COUNT(1) INTO v_record_count FROM t_records;\n    PRINT(c_analysis_prefix, ' records count: '||v_record_count);\n    --开始计算重置为0\n    UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index;\n    COMMIT;\n    PRINT(c_analysis_prefix, ' reset index to zero.');\n    --提交多个job\n    FOR I IN 1.. job_count LOOP\n        dbms_job.submit(v_tmp_jobno,'begin process_data('||I||','||batch_size||'); end;');\n        PRINT(c_analysis_prefix, ' submitted new job, no: '||v_tmp_jobno);\n    END LOOP;\n    PRINT(c_analysis_prefix, ' created '||job_count||' jobs.');\n    --定时检查处理进度\n    LOOP\n        SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index;\n        PRINT(c_analysis_prefix, ' current index: '||v_record_index);\n        IF v_record_index = v_record_count THEN\n            PRINT(c_analysis_prefix, ' processed all records, exiting...');\n            EXIT;\n        ELSE\n            dbms_lock.sleep(5);--暂停等待5秒\n        END IF;\n    END LOOP;\n    v_process_end_time := dbms_utility.get_time;\n    PRINT(c_analysis_prefix, 'process, elapsed time: '||(v_process_end_time-v_begin_time)/100||' seconds.');\n    dbms_output.put_line('process, elapsed time: '||(v_process_end_time-v_begin_time)/100||' seconds.');\n    --分类汇总产生报表\n    generate_csv_report;\n    --结束时间\n    v_analysis_end_time := dbms_utility.get_time;\n    PRINT(c_analysis_prefix, 'report, elapsed time: '||(v_analysis_end_time-v_process_end_time)/100||' seconds.');\n    dbms_output.put_line('report, elapsed time: '||(v_analysis_end_time-v_process_end_time)/100||' seconds.');\n--异常捕获部分\nEXCEPTION\n    WHEN e_invalid_input THEN\n        dbms_output.put_line('Invalid input values, job_count:'||job_count||', batch_size:'||batch_size);\n    WHEN OTHERS THEN\n        dbms_output.put_line('Error code: '||SQLCODE);\n        dbms_output.put_line('Error mesg: '||sqlerrm);\nEND;\n/\n```\n\n- 存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中\n\n```plsql\n-- 调用多次analysis，指定不同的job数和批数\ncreate or replace procedure mul_analysis is\n    -- 最小job数\n    v_begin_job_no NUMBER := 3;\n    -- 最大job数\n    v_end_job_no NUMBER := 8;\n    -- 每次增长的batch数量\n    v_range NUMBER := 2000;\n    -- 最小batch数量\n    v_begin_range NUMBER := 1000;\n    -- 最大batch数量\n    v_end_range NUMBER := 10000;\n    -- 当前range\n    range NUMBER;\n    begin\n        for I in v_begin_job_no..v_end_job_no LOOP\n            range := v_begin_range;\n            LOOP\n                -- 清洗表\n                init();\n                -- 分析\n                analysis(I, range);\n                range := range+v_range;\n\t\t\t\t-- range增长到10000则停止\n                if range > v_end_range then\n                    exit;\n                end if;\n            end loop;\n        end loop;\n    end;\n/\n```\n\n### 执行函数和存储过程\n\n> 在sqlplus中执行函数和存储过程之前需先打开serveroutput，即：\n>\n> ```plsql\n> SQL> set serveroutput on;\n> ```\n>\n> 这是因为存储过程中用到了`dbms_output.put_line`，上述语句是相当于告诉pl/sql引擎将`dbms_output.put_line`传递到缓冲区的内容输出到主控制台上。\n\n```\ncall init();\ncall analysis(4,1000);\n```\n\n\n\n## 结果分析\n\n通过执行`mul_analysis()`对一系列job和batch组合值进行测试，结果如下：\n\n![image-20181124205409162](/images/image-20181124205409162.png)\n\n\n# Lesson 2\n\n## 创建用户并分配权限\n\n### 创建用户\n\n```plsql\ncreate user audittest identified by audittest;\n```\n\n### 分配权限\n\n```plsql\ngrant connect,resource to audittest;\ngrant execute on dbms_lock to audittest;\nalter user audittest quota unlimited on users;\nconn audittest/audittest;\n```\n\n## 创建表及其他对象\n\n### 创建表\n\n> 注意：\n>\n> 这里在创建表时添加了`ENABLE`限制条件，oracle中对表和列的约束有`Enable`/`Disable`(启用/禁用)和`Validate`/`NoValidate`(验证/不验证)\n>\n> 举两个例子：\n>\n> **需更改的错误：**\n>\n> ```plsql\n> -- 创建表，对name字段添加唯一性约束\n> drop table T_TEST;\n> create table T_TEST(\n>   id int primary key ,\n>   name varchar2(10) constraint unique_name unique disable\n> );\n> -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错\n> begin\n>   insert into T_TEST values (1, 'tan');\n>   insert into T_TEST values (2, 'rui');\n>   insert into T_TEST values (3, 'tan');\n> end;\n> select * from T_TEST;\n> -- 修改掉违反唯一性约束的值\n> update T_TEST set name='chen' where id=3;\n> -- 使得唯一性约束生效\n> alter table T_TEST modify constraint unique_name enable;\n> select * from T_TEST;\n>\n> ```\n>\n> **需保留的错误：**\n>\n> ```plsql\n> -- 创建表，无约束\n> drop table T_TEST;\n> create table T_TEST(\n>   id int primary key ,\n>   name varchar2(10)\n> );\n> -- 一些old的记录本身可能存在重复数据\n> begin\n>   insert into T_TEST values (1, 'tan');\n>   insert into T_TEST values (2, 'rui');\n>   insert into T_TEST values (3, 'tan');\n> end;\n> select * from T_TEST;\n> -- 对name列创建非唯一性索引\n> create index i_name on T_TEST(name);\n> -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引\n> alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;\n> -- 此时无法插入name相同的数据了\n> insert into T_TEST values (4, 'tan');\n> ```\n\n```plsql\n--部门表\nCREATE TABLE \"AUDITTEST\".\"T_DEPARTMENT\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_PARENT_ID\" NUMBER(6,0),\n\t\"F_MANAGER\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_DEPARTMENT_PK\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_CODE\" IS '部门编号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_MANAGER\" IS '部门经理';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_DEPARTMENT\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_DEPARTMENT\"  IS '部门表';\n\n--用户表\nCREATE TABLE \"AUDITTEST\".\"T_USER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(20 BYTE),\n\t\"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n\t\"F_MOBILE\" VARCHAR2(20 BYTE),\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(50 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_USER_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_CODE\" IS '员工编号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_TELEPHONE\" IS '固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_USER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_USER\"  IS '用户表';\n\n--客户信息表\nCREATE TABLE \"AUDITTEST\".\"T_CUSTOMER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_FULL_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_CITY\" VARCHAR2(45 BYTE),\n\t\"F_BALANCE\" NUMBER(10,2) NOT NULL ENABLE,\n\t\"F_PARTNER\" VARCHAR2(45 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_SALESMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_DELETED_TAG\" NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_MODIFIED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_MODIFIED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_VERSION\" NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,\n\t PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CODE\" IS '客户编码';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_FULL_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_TELEPHONE\" IS '联系固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CITY\" IS '城市';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_BALANCE\" IS '余额';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_PARTNER\" IS '所属合作伙伴';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_SALESMAN\" IS '业务员';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_DELETED_TAG\" IS '删除标志，0：可用，1：已删除';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MODIFIED_ID\" IS '最后修改人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_MODIFIED_TIME\" IS '最后修改时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER\".\"F_VERSION\" IS '版本号';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_CUSTOMER\"  IS '客户信息表';\n\n--\nCREATE TABLE \"AUDITTEST\".\"T_CUSTOMER_HISTORY\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CODE\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_FULL_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_TELEPHONE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_CITY\" VARCHAR2(45 BYTE),\n\t\"F_BALANCE\" NUMBER(10,2) NOT NULL ENABLE,\n\t\"F_PARTNER\" VARCHAR2(45 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_SALESMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_DELETED_TAG\" NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_MODIFIED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_MODIFIED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t\"F_VERSION\" NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,\n\t CONSTRAINT \"T_CUSTOMER_HISTORY_PK\" PRIMARY KEY (\"F_ID\", \"F_VERSION\")\n);\n\n--客户信息历史表\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CODE\" IS '客户编码';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_FULL_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_TELEPHONE\" IS '联系固话';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CITY\" IS '城市';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_BALANCE\" IS '余额';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_PARTNER\" IS '所属合作伙伴';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_SALESMAN\" IS '业务员';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_DELETED_TAG\" IS '删除标志，0：可用，1：已删除';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MODIFIED_ID\" IS '最后修改人';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_MODIFIED_TIME\" IS '最后修改时间';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_CUSTOMER_HISTORY\".\"F_VERSION\" IS '版本号';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_CUSTOMER_HISTORY\"  IS '客户信息历史表';\n\n--审计表\nCREATE TABLE \"AUDITTEST\".\"T_AUDIT\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_TABLE_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_ROW_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NEW_VERSION\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_COLUMN_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_OLD_VALUE\" VARCHAR2(200 BYTE),\n\t\"F_NEW_VALUE\" VARCHAR2(200 BYTE),\n\t\"F_OPERATOR_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_OPERATION_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t CONSTRAINT \"T_AUDIT_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_ID\" IS '主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_TABLE_NAME\" IS '表名';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_ROW_ID\" IS '业务数据主键';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_NEW_VERSION\" IS '新的版本号';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_COLUMN_NAME\" IS '字段';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OLD_VALUE\" IS '原值';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_NEW_VALUE\" IS '新值';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OPERATOR_ID\" IS '操作用户';\nCOMMENT ON COLUMN \"AUDITTEST\".\"T_AUDIT\".\"F_OPERATION_TIME\" IS '操作时间';\nCOMMENT ON TABLE \"AUDITTEST\".\"T_AUDIT\"  IS '审计表';\n```\n\n### 创建索引、序列\n\n```plsql\n-- 创建复合索引\nCREATE INDEX \"AUDITTEST\".\"IDX_TABLE_ROWID\" ON \"AUDITTEST\".\"T_AUDIT\" (\"F_TABLE_NAME\", \"F_ROW_ID\") ;\n-- 创建序列\nCREATE SEQUENCE  SEQ_AUDIT_PK  INCREMENT BY 1 START WITH 1;\n```\n\n### 创建触发器\n\n```plsql\n--创建触发器\ncreate or replace trigger trg_customer_audit\nbefore update on t_customer\nfor each row\ndeclare\n    c_insert_sql constant varchar2(100) := 'insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)';\n    c_table_name constant varchar2(20)  := 'T_CUSTOMER';\n    v_column_name varchar2(20);\nbegin\n    --记录当前数据到历史表\n    insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version);\n\n    --递增记录的版本号\n    :new.f_version := :old.f_version+1;\n\n    --判断字段变化\n    if updating('F_LINKMAN') then\n        v_column_name := '联系人';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id;\n    end if;\n\n    if updating('F_MOBILE') then\n        v_column_name := '手机号码';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id;\n    end if;\n\n    if updating('F_TELEPHONE') then\n        v_column_name := '固定电话';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id;\n    end if;\n\n    if updating('F_EMAIL') then\n        v_column_name := '电子邮箱';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id;\n    end if;\n\n    if updating('F_ADDRESS') then\n        v_column_name := '联系地址';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id;\n    end if;\n\n    if updating('F_BALANCE') then\n        v_column_name := '余额';\n        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id;\n    end if;\nend;\n/\n\n--创建过程\n--过程：重设序列值\ncreate or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )\nIS\n    v_val NUMBER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY -' || v_val ||' MINVALUE 0';\n\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY 1 MINVALUE 0';\nend;\n/\n```\n\n### 创建过程\n\n#### 过程reset_seq\n\n> 将序列为输入参数seq_name的值重置\n\n```plsql\n--过程：重设序列值\ncreate or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )\nIS\n    v_val NUMBER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY -' || v_val ||' MINVALUE 0';\n\n    EXECUTE IMMEDIATE 'SELECT ' || seq_name || '.NEXTVAL FROM dual' INTO v_val;\n\n    EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || seq_name || ' INCREMENT BY 1 MINVALUE 0';\nend;\n/\n```\n\n#### 过程init\n\n> truncate(截断)所有表，重设序列，并添加初始值\n>\n> 注意：\n>\n> **`truncate`与`delete`的区别**：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。\n>\n> truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。\n>\n> 但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例：\n>\n> ```plsql\n> -- 创建表，f_id字段引用T_TEST的主码id\n> drop table T_TEST2;\n> create table T_TEST2(\n>   id1 int primary key ,\n>   f_id int,\n>   constraint fk\n>   foreign key (f_id)\n>     references T_TEST(id) on delete cascade\n> );\n> select *\n> from T_TEST2;\n> insert into T_TEST2 values(1, 1);\n> -- 可级联删除\n> delete from T_TEST;\n> -- 将外码置为禁用\n> alter table T_TEST2 modify constraint fk disable validate ;\n> -- 可截断（当不禁用外码时无法截断）\n> truncate table T_TEST;\n> ```\n>\n> 可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。\n\n```plsql\n--过程：数据初始化\ncreate or replace procedure init is\nbegin\n    --清除数据\n    execute immediate 'truncate table t_audit';\n    execute immediate 'truncate table t_customer_history';\n    execute immediate 'truncate table t_customer';\n    execute immediate 'truncate table t_user';\n    execute immediate 'truncate table t_department';\n    --重调序列\n    reset_seq('seq_audit_pk');\n\n    --插入部门\n    insert into t_department values(1,'销售部','D01',NULL,'李明','备注1...');\n    insert into t_department values(2,'销售部-北京分部','D0101',1,'赵军','备注2...');\n    insert into t_department values(3,'销售部-上海分部','D0102',1,'张华','备注3...');\n    insert into t_department values(4,'销售部-深圳分部','D0103',1,'王兵','备注4...');\n\n    --插入用户\n    insert into t_user values(1,1,'仲芳芳','U8201','女','13771234101','02131231011','use1@samtech.com','备注1...');\n    insert into t_user values(2,1,'李明申','U8202','男','13771234102','02131231012','use2@samtech.com','备注2...');\n    insert into t_user values(3,2,'张雪', 'U8203','女','13771234103','02131231013','use3@samtech.com','备注3...');\n    insert into t_user values(4,2,'王刚', 'U8204','男','13771234104','02131231014','use4@samtech.com','备注4...');\n    insert into t_user values(5,3,'赵昌日','U8205','男','13771234105','02131231015','use5@samtech.com','备注5...');\n    insert into t_user values(6,3,'孙晓华','U8206','男','13771234106','02131231016','use6@samtech.com','备注6...');\n    insert into t_user values(7,4,'陈亚男','U8207','女','13771234107','02131231017','use7@samtech.com','备注7...');\n    insert into t_user values(8,4,'刘兵超','U8208','男','13771234108','02131231018','use8@samtech.com','备注8...');\n\n    --插入客户\n    insert into t_customer\n    values(1,'C1808001','上海市永辉电子股份有限公司','张明升','15352678121','02135681589','ming@google.com','上海市静安区城区安泰路1108号','上海市',12082,'上海中远','备注...','张娜',0,1,sysdate,1,sysdate,1);\n    commit;\nend;\n/\n```\n\n#### 修改客户信息过程\n\n```plsql\n--过程：修改客户地址\ncreate or replace procedure modify_address\n(p_row_id in number,p_address in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_address,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated address successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户余额\ncreate or replace procedure modify_balance\n(p_row_id in number,p_balance in number, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_balance,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated balance successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户电子邮箱\ncreate or replace procedure modify_email\n(p_row_id in number,p_email in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_email,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated email successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户联系人\ncreate or replace procedure modify_linkman\n(p_row_id in number,p_linkman_name in varchar2, p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_linkman_name,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated linkman name successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改客户联系人信息\ncreate or replace procedure modify_linkman_info\n(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2,\n p_telephone in varchar2,p_email in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_linkman=:1, f_mobile=:2,\n    f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6'\n    using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated linkman info successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改联系手机\ncreate or replace procedure modify_mobile\n(p_row_id in number,p_mobile in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_mobile,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated mobile successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n\n--过程：修改联系固话\ncreate or replace procedure modify_telephone\n(p_row_id in number,p_telephone in varchar2,p_operator in number)\nas\nbegin\n    --校验参数省略\n    --...\n    execute immediate 'update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3'\n    using p_telephone,p_operator,p_row_id;\n    commit;\n    dbms_output.put_line('Updated mobile successfully.');\n\n    --异常捕获省略\n    --...\nend;\n/\n```\n\n### 执行\n\n```plsql\n-- 初始化\ncall init();\n\n-- 更改客户信息\nbegin\n\tmodify_linkman(1,'李明顺',1);\n\tdbms_lock.sleep(1);\n\tmodify_mobile(1,'13771083211',2);\n\tdbms_lock.sleep(1);\n\tmodify_balance(1,20020,3);\n\tdbms_lock.sleep(1);\n\tmodify_address(1,'中国上海市嘉定区xxx路',4);\n\tdbms_lock.sleep(1);\n\tmodify_email(1,'test1@163.com',5);\n\tdbms_lock.sleep(1);\n\tmodify_telephone(1,'02183652145',6);\n\tdbms_lock.sleep(1);\n\tmodify_linkman_info(1,'张雨轩','15332892301','02188881111','zhangyx@gmail.com',7);\nend;\n/\n\n-- 审计\nselect * from T_AUDIT;\n\n-- 回滚客户信息\n-- 方法1：\nupdate t_customer a\nset(\na.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,\na.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,\na.f_modified_id,a.f_modified_time\n)\n=\n(\nselect b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,\nb.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,\nb.f_deleted_tag,5,sysdate\nfrom t_customer_history b where b.f_id=a.f_id and b.f_version=3\n)\nwhere a.f_id=1;\n-- 方法2：\nmerge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)\nwhen matched then\nupdate set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,\na.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,\na.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;\n\n-- 查看验证数据\nselect * from t_customer where f_id=1\nunion\nselect * from t_customer_history where f_id=1 and f_version=3;\n```\n\n# Lesson 3\n\n## 创建用户并分配权限\n\n### 创建用户\n\n```plsql\ncreate user permission identified by permission;\n```\n\n### 分配权限\n\n```plsql\ngrant connect,resource to permission;\nalter user permisson quota unlimited on users;\nconn permission/permission;\n```\n\n## 创建表及其他对象\n\n### 方案一\n\n> 方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。\n\n#### 创建表\n\n```plsql\n\n--方案一\n--部门表\nCREATE TABLE T_DEPARTMENT\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_PARENT_ID\" NUMBER(6,0),\n\t\"F_MANAGER_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_DEPARTMENT_PK\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_MANAGER_ID\" IS '部门经理';\nCOMMENT ON COLUMN \"T_DEPARTMENT\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_DEPARTMENT\"  IS '部门表';\n\n--用户表\nCREATE TABLE \"T_USER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n\t\"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n\t\"F_MOBILE\" VARCHAR2(20 BYTE),\n\t\"F_EMAIL\" VARCHAR2(50 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t CONSTRAINT \"T_USER_PK\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_USER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_USER\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"T_USER\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"T_USER\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"T_USER\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"T_USER\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"T_USER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_USER\"  IS '用户表';\n\n--客户信息表\nCREATE TABLE \"T_CUSTOMER\"\n(\t\"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n\t\"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n\t\"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n\t\"F_EMAIL\" VARCHAR2(60 BYTE),\n\t\"F_ADDRESS\" VARCHAR2(200 BYTE),\n\t\"F_REMARK\" VARCHAR2(200 BYTE),\n\t\"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n\t\"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n\t PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"T_CUSTOMER\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON TABLE \"T_CUSTOMER\"  IS '客户信息表';\n```\n\n#### 创建过程\n\n##### 初始化\n\n```plsql\n--过程：数据初始化\nCREATE OR REPLACE PROCEDURE INIT IS\nBEGIN\n    --清除数据\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_CUSTOMER';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_DEPARTMENT';\n\n    --插入部门\n    INSERT INTO T_DEPARTMENT VALUES(1,'公司',NULL,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(2,'行政部',1,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(3,'销售部',1,2,'REMARK...');\n    INSERT INTO T_DEPARTMENT VALUES(4,'电销组',3,3,'销售部电销组');\n    INSERT INTO T_DEPARTMENT VALUES(5,'推销组',3,6,'销售部推销组');\n\n    --插入用户\n    INSERT INTO T_USER VALUES(1,1,'管理员','男','13771234101','USE1@SAMTECH.COM','系统管理员');\n    INSERT INTO T_USER VALUES(2,3,'李明申','男','13771234102','USE2@SAMTECH.COM','销售部经理');\n    INSERT INTO T_USER VALUES(3,4,'张雪', '女','13771234103','USE3@SAMTECH.COM','销售部电销组主管');\n    INSERT INTO T_USER VALUES(4,4,'王刚', '男','13771234104','USE4@SAMTECH.COM','销售部电销组业务员1');\n    INSERT INTO T_USER VALUES(5,4,'赵昌日','男','13771234105','USE5@SAMTECH.COM','销售部电销组业务员2');\n    INSERT INTO T_USER VALUES(6,5,'孙晓华','男','13771234106','USE6@SAMTECH.COM','销售部推销组主管');\n    INSERT INTO T_USER VALUES(7,5,'陈亚男','女','13771234107','USE7@SAMTECH.COM','销售部推销组业务员3');\n    INSERT INTO T_USER VALUES(8,5,'刘兵超','男','13771234108','USE8@SAMTECH.COM','销售部推销组业务员4');\n    INSERT INTO T_USER VALUES(9,3,'陈彬','女','13771234109','USE9@SAMTECH.COM','销售部业务员X1');\n    INSERT INTO T_USER VALUES(10,3,'王军','男','13771234110','USE10@SAMTECH.COM','销售部业务员X2');\n\n    --插入客户\n    INSERT INTO T_CUSTOMER VALUES(1,'上海市永辉电子股份有限公司'     ,'张明升','15352678121','MING1@GOOGLE.COM','上海市静安区城区安泰路1108号','电销组主管创建',3,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(2,'上海博运汽车销售有限公司'      ,'朱荣荣' ,'13231289212','MING2@GOOGLE.COM','上海市徐汇区钦江路256号','电销组业务员1创建',4,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(3,'安徽广宏顶管装备制造有限公司'   ,'邱阳阳' ,'15328921231','MING3@GOOGLE.COM','安徽省广德县经济开发区东纬路5号','电销组业务员2创建',5,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(4,'上海定丰霖贸易有限公司'        ,'赵兰'  ,'15532212322','MING4@GOOGLE.COM','上海市浦东新区东延路112号408室','推销组主管创建',6,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(5,'上海东俊科技有限公司'          ,'张军'  ,'15367823660','MING5@GOOGLE.COM','上海市长宁区王安路135号','推销组业务员1创建',7,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(6,'中科创客（深圳）智能工业设备公司','李明'  ,'17723180234','MING6@GOOGLE.COM','深圳市龙岗区富民工业园致康路301号','推销组业务员2创建',8,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(7,'南宁云讯科技有限公司'          ,'王永成','13568932166','MING7@GOOGLE.COM','广东省深圳市福田区长川路102号','销售部业务员X1创建',9,SYSDATE);\n    INSERT INTO T_CUSTOMER VALUES(8,'沈阳优速家政服务有限公司'       ,'李东升','13392312343','MING8@GOOGLE.COM','辽宁省沈阳市铁西区北二路青年易居东门32号','销售部业务员X2创建',10,SYSDATE);\n    COMMIT;\nEND;\n/\n```\n\n#### 执行\n\n##### 初始化\n\n```\nset serveroutput on;\nexec init;\n```\n\n##### 查询自己的客户\n\n```plsql\nSELECT * FROM t_customer A WHERE A.f_created_id=&id;\n```\n\n> `&id`是所查询人员的ID\n\n##### 查询某领导下属人员的所有客户\n\n```plsql\nselect * from t_user a  where exists(\nSELECT 1 FROM t_department b\nWHERE a.f_dept_id=b.f_id and b.f_manager_id=&id\nCONNECT BY b.F_PARENT_ID = PRIOR b.F_ID\nstart with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&id));\n```\n\n> `&id`是该领导的ID\n\n#### 当部门结构或员工归属调整时，权限编码如何处理？\n\n对于方案一，只需要更改员工直属领导ID即可\n\n### 方案二\n\n> 方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可\n\n#### 创建表\n\n```plsql\n--方案二\n--部门表\nCREATE TABLE T_DEPARTMENT_2\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n    \"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_PARENT_ID\" NUMBER(6,0),\n \"F_MANAGER_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_REMARK\" VARCHAR2(200 BYTE),\n  CONSTRAINT \"T_DEPARTMENT_PK2\" PRIMARY KEY (\"F_ID\")\n) ;\n\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_NAME\" IS '部门名称';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_CODE\" IS '部门编码';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_PARENT_ID\" IS '上级部门ID';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_MANAGER_ID\" IS '部门经理';\nCOMMENT ON COLUMN \"T_DEPARTMENT_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_DEPARTMENT_2\"  IS '部门表2';\n\n--用户表\nCREATE TABLE \"T_USER_2\"\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_DEPT_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n    \"F_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_SEX\" VARCHAR2(5 BYTE) DEFAULT NULL,\n \"F_MOBILE\" VARCHAR2(20 BYTE),\n \"F_EMAIL\" VARCHAR2(50 BYTE),\n \"F_REMARK\" VARCHAR2(200 BYTE),\n  CONSTRAINT \"T_USER_PK2\" PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_USER_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_DEPT_ID\" IS '部门ID';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_NAME\" IS '用户名';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_CODE\" IS '用户编码';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_SEX\" IS '性别';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_MOBILE\" IS '手机';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_EMAIL\" IS '邮箱';\nCOMMENT ON COLUMN \"T_USER_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON TABLE \"T_USER_2\"  IS '用户表2';\n\n--客户信息表\nCREATE TABLE \"T_CUSTOMER_2\"\n(  \"F_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_NAME\" VARCHAR2(145 BYTE) NOT NULL ENABLE,\n \"F_LINKMAN\" VARCHAR2(45 BYTE) NOT NULL ENABLE,\n \"F_MOBILE\" VARCHAR2(11 BYTE) NOT NULL ENABLE,\n \"F_EMAIL\" VARCHAR2(60 BYTE),\n \"F_ADDRESS\" VARCHAR2(200 BYTE),\n \"F_REMARK\" VARCHAR2(200 BYTE),\n    \"F_ACCESS_CODE\" VARCHAR2(50 BYTE) NOT NULL ENABLE,\n \"F_CREATED_ID\" NUMBER(6,0) NOT NULL ENABLE,\n \"F_CREATED_TIME\" TIMESTAMP (6) NOT NULL ENABLE,\n  PRIMARY KEY (\"F_ID\")\n);\n\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ID\" IS 'PK';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_NAME\" IS '客户全名';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_LINKMAN\" IS '联系人';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_MOBILE\" IS '联系手机';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_EMAIL\" IS '联系邮箱';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ADDRESS\" IS '地址';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_REMARK\" IS '备注信息';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_ACCESS_CODE\" IS '权限编码';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_CREATED_ID\" IS '创建人';\nCOMMENT ON COLUMN \"T_CUSTOMER_2\".\"F_CREATED_TIME\" IS '创建时间';\nCOMMENT ON TABLE \"T_CUSTOMER_2\"  IS '客户信息表2';\n\n-- 创建人员更改历史表\nCREATE TABLE T_USER_HISTORY(\n  ID NUMBER(6,0) PRIMARY KEY ,\n  F_ID NUMBER(6,0) ,\n  O_DEP_ID NUMBER(6,0) ,\n  O_ACCESS_CODE VARCHAR2(50 BYTE) ,\n  N_DEP_ID  NUMBER(6,0),\n  N_ACCESS_CODE VARCHAR2(50 BYTE),\n  TIME DATE\n);\n\nCOMMENT ON COLUMN T_USER_HISTORY.ID IS 'PK';\nCOMMENT ON COLUMN T_USER_HISTORY.F_ID IS '修改的人员ID';\nCOMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS '旧的部门';\nCOMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS '旧的权限';\nCOMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS '新的部门';\nCOMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS '新的权限';\nCOMMENT ON TABLE T_USER_HISTORY IS '用户权限更改历史';\n```\n\n#### 创建过程\n\n##### 初始化\n\n```plsql\n--过程：数据初始化\nCREATE OR REPLACE PROCEDURE INIT2 IS\nBEGIN\n    --清除数据\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_CUSTOMER_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_DEPARTMENT_2';\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE T_USER_HISTORY';\n\n    --插入部门\n    INSERT INTO T_DEPARTMENT_2 VALUES(1,'公司','1',NULL,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(2,'行政部','101',1,1,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(3,'销售部','102',1,2,'REMARK...');\n    INSERT INTO T_DEPARTMENT_2 VALUES(4,'电销组','10201',3,3,'销售部电销组');\n    INSERT INTO T_DEPARTMENT_2 VALUES(5,'推销组','10202',3,6,'销售部推销组');\n\n    --插入用户\n    INSERT INTO T_USER_2 VALUES(1,1,'管理员','1','男','13771234101','USE1@SAMTECH.COM','系统管理员');\n    INSERT INTO T_USER_2 VALUES(2,3,'李明申','102','男','13771234102','USE2@SAMTECH.COM','销售部经理');\n    INSERT INTO T_USER_2 VALUES(3,4,'张雪',  '10201', '女','13771234103','USE3@SAMTECH.COM','销售部电销组主管');\n    INSERT INTO T_USER_2 VALUES(4,4,'王刚',  '1020101', '男','13771234104','USE4@SAMTECH.COM','销售部电销组业务员1');\n    INSERT INTO T_USER_2 VALUES(5,4,'赵昌日','1020102','男','13771234105','USE5@SAMTECH.COM','销售部电销组业务员2');\n    INSERT INTO T_USER_2 VALUES(6,5,'孙晓华','10202','男','13771234106','USE6@SAMTECH.COM','销售部推销组主管');\n    INSERT INTO T_USER_2 VALUES(7,5,'陈亚男','1020201','女','13771234107','USE7@SAMTECH.COM','销售部推销组业务员3');\n    INSERT INTO T_USER_2 VALUES(8,5,'刘兵超','1020202','男','13771234108','USE8@SAMTECH.COM','销售部推销组业务员4');\n    INSERT INTO T_USER_2 VALUES(9,3,'陈彬',  '10203','女','13771234109','USE9@SAMTECH.COM','销售部业务员X1');\n    INSERT INTO T_USER_2 VALUES(10,3,'王军', '10204','男','13771234110','USE10@SAMTECH.COM','销售部业务员X2');\n\n    --插入客户\n    INSERT INTO T_CUSTOMER_2 VALUES(1,'上海市永辉电子股份有限公司'     ,'张明升','15352678121','MING1@GOOGLE.COM','上海市静安区城区安泰路1108号','电销组主管创建','10201',3,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(2,'上海博运汽车销售有限公司'      ,'朱荣荣' ,'13231289212','MING2@GOOGLE.COM','上海市徐汇区钦江路256号','电销组业务员1创建','1020101',4,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(3,'安徽广宏顶管装备制造有限公司'   ,'邱阳阳' ,'15328921231','MING3@GOOGLE.COM','安徽省广德县经济开发区东纬路5号','电销组业务员2创建','1020102',5,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(4,'上海定丰霖贸易有限公司'        ,'赵兰'  ,'15532212322','MING4@GOOGLE.COM','上海市浦东新区东延路112号408室','推销组主管创建','10202',6,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(5,'上海东俊科技有限公司'          ,'张军'  ,'15367823660','MING5@GOOGLE.COM','上海市长宁区王安路135号','推销组业务员1创建','1020201',7,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(6,'中科创客（深圳）智能工业设备公司','李明'  ,'17723180234','MING6@GOOGLE.COM','深圳市龙岗区富民工业园致康路301号','推销组业务员2创建','1020202',8,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(7,'南宁云讯科技有限公司'          ,'王永成','13568932166','MING7@GOOGLE.COM','广东省深圳市福田区长川路102号','销售部业务员X1创建','10203',9,SYSDATE);\n    INSERT INTO T_CUSTOMER_2 VALUES(8,'沈阳优速家政服务有限公司'       ,'李东升','13392312343','MING8@GOOGLE.COM','辽宁省沈阳市铁西区北二路青年易居东门32号','销售部业务员X2创建','10204',10,SYSDATE);\n    COMMIT;\nEND;\n/\n```\n\n##### 将某员工调换到某部门\n\n![image-20181126025537963](/images/image-20181126025537963.png)\n\n```plsql\n-- 更改用户到特定部门\nCREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS\n  -- 旧部门\n  O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE;\n  -- 旧权限\n  O_ACCESS_CODE T_USER_2.F_CODE%TYPE;\n  -- 部门权限前缀\n  DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE;\n  -- 部门当前人数\n  DEP_USER_COUNT T_USER_2.F_CODE%TYPE;\n  -- 本部门下的部门数\n  DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE;\n  -- 新权限\n  N_ACCESS_CODE T_USER_2.F_CODE%TYPE;\n  -- 更新该员工权限\n  C_UPDATE_USER VARCHAR2(100) := 'UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3';\n  -- 更新所有该员工的客户的ACCESS权限\n  C_UPDATE_CUSTOMER VARCHAR2(100) := 'UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2';\n  -- 插入一条修改记录\n  C_INSERT_HISTORY VARCHAR2(100) := 'INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)';\n  BEGIN\n    -- 旧部门\n    SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;\n    -- 旧权限\n    SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;\n    -- 新部门权限作为前缀\n    SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID;\n    -- 计算该部门人员数量\n    SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID;\n    -- 计算子部门数量\n    SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2;\n    -- 若新部门与旧部门相同，无需更改\n    IF N_DEP_ID=O_DEP_ID THEN\n      RETURN;\n    END IF;\n    -- 新权限CODE\n    IF DEP_DEP_COUNT > DEP_USER_COUNT THEN\n      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1);\n    ELSE\n      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1);\n    end if;\n    -- 输出相关变量\n    dbms_output.put_line('DEP_USER_COUNT : ' || DEP_USER_COUNT);\n    dbms_output.put_line('DEP_DEP_COUNT : ' || DEP_DEP_COUNT);\n    -- 输出相关变量\n    dbms_output.put_line('DEP_ACCESS_CODE_PREFIX : ' || DEP_ACCESS_CODE_PREFIX);\n    dbms_output.put_line('C_F_ID : ' || C_F_ID);\n    dbms_output.put_line('O_ACCESS_CODE : ' || O_ACCESS_CODE);\n    dbms_output.put_line('N_DEP_ID : ' || N_DEP_ID);\n    dbms_output.put_line('N_ACCESS_CODE : ' || N_ACCESS_CODE);\n    -- 更新该员工权限\n    EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID;\n    -- 更新所有该员工的客户的ACCESS权限\n    EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID;\n    -- 插入一条修改记录\n    EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE;\n    -- 提交\n    COMMIT;\n  END;\n  /\n```\n\n#### 创建序列\n\n```plsql\n-- 员工部门历史记录主码序列\nCREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1;\n```\n\n#### 执行\n\n```plsql\nselect * from t_customer_2 where f_access_code like 'xxx%';\n```\n\n> `xxx%`指匹配所有以`xxx`开头的权限码\n\n#### 当部门结构或员工归属调整时，权限编码如何处理？\n\n方案二中，调用新增的过程`CHANGE_TO_DEPARTMENT`即可级联更改权限码。\n","slug":"Practice","published":1,"updated":"2021-05-16T11:00:19.557Z","_id":"ckfukja9o000wszxolq7tgs33","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Oracle专家的三次授课笔记及Best Practice记录。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"Lesson-1\"><a href=\"#Lesson-1\" class=\"headerlink\" title=\"Lesson 1\"></a>Lesson 1</h1><h2 id=\"创建用户并分配权限\"><a href=\"#创建用户并分配权限\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建测试schema，命名为test\"><a href=\"#创建测试schema，命名为test\" class=\"headerlink\" title=\"创建测试schema，命名为test\"></a>创建测试schema，命名为test</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user test identified by test;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配连接资源\"><a href=\"#分配连接资源\" class=\"headerlink\" title=\"分配连接资源\"></a>分配连接资源</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to test;</span><br><span class=\"line\">grant execute on dbms_lock to test;</span><br><span class=\"line\">grant execute on UTL_FILE to test;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为test用户创建external-data目录以及分配权限\"><a href=\"#为test用户创建external-data目录以及分配权限\" class=\"headerlink\" title=\"为test用户创建external_data目录以及分配权限\"></a>为test用户创建external_data目录以及分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create directory external_data as &apos;/home/oracle/data&apos;;</span><br><span class=\"line\">grant read,write on directory external_data to test;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>要注意oracle用户必须拥有对这里的external_data路径读写的权限。</p>\n</blockquote>\n<h3 id=\"分配表空间权限\"><a href=\"#分配表空间权限\" class=\"headerlink\" title=\"分配表空间权限\"></a>分配表空间权限</h3><p>我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间：</p>\n<ul>\n<li><strong>SYSTEM</strong> - 存储数据字典</li>\n<li><strong>SYSAUX</strong> - 存储辅助应用程序的数据</li>\n<li><strong>TEMP</strong> - 存储数据库临时对象</li>\n<li><strong>USERS</strong> - 存储各个用户创建的对象</li>\n<li><strong>UNDOTBS</strong> - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询</li>\n<li>……</li>\n</ul>\n<p>而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- DBA下执行：</span><br><span class=\"line\">-- 查看数据库中的所有表空间</span><br><span class=\"line\">select * from v$tablespace;</span><br><span class=\"line\">-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)</span><br><span class=\"line\">select username,default_tablespace from dba_users where username=&apos;TEST&apos;;</span><br><span class=\"line\">-- 为用户赋予当前表空间下的权限</span><br><span class=\"line\">alter user test quota unlimited on users;</span><br><span class=\"line\">--  或者制定用户可用大小：</span><br><span class=\"line\">alter user test quota 50M on users;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接用户，建表，跑存储过程和函数\"><a href=\"#连接用户，建表，跑存储过程和函数\" class=\"headerlink\" title=\"连接用户，建表，跑存储过程和函数\"></a>连接用户，建表，跑存储过程和函数</h2><h3 id=\"连接test用户\"><a href=\"#连接test用户\" class=\"headerlink\" title=\"连接test用户\"></a>连接test用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 在系统命令下连接</span><br><span class=\"line\">cd $ORACLE_HOME/bin</span><br><span class=\"line\">./sqlplus test/test</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 在进入sqlplus后的连接</span><br><span class=\"line\">conn test/test</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_ID IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS &apos;手机号段&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_CITY IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS &apos;固话区号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS &apos;邮政编码&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_MOBILES  IS &apos;号段表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);</span><br><span class=\"line\">--*注：因f_id导入时缺少数据，所有先不设置为PK.</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_ID IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_NO IS &apos;通话号码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS &apos;开始时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_END_TIME IS &apos;结束时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_DURATION IS &apos;通话时长&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_MOBILE IS &apos;手机号码标志&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_RECORDS  IS &apos;通话清单表&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建ctl文件导入csv数据\"><a href=\"#创建ctl文件导入csv数据\" class=\"headerlink\" title=\"创建ctl文件导入csv数据\"></a>创建ctl文件导入csv数据</h3><p>进入<code>external_data</code>路径下并创建以下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cd /home/oracle/data</span><br><span class=\"line\"><span class=\"meta\">$</span> vi control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">$</span> vi control_records.ctl</span><br></pre></td></tr></table></figure>\n<p><code>control_mobiles.ctl:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD DATA</span><br><span class=\"line\">CHARACTERSET UTF8</span><br><span class=\"line\">INFILE &apos;/home/oracle/data/mobiles.csv&apos;</span><br><span class=\"line\">TRUNCATE INTO TABLE t_mobiles</span><br><span class=\"line\">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class=\"line\">TRAILING NULLCOLS</span><br><span class=\"line\">(</span><br><span class=\"line\">\tF_ID,</span><br><span class=\"line\">\tF_MOBILE_HEAD,</span><br><span class=\"line\">\tF_PROVINCE,</span><br><span class=\"line\">\tF_CITY,</span><br><span class=\"line\">\tF_PLATFORM,</span><br><span class=\"line\">\tF_TEL_HEAD,</span><br><span class=\"line\">\tF_ZIPCODE</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>control_records.ctl:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD DATA</span><br><span class=\"line\">CHARACTERSET UTF8</span><br><span class=\"line\">INFILE &apos;/home/oracle/data/records.csv&apos;</span><br><span class=\"line\">TRUNCATE INTO TABLE t_records</span><br><span class=\"line\">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class=\"line\">TRAILING NULLCOLS</span><br><span class=\"line\">(</span><br><span class=\"line\">\tF_NO,</span><br><span class=\"line\">\tF_BEGIN_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class=\"line\">\tF_END_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class=\"line\">\tF_DURATION INTEGER EXTERNAL</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在该路径下执行导入操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> $ORACLE_HOME/bin/sqlldr userid=test/test control=control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">$</span> $ORACLE_HOME/bin/sqlldr userid=test/test control=control_records.ctl</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>教程中命令为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> $ sqlldr userid=test/test@orcl control=control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>即在导入时指定<code>连接字符串</code>（这里的orcl实际上是连接字符串的别名），其在<code>$ORACLE_HOME/network/admin/tnsname.ora</code>中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。</p>\n<p>既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是<code>连接字符串</code>和<code>服务名</code>的区别，oracle有个默认服务名<code>XE</code>，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; jdbc:oracle:thin:@localhost:1521:XE</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> # 命令格式：sqlplus username/password@host:port/service_name</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键</span><br><span class=\"line\">create sequence seq_records increment by 1 start with 1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键</span><br><span class=\"line\">update t_records set f_id=seq_records.nextval;</span><br><span class=\"line\">alter table t_records add constraint t_records_pk primary key (f_id);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 3、创建并初始化同步锁表，用于多线程同步控制</span><br><span class=\"line\">CREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));</span><br><span class=\"line\">COMMENT ON COLUMN T_LOCK.F_NAME IS &apos;锁名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOCK.F_INDEX IS &apos;锁的当前值&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_LOCK  IS &apos;同步锁表&apos;;</span><br><span class=\"line\">insert into T_LOCK values(&apos;_RECORD_INDEX&apos;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 4、在电话号段表中创建唯一性索引，提高号段检索速度</span><br><span class=\"line\">create unique index uniq_mobile_head on t_mobiles(f_mobile_head);</span><br><span class=\"line\">update t_mobiles set f_province = &apos;内蒙古&apos; where f_province = &apos;内蒙&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 5、创建日志表，用于记录程序执行过程中的日志信息。</span><br><span class=\"line\">create table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_TIME IS &apos;日志时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_HEAD IS &apos;日志类型标志&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_CONTENT IS &apos;日志内容&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_LOG  IS &apos;日志表&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建函数和存储过程\"><a href=\"#创建函数和存储过程\" class=\"headerlink\" title=\"创建函数和存储过程\"></a>创建函数和存储过程</h2><h3 id=\"声明函数和存储过程\"><a href=\"#声明函数和存储过程\" class=\"headerlink\" title=\"声明函数和存储过程\"></a>声明函数和存储过程</h3><ul>\n<li>函数is_mobile，判断通话号码是否为手机号码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--函数：判断通话号码是否为手机号码</span><br><span class=\"line\">CREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2)</span><br><span class=\"line\">    RETURN BOOLEAN IS</span><br><span class=\"line\"></span><br><span class=\"line\">    v_phone VARCHAR2(20);</span><br><span class=\"line\">    v_head VARCHAR2(2);</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --检查参数func</span><br><span class=\"line\">    IF phone IS NULL THEN</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--去除前后空格</span><br><span class=\"line\">    v_phone := TRIM(phone);</span><br><span class=\"line\"></span><br><span class=\"line\">\t--去除号码前面的0</span><br><span class=\"line\">    IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class=\"line\">        v_phone := substr(v_phone, 2);</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--检查手机号码长度</span><br><span class=\"line\">    IF substr(v_phone,0,1) &lt;&gt; &apos;1&apos; OR LENGTH(v_phone) &lt;&gt; 11 THEN</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--截取号码前两位</span><br><span class=\"line\">    v_head := substr(v_phone,1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF v_head = &apos;13&apos; OR v_head = &apos;14&apos; OR v_head =&apos;15&apos; OR v_head =&apos;17&apos; OR v_head = &apos;18&apos; THEN</span><br><span class=\"line\">        RETURN TRUE;</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程init，清空t_log，同时t_lock置零</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：初始化测试数据</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE init IS</span><br><span class=\"line\">    CURSOR job_cursor IS SELECT JOB FROM user_jobs;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">\t--重置处理位置为0</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;update t_lock set f_index=0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--清除日志表中的记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;truncate table t_log&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--重置话单表中的记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1&apos;;</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    FOR tmp_job IN job_cursor LOOP</span><br><span class=\"line\">        dbms_job.broken(tmp_job.JOB,TRUE,sysdate);</span><br><span class=\"line\">        dbms_job.REMOVE(tmp_job.JOB);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程print，打印日志，存到T_LOG表中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：打印日志</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">\t--dbms_output.put_line(to_char(&apos;yyyy-mm-dd hh24:mi:ss&apos;)||&apos;,&apos;||prefix||&apos;,&apos;||content);</span><br><span class=\"line\">\tINSERT INTO t_log VALUES(sysdate,prefix, content);</span><br><span class=\"line\">\tCOMMIT;</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">\tWHEN OTHERS THEN</span><br><span class=\"line\">\t\tdbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">\t\tdbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程show，显示当前处理情况</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：显示当前处理情况</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE show IS</span><br><span class=\"line\">\t--待处理记录总数</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--当前日志表记录总数</span><br><span class=\"line\">    v_log_count NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--当前数据处理位置</span><br><span class=\"line\">    v_current_index NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--用户Job表游标</span><br><span class=\"line\">    CURSOR job_cursor IS SELECT * FROM user_jobs;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_log_count FROM t_log;</span><br><span class=\"line\">    SELECT f_index INTO v_current_index FROM t_lock;</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdbms_output.put_line(&apos;log count: &apos;||v_log_count);</span><br><span class=\"line\">    dbms_output.put_line(&apos;record count: &apos;||v_record_count);</span><br><span class=\"line\">    dbms_output.put_line(&apos;current index: &apos;||v_current_index);</span><br><span class=\"line\"></span><br><span class=\"line\">\t--清除用户job记录</span><br><span class=\"line\">    FOR tmp_job IN job_cursor LOOP</span><br><span class=\"line\">        dbms_output.put_line(&apos;job:&apos;||tmp_job.JOB||&apos;,broken:&apos;||tmp_job.broken||&apos;,total_time:&apos;||tmp_job.total_time||&apos;,failures:&apos;||tmp_job.failures||&apos;,interval:&apos;||tmp_job.INTERVAL||&apos;,last_sec:&apos;||tmp_job.last_sec||&apos;,next_sec:&apos;||tmp_job.next_sec);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程process_data，提交一个job处理数据</li>\n</ul>\n<blockquote>\n<p><strong>共享锁和排它锁:</strong></p>\n<ul>\n<li><p>当某事务对数据添加共享锁时，此时该事务<code>只能读不能写</code>，其他事务只能对该数据添加共享锁，而不能添加排它锁</p>\n</li>\n<li><p>当某事务对数据添加排它锁时，此时该事务<code>既能读又能写</code>，其他事务不能对该数据添加任何锁</p>\n</li>\n</ul>\n<p><strong>autocommit需要关掉:</strong></p>\n<p>假设现在有三个job对T_LOCK表进行并发读写，如下：</p>\n<p><img src=\"/images/image-20181124202306595.png\" alt=\"image-20181124202306595\"></p>\n<p>步骤如下：</p>\n<p><img src=\"/images/锁.png\" alt=\"锁\"></p>\n<p>阻塞情况：</p>\n<p><img src=\"/images/锁2.png\" alt=\"锁2\"></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：处理数据</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS</span><br><span class=\"line\">    --定义常量</span><br><span class=\"line\">    c_record_index CONSTANT VARCHAR2(20)   :=&apos;_RECORD_INDEX&apos;;</span><br><span class=\"line\">    c_process_prefix CONSTANT VARCHAR2(20) := &apos;[  PROCESS ]&apos;;</span><br><span class=\"line\">    c_select_record_sql VARCHAR2(100)  := &apos;select * from t_records where f_id &gt;= :x and f_id &lt;= :y&apos;;</span><br><span class=\"line\">    c_select_mobile_sql VARCHAR2(100)  := &apos;select * from t_mobiles where f_mobile_head = :x&apos;;</span><br><span class=\"line\">    c_update_mobile_sql VARCHAR2(100)  := &apos;update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z&apos;;</span><br><span class=\"line\">    c_update_record_sql VARCHAR2(100)  := &apos;update t_records set f_mobile = 0 where f_id = :n&apos;;</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\">    v_current_index NUMBER;</span><br><span class=\"line\">    v_begin_index NUMBER;</span><br><span class=\"line\">    v_end_index NUMBER;</span><br><span class=\"line\">    v_id NUMBER;</span><br><span class=\"line\">    v_phone VARCHAR2(20);</span><br><span class=\"line\">    v_province VARCHAR2(20);</span><br><span class=\"line\">    v_platform VARCHAR2(20);</span><br><span class=\"line\">    --定义动态游标</span><br><span class=\"line\">    TYPE ty_record_cursor IS REF CURSOR;</span><br><span class=\"line\">    record_cursor ty_record_cursor;</span><br><span class=\"line\">    mobile_cursor ty_record_cursor;</span><br><span class=\"line\">    v_record_row t_records%rowtype;</span><br><span class=\"line\">    v_mobile_row t_mobiles%rowtype;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], running...&apos;);</span><br><span class=\"line\">    --获取待处理的记录总数</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], records count: &apos;||v_record_count);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">        --获取记录锁</span><br><span class=\"line\">        SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], current index: &apos;||v_current_index);</span><br><span class=\"line\">        IF v_current_index = v_record_count THEN</span><br><span class=\"line\">            PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], finished.&apos;);</span><br><span class=\"line\">            EXIT;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        --记录本次处理的开始和结束记录位置</span><br><span class=\"line\">        v_end_index := v_current_index + batch_size;</span><br><span class=\"line\">        IF v_end_index &gt; v_record_count THEN</span><br><span class=\"line\">            v_end_index := v_record_count;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        --提交事务，释放锁</span><br><span class=\"line\">        UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index;</span><br><span class=\"line\">        COMMIT;</span><br><span class=\"line\">        --计算开始位置</span><br><span class=\"line\">        v_begin_index := v_current_index +1;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], begin index:&apos;||v_begin_index||&apos;, end index:&apos;||v_end_index);</span><br><span class=\"line\">        --test：dbms_lock.sleep(5);</span><br><span class=\"line\">        --查询一批记录进行逐个处理</span><br><span class=\"line\">        OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index;</span><br><span class=\"line\">        LOOP</span><br><span class=\"line\">            FETCH record_cursor INTO v_record_row;</span><br><span class=\"line\">            EXIT WHEN record_cursor%notfound;</span><br><span class=\"line\">            v_id    := v_record_row.f_id;</span><br><span class=\"line\">            v_phone := v_record_row.f_no;</span><br><span class=\"line\">            IF is_mobile(v_phone) THEN</span><br><span class=\"line\">                v_phone := TRIM(v_phone);</span><br><span class=\"line\">                IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class=\"line\">                    v_phone := substr(v_phone, 2);</span><br><span class=\"line\">                END IF;</span><br><span class=\"line\">                --PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], id:&apos;||v_id||&apos;, phone:&apos;||v_phone);</span><br><span class=\"line\">                --更新话单记录中的省份、运营商以及手机类型标志</span><br><span class=\"line\">                OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7);</span><br><span class=\"line\">                    FETCH mobile_cursor INTO v_mobile_row;</span><br><span class=\"line\">                    v_province := v_mobile_row.f_province;</span><br><span class=\"line\">                    v_platform := v_mobile_row.f_platform;</span><br><span class=\"line\">                    --FETCH mobile_cursor INTO v_province, v_platform;</span><br><span class=\"line\">                CLOSE mobile_cursor;</span><br><span class=\"line\">\t\t\t\t--更新话单记录的运营商、省份地区信息</span><br><span class=\"line\">                EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id;</span><br><span class=\"line\">            ELSE</span><br><span class=\"line\">                --更新话单记录为非移动号码类型</span><br><span class=\"line\">                EXECUTE IMMEDIATE c_update_record_sql USING v_id;</span><br><span class=\"line\">            END IF;</span><br><span class=\"line\">\t\t\t--提交事务</span><br><span class=\"line\">            COMMIT;</span><br><span class=\"line\">        END LOOP;</span><br><span class=\"line\">        CLOSE record_cursor;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], processed index: &apos;||v_end_index);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程generate_csv_report，生成报表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：生成报表</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE generate_csv_report IS</span><br><span class=\"line\">\tc_report_prefix CONSTANT VARCHAR2(20) := &apos;[  REPORT  ]&apos;;</span><br><span class=\"line\">    v_report_1  UTL_FILE.FILE_TYPE;</span><br><span class=\"line\">    v_report_2  UTL_FILE.FILE_TYPE;</span><br><span class=\"line\">    CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC;</span><br><span class=\"line\">    cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --生成报表1，根据运营商分类汇总各省份地区的通话量</span><br><span class=\"line\">    v_report_1 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report1.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class=\"line\">    FOR cur_tmp IN report_1_cursor LOOP</span><br><span class=\"line\">        UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || &apos;,&apos; || cur_tmp.f_province || &apos;,&apos; || cur_tmp.total);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    UTL_FILE.FCLOSE(v_report_1);</span><br><span class=\"line\">    --生成报表2，根据各省份地区汇总各运营商的通话量</span><br><span class=\"line\">    v_report_2 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report2.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class=\"line\">    FOR cur_tmp IN report_2_cursor LOOP</span><br><span class=\"line\">        UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || &apos;,&apos; || cur_tmp.f_platform || &apos;,&apos; ||  cur_tmp.total);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    UTL_FILE.FCLOSE(v_report_2);</span><br><span class=\"line\">    PRINT(c_report_prefix, &apos;generated reports.&apos;);</span><br><span class=\"line\">    EXCEPTION</span><br><span class=\"line\">        WHEN OTHERS THEN</span><br><span class=\"line\">            dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">            dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量</li>\n</ul>\n<blockquote>\n<p><strong><a href=\"https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_job.htm#BABHCBFD\" target=\"_blank\" rel=\"noopener\">dbms_job</a>:</strong></p>\n<p>用于管理job的package</p>\n<p><strong>oracle限定的job_queue_processes:</strong></p>\n<p>oracle中有一个对任务可启动进程的数量进行限制的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; SQL&gt; show parameter job_queue_processes;</span><br><span class=\"line\">&gt; NAME\t\t\t\t     TYPE\t VALUE</span><br><span class=\"line\">&gt; ----------------------------------------------------------</span><br><span class=\"line\">&gt; job_queue_processeses\t\t integer\t 10</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; SQL&gt; alter system set job_queue_processes=0...1000;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>使用ctrl+c是无法停止job的:</strong></p>\n<p>可使用<code>top</code>命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS</span><br><span class=\"line\">    --定义常量</span><br><span class=\"line\">    c_record_index CONSTANT VARCHAR2(20)\t:=&apos;_RECORD_INDEX&apos;;</span><br><span class=\"line\">\t  c_analysis_prefix CONSTANT VARCHAR2(20)\t:= &apos;[ ANALYSIS ]&apos;;</span><br><span class=\"line\">    --当前处理位置</span><br><span class=\"line\">    v_record_index NUMBER;</span><br><span class=\"line\">    --待处理的记录总数</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\">    --保存临时创建的job no</span><br><span class=\"line\">    v_tmp_jobno NUMBER;</span><br><span class=\"line\">    --开始结束时间</span><br><span class=\"line\">    v_begin_time NUMBER;</span><br><span class=\"line\">    v_process_end_time NUMBER;</span><br><span class=\"line\">    v_analysis_end_time NUMBER;</span><br><span class=\"line\">    --异常变量</span><br><span class=\"line\">    e_invalid_input EXCEPTION;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; start analysis...&apos;);</span><br><span class=\"line\">    --输入参数检查</span><br><span class=\"line\">    IF job_count &lt; 1 OR batch_size&lt;1 THEN</span><br><span class=\"line\">        RAISE e_invalid_input;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; checked input parameters.&apos;);</span><br><span class=\"line\">    --记录开始时间</span><br><span class=\"line\">    v_begin_time := dbms_utility.get_time;</span><br><span class=\"line\">    --获取待处理的记录总数</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; records count: &apos;||v_record_count);</span><br><span class=\"line\">    --开始计算重置为0</span><br><span class=\"line\">    UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index;</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; reset index to zero.&apos;);</span><br><span class=\"line\">    --提交多个job</span><br><span class=\"line\">    FOR I IN 1.. job_count LOOP</span><br><span class=\"line\">        dbms_job.submit(v_tmp_jobno,&apos;begin process_data(&apos;||I||&apos;,&apos;||batch_size||&apos;); end;&apos;);</span><br><span class=\"line\">        PRINT(c_analysis_prefix, &apos; submitted new job, no: &apos;||v_tmp_jobno);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; created &apos;||job_count||&apos; jobs.&apos;);</span><br><span class=\"line\">    --定时检查处理进度</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">        SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index;</span><br><span class=\"line\">        PRINT(c_analysis_prefix, &apos; current index: &apos;||v_record_index);</span><br><span class=\"line\">        IF v_record_index = v_record_count THEN</span><br><span class=\"line\">            PRINT(c_analysis_prefix, &apos; processed all records, exiting...&apos;);</span><br><span class=\"line\">            EXIT;</span><br><span class=\"line\">        ELSE</span><br><span class=\"line\">            dbms_lock.sleep(5);--暂停等待5秒</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    v_process_end_time := dbms_utility.get_time;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    --分类汇总产生报表</span><br><span class=\"line\">    generate_csv_report;</span><br><span class=\"line\">    --结束时间</span><br><span class=\"line\">    v_analysis_end_time := dbms_utility.get_time;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">--异常捕获部分</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">    WHEN e_invalid_input THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Invalid input values, job_count:&apos;||job_count||&apos;, batch_size:&apos;||batch_size);</span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 调用多次analysis，指定不同的job数和批数</span><br><span class=\"line\">create or replace procedure mul_analysis is</span><br><span class=\"line\">    -- 最小job数</span><br><span class=\"line\">    v_begin_job_no NUMBER := 3;</span><br><span class=\"line\">    -- 最大job数</span><br><span class=\"line\">    v_end_job_no NUMBER := 8;</span><br><span class=\"line\">    -- 每次增长的batch数量</span><br><span class=\"line\">    v_range NUMBER := 2000;</span><br><span class=\"line\">    -- 最小batch数量</span><br><span class=\"line\">    v_begin_range NUMBER := 1000;</span><br><span class=\"line\">    -- 最大batch数量</span><br><span class=\"line\">    v_end_range NUMBER := 10000;</span><br><span class=\"line\">    -- 当前range</span><br><span class=\"line\">    range NUMBER;</span><br><span class=\"line\">    begin</span><br><span class=\"line\">        for I in v_begin_job_no..v_end_job_no LOOP</span><br><span class=\"line\">            range := v_begin_range;</span><br><span class=\"line\">            LOOP</span><br><span class=\"line\">                -- 清洗表</span><br><span class=\"line\">                init();</span><br><span class=\"line\">                -- 分析</span><br><span class=\"line\">                analysis(I, range);</span><br><span class=\"line\">                range := range+v_range;</span><br><span class=\"line\">\t\t\t\t-- range增长到10000则停止</span><br><span class=\"line\">                if range &gt; v_end_range then</span><br><span class=\"line\">                    exit;</span><br><span class=\"line\">                end if;</span><br><span class=\"line\">            end loop;</span><br><span class=\"line\">        end loop;</span><br><span class=\"line\">    end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行函数和存储过程\"><a href=\"#执行函数和存储过程\" class=\"headerlink\" title=\"执行函数和存储过程\"></a>执行函数和存储过程</h3><blockquote>\n<p>在sqlplus中执行函数和存储过程之前需先打开serveroutput，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; SQL&gt; set serveroutput on;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这是因为存储过程中用到了<code>dbms_output.put_line</code>，上述语句是相当于告诉pl/sql引擎将<code>dbms_output.put_line</code>传递到缓冲区的内容输出到主控制台上。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">call init();</span><br><span class=\"line\">call analysis(4,1000);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><p>通过执行<code>mul_analysis()</code>对一系列job和batch组合值进行测试，结果如下：</p>\n<p><img src=\"/images/image-20181124205409162.png\" alt=\"image-20181124205409162\"></p>\n<h1 id=\"Lesson-2\"><a href=\"#Lesson-2\" class=\"headerlink\" title=\"Lesson 2\"></a>Lesson 2</h1><h2 id=\"创建用户并分配权限-1\"><a href=\"#创建用户并分配权限-1\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user audittest identified by audittest;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配权限\"><a href=\"#分配权限\" class=\"headerlink\" title=\"分配权限\"></a>分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to audittest;</span><br><span class=\"line\">grant execute on dbms_lock to audittest;</span><br><span class=\"line\">alter user audittest quota unlimited on users;</span><br><span class=\"line\">conn audittest/audittest;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表及其他对象\"><a href=\"#创建表及其他对象\" class=\"headerlink\" title=\"创建表及其他对象\"></a>创建表及其他对象</h2><h3 id=\"创建表-1\"><a href=\"#创建表-1\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><blockquote>\n<p>注意：</p>\n<p>这里在创建表时添加了<code>ENABLE</code>限制条件，oracle中对表和列的约束有<code>Enable</code>/<code>Disable</code>(启用/禁用)和<code>Validate</code>/<code>NoValidate</code>(验证/不验证)</p>\n<p>举两个例子：</p>\n<p><strong>需更改的错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，对name字段添加唯一性约束</span><br><span class=\"line\">&gt; drop table T_TEST;</span><br><span class=\"line\">&gt; create table T_TEST(</span><br><span class=\"line\">&gt;   id int primary key ,</span><br><span class=\"line\">&gt;   name varchar2(10) constraint unique_name unique disable</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错</span><br><span class=\"line\">&gt; begin</span><br><span class=\"line\">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt; -- 修改掉违反唯一性约束的值</span><br><span class=\"line\">&gt; update T_TEST set name=&apos;chen&apos; where id=3;</span><br><span class=\"line\">&gt; -- 使得唯一性约束生效</span><br><span class=\"line\">&gt; alter table T_TEST modify constraint unique_name enable;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>需保留的错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，无约束</span><br><span class=\"line\">&gt; drop table T_TEST;</span><br><span class=\"line\">&gt; create table T_TEST(</span><br><span class=\"line\">&gt;   id int primary key ,</span><br><span class=\"line\">&gt;   name varchar2(10)</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; -- 一些old的记录本身可能存在重复数据</span><br><span class=\"line\">&gt; begin</span><br><span class=\"line\">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt; -- 对name列创建非唯一性索引</span><br><span class=\"line\">&gt; create index i_name on T_TEST(name);</span><br><span class=\"line\">&gt; -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引</span><br><span class=\"line\">&gt; alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;</span><br><span class=\"line\">&gt; -- 此时无法插入name相同的数据了</span><br><span class=\"line\">&gt; insert into T_TEST values (4, &apos;tan&apos;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\">\t&quot;F_MANAGER&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_CODE&quot; IS &apos;部门编号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_MANAGER&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_CODE&quot; IS &apos;员工编号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_TELEPHONE&quot; IS &apos;固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class=\"line\">\t PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class=\"line\">\t CONSTRAINT &quot;T_CUSTOMER_HISTORY_PK&quot; PRIMARY KEY (&quot;F_ID&quot;, &quot;F_VERSION&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息历史表</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;  IS &apos;客户信息历史表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--审计表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TABLE_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_ROW_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NEW_VERSION&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_COLUMN_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_OLD_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_NEW_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_OPERATOR_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_OPERATION_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t CONSTRAINT &quot;T_AUDIT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_TABLE_NAME&quot; IS &apos;表名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ROW_ID&quot; IS &apos;业务数据主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VERSION&quot; IS &apos;新的版本号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_COLUMN_NAME&quot; IS &apos;字段&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OLD_VALUE&quot; IS &apos;原值&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VALUE&quot; IS &apos;新值&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATOR_ID&quot; IS &apos;操作用户&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATION_TIME&quot; IS &apos;操作时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;  IS &apos;审计表&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建索引、序列\"><a href=\"#创建索引、序列\" class=\"headerlink\" title=\"创建索引、序列\"></a>创建索引、序列</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 创建复合索引</span><br><span class=\"line\">CREATE INDEX &quot;AUDITTEST&quot;.&quot;IDX_TABLE_ROWID&quot; ON &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot; (&quot;F_TABLE_NAME&quot;, &quot;F_ROW_ID&quot;) ;</span><br><span class=\"line\">-- 创建序列</span><br><span class=\"line\">CREATE SEQUENCE  SEQ_AUDIT_PK  INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--创建触发器</span><br><span class=\"line\">create or replace trigger trg_customer_audit</span><br><span class=\"line\">before update on t_customer</span><br><span class=\"line\">for each row</span><br><span class=\"line\">declare</span><br><span class=\"line\">    c_insert_sql constant varchar2(100) := &apos;insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)&apos;;</span><br><span class=\"line\">    c_table_name constant varchar2(20)  := &apos;T_CUSTOMER&apos;;</span><br><span class=\"line\">    v_column_name varchar2(20);</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --记录当前数据到历史表</span><br><span class=\"line\">    insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version);</span><br><span class=\"line\"></span><br><span class=\"line\">    --递增记录的版本号</span><br><span class=\"line\">    :new.f_version := :old.f_version+1;</span><br><span class=\"line\"></span><br><span class=\"line\">    --判断字段变化</span><br><span class=\"line\">    if updating(&apos;F_LINKMAN&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;联系人&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_MOBILE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;手机号码&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_TELEPHONE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;固定电话&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_EMAIL&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;电子邮箱&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_ADDRESS&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;联系地址&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_BALANCE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;余额&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--创建过程</span><br><span class=\"line\">--过程：重设序列值</span><br><span class=\"line\">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class=\"line\">IS</span><br><span class=\"line\">    v_val NUMBER;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建过程\"><a href=\"#创建过程\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h3><h4 id=\"过程reset-seq\"><a href=\"#过程reset-seq\" class=\"headerlink\" title=\"过程reset_seq\"></a>过程reset_seq</h4><blockquote>\n<p>将序列为输入参数seq_name的值重置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：重设序列值</span><br><span class=\"line\">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class=\"line\">IS</span><br><span class=\"line\">    v_val NUMBER;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"过程init\"><a href=\"#过程init\" class=\"headerlink\" title=\"过程init\"></a>过程init</h4><blockquote>\n<p>truncate(截断)所有表，重设序列，并添加初始值</p>\n<p>注意：</p>\n<p><strong><code>truncate</code>与<code>delete</code>的区别</strong>：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。</p>\n<p>truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。</p>\n<p>但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，f_id字段引用T_TEST的主码id</span><br><span class=\"line\">&gt; drop table T_TEST2;</span><br><span class=\"line\">&gt; create table T_TEST2(</span><br><span class=\"line\">&gt;   id1 int primary key ,</span><br><span class=\"line\">&gt;   f_id int,</span><br><span class=\"line\">&gt;   constraint fk</span><br><span class=\"line\">&gt;   foreign key (f_id)</span><br><span class=\"line\">&gt;     references T_TEST(id) on delete cascade</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; select *</span><br><span class=\"line\">&gt; from T_TEST2;</span><br><span class=\"line\">&gt; insert into T_TEST2 values(1, 1);</span><br><span class=\"line\">&gt; -- 可级联删除</span><br><span class=\"line\">&gt; delete from T_TEST;</span><br><span class=\"line\">&gt; -- 将外码置为禁用</span><br><span class=\"line\">&gt; alter table T_TEST2 modify constraint fk disable validate ;</span><br><span class=\"line\">&gt; -- 可截断（当不禁用外码时无法截断）</span><br><span class=\"line\">&gt; truncate table T_TEST;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">create or replace procedure init is</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    execute immediate &apos;truncate table t_audit&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_customer_history&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_customer&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_user&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_department&apos;;</span><br><span class=\"line\">    --重调序列</span><br><span class=\"line\">    reset_seq(&apos;seq_audit_pk&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    insert into t_department values(1,&apos;销售部&apos;,&apos;D01&apos;,NULL,&apos;李明&apos;,&apos;备注1...&apos;);</span><br><span class=\"line\">    insert into t_department values(2,&apos;销售部-北京分部&apos;,&apos;D0101&apos;,1,&apos;赵军&apos;,&apos;备注2...&apos;);</span><br><span class=\"line\">    insert into t_department values(3,&apos;销售部-上海分部&apos;,&apos;D0102&apos;,1,&apos;张华&apos;,&apos;备注3...&apos;);</span><br><span class=\"line\">    insert into t_department values(4,&apos;销售部-深圳分部&apos;,&apos;D0103&apos;,1,&apos;王兵&apos;,&apos;备注4...&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    insert into t_user values(1,1,&apos;仲芳芳&apos;,&apos;U8201&apos;,&apos;女&apos;,&apos;13771234101&apos;,&apos;02131231011&apos;,&apos;use1@samtech.com&apos;,&apos;备注1...&apos;);</span><br><span class=\"line\">    insert into t_user values(2,1,&apos;李明申&apos;,&apos;U8202&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;02131231012&apos;,&apos;use2@samtech.com&apos;,&apos;备注2...&apos;);</span><br><span class=\"line\">    insert into t_user values(3,2,&apos;张雪&apos;, &apos;U8203&apos;,&apos;女&apos;,&apos;13771234103&apos;,&apos;02131231013&apos;,&apos;use3@samtech.com&apos;,&apos;备注3...&apos;);</span><br><span class=\"line\">    insert into t_user values(4,2,&apos;王刚&apos;, &apos;U8204&apos;,&apos;男&apos;,&apos;13771234104&apos;,&apos;02131231014&apos;,&apos;use4@samtech.com&apos;,&apos;备注4...&apos;);</span><br><span class=\"line\">    insert into t_user values(5,3,&apos;赵昌日&apos;,&apos;U8205&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;02131231015&apos;,&apos;use5@samtech.com&apos;,&apos;备注5...&apos;);</span><br><span class=\"line\">    insert into t_user values(6,3,&apos;孙晓华&apos;,&apos;U8206&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;02131231016&apos;,&apos;use6@samtech.com&apos;,&apos;备注6...&apos;);</span><br><span class=\"line\">    insert into t_user values(7,4,&apos;陈亚男&apos;,&apos;U8207&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;02131231017&apos;,&apos;use7@samtech.com&apos;,&apos;备注7...&apos;);</span><br><span class=\"line\">    insert into t_user values(8,4,&apos;刘兵超&apos;,&apos;U8208&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;02131231018&apos;,&apos;use8@samtech.com&apos;,&apos;备注8...&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    insert into t_customer</span><br><span class=\"line\">    values(1,&apos;C1808001&apos;,&apos;上海市永辉电子股份有限公司&apos;,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;02135681589&apos;,&apos;ming@google.com&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;上海市&apos;,12082,&apos;上海中远&apos;,&apos;备注...&apos;,&apos;张娜&apos;,0,1,sysdate,1,sysdate,1);</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改客户信息过程\"><a href=\"#修改客户信息过程\" class=\"headerlink\" title=\"修改客户信息过程\"></a>修改客户信息过程</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：修改客户地址</span><br><span class=\"line\">create or replace procedure modify_address</span><br><span class=\"line\">(p_row_id in number,p_address in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_address,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated address successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户余额</span><br><span class=\"line\">create or replace procedure modify_balance</span><br><span class=\"line\">(p_row_id in number,p_balance in number, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_balance,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated balance successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户电子邮箱</span><br><span class=\"line\">create or replace procedure modify_email</span><br><span class=\"line\">(p_row_id in number,p_email in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_email,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated email successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户联系人</span><br><span class=\"line\">create or replace procedure modify_linkman</span><br><span class=\"line\">(p_row_id in number,p_linkman_name in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_linkman_name,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated linkman name successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户联系人信息</span><br><span class=\"line\">create or replace procedure modify_linkman_info</span><br><span class=\"line\">(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2,</span><br><span class=\"line\"> p_telephone in varchar2,p_email in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_linkman=:1, f_mobile=:2,</span><br><span class=\"line\">    f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6&apos;</span><br><span class=\"line\">    using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated linkman info successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改联系手机</span><br><span class=\"line\">create or replace procedure modify_mobile</span><br><span class=\"line\">(p_row_id in number,p_mobile in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_mobile,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改联系固话</span><br><span class=\"line\">create or replace procedure modify_telephone</span><br><span class=\"line\">(p_row_id in number,p_telephone in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_telephone,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行\"><a href=\"#执行\" class=\"headerlink\" title=\"执行\"></a>执行</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 初始化</span><br><span class=\"line\">call init();</span><br><span class=\"line\"></span><br><span class=\"line\">-- 更改客户信息</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tmodify_linkman(1,&apos;李明顺&apos;,1);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_mobile(1,&apos;13771083211&apos;,2);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_balance(1,20020,3);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_address(1,&apos;中国上海市嘉定区xxx路&apos;,4);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_email(1,&apos;test1@163.com&apos;,5);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_telephone(1,&apos;02183652145&apos;,6);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_linkman_info(1,&apos;张雨轩&apos;,&apos;15332892301&apos;,&apos;02188881111&apos;,&apos;zhangyx@gmail.com&apos;,7);</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">-- 审计</span><br><span class=\"line\">select * from T_AUDIT;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 回滚客户信息</span><br><span class=\"line\">-- 方法1：</span><br><span class=\"line\">update t_customer a</span><br><span class=\"line\">set(</span><br><span class=\"line\">a.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,</span><br><span class=\"line\">a.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,</span><br><span class=\"line\">a.f_modified_id,a.f_modified_time</span><br><span class=\"line\">)</span><br><span class=\"line\">=</span><br><span class=\"line\">(</span><br><span class=\"line\">select b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,</span><br><span class=\"line\">b.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,</span><br><span class=\"line\">b.f_deleted_tag,5,sysdate</span><br><span class=\"line\">from t_customer_history b where b.f_id=a.f_id and b.f_version=3</span><br><span class=\"line\">)</span><br><span class=\"line\">where a.f_id=1;</span><br><span class=\"line\">-- 方法2：</span><br><span class=\"line\">merge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)</span><br><span class=\"line\">when matched then</span><br><span class=\"line\">update set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,</span><br><span class=\"line\">a.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,</span><br><span class=\"line\">a.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看验证数据</span><br><span class=\"line\">select * from t_customer where f_id=1</span><br><span class=\"line\">union</span><br><span class=\"line\">select * from t_customer_history where f_id=1 and f_version=3;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Lesson-3\"><a href=\"#Lesson-3\" class=\"headerlink\" title=\"Lesson 3\"></a>Lesson 3</h1><h2 id=\"创建用户并分配权限-2\"><a href=\"#创建用户并分配权限-2\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建用户-1\"><a href=\"#创建用户-1\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user permission identified by permission;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配权限-1\"><a href=\"#分配权限-1\" class=\"headerlink\" title=\"分配权限\"></a>分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to permission;</span><br><span class=\"line\">alter user permisson quota unlimited on users;</span><br><span class=\"line\">conn permission/permission;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表及其他对象-1\"><a href=\"#创建表及其他对象-1\" class=\"headerlink\" title=\"创建表及其他对象\"></a>创建表及其他对象</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><blockquote>\n<p>方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。</p>\n</blockquote>\n<h4 id=\"创建表-2\"><a href=\"#创建表-2\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">--方案一</span><br><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE T_DEPARTMENT</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\">\t&quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;T_USER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;T_CUSTOMER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建过程-1\"><a href=\"#创建过程-1\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE INIT IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(1,&apos;公司&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(2,&apos;行政部&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(3,&apos;销售部&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(4,&apos;电销组&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(5,&apos;推销组&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(1,1,&apos;管理员&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(2,3,&apos;李明申&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(3,4,&apos;张雪&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(4,4,&apos;王刚&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(5,4,&apos;赵昌日&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(6,5,&apos;孙晓华&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(7,5,&apos;陈亚男&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(8,5,&apos;刘兵超&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(9,3,&apos;陈彬&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(10,3,&apos;王军&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,3,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,4,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,5,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,6,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,7,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,8,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,9,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,10,SYSDATE);</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行-1\"><a href=\"#执行-1\" class=\"headerlink\" title=\"执行\"></a>执行</h4><h5 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\">exec init;</span><br></pre></td></tr></table></figure>\n<h5 id=\"查询自己的客户\"><a href=\"#查询自己的客户\" class=\"headerlink\" title=\"查询自己的客户\"></a>查询自己的客户</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t_customer A WHERE A.f_created_id=&amp;id;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&amp;id</code>是所查询人员的ID</p>\n</blockquote>\n<h5 id=\"查询某领导下属人员的所有客户\"><a href=\"#查询某领导下属人员的所有客户\" class=\"headerlink\" title=\"查询某领导下属人员的所有客户\"></a>查询某领导下属人员的所有客户</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t_user a  where exists(</span><br><span class=\"line\">SELECT 1 FROM t_department b</span><br><span class=\"line\">WHERE a.f_dept_id=b.f_id and b.f_manager_id=&amp;id</span><br><span class=\"line\">CONNECT BY b.F_PARENT_ID = PRIOR b.F_ID</span><br><span class=\"line\">start with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&amp;id));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&amp;id</code>是该领导的ID</p>\n</blockquote>\n<h4 id=\"当部门结构或员工归属调整时，权限编码如何处理？\"><a href=\"#当部门结构或员工归属调整时，权限编码如何处理？\" class=\"headerlink\" title=\"当部门结构或员工归属调整时，权限编码如何处理？\"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>对于方案一，只需要更改员工直属领导ID即可</p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><blockquote>\n<p>方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可</p>\n</blockquote>\n<h4 id=\"创建表-3\"><a href=\"#创建表-3\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--方案二</span><br><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE T_DEPARTMENT_2</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\"> &quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">  CONSTRAINT &quot;T_DEPARTMENT_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_CODE&quot; IS &apos;部门编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_DEPARTMENT_2&quot;  IS &apos;部门表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;T_USER_2&quot;</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\"> &quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\"> &quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">  CONSTRAINT &quot;T_USER_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_CODE&quot; IS &apos;用户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_USER_2&quot;  IS &apos;用户表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;T_CUSTOMER_2&quot;</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\"> &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">    &quot;F_ACCESS_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">  PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ACCESS_CODE&quot; IS &apos;权限编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_CUSTOMER_2&quot;  IS &apos;客户信息表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建人员更改历史表</span><br><span class=\"line\">CREATE TABLE T_USER_HISTORY(</span><br><span class=\"line\">  ID NUMBER(6,0) PRIMARY KEY ,</span><br><span class=\"line\">  F_ID NUMBER(6,0) ,</span><br><span class=\"line\">  O_DEP_ID NUMBER(6,0) ,</span><br><span class=\"line\">  O_ACCESS_CODE VARCHAR2(50 BYTE) ,</span><br><span class=\"line\">  N_DEP_ID  NUMBER(6,0),</span><br><span class=\"line\">  N_ACCESS_CODE VARCHAR2(50 BYTE),</span><br><span class=\"line\">  TIME DATE</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.ID IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.F_ID IS &apos;修改的人员ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS &apos;旧的部门&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS &apos;旧的权限&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS &apos;新的部门&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS &apos;新的权限&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_USER_HISTORY IS &apos;用户权限更改历史&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建过程-2\"><a href=\"#创建过程-2\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><h5 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE INIT2 IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_HISTORY&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(1,&apos;公司&apos;,&apos;1&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(2,&apos;行政部&apos;,&apos;101&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(3,&apos;销售部&apos;,&apos;102&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(4,&apos;电销组&apos;,&apos;10201&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(5,&apos;推销组&apos;,&apos;10202&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(1,1,&apos;管理员&apos;,&apos;1&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(2,3,&apos;李明申&apos;,&apos;102&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(3,4,&apos;张雪&apos;,  &apos;10201&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(4,4,&apos;王刚&apos;,  &apos;1020101&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(5,4,&apos;赵昌日&apos;,&apos;1020102&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(6,5,&apos;孙晓华&apos;,&apos;10202&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(7,5,&apos;陈亚男&apos;,&apos;1020201&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(8,5,&apos;刘兵超&apos;,&apos;1020202&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(9,3,&apos;陈彬&apos;,  &apos;10203&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(10,3,&apos;王军&apos;, &apos;10204&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,&apos;10201&apos;,3,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,&apos;1020101&apos;,4,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,&apos;1020102&apos;,5,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,&apos;10202&apos;,6,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,&apos;1020201&apos;,7,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,&apos;1020202&apos;,8,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,&apos;10203&apos;,9,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,&apos;10204&apos;,10,SYSDATE);</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h5 id=\"将某员工调换到某部门\"><a href=\"#将某员工调换到某部门\" class=\"headerlink\" title=\"将某员工调换到某部门\"></a>将某员工调换到某部门</h5><p><img src=\"/images/image-20181126025537963.png\" alt=\"image-20181126025537963\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 更改用户到特定部门</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS</span><br><span class=\"line\">  -- 旧部门</span><br><span class=\"line\">  O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE;</span><br><span class=\"line\">  -- 旧权限</span><br><span class=\"line\">  O_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 部门权限前缀</span><br><span class=\"line\">  DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 部门当前人数</span><br><span class=\"line\">  DEP_USER_COUNT T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 本部门下的部门数</span><br><span class=\"line\">  DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 新权限</span><br><span class=\"line\">  N_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 更新该员工权限</span><br><span class=\"line\">  C_UPDATE_USER VARCHAR2(100) := &apos;UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3&apos;;</span><br><span class=\"line\">  -- 更新所有该员工的客户的ACCESS权限</span><br><span class=\"line\">  C_UPDATE_CUSTOMER VARCHAR2(100) := &apos;UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2&apos;;</span><br><span class=\"line\">  -- 插入一条修改记录</span><br><span class=\"line\">  C_INSERT_HISTORY VARCHAR2(100) := &apos;INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)&apos;;</span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\">    -- 旧部门</span><br><span class=\"line\">    SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class=\"line\">    -- 旧权限</span><br><span class=\"line\">    SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class=\"line\">    -- 新部门权限作为前缀</span><br><span class=\"line\">    SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID;</span><br><span class=\"line\">    -- 计算该部门人员数量</span><br><span class=\"line\">    SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID;</span><br><span class=\"line\">    -- 计算子部门数量</span><br><span class=\"line\">    SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2;</span><br><span class=\"line\">    -- 若新部门与旧部门相同，无需更改</span><br><span class=\"line\">    IF N_DEP_ID=O_DEP_ID THEN</span><br><span class=\"line\">      RETURN;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    -- 新权限CODE</span><br><span class=\"line\">    IF DEP_DEP_COUNT &gt; DEP_USER_COUNT THEN</span><br><span class=\"line\">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1);</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">    -- 输出相关变量</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_USER_COUNT : &apos; || DEP_USER_COUNT);</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_DEP_COUNT : &apos; || DEP_DEP_COUNT);</span><br><span class=\"line\">    -- 输出相关变量</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_ACCESS_CODE_PREFIX : &apos; || DEP_ACCESS_CODE_PREFIX);</span><br><span class=\"line\">    dbms_output.put_line(&apos;C_F_ID : &apos; || C_F_ID);</span><br><span class=\"line\">    dbms_output.put_line(&apos;O_ACCESS_CODE : &apos; || O_ACCESS_CODE);</span><br><span class=\"line\">    dbms_output.put_line(&apos;N_DEP_ID : &apos; || N_DEP_ID);</span><br><span class=\"line\">    dbms_output.put_line(&apos;N_ACCESS_CODE : &apos; || N_ACCESS_CODE);</span><br><span class=\"line\">    -- 更新该员工权限</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID;</span><br><span class=\"line\">    -- 更新所有该员工的客户的ACCESS权限</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID;</span><br><span class=\"line\">    -- 插入一条修改记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE;</span><br><span class=\"line\">    -- 提交</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">  END;</span><br><span class=\"line\">  /</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建序列\"><a href=\"#创建序列\" class=\"headerlink\" title=\"创建序列\"></a>创建序列</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 员工部门历史记录主码序列</span><br><span class=\"line\">CREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行-2\"><a href=\"#执行-2\" class=\"headerlink\" title=\"执行\"></a>执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t_customer_2 where f_access_code like &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>xxx%</code>指匹配所有以<code>xxx</code>开头的权限码</p>\n</blockquote>\n<h4 id=\"当部门结构或员工归属调整时，权限编码如何处理？-1\"><a href=\"#当部门结构或员工归属调整时，权限编码如何处理？-1\" class=\"headerlink\" title=\"当部门结构或员工归属调整时，权限编码如何处理？\"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>方案二中，调用新增的过程<code>CHANGE_TO_DEPARTMENT</code>即可级联更改权限码。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Oracle专家的三次授课笔记及Best Practice记录。</p>\n</blockquote>","more":"<h1 id=\"Lesson-1\"><a href=\"#Lesson-1\" class=\"headerlink\" title=\"Lesson 1\"></a>Lesson 1</h1><h2 id=\"创建用户并分配权限\"><a href=\"#创建用户并分配权限\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建测试schema，命名为test\"><a href=\"#创建测试schema，命名为test\" class=\"headerlink\" title=\"创建测试schema，命名为test\"></a>创建测试schema，命名为test</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user test identified by test;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配连接资源\"><a href=\"#分配连接资源\" class=\"headerlink\" title=\"分配连接资源\"></a>分配连接资源</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to test;</span><br><span class=\"line\">grant execute on dbms_lock to test;</span><br><span class=\"line\">grant execute on UTL_FILE to test;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为test用户创建external-data目录以及分配权限\"><a href=\"#为test用户创建external-data目录以及分配权限\" class=\"headerlink\" title=\"为test用户创建external_data目录以及分配权限\"></a>为test用户创建external_data目录以及分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create directory external_data as &apos;/home/oracle/data&apos;;</span><br><span class=\"line\">grant read,write on directory external_data to test;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>要注意oracle用户必须拥有对这里的external_data路径读写的权限。</p>\n</blockquote>\n<h3 id=\"分配表空间权限\"><a href=\"#分配表空间权限\" class=\"headerlink\" title=\"分配表空间权限\"></a>分配表空间权限</h3><p>我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间：</p>\n<ul>\n<li><strong>SYSTEM</strong> - 存储数据字典</li>\n<li><strong>SYSAUX</strong> - 存储辅助应用程序的数据</li>\n<li><strong>TEMP</strong> - 存储数据库临时对象</li>\n<li><strong>USERS</strong> - 存储各个用户创建的对象</li>\n<li><strong>UNDOTBS</strong> - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询</li>\n<li>……</li>\n</ul>\n<p>而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- DBA下执行：</span><br><span class=\"line\">-- 查看数据库中的所有表空间</span><br><span class=\"line\">select * from v$tablespace;</span><br><span class=\"line\">-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)</span><br><span class=\"line\">select username,default_tablespace from dba_users where username=&apos;TEST&apos;;</span><br><span class=\"line\">-- 为用户赋予当前表空间下的权限</span><br><span class=\"line\">alter user test quota unlimited on users;</span><br><span class=\"line\">--  或者制定用户可用大小：</span><br><span class=\"line\">alter user test quota 50M on users;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接用户，建表，跑存储过程和函数\"><a href=\"#连接用户，建表，跑存储过程和函数\" class=\"headerlink\" title=\"连接用户，建表，跑存储过程和函数\"></a>连接用户，建表，跑存储过程和函数</h2><h3 id=\"连接test用户\"><a href=\"#连接test用户\" class=\"headerlink\" title=\"连接test用户\"></a>连接test用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 在系统命令下连接</span><br><span class=\"line\">cd $ORACLE_HOME/bin</span><br><span class=\"line\">./sqlplus test/test</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 在进入sqlplus后的连接</span><br><span class=\"line\">conn test/test</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_ID IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS &apos;手机号段&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_CITY IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS &apos;固话区号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS &apos;邮政编码&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_MOBILES  IS &apos;号段表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">create table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);</span><br><span class=\"line\">--*注：因f_id导入时缺少数据，所有先不设置为PK.</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_ID IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_NO IS &apos;通话号码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS &apos;开始时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_END_TIME IS &apos;结束时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_DURATION IS &apos;通话时长&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_RECORDS.F_MOBILE IS &apos;手机号码标志&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_RECORDS  IS &apos;通话清单表&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建ctl文件导入csv数据\"><a href=\"#创建ctl文件导入csv数据\" class=\"headerlink\" title=\"创建ctl文件导入csv数据\"></a>创建ctl文件导入csv数据</h3><p>进入<code>external_data</code>路径下并创建以下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cd /home/oracle/data</span><br><span class=\"line\"><span class=\"meta\">$</span> vi control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">$</span> vi control_records.ctl</span><br></pre></td></tr></table></figure>\n<p><code>control_mobiles.ctl:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD DATA</span><br><span class=\"line\">CHARACTERSET UTF8</span><br><span class=\"line\">INFILE &apos;/home/oracle/data/mobiles.csv&apos;</span><br><span class=\"line\">TRUNCATE INTO TABLE t_mobiles</span><br><span class=\"line\">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class=\"line\">TRAILING NULLCOLS</span><br><span class=\"line\">(</span><br><span class=\"line\">\tF_ID,</span><br><span class=\"line\">\tF_MOBILE_HEAD,</span><br><span class=\"line\">\tF_PROVINCE,</span><br><span class=\"line\">\tF_CITY,</span><br><span class=\"line\">\tF_PLATFORM,</span><br><span class=\"line\">\tF_TEL_HEAD,</span><br><span class=\"line\">\tF_ZIPCODE</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>control_records.ctl:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD DATA</span><br><span class=\"line\">CHARACTERSET UTF8</span><br><span class=\"line\">INFILE &apos;/home/oracle/data/records.csv&apos;</span><br><span class=\"line\">TRUNCATE INTO TABLE t_records</span><br><span class=\"line\">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class=\"line\">TRAILING NULLCOLS</span><br><span class=\"line\">(</span><br><span class=\"line\">\tF_NO,</span><br><span class=\"line\">\tF_BEGIN_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class=\"line\">\tF_END_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class=\"line\">\tF_DURATION INTEGER EXTERNAL</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在该路径下执行导入操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> $ORACLE_HOME/bin/sqlldr userid=test/test control=control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">$</span> $ORACLE_HOME/bin/sqlldr userid=test/test control=control_records.ctl</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>教程中命令为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> $ sqlldr userid=test/test@orcl control=control_mobiles.ctl</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>即在导入时指定<code>连接字符串</code>（这里的orcl实际上是连接字符串的别名），其在<code>$ORACLE_HOME/network/admin/tnsname.ora</code>中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。</p>\n<p>既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是<code>连接字符串</code>和<code>服务名</code>的区别，oracle有个默认服务名<code>XE</code>，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; jdbc:oracle:thin:@localhost:1521:XE</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> # 命令格式：sqlplus username/password@host:port/service_name</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键</span><br><span class=\"line\">create sequence seq_records increment by 1 start with 1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键</span><br><span class=\"line\">update t_records set f_id=seq_records.nextval;</span><br><span class=\"line\">alter table t_records add constraint t_records_pk primary key (f_id);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 3、创建并初始化同步锁表，用于多线程同步控制</span><br><span class=\"line\">CREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));</span><br><span class=\"line\">COMMENT ON COLUMN T_LOCK.F_NAME IS &apos;锁名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOCK.F_INDEX IS &apos;锁的当前值&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_LOCK  IS &apos;同步锁表&apos;;</span><br><span class=\"line\">insert into T_LOCK values(&apos;_RECORD_INDEX&apos;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 4、在电话号段表中创建唯一性索引，提高号段检索速度</span><br><span class=\"line\">create unique index uniq_mobile_head on t_mobiles(f_mobile_head);</span><br><span class=\"line\">update t_mobiles set f_province = &apos;内蒙古&apos; where f_province = &apos;内蒙&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 5、创建日志表，用于记录程序执行过程中的日志信息。</span><br><span class=\"line\">create table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_TIME IS &apos;日志时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_HEAD IS &apos;日志类型标志&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_LOG.F_CONTENT IS &apos;日志内容&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_LOG  IS &apos;日志表&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建函数和存储过程\"><a href=\"#创建函数和存储过程\" class=\"headerlink\" title=\"创建函数和存储过程\"></a>创建函数和存储过程</h2><h3 id=\"声明函数和存储过程\"><a href=\"#声明函数和存储过程\" class=\"headerlink\" title=\"声明函数和存储过程\"></a>声明函数和存储过程</h3><ul>\n<li>函数is_mobile，判断通话号码是否为手机号码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--函数：判断通话号码是否为手机号码</span><br><span class=\"line\">CREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2)</span><br><span class=\"line\">    RETURN BOOLEAN IS</span><br><span class=\"line\"></span><br><span class=\"line\">    v_phone VARCHAR2(20);</span><br><span class=\"line\">    v_head VARCHAR2(2);</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --检查参数func</span><br><span class=\"line\">    IF phone IS NULL THEN</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--去除前后空格</span><br><span class=\"line\">    v_phone := TRIM(phone);</span><br><span class=\"line\"></span><br><span class=\"line\">\t--去除号码前面的0</span><br><span class=\"line\">    IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class=\"line\">        v_phone := substr(v_phone, 2);</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--检查手机号码长度</span><br><span class=\"line\">    IF substr(v_phone,0,1) &lt;&gt; &apos;1&apos; OR LENGTH(v_phone) &lt;&gt; 11 THEN</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--截取号码前两位</span><br><span class=\"line\">    v_head := substr(v_phone,1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF v_head = &apos;13&apos; OR v_head = &apos;14&apos; OR v_head =&apos;15&apos; OR v_head =&apos;17&apos; OR v_head = &apos;18&apos; THEN</span><br><span class=\"line\">        RETURN TRUE;</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">        RETURN FALSE;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程init，清空t_log，同时t_lock置零</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：初始化测试数据</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE init IS</span><br><span class=\"line\">    CURSOR job_cursor IS SELECT JOB FROM user_jobs;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">\t--重置处理位置为0</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;update t_lock set f_index=0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--清除日志表中的记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;truncate table t_log&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--重置话单表中的记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1&apos;;</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    FOR tmp_job IN job_cursor LOOP</span><br><span class=\"line\">        dbms_job.broken(tmp_job.JOB,TRUE,sysdate);</span><br><span class=\"line\">        dbms_job.REMOVE(tmp_job.JOB);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程print，打印日志，存到T_LOG表中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：打印日志</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">\t--dbms_output.put_line(to_char(&apos;yyyy-mm-dd hh24:mi:ss&apos;)||&apos;,&apos;||prefix||&apos;,&apos;||content);</span><br><span class=\"line\">\tINSERT INTO t_log VALUES(sysdate,prefix, content);</span><br><span class=\"line\">\tCOMMIT;</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">\tWHEN OTHERS THEN</span><br><span class=\"line\">\t\tdbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">\t\tdbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程show，显示当前处理情况</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：显示当前处理情况</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE show IS</span><br><span class=\"line\">\t--待处理记录总数</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--当前日志表记录总数</span><br><span class=\"line\">    v_log_count NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--当前数据处理位置</span><br><span class=\"line\">    v_current_index NUMBER;</span><br><span class=\"line\"></span><br><span class=\"line\">\t--用户Job表游标</span><br><span class=\"line\">    CURSOR job_cursor IS SELECT * FROM user_jobs;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_log_count FROM t_log;</span><br><span class=\"line\">    SELECT f_index INTO v_current_index FROM t_lock;</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdbms_output.put_line(&apos;log count: &apos;||v_log_count);</span><br><span class=\"line\">    dbms_output.put_line(&apos;record count: &apos;||v_record_count);</span><br><span class=\"line\">    dbms_output.put_line(&apos;current index: &apos;||v_current_index);</span><br><span class=\"line\"></span><br><span class=\"line\">\t--清除用户job记录</span><br><span class=\"line\">    FOR tmp_job IN job_cursor LOOP</span><br><span class=\"line\">        dbms_output.put_line(&apos;job:&apos;||tmp_job.JOB||&apos;,broken:&apos;||tmp_job.broken||&apos;,total_time:&apos;||tmp_job.total_time||&apos;,failures:&apos;||tmp_job.failures||&apos;,interval:&apos;||tmp_job.INTERVAL||&apos;,last_sec:&apos;||tmp_job.last_sec||&apos;,next_sec:&apos;||tmp_job.next_sec);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程process_data，提交一个job处理数据</li>\n</ul>\n<blockquote>\n<p><strong>共享锁和排它锁:</strong></p>\n<ul>\n<li><p>当某事务对数据添加共享锁时，此时该事务<code>只能读不能写</code>，其他事务只能对该数据添加共享锁，而不能添加排它锁</p>\n</li>\n<li><p>当某事务对数据添加排它锁时，此时该事务<code>既能读又能写</code>，其他事务不能对该数据添加任何锁</p>\n</li>\n</ul>\n<p><strong>autocommit需要关掉:</strong></p>\n<p>假设现在有三个job对T_LOCK表进行并发读写，如下：</p>\n<p><img src=\"/images/image-20181124202306595.png\" alt=\"image-20181124202306595\"></p>\n<p>步骤如下：</p>\n<p><img src=\"/images/锁.png\" alt=\"锁\"></p>\n<p>阻塞情况：</p>\n<p><img src=\"/images/锁2.png\" alt=\"锁2\"></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：处理数据</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS</span><br><span class=\"line\">    --定义常量</span><br><span class=\"line\">    c_record_index CONSTANT VARCHAR2(20)   :=&apos;_RECORD_INDEX&apos;;</span><br><span class=\"line\">    c_process_prefix CONSTANT VARCHAR2(20) := &apos;[  PROCESS ]&apos;;</span><br><span class=\"line\">    c_select_record_sql VARCHAR2(100)  := &apos;select * from t_records where f_id &gt;= :x and f_id &lt;= :y&apos;;</span><br><span class=\"line\">    c_select_mobile_sql VARCHAR2(100)  := &apos;select * from t_mobiles where f_mobile_head = :x&apos;;</span><br><span class=\"line\">    c_update_mobile_sql VARCHAR2(100)  := &apos;update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z&apos;;</span><br><span class=\"line\">    c_update_record_sql VARCHAR2(100)  := &apos;update t_records set f_mobile = 0 where f_id = :n&apos;;</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\">    v_current_index NUMBER;</span><br><span class=\"line\">    v_begin_index NUMBER;</span><br><span class=\"line\">    v_end_index NUMBER;</span><br><span class=\"line\">    v_id NUMBER;</span><br><span class=\"line\">    v_phone VARCHAR2(20);</span><br><span class=\"line\">    v_province VARCHAR2(20);</span><br><span class=\"line\">    v_platform VARCHAR2(20);</span><br><span class=\"line\">    --定义动态游标</span><br><span class=\"line\">    TYPE ty_record_cursor IS REF CURSOR;</span><br><span class=\"line\">    record_cursor ty_record_cursor;</span><br><span class=\"line\">    mobile_cursor ty_record_cursor;</span><br><span class=\"line\">    v_record_row t_records%rowtype;</span><br><span class=\"line\">    v_mobile_row t_mobiles%rowtype;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], running...&apos;);</span><br><span class=\"line\">    --获取待处理的记录总数</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], records count: &apos;||v_record_count);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">        --获取记录锁</span><br><span class=\"line\">        SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], current index: &apos;||v_current_index);</span><br><span class=\"line\">        IF v_current_index = v_record_count THEN</span><br><span class=\"line\">            PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], finished.&apos;);</span><br><span class=\"line\">            EXIT;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        --记录本次处理的开始和结束记录位置</span><br><span class=\"line\">        v_end_index := v_current_index + batch_size;</span><br><span class=\"line\">        IF v_end_index &gt; v_record_count THEN</span><br><span class=\"line\">            v_end_index := v_record_count;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        --提交事务，释放锁</span><br><span class=\"line\">        UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index;</span><br><span class=\"line\">        COMMIT;</span><br><span class=\"line\">        --计算开始位置</span><br><span class=\"line\">        v_begin_index := v_current_index +1;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], begin index:&apos;||v_begin_index||&apos;, end index:&apos;||v_end_index);</span><br><span class=\"line\">        --test：dbms_lock.sleep(5);</span><br><span class=\"line\">        --查询一批记录进行逐个处理</span><br><span class=\"line\">        OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index;</span><br><span class=\"line\">        LOOP</span><br><span class=\"line\">            FETCH record_cursor INTO v_record_row;</span><br><span class=\"line\">            EXIT WHEN record_cursor%notfound;</span><br><span class=\"line\">            v_id    := v_record_row.f_id;</span><br><span class=\"line\">            v_phone := v_record_row.f_no;</span><br><span class=\"line\">            IF is_mobile(v_phone) THEN</span><br><span class=\"line\">                v_phone := TRIM(v_phone);</span><br><span class=\"line\">                IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class=\"line\">                    v_phone := substr(v_phone, 2);</span><br><span class=\"line\">                END IF;</span><br><span class=\"line\">                --PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], id:&apos;||v_id||&apos;, phone:&apos;||v_phone);</span><br><span class=\"line\">                --更新话单记录中的省份、运营商以及手机类型标志</span><br><span class=\"line\">                OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7);</span><br><span class=\"line\">                    FETCH mobile_cursor INTO v_mobile_row;</span><br><span class=\"line\">                    v_province := v_mobile_row.f_province;</span><br><span class=\"line\">                    v_platform := v_mobile_row.f_platform;</span><br><span class=\"line\">                    --FETCH mobile_cursor INTO v_province, v_platform;</span><br><span class=\"line\">                CLOSE mobile_cursor;</span><br><span class=\"line\">\t\t\t\t--更新话单记录的运营商、省份地区信息</span><br><span class=\"line\">                EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id;</span><br><span class=\"line\">            ELSE</span><br><span class=\"line\">                --更新话单记录为非移动号码类型</span><br><span class=\"line\">                EXECUTE IMMEDIATE c_update_record_sql USING v_id;</span><br><span class=\"line\">            END IF;</span><br><span class=\"line\">\t\t\t--提交事务</span><br><span class=\"line\">            COMMIT;</span><br><span class=\"line\">        END LOOP;</span><br><span class=\"line\">        CLOSE record_cursor;</span><br><span class=\"line\">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], processed index: &apos;||v_end_index);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程generate_csv_report，生成报表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--存储过程：生成报表</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE generate_csv_report IS</span><br><span class=\"line\">\tc_report_prefix CONSTANT VARCHAR2(20) := &apos;[  REPORT  ]&apos;;</span><br><span class=\"line\">    v_report_1  UTL_FILE.FILE_TYPE;</span><br><span class=\"line\">    v_report_2  UTL_FILE.FILE_TYPE;</span><br><span class=\"line\">    CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC;</span><br><span class=\"line\">    cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --生成报表1，根据运营商分类汇总各省份地区的通话量</span><br><span class=\"line\">    v_report_1 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report1.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class=\"line\">    FOR cur_tmp IN report_1_cursor LOOP</span><br><span class=\"line\">        UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || &apos;,&apos; || cur_tmp.f_province || &apos;,&apos; || cur_tmp.total);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    UTL_FILE.FCLOSE(v_report_1);</span><br><span class=\"line\">    --生成报表2，根据各省份地区汇总各运营商的通话量</span><br><span class=\"line\">    v_report_2 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report2.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class=\"line\">    FOR cur_tmp IN report_2_cursor LOOP</span><br><span class=\"line\">        UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || &apos;,&apos; || cur_tmp.f_platform || &apos;,&apos; ||  cur_tmp.total);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    UTL_FILE.FCLOSE(v_report_2);</span><br><span class=\"line\">    PRINT(c_report_prefix, &apos;generated reports.&apos;);</span><br><span class=\"line\">    EXCEPTION</span><br><span class=\"line\">        WHEN OTHERS THEN</span><br><span class=\"line\">            dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">            dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量</li>\n</ul>\n<blockquote>\n<p><strong><a href=\"https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_job.htm#BABHCBFD\" target=\"_blank\" rel=\"noopener\">dbms_job</a>:</strong></p>\n<p>用于管理job的package</p>\n<p><strong>oracle限定的job_queue_processes:</strong></p>\n<p>oracle中有一个对任务可启动进程的数量进行限制的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; SQL&gt; show parameter job_queue_processes;</span><br><span class=\"line\">&gt; NAME\t\t\t\t     TYPE\t VALUE</span><br><span class=\"line\">&gt; ----------------------------------------------------------</span><br><span class=\"line\">&gt; job_queue_processeses\t\t integer\t 10</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; SQL&gt; alter system set job_queue_processes=0...1000;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>使用ctrl+c是无法停止job的:</strong></p>\n<p>可使用<code>top</code>命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS</span><br><span class=\"line\">    --定义常量</span><br><span class=\"line\">    c_record_index CONSTANT VARCHAR2(20)\t:=&apos;_RECORD_INDEX&apos;;</span><br><span class=\"line\">\t  c_analysis_prefix CONSTANT VARCHAR2(20)\t:= &apos;[ ANALYSIS ]&apos;;</span><br><span class=\"line\">    --当前处理位置</span><br><span class=\"line\">    v_record_index NUMBER;</span><br><span class=\"line\">    --待处理的记录总数</span><br><span class=\"line\">    v_record_count NUMBER;</span><br><span class=\"line\">    --保存临时创建的job no</span><br><span class=\"line\">    v_tmp_jobno NUMBER;</span><br><span class=\"line\">    --开始结束时间</span><br><span class=\"line\">    v_begin_time NUMBER;</span><br><span class=\"line\">    v_process_end_time NUMBER;</span><br><span class=\"line\">    v_analysis_end_time NUMBER;</span><br><span class=\"line\">    --异常变量</span><br><span class=\"line\">    e_invalid_input EXCEPTION;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; start analysis...&apos;);</span><br><span class=\"line\">    --输入参数检查</span><br><span class=\"line\">    IF job_count &lt; 1 OR batch_size&lt;1 THEN</span><br><span class=\"line\">        RAISE e_invalid_input;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; checked input parameters.&apos;);</span><br><span class=\"line\">    --记录开始时间</span><br><span class=\"line\">    v_begin_time := dbms_utility.get_time;</span><br><span class=\"line\">    --获取待处理的记录总数</span><br><span class=\"line\">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; records count: &apos;||v_record_count);</span><br><span class=\"line\">    --开始计算重置为0</span><br><span class=\"line\">    UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index;</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; reset index to zero.&apos;);</span><br><span class=\"line\">    --提交多个job</span><br><span class=\"line\">    FOR I IN 1.. job_count LOOP</span><br><span class=\"line\">        dbms_job.submit(v_tmp_jobno,&apos;begin process_data(&apos;||I||&apos;,&apos;||batch_size||&apos;); end;&apos;);</span><br><span class=\"line\">        PRINT(c_analysis_prefix, &apos; submitted new job, no: &apos;||v_tmp_jobno);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos; created &apos;||job_count||&apos; jobs.&apos;);</span><br><span class=\"line\">    --定时检查处理进度</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">        SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index;</span><br><span class=\"line\">        PRINT(c_analysis_prefix, &apos; current index: &apos;||v_record_index);</span><br><span class=\"line\">        IF v_record_index = v_record_count THEN</span><br><span class=\"line\">            PRINT(c_analysis_prefix, &apos; processed all records, exiting...&apos;);</span><br><span class=\"line\">            EXIT;</span><br><span class=\"line\">        ELSE</span><br><span class=\"line\">            dbms_lock.sleep(5);--暂停等待5秒</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    v_process_end_time := dbms_utility.get_time;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    --分类汇总产生报表</span><br><span class=\"line\">    generate_csv_report;</span><br><span class=\"line\">    --结束时间</span><br><span class=\"line\">    v_analysis_end_time := dbms_utility.get_time;</span><br><span class=\"line\">    PRINT(c_analysis_prefix, &apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class=\"line\">--异常捕获部分</span><br><span class=\"line\">EXCEPTION</span><br><span class=\"line\">    WHEN e_invalid_input THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Invalid input values, job_count:&apos;||job_count||&apos;, batch_size:&apos;||batch_size);</span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class=\"line\">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 调用多次analysis，指定不同的job数和批数</span><br><span class=\"line\">create or replace procedure mul_analysis is</span><br><span class=\"line\">    -- 最小job数</span><br><span class=\"line\">    v_begin_job_no NUMBER := 3;</span><br><span class=\"line\">    -- 最大job数</span><br><span class=\"line\">    v_end_job_no NUMBER := 8;</span><br><span class=\"line\">    -- 每次增长的batch数量</span><br><span class=\"line\">    v_range NUMBER := 2000;</span><br><span class=\"line\">    -- 最小batch数量</span><br><span class=\"line\">    v_begin_range NUMBER := 1000;</span><br><span class=\"line\">    -- 最大batch数量</span><br><span class=\"line\">    v_end_range NUMBER := 10000;</span><br><span class=\"line\">    -- 当前range</span><br><span class=\"line\">    range NUMBER;</span><br><span class=\"line\">    begin</span><br><span class=\"line\">        for I in v_begin_job_no..v_end_job_no LOOP</span><br><span class=\"line\">            range := v_begin_range;</span><br><span class=\"line\">            LOOP</span><br><span class=\"line\">                -- 清洗表</span><br><span class=\"line\">                init();</span><br><span class=\"line\">                -- 分析</span><br><span class=\"line\">                analysis(I, range);</span><br><span class=\"line\">                range := range+v_range;</span><br><span class=\"line\">\t\t\t\t-- range增长到10000则停止</span><br><span class=\"line\">                if range &gt; v_end_range then</span><br><span class=\"line\">                    exit;</span><br><span class=\"line\">                end if;</span><br><span class=\"line\">            end loop;</span><br><span class=\"line\">        end loop;</span><br><span class=\"line\">    end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行函数和存储过程\"><a href=\"#执行函数和存储过程\" class=\"headerlink\" title=\"执行函数和存储过程\"></a>执行函数和存储过程</h3><blockquote>\n<p>在sqlplus中执行函数和存储过程之前需先打开serveroutput，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; SQL&gt; set serveroutput on;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这是因为存储过程中用到了<code>dbms_output.put_line</code>，上述语句是相当于告诉pl/sql引擎将<code>dbms_output.put_line</code>传递到缓冲区的内容输出到主控制台上。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">call init();</span><br><span class=\"line\">call analysis(4,1000);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><p>通过执行<code>mul_analysis()</code>对一系列job和batch组合值进行测试，结果如下：</p>\n<p><img src=\"/images/image-20181124205409162.png\" alt=\"image-20181124205409162\"></p>\n<h1 id=\"Lesson-2\"><a href=\"#Lesson-2\" class=\"headerlink\" title=\"Lesson 2\"></a>Lesson 2</h1><h2 id=\"创建用户并分配权限-1\"><a href=\"#创建用户并分配权限-1\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user audittest identified by audittest;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配权限\"><a href=\"#分配权限\" class=\"headerlink\" title=\"分配权限\"></a>分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to audittest;</span><br><span class=\"line\">grant execute on dbms_lock to audittest;</span><br><span class=\"line\">alter user audittest quota unlimited on users;</span><br><span class=\"line\">conn audittest/audittest;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表及其他对象\"><a href=\"#创建表及其他对象\" class=\"headerlink\" title=\"创建表及其他对象\"></a>创建表及其他对象</h2><h3 id=\"创建表-1\"><a href=\"#创建表-1\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><blockquote>\n<p>注意：</p>\n<p>这里在创建表时添加了<code>ENABLE</code>限制条件，oracle中对表和列的约束有<code>Enable</code>/<code>Disable</code>(启用/禁用)和<code>Validate</code>/<code>NoValidate</code>(验证/不验证)</p>\n<p>举两个例子：</p>\n<p><strong>需更改的错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，对name字段添加唯一性约束</span><br><span class=\"line\">&gt; drop table T_TEST;</span><br><span class=\"line\">&gt; create table T_TEST(</span><br><span class=\"line\">&gt;   id int primary key ,</span><br><span class=\"line\">&gt;   name varchar2(10) constraint unique_name unique disable</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错</span><br><span class=\"line\">&gt; begin</span><br><span class=\"line\">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt; -- 修改掉违反唯一性约束的值</span><br><span class=\"line\">&gt; update T_TEST set name=&apos;chen&apos; where id=3;</span><br><span class=\"line\">&gt; -- 使得唯一性约束生效</span><br><span class=\"line\">&gt; alter table T_TEST modify constraint unique_name enable;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>需保留的错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，无约束</span><br><span class=\"line\">&gt; drop table T_TEST;</span><br><span class=\"line\">&gt; create table T_TEST(</span><br><span class=\"line\">&gt;   id int primary key ,</span><br><span class=\"line\">&gt;   name varchar2(10)</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; -- 一些old的记录本身可能存在重复数据</span><br><span class=\"line\">&gt; begin</span><br><span class=\"line\">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class=\"line\">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt; select * from T_TEST;</span><br><span class=\"line\">&gt; -- 对name列创建非唯一性索引</span><br><span class=\"line\">&gt; create index i_name on T_TEST(name);</span><br><span class=\"line\">&gt; -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引</span><br><span class=\"line\">&gt; alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;</span><br><span class=\"line\">&gt; -- 此时无法插入name相同的数据了</span><br><span class=\"line\">&gt; insert into T_TEST values (4, &apos;tan&apos;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\">\t&quot;F_MANAGER&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_CODE&quot; IS &apos;部门编号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_MANAGER&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_CODE&quot; IS &apos;员工编号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_TELEPHONE&quot; IS &apos;固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class=\"line\">\t PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class=\"line\">\t CONSTRAINT &quot;T_CUSTOMER_HISTORY_PK&quot; PRIMARY KEY (&quot;F_ID&quot;, &quot;F_VERSION&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息历史表</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;  IS &apos;客户信息历史表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--审计表</span><br><span class=\"line\">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_TABLE_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_ROW_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NEW_VERSION&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_COLUMN_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_OLD_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_NEW_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_OPERATOR_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_OPERATION_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t CONSTRAINT &quot;T_AUDIT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_TABLE_NAME&quot; IS &apos;表名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ROW_ID&quot; IS &apos;业务数据主键&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VERSION&quot; IS &apos;新的版本号&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_COLUMN_NAME&quot; IS &apos;字段&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OLD_VALUE&quot; IS &apos;原值&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VALUE&quot; IS &apos;新值&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATOR_ID&quot; IS &apos;操作用户&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATION_TIME&quot; IS &apos;操作时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;  IS &apos;审计表&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建索引、序列\"><a href=\"#创建索引、序列\" class=\"headerlink\" title=\"创建索引、序列\"></a>创建索引、序列</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 创建复合索引</span><br><span class=\"line\">CREATE INDEX &quot;AUDITTEST&quot;.&quot;IDX_TABLE_ROWID&quot; ON &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot; (&quot;F_TABLE_NAME&quot;, &quot;F_ROW_ID&quot;) ;</span><br><span class=\"line\">-- 创建序列</span><br><span class=\"line\">CREATE SEQUENCE  SEQ_AUDIT_PK  INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--创建触发器</span><br><span class=\"line\">create or replace trigger trg_customer_audit</span><br><span class=\"line\">before update on t_customer</span><br><span class=\"line\">for each row</span><br><span class=\"line\">declare</span><br><span class=\"line\">    c_insert_sql constant varchar2(100) := &apos;insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)&apos;;</span><br><span class=\"line\">    c_table_name constant varchar2(20)  := &apos;T_CUSTOMER&apos;;</span><br><span class=\"line\">    v_column_name varchar2(20);</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --记录当前数据到历史表</span><br><span class=\"line\">    insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version);</span><br><span class=\"line\"></span><br><span class=\"line\">    --递增记录的版本号</span><br><span class=\"line\">    :new.f_version := :old.f_version+1;</span><br><span class=\"line\"></span><br><span class=\"line\">    --判断字段变化</span><br><span class=\"line\">    if updating(&apos;F_LINKMAN&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;联系人&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_MOBILE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;手机号码&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_TELEPHONE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;固定电话&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_EMAIL&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;电子邮箱&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_ADDRESS&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;联系地址&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    if updating(&apos;F_BALANCE&apos;) then</span><br><span class=\"line\">        v_column_name := &apos;余额&apos;;</span><br><span class=\"line\">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--创建过程</span><br><span class=\"line\">--过程：重设序列值</span><br><span class=\"line\">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class=\"line\">IS</span><br><span class=\"line\">    v_val NUMBER;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建过程\"><a href=\"#创建过程\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h3><h4 id=\"过程reset-seq\"><a href=\"#过程reset-seq\" class=\"headerlink\" title=\"过程reset_seq\"></a>过程reset_seq</h4><blockquote>\n<p>将序列为输入参数seq_name的值重置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：重设序列值</span><br><span class=\"line\">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class=\"line\">IS</span><br><span class=\"line\">    v_val NUMBER;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class=\"line\"></span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"过程init\"><a href=\"#过程init\" class=\"headerlink\" title=\"过程init\"></a>过程init</h4><blockquote>\n<p>truncate(截断)所有表，重设序列，并添加初始值</p>\n<p>注意：</p>\n<p><strong><code>truncate</code>与<code>delete</code>的区别</strong>：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。</p>\n<p>truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。</p>\n<p>但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; -- 创建表，f_id字段引用T_TEST的主码id</span><br><span class=\"line\">&gt; drop table T_TEST2;</span><br><span class=\"line\">&gt; create table T_TEST2(</span><br><span class=\"line\">&gt;   id1 int primary key ,</span><br><span class=\"line\">&gt;   f_id int,</span><br><span class=\"line\">&gt;   constraint fk</span><br><span class=\"line\">&gt;   foreign key (f_id)</span><br><span class=\"line\">&gt;     references T_TEST(id) on delete cascade</span><br><span class=\"line\">&gt; );</span><br><span class=\"line\">&gt; select *</span><br><span class=\"line\">&gt; from T_TEST2;</span><br><span class=\"line\">&gt; insert into T_TEST2 values(1, 1);</span><br><span class=\"line\">&gt; -- 可级联删除</span><br><span class=\"line\">&gt; delete from T_TEST;</span><br><span class=\"line\">&gt; -- 将外码置为禁用</span><br><span class=\"line\">&gt; alter table T_TEST2 modify constraint fk disable validate ;</span><br><span class=\"line\">&gt; -- 可截断（当不禁用外码时无法截断）</span><br><span class=\"line\">&gt; truncate table T_TEST;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">create or replace procedure init is</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    execute immediate &apos;truncate table t_audit&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_customer_history&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_customer&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_user&apos;;</span><br><span class=\"line\">    execute immediate &apos;truncate table t_department&apos;;</span><br><span class=\"line\">    --重调序列</span><br><span class=\"line\">    reset_seq(&apos;seq_audit_pk&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    insert into t_department values(1,&apos;销售部&apos;,&apos;D01&apos;,NULL,&apos;李明&apos;,&apos;备注1...&apos;);</span><br><span class=\"line\">    insert into t_department values(2,&apos;销售部-北京分部&apos;,&apos;D0101&apos;,1,&apos;赵军&apos;,&apos;备注2...&apos;);</span><br><span class=\"line\">    insert into t_department values(3,&apos;销售部-上海分部&apos;,&apos;D0102&apos;,1,&apos;张华&apos;,&apos;备注3...&apos;);</span><br><span class=\"line\">    insert into t_department values(4,&apos;销售部-深圳分部&apos;,&apos;D0103&apos;,1,&apos;王兵&apos;,&apos;备注4...&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    insert into t_user values(1,1,&apos;仲芳芳&apos;,&apos;U8201&apos;,&apos;女&apos;,&apos;13771234101&apos;,&apos;02131231011&apos;,&apos;use1@samtech.com&apos;,&apos;备注1...&apos;);</span><br><span class=\"line\">    insert into t_user values(2,1,&apos;李明申&apos;,&apos;U8202&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;02131231012&apos;,&apos;use2@samtech.com&apos;,&apos;备注2...&apos;);</span><br><span class=\"line\">    insert into t_user values(3,2,&apos;张雪&apos;, &apos;U8203&apos;,&apos;女&apos;,&apos;13771234103&apos;,&apos;02131231013&apos;,&apos;use3@samtech.com&apos;,&apos;备注3...&apos;);</span><br><span class=\"line\">    insert into t_user values(4,2,&apos;王刚&apos;, &apos;U8204&apos;,&apos;男&apos;,&apos;13771234104&apos;,&apos;02131231014&apos;,&apos;use4@samtech.com&apos;,&apos;备注4...&apos;);</span><br><span class=\"line\">    insert into t_user values(5,3,&apos;赵昌日&apos;,&apos;U8205&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;02131231015&apos;,&apos;use5@samtech.com&apos;,&apos;备注5...&apos;);</span><br><span class=\"line\">    insert into t_user values(6,3,&apos;孙晓华&apos;,&apos;U8206&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;02131231016&apos;,&apos;use6@samtech.com&apos;,&apos;备注6...&apos;);</span><br><span class=\"line\">    insert into t_user values(7,4,&apos;陈亚男&apos;,&apos;U8207&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;02131231017&apos;,&apos;use7@samtech.com&apos;,&apos;备注7...&apos;);</span><br><span class=\"line\">    insert into t_user values(8,4,&apos;刘兵超&apos;,&apos;U8208&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;02131231018&apos;,&apos;use8@samtech.com&apos;,&apos;备注8...&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    insert into t_customer</span><br><span class=\"line\">    values(1,&apos;C1808001&apos;,&apos;上海市永辉电子股份有限公司&apos;,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;02135681589&apos;,&apos;ming@google.com&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;上海市&apos;,12082,&apos;上海中远&apos;,&apos;备注...&apos;,&apos;张娜&apos;,0,1,sysdate,1,sysdate,1);</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改客户信息过程\"><a href=\"#修改客户信息过程\" class=\"headerlink\" title=\"修改客户信息过程\"></a>修改客户信息过程</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：修改客户地址</span><br><span class=\"line\">create or replace procedure modify_address</span><br><span class=\"line\">(p_row_id in number,p_address in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_address,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated address successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户余额</span><br><span class=\"line\">create or replace procedure modify_balance</span><br><span class=\"line\">(p_row_id in number,p_balance in number, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_balance,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated balance successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户电子邮箱</span><br><span class=\"line\">create or replace procedure modify_email</span><br><span class=\"line\">(p_row_id in number,p_email in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_email,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated email successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户联系人</span><br><span class=\"line\">create or replace procedure modify_linkman</span><br><span class=\"line\">(p_row_id in number,p_linkman_name in varchar2, p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_linkman_name,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated linkman name successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改客户联系人信息</span><br><span class=\"line\">create or replace procedure modify_linkman_info</span><br><span class=\"line\">(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2,</span><br><span class=\"line\"> p_telephone in varchar2,p_email in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_linkman=:1, f_mobile=:2,</span><br><span class=\"line\">    f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6&apos;</span><br><span class=\"line\">    using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated linkman info successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改联系手机</span><br><span class=\"line\">create or replace procedure modify_mobile</span><br><span class=\"line\">(p_row_id in number,p_mobile in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_mobile,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">--过程：修改联系固话</span><br><span class=\"line\">create or replace procedure modify_telephone</span><br><span class=\"line\">(p_row_id in number,p_telephone in varchar2,p_operator in number)</span><br><span class=\"line\">as</span><br><span class=\"line\">begin</span><br><span class=\"line\">    --校验参数省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">    execute immediate &apos;update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class=\"line\">    using p_telephone,p_operator,p_row_id;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --异常捕获省略</span><br><span class=\"line\">    --...</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行\"><a href=\"#执行\" class=\"headerlink\" title=\"执行\"></a>执行</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 初始化</span><br><span class=\"line\">call init();</span><br><span class=\"line\"></span><br><span class=\"line\">-- 更改客户信息</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tmodify_linkman(1,&apos;李明顺&apos;,1);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_mobile(1,&apos;13771083211&apos;,2);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_balance(1,20020,3);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_address(1,&apos;中国上海市嘉定区xxx路&apos;,4);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_email(1,&apos;test1@163.com&apos;,5);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_telephone(1,&apos;02183652145&apos;,6);</span><br><span class=\"line\">\tdbms_lock.sleep(1);</span><br><span class=\"line\">\tmodify_linkman_info(1,&apos;张雨轩&apos;,&apos;15332892301&apos;,&apos;02188881111&apos;,&apos;zhangyx@gmail.com&apos;,7);</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\">-- 审计</span><br><span class=\"line\">select * from T_AUDIT;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 回滚客户信息</span><br><span class=\"line\">-- 方法1：</span><br><span class=\"line\">update t_customer a</span><br><span class=\"line\">set(</span><br><span class=\"line\">a.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,</span><br><span class=\"line\">a.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,</span><br><span class=\"line\">a.f_modified_id,a.f_modified_time</span><br><span class=\"line\">)</span><br><span class=\"line\">=</span><br><span class=\"line\">(</span><br><span class=\"line\">select b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,</span><br><span class=\"line\">b.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,</span><br><span class=\"line\">b.f_deleted_tag,5,sysdate</span><br><span class=\"line\">from t_customer_history b where b.f_id=a.f_id and b.f_version=3</span><br><span class=\"line\">)</span><br><span class=\"line\">where a.f_id=1;</span><br><span class=\"line\">-- 方法2：</span><br><span class=\"line\">merge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)</span><br><span class=\"line\">when matched then</span><br><span class=\"line\">update set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,</span><br><span class=\"line\">a.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,</span><br><span class=\"line\">a.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看验证数据</span><br><span class=\"line\">select * from t_customer where f_id=1</span><br><span class=\"line\">union</span><br><span class=\"line\">select * from t_customer_history where f_id=1 and f_version=3;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Lesson-3\"><a href=\"#Lesson-3\" class=\"headerlink\" title=\"Lesson 3\"></a>Lesson 3</h1><h2 id=\"创建用户并分配权限-2\"><a href=\"#创建用户并分配权限-2\" class=\"headerlink\" title=\"创建用户并分配权限\"></a>创建用户并分配权限</h2><h3 id=\"创建用户-1\"><a href=\"#创建用户-1\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">create user permission identified by permission;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分配权限-1\"><a href=\"#分配权限-1\" class=\"headerlink\" title=\"分配权限\"></a>分配权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grant connect,resource to permission;</span><br><span class=\"line\">alter user permisson quota unlimited on users;</span><br><span class=\"line\">conn permission/permission;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表及其他对象-1\"><a href=\"#创建表及其他对象-1\" class=\"headerlink\" title=\"创建表及其他对象\"></a>创建表及其他对象</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><blockquote>\n<p>方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。</p>\n</blockquote>\n<h4 id=\"创建表-2\"><a href=\"#创建表-2\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">--方案一</span><br><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE T_DEPARTMENT</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\">\t&quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;T_USER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;T_CUSTOMER&quot;</span><br><span class=\"line\">(\t&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\">\t&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">\t&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\">\t&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">\t PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建过程-1\"><a href=\"#创建过程-1\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><h5 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE INIT IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(1,&apos;公司&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(2,&apos;行政部&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(3,&apos;销售部&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(4,&apos;电销组&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT VALUES(5,&apos;推销组&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(1,1,&apos;管理员&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(2,3,&apos;李明申&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(3,4,&apos;张雪&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(4,4,&apos;王刚&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(5,4,&apos;赵昌日&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(6,5,&apos;孙晓华&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(7,5,&apos;陈亚男&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(8,5,&apos;刘兵超&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(9,3,&apos;陈彬&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER VALUES(10,3,&apos;王军&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,3,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,4,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,5,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,6,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,7,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,8,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,9,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,10,SYSDATE);</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行-1\"><a href=\"#执行-1\" class=\"headerlink\" title=\"执行\"></a>执行</h4><h5 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\">exec init;</span><br></pre></td></tr></table></figure>\n<h5 id=\"查询自己的客户\"><a href=\"#查询自己的客户\" class=\"headerlink\" title=\"查询自己的客户\"></a>查询自己的客户</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t_customer A WHERE A.f_created_id=&amp;id;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&amp;id</code>是所查询人员的ID</p>\n</blockquote>\n<h5 id=\"查询某领导下属人员的所有客户\"><a href=\"#查询某领导下属人员的所有客户\" class=\"headerlink\" title=\"查询某领导下属人员的所有客户\"></a>查询某领导下属人员的所有客户</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t_user a  where exists(</span><br><span class=\"line\">SELECT 1 FROM t_department b</span><br><span class=\"line\">WHERE a.f_dept_id=b.f_id and b.f_manager_id=&amp;id</span><br><span class=\"line\">CONNECT BY b.F_PARENT_ID = PRIOR b.F_ID</span><br><span class=\"line\">start with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&amp;id));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&amp;id</code>是该领导的ID</p>\n</blockquote>\n<h4 id=\"当部门结构或员工归属调整时，权限编码如何处理？\"><a href=\"#当部门结构或员工归属调整时，权限编码如何处理？\" class=\"headerlink\" title=\"当部门结构或员工归属调整时，权限编码如何处理？\"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>对于方案一，只需要更改员工直属领导ID即可</p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><blockquote>\n<p>方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可</p>\n</blockquote>\n<h4 id=\"创建表-3\"><a href=\"#创建表-3\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--方案二</span><br><span class=\"line\">--部门表</span><br><span class=\"line\">CREATE TABLE T_DEPARTMENT_2</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class=\"line\"> &quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">  CONSTRAINT &quot;T_DEPARTMENT_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">) ;</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_CODE&quot; IS &apos;部门编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_DEPARTMENT_2&quot;  IS &apos;部门表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--用户表</span><br><span class=\"line\">CREATE TABLE &quot;T_USER_2&quot;</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class=\"line\"> &quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class=\"line\"> &quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">  CONSTRAINT &quot;T_USER_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_CODE&quot; IS &apos;用户编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_USER_2&quot;  IS &apos;用户表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">--客户信息表</span><br><span class=\"line\">CREATE TABLE &quot;T_CUSTOMER_2&quot;</span><br><span class=\"line\">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class=\"line\"> &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class=\"line\">    &quot;F_ACCESS_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class=\"line\"> &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class=\"line\">  PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ACCESS_CODE&quot; IS &apos;权限编码&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class=\"line\">COMMENT ON TABLE &quot;T_CUSTOMER_2&quot;  IS &apos;客户信息表2&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建人员更改历史表</span><br><span class=\"line\">CREATE TABLE T_USER_HISTORY(</span><br><span class=\"line\">  ID NUMBER(6,0) PRIMARY KEY ,</span><br><span class=\"line\">  F_ID NUMBER(6,0) ,</span><br><span class=\"line\">  O_DEP_ID NUMBER(6,0) ,</span><br><span class=\"line\">  O_ACCESS_CODE VARCHAR2(50 BYTE) ,</span><br><span class=\"line\">  N_DEP_ID  NUMBER(6,0),</span><br><span class=\"line\">  N_ACCESS_CODE VARCHAR2(50 BYTE),</span><br><span class=\"line\">  TIME DATE</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.ID IS &apos;PK&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.F_ID IS &apos;修改的人员ID&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS &apos;旧的部门&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS &apos;旧的权限&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS &apos;新的部门&apos;;</span><br><span class=\"line\">COMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS &apos;新的权限&apos;;</span><br><span class=\"line\">COMMENT ON TABLE T_USER_HISTORY IS &apos;用户权限更改历史&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建过程-2\"><a href=\"#创建过程-2\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><h5 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--过程：数据初始化</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE INIT2 IS</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    --清除数据</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT_2&apos;;</span><br><span class=\"line\">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_HISTORY&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入部门</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(1,&apos;公司&apos;,&apos;1&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(2,&apos;行政部&apos;,&apos;101&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(3,&apos;销售部&apos;,&apos;102&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(4,&apos;电销组&apos;,&apos;10201&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class=\"line\">    INSERT INTO T_DEPARTMENT_2 VALUES(5,&apos;推销组&apos;,&apos;10202&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入用户</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(1,1,&apos;管理员&apos;,&apos;1&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(2,3,&apos;李明申&apos;,&apos;102&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(3,4,&apos;张雪&apos;,  &apos;10201&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(4,4,&apos;王刚&apos;,  &apos;1020101&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(5,4,&apos;赵昌日&apos;,&apos;1020102&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(6,5,&apos;孙晓华&apos;,&apos;10202&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(7,5,&apos;陈亚男&apos;,&apos;1020201&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(8,5,&apos;刘兵超&apos;,&apos;1020202&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(9,3,&apos;陈彬&apos;,  &apos;10203&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class=\"line\">    INSERT INTO T_USER_2 VALUES(10,3,&apos;王军&apos;, &apos;10204&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    --插入客户</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,&apos;10201&apos;,3,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,&apos;1020101&apos;,4,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,&apos;1020102&apos;,5,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,&apos;10202&apos;,6,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,&apos;1020201&apos;,7,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,&apos;1020202&apos;,8,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,&apos;10203&apos;,9,SYSDATE);</span><br><span class=\"line\">    INSERT INTO T_CUSTOMER_2 VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,&apos;10204&apos;,10,SYSDATE);</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">END;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<h5 id=\"将某员工调换到某部门\"><a href=\"#将某员工调换到某部门\" class=\"headerlink\" title=\"将某员工调换到某部门\"></a>将某员工调换到某部门</h5><p><img src=\"/images/image-20181126025537963.png\" alt=\"image-20181126025537963\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 更改用户到特定部门</span><br><span class=\"line\">CREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS</span><br><span class=\"line\">  -- 旧部门</span><br><span class=\"line\">  O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE;</span><br><span class=\"line\">  -- 旧权限</span><br><span class=\"line\">  O_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 部门权限前缀</span><br><span class=\"line\">  DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 部门当前人数</span><br><span class=\"line\">  DEP_USER_COUNT T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 本部门下的部门数</span><br><span class=\"line\">  DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 新权限</span><br><span class=\"line\">  N_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class=\"line\">  -- 更新该员工权限</span><br><span class=\"line\">  C_UPDATE_USER VARCHAR2(100) := &apos;UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3&apos;;</span><br><span class=\"line\">  -- 更新所有该员工的客户的ACCESS权限</span><br><span class=\"line\">  C_UPDATE_CUSTOMER VARCHAR2(100) := &apos;UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2&apos;;</span><br><span class=\"line\">  -- 插入一条修改记录</span><br><span class=\"line\">  C_INSERT_HISTORY VARCHAR2(100) := &apos;INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)&apos;;</span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\">    -- 旧部门</span><br><span class=\"line\">    SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class=\"line\">    -- 旧权限</span><br><span class=\"line\">    SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class=\"line\">    -- 新部门权限作为前缀</span><br><span class=\"line\">    SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID;</span><br><span class=\"line\">    -- 计算该部门人员数量</span><br><span class=\"line\">    SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID;</span><br><span class=\"line\">    -- 计算子部门数量</span><br><span class=\"line\">    SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2;</span><br><span class=\"line\">    -- 若新部门与旧部门相同，无需更改</span><br><span class=\"line\">    IF N_DEP_ID=O_DEP_ID THEN</span><br><span class=\"line\">      RETURN;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    -- 新权限CODE</span><br><span class=\"line\">    IF DEP_DEP_COUNT &gt; DEP_USER_COUNT THEN</span><br><span class=\"line\">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1);</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">    -- 输出相关变量</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_USER_COUNT : &apos; || DEP_USER_COUNT);</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_DEP_COUNT : &apos; || DEP_DEP_COUNT);</span><br><span class=\"line\">    -- 输出相关变量</span><br><span class=\"line\">    dbms_output.put_line(&apos;DEP_ACCESS_CODE_PREFIX : &apos; || DEP_ACCESS_CODE_PREFIX);</span><br><span class=\"line\">    dbms_output.put_line(&apos;C_F_ID : &apos; || C_F_ID);</span><br><span class=\"line\">    dbms_output.put_line(&apos;O_ACCESS_CODE : &apos; || O_ACCESS_CODE);</span><br><span class=\"line\">    dbms_output.put_line(&apos;N_DEP_ID : &apos; || N_DEP_ID);</span><br><span class=\"line\">    dbms_output.put_line(&apos;N_ACCESS_CODE : &apos; || N_ACCESS_CODE);</span><br><span class=\"line\">    -- 更新该员工权限</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID;</span><br><span class=\"line\">    -- 更新所有该员工的客户的ACCESS权限</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID;</span><br><span class=\"line\">    -- 插入一条修改记录</span><br><span class=\"line\">    EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE;</span><br><span class=\"line\">    -- 提交</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\">  END;</span><br><span class=\"line\">  /</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建序列\"><a href=\"#创建序列\" class=\"headerlink\" title=\"创建序列\"></a>创建序列</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 员工部门历史记录主码序列</span><br><span class=\"line\">CREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行-2\"><a href=\"#执行-2\" class=\"headerlink\" title=\"执行\"></a>执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from t_customer_2 where f_access_code like &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>xxx%</code>指匹配所有以<code>xxx</code>开头的权限码</p>\n</blockquote>\n<h4 id=\"当部门结构或员工归属调整时，权限编码如何处理？-1\"><a href=\"#当部门结构或员工归属调整时，权限编码如何处理？-1\" class=\"headerlink\" title=\"当部门结构或员工归属调整时，权限编码如何处理？\"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>方案二中，调用新增的过程<code>CHANGE_TO_DEPARTMENT</code>即可级联更改权限码。</p>"},{"title":"内存数据库 - 课程笔记","date":"2018-09-02T12:59:50.000Z","_content":"# 内存计算与内存数据库\n\n## 第零章\n\nOLTP：行存储（记录：元组），联机事务处理\n\nOLAP：列存储（key-value），联机分析处理\n\n## Timesten操作小记\n\n<!-- more -->\n\n### 平台\n\n> 系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga)\n>\n\n### 创建DSN（Data Source Name）\n\n> 逻辑名，用于标识某一数据库连接\n\n#### 打开数据库配置文件(通常称为`系统ODBC.INI配置文件`)\n\n```sh\n$ cd $TT_HOME/info\n$ gedit sys.odbc.ini\n```\n#### 在数据库DSN列表中添加需要新建的数据库名称\n\n```ini\n# 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示\n[ODBC Data Sources]\nmy_ttdb=TimesTen 11.2.2 Driver\nTT_1122=TimesTen 11.2.2 Driver\nsampledb_1122=TimesTen 11.2.2 Driver\ncachedb1_1122=TimesTen 11.2.2 Driver\nrepdb1_1122=TimesTen 11.2.2 Driver\nrepdb2_1122=TimesTen 11.2.2 Driver\nsampledbCS_1122=TimesTen 11.2.2 Client Driver\ncachedb1CS_1122=TimesTen 11.2.2 Client Driver\nrepdb1CS_1122=TimesTen 11.2.2 Client Driver\nrepdb2CS_1122=TimesTen 11.2.2 Client Driver\n```\n\n#### 为2中创建的数据库添加配置，<u>**日志文件与检查点文件应存储在不同磁盘中**</u>\n\n```ini\n# 配置my_ttdb\n[my_ttdb]\n# 数据库监听器驱动位置\nDriver=/home/oracle/TimesTen/tt1122/lib/libtten.so \n# DataStore为检查点文件存储位置\nDataStore=/u02/ttdata/datastores/my_ttdb \n# LogDir为日志文件存储位置\nLogDir=/u03/ttdata/logs\n# 以下两个Size是TimesTen内存数据库的内存分配\nPermSize=40\nTempSize=32\n# 数据库的字符集\nDatabaseCharacterSet=AL32UTF8\n```\n\n> TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客[**<u>如何更改TimesTen数据库的大小</u>**](https://blog.csdn.net/stevensxiao/article/details/51050831)。\n\n#### 保存配置文件并关闭\n\n### 数据库服务器基本命令\n\n#### 查看服务器状态\n\n```sh\n[oracle@timesten-hol info]$ ttstatus\nTimesTen status report as of Thu Sep 27 04:08:30 2018\n\nDaemon pid 2637 port 53392 instance tt1122\nTimesTen server pid 2646 started on port 53393\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n#### 启动/停止数据库\n\n```sh\n[oracle@timesten-hol info]$ ttdaemonadmin -stop\nTimesTen Daemon stopped.\n[oracle@timesten-hol info]$ ttstatus\nttStatus: Could not connect to the TimesTen daemon.\nIf the TimesTen daemon is not running, please start it\nby running \"ttDaemonAdmin -start\".\n[oracle@timesten-hol info]$ ttdaemonadmin -start\nTimesTen Daemon startup OK.\n[oracle@timesten-hol info]$ ttstatus\nTimesTen status report as of Thu Sep 27 04:10:00 2018\n\nDaemon pid 6522 port 53392 instance tt1122\nTimesTen server pid 6531 started on port 53393\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n### 创建TimesTen内存数据库\n\n> 默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过`ttadmin -RAMPolicy`修改，后面会说到。\n>\n> 也就是说，默认情况下（前提是RAM策略为`inUse`，下一节会讲到RAM策略的修改），每次在执行`connect “dsn=ttdb_name”`连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是`创建`而不是`连接到`。\n\n#### 连接到特定DSN，创建内存数据库\n\n```sh\n[oracle@timesten-hol info]$ ttisql\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nCommand> connect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n```\n\n或者直接在ttisql中指定DSN名称：\n\n```sh\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\"\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n[oracle@timesten-hol ~]$ ttisql my_ttdb\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"DSN=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n```\n\n\n\n> **问题：重复运行`connect “dsn=ttdb_name”`命令可以看到命令行中显示了多了连接，这是什么作用呢？**\n>\n> ```sh\n> Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con1: Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con2: Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con3: Command> \n> ```\n\n#### 查看内存数据库的内存分配及容量\n\n```sh\nCommand> dssize\n\n  PERM_ALLOCATED_SIZE:      40960\n  PERM_IN_USE_SIZE:         9453\n  PERM_IN_USE_HIGH_WATER:   9453\n  TEMP_ALLOCATED_SIZE:      32768\n  TEMP_IN_USE_SIZE:         9442\n  TEMP_IN_USE_HIGH_WATER:   9505\n```\n\n#### 使用Host命令可以调用操作系统级别的指令\n\n```sh\nCommand> host ttstatus;\nTimesTen status report as of Thu Sep 27 04:37:28 2018\n\nDaemon pid 6522 port 53392 instance tt1122\nTimesTen server pid 6531 started on port 53393\n------------------------------------------------------------------------\nData store /u01/ttdata/datastores/my_ttdb\nThere are 12 connections to the data store\nShared Memory KEY 0x1200c904 ID 2785297\nPL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000\nType            PID     Context             Connection Name              ConnID\nProcess         6973    0x0000000000c72c00  my_ttdb                           1\nSubdaemon       6529    0x00000000012d3360  Manager                         142\nSubdaemon       6529    0x000000000132a1e0  Rollback                        141\nSubdaemon       6529    0x000000000140b360  HistGC                          139\nSubdaemon       6529    0x0000000001420070  AsyncMV                         140\nSubdaemon       6529    0x00000000014b4e00  Log Marker                      136\nSubdaemon       6529    0x0000000001509a30  Deadlock Detector               135\nSubdaemon       6529    0x000000000151e620  Flusher                         134\nSubdaemon       6529    0x0000000001533210  Checkpoint                      133\nSubdaemon       6529    0x00000000016286b0  Monitor                         132\nSubdaemon       6529    0x00007f95880208e0  Aging                           138\nSubdaemon       6529    0x00007f958808f900  IndexGC                         137\nReplication policy  : Manual\nCache Agent policy  : Manual\nPL/SQL enabled.\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n### 修改RAM策略\n\n> 上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为`inUse`的情况，下面会讲到当RAM策略设置为`Manual`时创建内存数据库的过程。\n>\n> `Manual`策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而`inUse`策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。\n\n#### 查看当前RAM策略\n\n```sh\n[oracle@timesten-hol info]$ ttadmin my_ttdb\nRAM Residence Policy            : inUse\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n```\n\n#### 修改RAM策略为手动模式（Manual）\n\n> 手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : False\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\n  707: Attempt to connect to a data store that has been manually unloaded from RAM\nThe command failed.\nDone.\n[oracle@timesten-hol info]$ \n```\n\n#### 向内存中装载数据\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -ramload my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : True\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\nCommand> \n```\n\n#### 从内存中卸载数据\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : False\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\n  707: Attempt to connect to a data store that has been manually unloaded from RAM\nThe command failed.\nDone.\n[oracle@timesten-hol info]$ \n```\n\n### 日志和检查点\n\n#### 查看日志文件，**<u>提交之前会预写日志</u>**\n\n```sh\nCommand> host ls -al /u03/ttdata/logs/my*\n-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2\n```\n\n#### 查看检查点\n\n```sh\nCommand> host ls -al /u02/ttdata/datastores/my*\n-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0\n-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1\n```\n\n#### 手动更新检查点文件\n\n> 非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。\n>\n> 如下调用检查点文件：\n\n```plsql\nCommand> call ttckpt;\nCommand> call ttckpt;\n```\n\n### ttisql基本命令——用户操作\n\n#### 创建用户，可在表`sys.all_users`中查找所有的用户信息\n\n```plsql\nCommand> select * from sys.all_users;\n< SYS, 0, 2018-09-27 04:18:18.063030 >\n< TTREP, 2, 2018-09-27 04:18:18.063030 >\n< SYSTEM, 3, 2018-09-27 04:18:18.063030 >\n< GRID, 4, 2018-09-27 04:18:18.063030 >\n< ORACLE, 10, 2018-09-27 04:18:18.063030 >\n< SCOTT, 11, 2018-09-27 05:06:39.267433 >\n6 rows found.\nCommand> create user tthr identified by tthr;\n\nUser created.\n\nCommand> select * from sys.all_users;\n< SYS, 0, 2018-09-27 04:18:18.063030 >\n< TTREP, 2, 2018-09-27 04:18:18.063030 >\n< SYSTEM, 3, 2018-09-27 04:18:18.063030 >\n< GRID, 4, 2018-09-27 04:18:18.063030 >\n< ORACLE, 10, 2018-09-27 04:18:18.063030 >\n< SCOTT, 11, 2018-09-27 05:06:39.267433 >\n< TTHR, 12, 2018-09-28 23:11:57.126074 >\n7 rows found.\n```\n\n#### 给用户分配权限\n\n```plsql\nCommand> grant create session to tthr;\nCommand> grant create table to tthr;\nCommand> grant create view to tthr;\nCommand> grant create sequence to tthr;\n```\n\n#### 查看当前数据库系统内用户权限\n\n```\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n9 rows found.\n```\n\n#### 撤回用户权限\n\n> 以下示例展示了如何从用户撤回权限（赋予`delete any table`权限后再撤回该权限）\n\n```plsql\nCommand> grant delete any table to tthr;\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, DELETE ANY TABLE, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n10 rows found.\nCommand> revoke delete any table from tthr;\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n9 rows found.\n```\n\n### ttisql基本命令——数据库对象操作\n\n#### 关闭自动提交\n\n> 意即每次执行事务后，均需要执行`commit`以提交事务。\n\n```plsql\nCommand> autocommit off;\n```\n\n#### 建表、插入数据\n\n```plsql\nCommand> create table ttemployees\n       > (employee_id NUMBER(6) NOT NULL,\n       > last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB,\n       > PRIMARY KEY (employee_id) )\n       > UNIQUE HASH ON (employee_id) PAGES = 1;\nCommand> insert into ttemployees values (1, 'Smith', '2009-02-23', 'excellent'); \n1 row inserted.\nCommand> insert into ttemployees values (2, 'King', '2005-08-05', 'great');\n1 row inserted.\nCommand> insert into ttemployees values (3, 'Taylor', '2012-01-28', EMPTY_CLOB());\n1 row inserted.\nCommand> commit;\n```\n\n#### 一些命令总结\n\n> - tables and alltables - Lists tables\n> - indexes and allindexes - Lists indexes\n> - views and allviews - Lists views\n> - sequences and allsequences - Lists sequences\n> - synonyms and allsynonyms - Lists synonyms\n> - functions and allfunctions - Lists PL/SQL functions\n> - procedures and allprocedures - Lists PL/SQL procedures\n> - packages and allpackages - Lists PL/SQL packages\n\n### PLSQL编程\n\n#### 创建plsqldb、pls用户、运行sql脚本\n\n```sql\ncall ttOptUpdateStats;\n// 更新统计数据，用于分析生成最优执行计划\n```\n\n#### 使用sql developer连接TimesTen和Oracle\n\n配置如下：\n\n![TimesTen数据库连接配置](/images/image-20181018140355729.png)\n\n![Oracle数据库连接配置](/images/image-20181018140412582.png)\n\n#### plsql语法\n\n> ## What Is a PL/SQL Package?\n>\n> A **package** is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The **specification** (**spec** for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The **body** fully defines cursors and subprograms, and so implements the spec.\n>\n> `包`是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，`规范`和`主体`，主体不是必要的。`规范`是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。`主体`将完全定义游标和子程序，以此实现`规范`。\n>\n> As [Figure 9-1](https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#5871) shows, you can think of the spec as an operational interface and of the body as a \"black box.\" You can debug, enhance, or replace a package body without changing the interface (package spec) to the package.\n>\n> ![包](/images/image-20181018143452887.png)\n>\n> ——[Oracle PL/SQL Package文档](https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#362)\n\n`1_package.sql:`\n\n```plsql\nCREATE OR REPLACE PACKAGE test AS\n\n  -- Declare a record for the desired EMP fields\n  TYPE empRecType IS RECORD (\n    r_empno  EMP.EMPNO%TYPE,\n      -- 使用EMP表中EMPNO的类型\n    r_ename  EMP.ENAME%TYPE,\n    r_salary EMP.SAL%TYPE\n  );\n\n  -- Declare a Ref Cursor type\n  TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值\n\n  -- A parameterized cursor，定义\n  \t-- 游标\n  CURSOR low_paid (num PLS_INTEGER) IS\n    SELECT empno \n      FROM emp\n      WHERE rownum <= num\n      ORDER BY sal ASC;\n\t-- 过程(IN表示输入，OUT表示输出)\n  PROCEDURE ddl_dml\n    (myComment IN  VARCHAR2,\n     errCode   OUT PLS_INTEGER, -- 整型\n     errText   OUT VARCHAR2); \n\n\n  PROCEDURE givePayRise\n    (num       IN  PLS_INTEGER,\n     name      OUT EMP.ENAME%TYPE, \n     \t-- name是plsql中的保留字，应该尽量避免使用保留字\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2); \n\n\n  PROCEDURE getCommEmps\n    (empRefCur IN OUT EmpCurType,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2); \n\n  -- Associative array\n  TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type\n  INDEX BY PLS_INTEGER; -- indexed by pls_integer\n  \n  FUNCTION get_sum_multiples\n   ( multiple IN PLS_INTEGER,\n     num      IN PLS_INTEGER\n   ) RETURN sum_multiples;\n\nEND test;\n/\n\n\nCREATE OR REPLACE PACKAGE BODY test AS\n\n  PROCEDURE ddl_dml\n    (myComment IN  VARCHAR2,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n    sql_str                    VARCHAR2(256);\n    name_already_exists        EXCEPTION;\n    insufficient_privileges    EXCEPTION;\n    PRAGMA EXCEPTION_INIT(name_already_exists,     -0955);\n    PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031);\n    seq_value                  number;\n\n\n  BEGIN\n\n\n    BEGIN\n      sql_str := 'create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))';\n      DBMS_OUTPUT.PUT_LINE(sql_str);\n      execute immediate sql_str;\n    EXCEPTION\n      WHEN name_already_exists THEN\n        DBMS_OUTPUT.PUT_LINE('  Ignore existing table errors');\n      WHEN insufficient_privileges THEN\n        DBMS_OUTPUT.PUT_LINE('  Ignore insufficient privileges errors');\n    END;\n\n    -- Cast num_col1 and char_col values\n    insert into temp values (1, 1, myComment);\n\n    commit;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n  \n    WHEN name_already_exists THEN\n\n      errCode := 0;\n      errtext := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END ddl_dml;\n\n\n\n  PROCEDURE givePayRise\n    (num       IN  PLS_INTEGER,\n     name      OUT EMP.ENAME%TYPE,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n   -- Can use PLSQL collections within TimesTen PLSQL\n   TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE;\n   lowest_paid lowest_paid_type;\n\n   i           PLS_INTEGER; \n   numRows     PLS_INTEGER;\n   lucky_index PLS_INTEGER; \n   lucky_emp   EMP.EMPNO%TYPE; \n\n  BEGIN\n\n    -- Initialize the output variable\n    name := 'Nobody';\n\n    -- Initialize the collection\n    lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n    i := 1;\n    \n    -- Constrain the resultset size\n    IF num < 1 OR num > 10 THEN\n\n      -- If bad inputs, default to 5 rows\n      numRows := 5;\n    ELSE\n      numRows := num;\n    END IF;\n\n\n    -- Create the cursor resultset with up to 'numRows' rows\n    OPEN low_paid( numRows );\n\n    LOOP\n\n      -- Get the current empid\n      FETCH low_paid INTO lowest_paid(i);\n\n      EXIT WHEN low_paid%NOTFOUND;\n\n      -- Increment the PLSQL table index\n      i := i + 1;\n\n    END LOOP;\n\n    -- Close the cursor\n    CLOSE low_paid;\n\n\n    -- List the subset of lowest paid employees\n    FOR j in lowest_paid.FIRST .. numRows LOOP\n      DBMS_OUTPUT.PUT_LINE('  Lowest paid empno ' || j || ' is ' || lowest_paid(j) );\n    END LOOP;\n\n    -- Randomly choose one of the lowest paid employees for a 10% pay raise.\n    lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); \n    lucky_emp := lowest_paid(lucky_index);\n\n\n    -- Give lucky_emp a 10% pay raise and return their name\n    UPDATE emp\n      SET sal = sal * 1.1\n      WHERE empno = lucky_emp\n      RETURNING ename INTO name;\n\n    COMMIT;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n  \n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END givePayRise;\n\n\n\n  PROCEDURE getCommEmps\n    (empRefCur IN OUT EmpCurType,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n    salesGuy empRecType;\n\n  BEGIN \n\n    DBMS_OUTPUT.PUT_LINE(' ');\n    DBMS_OUTPUT.PUT_LINE('Displaying the refcursor for the sales people');\n\n    -- The refcursor (empRefCur) result was opened before calling this procedure\n    LOOP\n      FETCH empRefCur INTO salesGuy;\n      EXIT WHEN empRefCur%NOTFOUND;\n\n      DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename);\n    END LOOP;\n\n    CLOSE empRefCur;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n\n  \n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END getCommEmps;\n\n  FUNCTION get_sum_multiples\n   ( multiple IN PLS_INTEGER,\n     num      IN PLS_INTEGER\n   ) RETURN sum_multiples\n   IS\n     s sum_multiples;\n  BEGIN\n    FOR i in 1..num LOOP\n      s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples\n    END LOOP;\n    RETURN s;\n  END get_sum_multiples;\n\nBEGIN  -- package initialization goes here\n  DBMS_OUTPUT.PUT_LINE('Initialized package test');\nEND test;\n/\n```\n\n`2_call_package.sql:`\n\n```plsql\nset serveroutput on;\n\ndeclare\n  errCode      PLS_INTEGER;\n  errtext      VARCHAR2(256);\n  myRefCur     test.EmpCurType; -- 使用test包中定义的类型\n  salesPerson  test.empRecType;\n  name         EMP.ENAME%TYPE;\n  n           PLS_INTEGER := 5; -- number of multiples to sum for display\n  sn          PLS_INTEGER := 10; -- number of multiples to sum\n  m           PLS_INTEGER := 3; -- multiple\n  \n  \nbegin\n\n    dbms_output.put_line(' ');\n    dbms_output.put_line(' ');\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Find some of the lowest paid employees and give a random employee a 10% pay raise');\n    -- Give a lowely paid random employee a 10% pay raise\n    test.givePayRise(5, name, errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    else\n      dbms_output.put_line(name || ' got the 10% payraise');\n    end if;\n\n    -- Open a refcursor\n    OPEN myRefCur FOR\n      SELECT empno, ename, sal\n      FROM emp\n      WHERE comm IS NOT NULL;\n\n    -- display the resultset of the refcursor\n    test.getCommEmps(myRefCur, errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    end if;\n\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Do some DDL and DML in a stored procedure');\n    test.ddl_dml('hi', errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    end if;\n    \n    -- associative arrays\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Use an associative array to compute the sum of multiples');\n    dbms_output.put_line(\n      'Sum of the first ' || TO_CHAR(n) || ' multiples of ' || TO_CHAR(m) \n       || ' is ' ||  TO_CHAR(test.get_sum_multiples (m, sn)(n)));\n    \n\nend;\n/\n```\n\n`3_create_package_workload.sql:`\n\n```plsql\nCREATE OR REPLACE PACKAGE workload AS\n\n  PROCEDURE oltp_read_only (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2);\n\n  PROCEDURE oltp_read_write (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    v_c       IN  CHAR,\n    v_p       IN  VARCHAR2,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2);\n\nEND workload;\n/\n\n\nCREATE OR REPLACE PACKAGE BODY workload AS\n\n  -- Private package variables used for package initialization\n  theErrCode PLS_INTEGER   := 0;\n  theErrText VARCHAR2(256) := 'OK';\n\n  -- Using shared package cursors for efficiency\n  CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m;\n\n  CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m\n       ORDER BY c;\n\n  CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT DISTINCT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m\n       ORDER BY c;\n\n\n  -- The workload read only workload\n  PROCEDURE oltp_read_only (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2) IS\n\n    -- Store the result of the column 'c'\n    cValue  char(120);\n\n    -- Store the sum of the rows in (n..m)\n    sumK    number(38,0);\n\n  BEGIN\n\n    errCode := 0;\n    errtext := 'OK';\n\n    -- oltp point query\n    FOR i in 1 .. 10 LOOP\n\n      -- DBMS_OUTPUT.PUT_LINE('oltp point query');\n      SELECT c INTO cValue FROM sbtest WHERE id = v_id;\n      -- DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n\n    END LOOP;\n\n    -- oltp range query (using a cursor for loop)\n--    DBMS_OUTPUT.PUT_LINE('oltp range query');\n    FOR range_rows IN range_query(v_n, v_m)\n    LOOP\n--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || ' c = ' || range_rows.c);\n      null;\n    END LOOP;\n\n    -- olpt range SUM() query\n--    DBMS_OUTPUT.PUT_LINE('oltp range SUM() query');\n    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;\n--    DBMS_OUTPUT.PUT_LINE('sumK = ' || sumK);\n\n    -- oltp range ORDER BY query (using explicit fetches)\n--    DBMS_OUTPUT.PUT_LINE('oltp range ORDER BY query');\n    OPEN range_order_query(v_n, v_m);\n    LOOP\n      FETCH range_order_query INTO cValue;\n      EXIT WHEN range_order_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_order_query;\n\n    -- oltp range DISTINCT query\n--    DBMS_OUTPUT.PUT_LINE('oltp range DISTINCT query');\n    OPEN range_distinct_query(v_n, v_m);\n    LOOP\n      FETCH range_distinct_query INTO cValue;\n      EXIT WHEN range_distinct_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_distinct_query;\n\n  EXCEPTION\n\n    WHEN NO_DATA_FOUND THEN\n\n      errCode  := 0;\n      errText  := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END oltp_read_only;\n\n\n  -- The workload read + write workload\n  PROCEDURE oltp_read_write (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    v_c       IN  CHAR,\n    v_p       IN  VARCHAR2,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2) IS\n\n    -- Store the result of the column 'c'\n    cValue  char(120);\n\n    -- Store the sum of the rows in (n..m)\n    sumK    number(38,0);\n\n  BEGIN\n\n    errCode := 0;\n    errtext := 'OK';\n\n    -- oltp point query\n    FOR i in 1 .. 10 LOOP\n\n      -- DBMS_OUTPUT.PUT_LINE('oltp point query');\n      SELECT c INTO cValue FROM sbtest WHERE id = v_id;\n      -- DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n\n    END LOOP;\n\n    -- oltp range query (using a cursor for loop)\n--    DBMS_OUTPUT.PUT_LINE('oltp range query');\n    FOR range_rows IN range_query(v_n, v_m)\n    LOOP\n--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || ' c = ' || range_rows.c);\n      null;\n    END LOOP;\n\n    -- olpt range SUM() query\n--    DBMS_OUTPUT.PUT_LINE('oltp range SUM() query');\n    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;\n--    DBMS_OUTPUT.PUT_LINE('sumK = ' || sumK);\n\n    -- oltp range ORDER BY query (using explict fetches)\n--    DBMS_OUTPUT.PUT_LINE('oltp range ORDER BY query');\n    OPEN range_order_query(v_n, v_m);\n    LOOP\n      FETCH range_order_query INTO cValue;\n      EXIT WHEN range_order_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_order_query;\n\n    -- oltp range DISTINCT query\n--    DBMS_OUTPUT.PUT_LINE('oltp range DISTINCT query');\n    OPEN range_distinct_query(v_n, v_m);\n    LOOP\n      FETCH range_distinct_query INTO cValue;\n      EXIT WHEN range_distinct_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_distinct_query;\n\n    -- oltp UPDATES on index column\n--    DBMS_OUTPUT.PUT_LINE('oltp UPDATES on index column');\n    UPDATE sbtest \n      SET k = k + 1 \n      WHERE id = v_n;\n\n    -- oltp UPDATES on non-index column\n--    DBMS_OUTPUT.PUT_LINE('oltp UPDATES on non-index column');\n    UPDATE sbtest \n      SET c =  v_n\n      WHERE id = v_m; \n\n    -- oltp DELETE query\n--    DBMS_OUTPUT.PUT_LINE('oltp DELETE query');\n    DELETE FROM sbtest \n      WHERE id = v_n;\n\n    -- oltp INSERT query\n--    DBMS_OUTPUT.PUT_LINE('oltp INSERT query');\n    INSERT INTO sbtest (id, k, c, pad)\n      VALUES (v_n, v_m, v_c, v_p);  \n\n    -- Commit the changes\n    COMMIT;\n\n  EXCEPTION\n\n    WHEN NO_DATA_FOUND THEN\n\n      errCode  := 0;\n      errText  := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END oltp_read_write;\n\nBEGIN  -- package initialization goes here\n\n  -- Run the procedures once to initialize everything\n  oltp_read_only(1, 1, 10, theErrCode, theErrText );\n  oltp_read_write(1, 1, 10, 'abc', 'def', theErrCode, theErrText );\n\n  DBMS_OUTPUT.PUT_LINE('Initialized the workload package');\nEND workload;\n/\n```\n\n`4_call_workload.sql:`\n\n```plsql\nset serveroutput on;\n\ndeclare\n  counter    PLS_INTEGER;\n  errCode    PLS_INTEGER;\n  errtext    VARCHAR2(256);\n  line1      VARCHAR2(256);\n  line2      VARCHAR2(256);\n  someText   sbtest.c%TYPE;\n  moreText   VARCHAR2(256);\n  i          PLS_INTEGER;\n  iterations PLS_INTEGER;\n  startTime  NUMBER;\n  endTime    NUMBER;\n  duration   NUMBER;\nbegin\n\n  -- Initialize the someText string\n  line1 := 'The quick brown foxy did da jumping thing over that lazy doggy. ';\n  line2 := 'Question three, who was scott and who or what was tiger?';\n  someText := line1 || line2;\n  moreText := '';\n \n  -- Initialize the moreText string\n  FOR i in 1 .. 60 LOOP\n    moreText := moreText || 'a';\n  END LOOP;\n  \n  -- Get the start time in centi-seconds\n  startTime := DBMS_UTILITY.GET_TIME();\n\n  iterations := 10000;\n  for counter in 1 .. iterations LOOP\n    workload.oltp_read_only(1, 1, 1100, errCode, errtext);\n    if errCode != 0 then\n      exit;\n    end if;\n  end loop;\n\n  -- Get the end time in centi-seconds\n  endTime := DBMS_UTILITY.GET_TIME();\n  if errCode !=0 then \n    dbms_output.put_line('  ');\n    dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n  end if;\n  duration := endTime - startTime;\n  IF duration > 0 THEN\n    dbms_output.put_line('  ');\n    dbms_output.put_line('Called workload.oltp_read_only  ' || iterations || ' times. TPS = ' || trunc(iterations / duration * 100, 1) );\n  ELSE\n    dbms_output.put_line('Could not get valid timing info');\n  END IF;\n\n\n  iterations := 10000;\n  for counter in 1 .. iterations LOOP\n    workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext);\n    if errCode != 0 then\n      exit;\n    end if;\n  end loop;\n\n  -- Get the end time in centi-seconds\n  endTime := DBMS_UTILITY.GET_TIME();\n\n  if errCode !=0 then \n    dbms_output.put_line('  ');\n    dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n  end if;\n\n  duration := endTime - startTime;\n  IF duration > 0 THEN\n    dbms_output.put_line('Called workload.oltp_read_write ' || iterations || ' times. TPS = ' || trunc(iterations / duration * 100, 1) );\n  ELSE\n    dbms_output.put_line('Could not get valid timing info');\n  END IF;\nend;\n/\n```\n\n","source":"_posts/TimesTen内存数据库课程笔记.md","raw":"---\ntitle: 内存数据库 - 课程笔记\ndate: 2018-9-2 20:59:50\ntags: \n  - TimesTen \n  - 内存数据库 \ncategories: \n  - 数据库\n---\n# 内存计算与内存数据库\n\n## 第零章\n\nOLTP：行存储（记录：元组），联机事务处理\n\nOLAP：列存储（key-value），联机分析处理\n\n## Timesten操作小记\n\n<!-- more -->\n\n### 平台\n\n> 系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga)\n>\n\n### 创建DSN（Data Source Name）\n\n> 逻辑名，用于标识某一数据库连接\n\n#### 打开数据库配置文件(通常称为`系统ODBC.INI配置文件`)\n\n```sh\n$ cd $TT_HOME/info\n$ gedit sys.odbc.ini\n```\n#### 在数据库DSN列表中添加需要新建的数据库名称\n\n```ini\n# 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示\n[ODBC Data Sources]\nmy_ttdb=TimesTen 11.2.2 Driver\nTT_1122=TimesTen 11.2.2 Driver\nsampledb_1122=TimesTen 11.2.2 Driver\ncachedb1_1122=TimesTen 11.2.2 Driver\nrepdb1_1122=TimesTen 11.2.2 Driver\nrepdb2_1122=TimesTen 11.2.2 Driver\nsampledbCS_1122=TimesTen 11.2.2 Client Driver\ncachedb1CS_1122=TimesTen 11.2.2 Client Driver\nrepdb1CS_1122=TimesTen 11.2.2 Client Driver\nrepdb2CS_1122=TimesTen 11.2.2 Client Driver\n```\n\n#### 为2中创建的数据库添加配置，<u>**日志文件与检查点文件应存储在不同磁盘中**</u>\n\n```ini\n# 配置my_ttdb\n[my_ttdb]\n# 数据库监听器驱动位置\nDriver=/home/oracle/TimesTen/tt1122/lib/libtten.so \n# DataStore为检查点文件存储位置\nDataStore=/u02/ttdata/datastores/my_ttdb \n# LogDir为日志文件存储位置\nLogDir=/u03/ttdata/logs\n# 以下两个Size是TimesTen内存数据库的内存分配\nPermSize=40\nTempSize=32\n# 数据库的字符集\nDatabaseCharacterSet=AL32UTF8\n```\n\n> TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客[**<u>如何更改TimesTen数据库的大小</u>**](https://blog.csdn.net/stevensxiao/article/details/51050831)。\n\n#### 保存配置文件并关闭\n\n### 数据库服务器基本命令\n\n#### 查看服务器状态\n\n```sh\n[oracle@timesten-hol info]$ ttstatus\nTimesTen status report as of Thu Sep 27 04:08:30 2018\n\nDaemon pid 2637 port 53392 instance tt1122\nTimesTen server pid 2646 started on port 53393\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n#### 启动/停止数据库\n\n```sh\n[oracle@timesten-hol info]$ ttdaemonadmin -stop\nTimesTen Daemon stopped.\n[oracle@timesten-hol info]$ ttstatus\nttStatus: Could not connect to the TimesTen daemon.\nIf the TimesTen daemon is not running, please start it\nby running \"ttDaemonAdmin -start\".\n[oracle@timesten-hol info]$ ttdaemonadmin -start\nTimesTen Daemon startup OK.\n[oracle@timesten-hol info]$ ttstatus\nTimesTen status report as of Thu Sep 27 04:10:00 2018\n\nDaemon pid 6522 port 53392 instance tt1122\nTimesTen server pid 6531 started on port 53393\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n### 创建TimesTen内存数据库\n\n> 默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过`ttadmin -RAMPolicy`修改，后面会说到。\n>\n> 也就是说，默认情况下（前提是RAM策略为`inUse`，下一节会讲到RAM策略的修改），每次在执行`connect “dsn=ttdb_name”`连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是`创建`而不是`连接到`。\n\n#### 连接到特定DSN，创建内存数据库\n\n```sh\n[oracle@timesten-hol info]$ ttisql\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nCommand> connect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n```\n\n或者直接在ttisql中指定DSN名称：\n\n```sh\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\"\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n[oracle@timesten-hol ~]$ ttisql my_ttdb\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"DSN=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\n```\n\n\n\n> **问题：重复运行`connect “dsn=ttdb_name”`命令可以看到命令行中显示了多了连接，这是什么作用呢？**\n>\n> ```sh\n> Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con1: Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con2: Command> connect \"dsn=my_ttdb\";\n> Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n> (Default setting AutoCommit=1)\n> con3: Command> \n> ```\n\n#### 查看内存数据库的内存分配及容量\n\n```sh\nCommand> dssize\n\n  PERM_ALLOCATED_SIZE:      40960\n  PERM_IN_USE_SIZE:         9453\n  PERM_IN_USE_HIGH_WATER:   9453\n  TEMP_ALLOCATED_SIZE:      32768\n  TEMP_IN_USE_SIZE:         9442\n  TEMP_IN_USE_HIGH_WATER:   9505\n```\n\n#### 使用Host命令可以调用操作系统级别的指令\n\n```sh\nCommand> host ttstatus;\nTimesTen status report as of Thu Sep 27 04:37:28 2018\n\nDaemon pid 6522 port 53392 instance tt1122\nTimesTen server pid 6531 started on port 53393\n------------------------------------------------------------------------\nData store /u01/ttdata/datastores/my_ttdb\nThere are 12 connections to the data store\nShared Memory KEY 0x1200c904 ID 2785297\nPL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000\nType            PID     Context             Connection Name              ConnID\nProcess         6973    0x0000000000c72c00  my_ttdb                           1\nSubdaemon       6529    0x00000000012d3360  Manager                         142\nSubdaemon       6529    0x000000000132a1e0  Rollback                        141\nSubdaemon       6529    0x000000000140b360  HistGC                          139\nSubdaemon       6529    0x0000000001420070  AsyncMV                         140\nSubdaemon       6529    0x00000000014b4e00  Log Marker                      136\nSubdaemon       6529    0x0000000001509a30  Deadlock Detector               135\nSubdaemon       6529    0x000000000151e620  Flusher                         134\nSubdaemon       6529    0x0000000001533210  Checkpoint                      133\nSubdaemon       6529    0x00000000016286b0  Monitor                         132\nSubdaemon       6529    0x00007f95880208e0  Aging                           138\nSubdaemon       6529    0x00007f958808f900  IndexGC                         137\nReplication policy  : Manual\nCache Agent policy  : Manual\nPL/SQL enabled.\n------------------------------------------------------------------------\nAccessible by group oracle\nEnd of report\n```\n\n### 修改RAM策略\n\n> 上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为`inUse`的情况，下面会讲到当RAM策略设置为`Manual`时创建内存数据库的过程。\n>\n> `Manual`策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而`inUse`策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。\n\n#### 查看当前RAM策略\n\n```sh\n[oracle@timesten-hol info]$ ttadmin my_ttdb\nRAM Residence Policy            : inUse\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n```\n\n#### 修改RAM策略为手动模式（Manual）\n\n> 手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : False\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\n  707: Attempt to connect to a data store that has been manually unloaded from RAM\nThe command failed.\nDone.\n[oracle@timesten-hol info]$ \n```\n\n#### 向内存中装载数据\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -ramload my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : True\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\nConnection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;\n(Default setting AutoCommit=1)\nCommand> \n```\n\n#### 从内存中卸载数据\n\n```sh\n[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdb\nRAM Residence Policy            : manual\nManually Loaded In RAM          : False\nReplication Agent Policy        : manual\nReplication Manually Started    : False\nCache Agent Policy              : manual\nCache Agent Manually Started    : False\n[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";\n\nCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.\nType ? or \"help\" for help, type \"exit\" to quit ttIsql.\n\nconnect \"dsn=my_ttdb\";\n  707: Attempt to connect to a data store that has been manually unloaded from RAM\nThe command failed.\nDone.\n[oracle@timesten-hol info]$ \n```\n\n### 日志和检查点\n\n#### 查看日志文件，**<u>提交之前会预写日志</u>**\n\n```sh\nCommand> host ls -al /u03/ttdata/logs/my*\n-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1\n-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2\n```\n\n#### 查看检查点\n\n```sh\nCommand> host ls -al /u02/ttdata/datastores/my*\n-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0\n-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1\n```\n\n#### 手动更新检查点文件\n\n> 非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。\n>\n> 如下调用检查点文件：\n\n```plsql\nCommand> call ttckpt;\nCommand> call ttckpt;\n```\n\n### ttisql基本命令——用户操作\n\n#### 创建用户，可在表`sys.all_users`中查找所有的用户信息\n\n```plsql\nCommand> select * from sys.all_users;\n< SYS, 0, 2018-09-27 04:18:18.063030 >\n< TTREP, 2, 2018-09-27 04:18:18.063030 >\n< SYSTEM, 3, 2018-09-27 04:18:18.063030 >\n< GRID, 4, 2018-09-27 04:18:18.063030 >\n< ORACLE, 10, 2018-09-27 04:18:18.063030 >\n< SCOTT, 11, 2018-09-27 05:06:39.267433 >\n6 rows found.\nCommand> create user tthr identified by tthr;\n\nUser created.\n\nCommand> select * from sys.all_users;\n< SYS, 0, 2018-09-27 04:18:18.063030 >\n< TTREP, 2, 2018-09-27 04:18:18.063030 >\n< SYSTEM, 3, 2018-09-27 04:18:18.063030 >\n< GRID, 4, 2018-09-27 04:18:18.063030 >\n< ORACLE, 10, 2018-09-27 04:18:18.063030 >\n< SCOTT, 11, 2018-09-27 05:06:39.267433 >\n< TTHR, 12, 2018-09-28 23:11:57.126074 >\n7 rows found.\n```\n\n#### 给用户分配权限\n\n```plsql\nCommand> grant create session to tthr;\nCommand> grant create table to tthr;\nCommand> grant create view to tthr;\nCommand> grant create sequence to tthr;\n```\n\n#### 查看当前数据库系统内用户权限\n\n```\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n9 rows found.\n```\n\n#### 撤回用户权限\n\n> 以下示例展示了如何从用户撤回权限（赋予`delete any table`权限后再撤回该权限）\n\n```plsql\nCommand> grant delete any table to tthr;\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, DELETE ANY TABLE, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n10 rows found.\nCommand> revoke delete any table from tthr;\nCommand> select * from sys.dba_sys_privs;\n< SYS, ADMIN, YES >\n< SYSTEM, ADMIN, YES >\n< ORACLE, ADMIN, YES >\n< SCOTT, CREATE SESSION, NO >\n< SCOTT, CREATE TABLE, NO >\n< TTHR, CREATE SESSION, NO >\n< TTHR, CREATE TABLE, NO >\n< TTHR, CREATE VIEW, NO >\n< TTHR, CREATE SEQUENCE, NO >\n9 rows found.\n```\n\n### ttisql基本命令——数据库对象操作\n\n#### 关闭自动提交\n\n> 意即每次执行事务后，均需要执行`commit`以提交事务。\n\n```plsql\nCommand> autocommit off;\n```\n\n#### 建表、插入数据\n\n```plsql\nCommand> create table ttemployees\n       > (employee_id NUMBER(6) NOT NULL,\n       > last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB,\n       > PRIMARY KEY (employee_id) )\n       > UNIQUE HASH ON (employee_id) PAGES = 1;\nCommand> insert into ttemployees values (1, 'Smith', '2009-02-23', 'excellent'); \n1 row inserted.\nCommand> insert into ttemployees values (2, 'King', '2005-08-05', 'great');\n1 row inserted.\nCommand> insert into ttemployees values (3, 'Taylor', '2012-01-28', EMPTY_CLOB());\n1 row inserted.\nCommand> commit;\n```\n\n#### 一些命令总结\n\n> - tables and alltables - Lists tables\n> - indexes and allindexes - Lists indexes\n> - views and allviews - Lists views\n> - sequences and allsequences - Lists sequences\n> - synonyms and allsynonyms - Lists synonyms\n> - functions and allfunctions - Lists PL/SQL functions\n> - procedures and allprocedures - Lists PL/SQL procedures\n> - packages and allpackages - Lists PL/SQL packages\n\n### PLSQL编程\n\n#### 创建plsqldb、pls用户、运行sql脚本\n\n```sql\ncall ttOptUpdateStats;\n// 更新统计数据，用于分析生成最优执行计划\n```\n\n#### 使用sql developer连接TimesTen和Oracle\n\n配置如下：\n\n![TimesTen数据库连接配置](/images/image-20181018140355729.png)\n\n![Oracle数据库连接配置](/images/image-20181018140412582.png)\n\n#### plsql语法\n\n> ## What Is a PL/SQL Package?\n>\n> A **package** is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The **specification** (**spec** for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The **body** fully defines cursors and subprograms, and so implements the spec.\n>\n> `包`是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，`规范`和`主体`，主体不是必要的。`规范`是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。`主体`将完全定义游标和子程序，以此实现`规范`。\n>\n> As [Figure 9-1](https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#5871) shows, you can think of the spec as an operational interface and of the body as a \"black box.\" You can debug, enhance, or replace a package body without changing the interface (package spec) to the package.\n>\n> ![包](/images/image-20181018143452887.png)\n>\n> ——[Oracle PL/SQL Package文档](https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#362)\n\n`1_package.sql:`\n\n```plsql\nCREATE OR REPLACE PACKAGE test AS\n\n  -- Declare a record for the desired EMP fields\n  TYPE empRecType IS RECORD (\n    r_empno  EMP.EMPNO%TYPE,\n      -- 使用EMP表中EMPNO的类型\n    r_ename  EMP.ENAME%TYPE,\n    r_salary EMP.SAL%TYPE\n  );\n\n  -- Declare a Ref Cursor type\n  TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值\n\n  -- A parameterized cursor，定义\n  \t-- 游标\n  CURSOR low_paid (num PLS_INTEGER) IS\n    SELECT empno \n      FROM emp\n      WHERE rownum <= num\n      ORDER BY sal ASC;\n\t-- 过程(IN表示输入，OUT表示输出)\n  PROCEDURE ddl_dml\n    (myComment IN  VARCHAR2,\n     errCode   OUT PLS_INTEGER, -- 整型\n     errText   OUT VARCHAR2); \n\n\n  PROCEDURE givePayRise\n    (num       IN  PLS_INTEGER,\n     name      OUT EMP.ENAME%TYPE, \n     \t-- name是plsql中的保留字，应该尽量避免使用保留字\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2); \n\n\n  PROCEDURE getCommEmps\n    (empRefCur IN OUT EmpCurType,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2); \n\n  -- Associative array\n  TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type\n  INDEX BY PLS_INTEGER; -- indexed by pls_integer\n  \n  FUNCTION get_sum_multiples\n   ( multiple IN PLS_INTEGER,\n     num      IN PLS_INTEGER\n   ) RETURN sum_multiples;\n\nEND test;\n/\n\n\nCREATE OR REPLACE PACKAGE BODY test AS\n\n  PROCEDURE ddl_dml\n    (myComment IN  VARCHAR2,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n    sql_str                    VARCHAR2(256);\n    name_already_exists        EXCEPTION;\n    insufficient_privileges    EXCEPTION;\n    PRAGMA EXCEPTION_INIT(name_already_exists,     -0955);\n    PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031);\n    seq_value                  number;\n\n\n  BEGIN\n\n\n    BEGIN\n      sql_str := 'create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))';\n      DBMS_OUTPUT.PUT_LINE(sql_str);\n      execute immediate sql_str;\n    EXCEPTION\n      WHEN name_already_exists THEN\n        DBMS_OUTPUT.PUT_LINE('  Ignore existing table errors');\n      WHEN insufficient_privileges THEN\n        DBMS_OUTPUT.PUT_LINE('  Ignore insufficient privileges errors');\n    END;\n\n    -- Cast num_col1 and char_col values\n    insert into temp values (1, 1, myComment);\n\n    commit;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n  \n    WHEN name_already_exists THEN\n\n      errCode := 0;\n      errtext := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END ddl_dml;\n\n\n\n  PROCEDURE givePayRise\n    (num       IN  PLS_INTEGER,\n     name      OUT EMP.ENAME%TYPE,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n   -- Can use PLSQL collections within TimesTen PLSQL\n   TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE;\n   lowest_paid lowest_paid_type;\n\n   i           PLS_INTEGER; \n   numRows     PLS_INTEGER;\n   lucky_index PLS_INTEGER; \n   lucky_emp   EMP.EMPNO%TYPE; \n\n  BEGIN\n\n    -- Initialize the output variable\n    name := 'Nobody';\n\n    -- Initialize the collection\n    lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n    i := 1;\n    \n    -- Constrain the resultset size\n    IF num < 1 OR num > 10 THEN\n\n      -- If bad inputs, default to 5 rows\n      numRows := 5;\n    ELSE\n      numRows := num;\n    END IF;\n\n\n    -- Create the cursor resultset with up to 'numRows' rows\n    OPEN low_paid( numRows );\n\n    LOOP\n\n      -- Get the current empid\n      FETCH low_paid INTO lowest_paid(i);\n\n      EXIT WHEN low_paid%NOTFOUND;\n\n      -- Increment the PLSQL table index\n      i := i + 1;\n\n    END LOOP;\n\n    -- Close the cursor\n    CLOSE low_paid;\n\n\n    -- List the subset of lowest paid employees\n    FOR j in lowest_paid.FIRST .. numRows LOOP\n      DBMS_OUTPUT.PUT_LINE('  Lowest paid empno ' || j || ' is ' || lowest_paid(j) );\n    END LOOP;\n\n    -- Randomly choose one of the lowest paid employees for a 10% pay raise.\n    lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); \n    lucky_emp := lowest_paid(lucky_index);\n\n\n    -- Give lucky_emp a 10% pay raise and return their name\n    UPDATE emp\n      SET sal = sal * 1.1\n      WHERE empno = lucky_emp\n      RETURNING ename INTO name;\n\n    COMMIT;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n  \n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END givePayRise;\n\n\n\n  PROCEDURE getCommEmps\n    (empRefCur IN OUT EmpCurType,\n     errCode   OUT PLS_INTEGER,\n     errText   OUT VARCHAR2) IS\n\n    salesGuy empRecType;\n\n  BEGIN \n\n    DBMS_OUTPUT.PUT_LINE(' ');\n    DBMS_OUTPUT.PUT_LINE('Displaying the refcursor for the sales people');\n\n    -- The refcursor (empRefCur) result was opened before calling this procedure\n    LOOP\n      FETCH empRefCur INTO salesGuy;\n      EXIT WHEN empRefCur%NOTFOUND;\n\n      DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename);\n    END LOOP;\n\n    CLOSE empRefCur;\n\n    errCode := 0;\n    errtext := 'OK';\n\n  EXCEPTION\n\n  \n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END getCommEmps;\n\n  FUNCTION get_sum_multiples\n   ( multiple IN PLS_INTEGER,\n     num      IN PLS_INTEGER\n   ) RETURN sum_multiples\n   IS\n     s sum_multiples;\n  BEGIN\n    FOR i in 1..num LOOP\n      s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples\n    END LOOP;\n    RETURN s;\n  END get_sum_multiples;\n\nBEGIN  -- package initialization goes here\n  DBMS_OUTPUT.PUT_LINE('Initialized package test');\nEND test;\n/\n```\n\n`2_call_package.sql:`\n\n```plsql\nset serveroutput on;\n\ndeclare\n  errCode      PLS_INTEGER;\n  errtext      VARCHAR2(256);\n  myRefCur     test.EmpCurType; -- 使用test包中定义的类型\n  salesPerson  test.empRecType;\n  name         EMP.ENAME%TYPE;\n  n           PLS_INTEGER := 5; -- number of multiples to sum for display\n  sn          PLS_INTEGER := 10; -- number of multiples to sum\n  m           PLS_INTEGER := 3; -- multiple\n  \n  \nbegin\n\n    dbms_output.put_line(' ');\n    dbms_output.put_line(' ');\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Find some of the lowest paid employees and give a random employee a 10% pay raise');\n    -- Give a lowely paid random employee a 10% pay raise\n    test.givePayRise(5, name, errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    else\n      dbms_output.put_line(name || ' got the 10% payraise');\n    end if;\n\n    -- Open a refcursor\n    OPEN myRefCur FOR\n      SELECT empno, ename, sal\n      FROM emp\n      WHERE comm IS NOT NULL;\n\n    -- display the resultset of the refcursor\n    test.getCommEmps(myRefCur, errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    end if;\n\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Do some DDL and DML in a stored procedure');\n    test.ddl_dml('hi', errCode, errText);\n    if errCode != 0 then\n      dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n    end if;\n    \n    -- associative arrays\n    dbms_output.put_line(' ');\n    dbms_output.put_line('Use an associative array to compute the sum of multiples');\n    dbms_output.put_line(\n      'Sum of the first ' || TO_CHAR(n) || ' multiples of ' || TO_CHAR(m) \n       || ' is ' ||  TO_CHAR(test.get_sum_multiples (m, sn)(n)));\n    \n\nend;\n/\n```\n\n`3_create_package_workload.sql:`\n\n```plsql\nCREATE OR REPLACE PACKAGE workload AS\n\n  PROCEDURE oltp_read_only (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2);\n\n  PROCEDURE oltp_read_write (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    v_c       IN  CHAR,\n    v_p       IN  VARCHAR2,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2);\n\nEND workload;\n/\n\n\nCREATE OR REPLACE PACKAGE BODY workload AS\n\n  -- Private package variables used for package initialization\n  theErrCode PLS_INTEGER   := 0;\n  theErrText VARCHAR2(256) := 'OK';\n\n  -- Using shared package cursors for efficiency\n  CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m;\n\n  CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m\n       ORDER BY c;\n\n  CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS\n     SELECT DISTINCT c \n       FROM sbtest \n       WHERE id BETWEEN n AND m\n       ORDER BY c;\n\n\n  -- The workload read only workload\n  PROCEDURE oltp_read_only (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2) IS\n\n    -- Store the result of the column 'c'\n    cValue  char(120);\n\n    -- Store the sum of the rows in (n..m)\n    sumK    number(38,0);\n\n  BEGIN\n\n    errCode := 0;\n    errtext := 'OK';\n\n    -- oltp point query\n    FOR i in 1 .. 10 LOOP\n\n      -- DBMS_OUTPUT.PUT_LINE('oltp point query');\n      SELECT c INTO cValue FROM sbtest WHERE id = v_id;\n      -- DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n\n    END LOOP;\n\n    -- oltp range query (using a cursor for loop)\n--    DBMS_OUTPUT.PUT_LINE('oltp range query');\n    FOR range_rows IN range_query(v_n, v_m)\n    LOOP\n--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || ' c = ' || range_rows.c);\n      null;\n    END LOOP;\n\n    -- olpt range SUM() query\n--    DBMS_OUTPUT.PUT_LINE('oltp range SUM() query');\n    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;\n--    DBMS_OUTPUT.PUT_LINE('sumK = ' || sumK);\n\n    -- oltp range ORDER BY query (using explicit fetches)\n--    DBMS_OUTPUT.PUT_LINE('oltp range ORDER BY query');\n    OPEN range_order_query(v_n, v_m);\n    LOOP\n      FETCH range_order_query INTO cValue;\n      EXIT WHEN range_order_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_order_query;\n\n    -- oltp range DISTINCT query\n--    DBMS_OUTPUT.PUT_LINE('oltp range DISTINCT query');\n    OPEN range_distinct_query(v_n, v_m);\n    LOOP\n      FETCH range_distinct_query INTO cValue;\n      EXIT WHEN range_distinct_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_distinct_query;\n\n  EXCEPTION\n\n    WHEN NO_DATA_FOUND THEN\n\n      errCode  := 0;\n      errText  := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END oltp_read_only;\n\n\n  -- The workload read + write workload\n  PROCEDURE oltp_read_write (\n    v_id      IN  PLS_INTEGER,\n    v_n       IN  PLS_INTEGER,\n    v_m       IN  PLS_INTEGER,\n    v_c       IN  CHAR,\n    v_p       IN  VARCHAR2,\n    errCode   OUT PLS_INTEGER,\n    errText   OUT VARCHAR2) IS\n\n    -- Store the result of the column 'c'\n    cValue  char(120);\n\n    -- Store the sum of the rows in (n..m)\n    sumK    number(38,0);\n\n  BEGIN\n\n    errCode := 0;\n    errtext := 'OK';\n\n    -- oltp point query\n    FOR i in 1 .. 10 LOOP\n\n      -- DBMS_OUTPUT.PUT_LINE('oltp point query');\n      SELECT c INTO cValue FROM sbtest WHERE id = v_id;\n      -- DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n\n    END LOOP;\n\n    -- oltp range query (using a cursor for loop)\n--    DBMS_OUTPUT.PUT_LINE('oltp range query');\n    FOR range_rows IN range_query(v_n, v_m)\n    LOOP\n--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || ' c = ' || range_rows.c);\n      null;\n    END LOOP;\n\n    -- olpt range SUM() query\n--    DBMS_OUTPUT.PUT_LINE('oltp range SUM() query');\n    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;\n--    DBMS_OUTPUT.PUT_LINE('sumK = ' || sumK);\n\n    -- oltp range ORDER BY query (using explict fetches)\n--    DBMS_OUTPUT.PUT_LINE('oltp range ORDER BY query');\n    OPEN range_order_query(v_n, v_m);\n    LOOP\n      FETCH range_order_query INTO cValue;\n      EXIT WHEN range_order_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_order_query;\n\n    -- oltp range DISTINCT query\n--    DBMS_OUTPUT.PUT_LINE('oltp range DISTINCT query');\n    OPEN range_distinct_query(v_n, v_m);\n    LOOP\n      FETCH range_distinct_query INTO cValue;\n      EXIT WHEN range_distinct_query%NOTFOUND;\n--      DBMS_OUTPUT.PUT_LINE('c = ' || cValue);\n    END LOOP;\n    CLOSE range_distinct_query;\n\n    -- oltp UPDATES on index column\n--    DBMS_OUTPUT.PUT_LINE('oltp UPDATES on index column');\n    UPDATE sbtest \n      SET k = k + 1 \n      WHERE id = v_n;\n\n    -- oltp UPDATES on non-index column\n--    DBMS_OUTPUT.PUT_LINE('oltp UPDATES on non-index column');\n    UPDATE sbtest \n      SET c =  v_n\n      WHERE id = v_m; \n\n    -- oltp DELETE query\n--    DBMS_OUTPUT.PUT_LINE('oltp DELETE query');\n    DELETE FROM sbtest \n      WHERE id = v_n;\n\n    -- oltp INSERT query\n--    DBMS_OUTPUT.PUT_LINE('oltp INSERT query');\n    INSERT INTO sbtest (id, k, c, pad)\n      VALUES (v_n, v_m, v_c, v_p);  \n\n    -- Commit the changes\n    COMMIT;\n\n  EXCEPTION\n\n    WHEN NO_DATA_FOUND THEN\n\n      errCode  := 0;\n      errText  := 'OK';\n\n    WHEN OTHERS THEN\n\n      errCode  := SQLCODE;\n      errText  := SUBSTR(SQLERRM, 1, 200);\n\n  END oltp_read_write;\n\nBEGIN  -- package initialization goes here\n\n  -- Run the procedures once to initialize everything\n  oltp_read_only(1, 1, 10, theErrCode, theErrText );\n  oltp_read_write(1, 1, 10, 'abc', 'def', theErrCode, theErrText );\n\n  DBMS_OUTPUT.PUT_LINE('Initialized the workload package');\nEND workload;\n/\n```\n\n`4_call_workload.sql:`\n\n```plsql\nset serveroutput on;\n\ndeclare\n  counter    PLS_INTEGER;\n  errCode    PLS_INTEGER;\n  errtext    VARCHAR2(256);\n  line1      VARCHAR2(256);\n  line2      VARCHAR2(256);\n  someText   sbtest.c%TYPE;\n  moreText   VARCHAR2(256);\n  i          PLS_INTEGER;\n  iterations PLS_INTEGER;\n  startTime  NUMBER;\n  endTime    NUMBER;\n  duration   NUMBER;\nbegin\n\n  -- Initialize the someText string\n  line1 := 'The quick brown foxy did da jumping thing over that lazy doggy. ';\n  line2 := 'Question three, who was scott and who or what was tiger?';\n  someText := line1 || line2;\n  moreText := '';\n \n  -- Initialize the moreText string\n  FOR i in 1 .. 60 LOOP\n    moreText := moreText || 'a';\n  END LOOP;\n  \n  -- Get the start time in centi-seconds\n  startTime := DBMS_UTILITY.GET_TIME();\n\n  iterations := 10000;\n  for counter in 1 .. iterations LOOP\n    workload.oltp_read_only(1, 1, 1100, errCode, errtext);\n    if errCode != 0 then\n      exit;\n    end if;\n  end loop;\n\n  -- Get the end time in centi-seconds\n  endTime := DBMS_UTILITY.GET_TIME();\n  if errCode !=0 then \n    dbms_output.put_line('  ');\n    dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n  end if;\n  duration := endTime - startTime;\n  IF duration > 0 THEN\n    dbms_output.put_line('  ');\n    dbms_output.put_line('Called workload.oltp_read_only  ' || iterations || ' times. TPS = ' || trunc(iterations / duration * 100, 1) );\n  ELSE\n    dbms_output.put_line('Could not get valid timing info');\n  END IF;\n\n\n  iterations := 10000;\n  for counter in 1 .. iterations LOOP\n    workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext);\n    if errCode != 0 then\n      exit;\n    end if;\n  end loop;\n\n  -- Get the end time in centi-seconds\n  endTime := DBMS_UTILITY.GET_TIME();\n\n  if errCode !=0 then \n    dbms_output.put_line('  ');\n    dbms_output.put_line('Error code = ' || errCode || ' Error Text = ' || errtext);\n  end if;\n\n  duration := endTime - startTime;\n  IF duration > 0 THEN\n    dbms_output.put_line('Called workload.oltp_read_write ' || iterations || ' times. TPS = ' || trunc(iterations / duration * 100, 1) );\n  ELSE\n    dbms_output.put_line('Could not get valid timing info');\n  END IF;\nend;\n/\n```\n\n","slug":"TimesTen内存数据库课程笔记","published":1,"updated":"2021-05-16T11:00:13.403Z","_id":"ckfukja9p000xszxo3gt7tpv1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"内存计算与内存数据库\"><a href=\"#内存计算与内存数据库\" class=\"headerlink\" title=\"内存计算与内存数据库\"></a>内存计算与内存数据库</h1><h2 id=\"第零章\"><a href=\"#第零章\" class=\"headerlink\" title=\"第零章\"></a>第零章</h2><p>OLTP：行存储（记录：元组），联机事务处理</p>\n<p>OLAP：列存储（key-value），联机分析处理</p>\n<h2 id=\"Timesten操作小记\"><a href=\"#Timesten操作小记\" class=\"headerlink\" title=\"Timesten操作小记\"></a>Timesten操作小记</h2><a id=\"more\"></a>\n<h3 id=\"平台\"><a href=\"#平台\" class=\"headerlink\" title=\"平台\"></a>平台</h3><blockquote>\n<p>系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga)</p>\n</blockquote>\n<h3 id=\"创建DSN（Data-Source-Name）\"><a href=\"#创建DSN（Data-Source-Name）\" class=\"headerlink\" title=\"创建DSN（Data Source Name）\"></a>创建DSN（Data Source Name）</h3><blockquote>\n<p>逻辑名，用于标识某一数据库连接</p>\n</blockquote>\n<h4 id=\"打开数据库配置文件-通常称为系统ODBC-INI配置文件\"><a href=\"#打开数据库配置文件-通常称为系统ODBC-INI配置文件\" class=\"headerlink\" title=\"打开数据库配置文件(通常称为系统ODBC.INI配置文件)\"></a>打开数据库配置文件(通常称为<code>系统ODBC.INI配置文件</code>)</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"variable\">$TT_HOME</span>/info</span><br><span class=\"line\">$ gedit sys.odbc.ini</span><br></pre></td></tr></table></figure>\n<h4 id=\"在数据库DSN列表中添加需要新建的数据库名称\"><a href=\"#在数据库DSN列表中添加需要新建的数据库名称\" class=\"headerlink\" title=\"在数据库DSN列表中添加需要新建的数据库名称\"></a>在数据库DSN列表中添加需要新建的数据库名称</h4><figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示</span></span><br><span class=\"line\"><span class=\"section\">[ODBC Data Sources]</span></span><br><span class=\"line\"><span class=\"attr\">my_ttdb</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">TT_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">sampledb_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">cachedb1_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">repdb1_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">repdb2_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">sampledbCS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">cachedb1CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">repdb1CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">repdb2CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br></pre></td></tr></table></figure>\n<h4 id=\"为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\"><a href=\"#为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\" class=\"headerlink\" title=\"为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\"></a>为2中创建的数据库添加配置，<u><strong>日志文件与检查点文件应存储在不同磁盘中</strong></u></h4><figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置my_ttdb</span></span><br><span class=\"line\"><span class=\"section\">[my_ttdb]</span></span><br><span class=\"line\"><span class=\"comment\"># 数据库监听器驱动位置</span></span><br><span class=\"line\"><span class=\"attr\">Driver</span>=/home/oracle/TimesTen/tt1122/lib/libtten.so </span><br><span class=\"line\"><span class=\"comment\"># DataStore为检查点文件存储位置</span></span><br><span class=\"line\"><span class=\"attr\">DataStore</span>=/u02/ttdata/datastores/my_ttdb </span><br><span class=\"line\"><span class=\"comment\"># LogDir为日志文件存储位置</span></span><br><span class=\"line\"><span class=\"attr\">LogDir</span>=/u03/ttdata/logs</span><br><span class=\"line\"><span class=\"comment\"># 以下两个Size是TimesTen内存数据库的内存分配</span></span><br><span class=\"line\"><span class=\"attr\">PermSize</span>=<span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"attr\">TempSize</span>=<span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"comment\"># 数据库的字符集</span></span><br><span class=\"line\"><span class=\"attr\">DatabaseCharacterSet</span>=AL32UTF8</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客<a href=\"https://blog.csdn.net/stevensxiao/article/details/51050831\" target=\"_blank\" rel=\"noopener\"><strong><u>如何更改TimesTen数据库的大小</u></strong></a>。</p>\n</blockquote>\n<h4 id=\"保存配置文件并关闭\"><a href=\"#保存配置文件并关闭\" class=\"headerlink\" title=\"保存配置文件并关闭\"></a>保存配置文件并关闭</h4><h3 id=\"数据库服务器基本命令\"><a href=\"#数据库服务器基本命令\" class=\"headerlink\" title=\"数据库服务器基本命令\"></a>数据库服务器基本命令</h3><h4 id=\"查看服务器状态\"><a href=\"#查看服务器状态\" class=\"headerlink\" title=\"查看服务器状态\"></a>查看服务器状态</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:08:30 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 2637 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 2646 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动-停止数据库\"><a href=\"#启动-停止数据库\" class=\"headerlink\" title=\"启动/停止数据库\"></a>启动/停止数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttdaemonadmin -stop</span><br><span class=\"line\">TimesTen Daemon stopped.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">ttStatus: Could not connect to the TimesTen daemon.</span><br><span class=\"line\">If the TimesTen daemon is not running, please start it</span><br><span class=\"line\">by running <span class=\"string\">\"ttDaemonAdmin -start\"</span>.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttdaemonadmin -start</span><br><span class=\"line\">TimesTen Daemon startup OK.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:10:00 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 6522 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 6531 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建TimesTen内存数据库\"><a href=\"#创建TimesTen内存数据库\" class=\"headerlink\" title=\"创建TimesTen内存数据库\"></a>创建TimesTen内存数据库</h3><blockquote>\n<p>默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过<code>ttadmin -RAMPolicy</code>修改，后面会说到。</p>\n<p>也就是说，默认情况下（前提是RAM策略为<code>inUse</code>，下一节会讲到RAM策略的修改），每次在执行<code>connect “dsn=ttdb_name”</code>连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是<code>创建</code>而不是<code>连接到</code>。</p>\n</blockquote>\n<h4 id=\"连接到特定DSN，创建内存数据库\"><a href=\"#连接到特定DSN，创建内存数据库\" class=\"headerlink\" title=\"连接到特定DSN，创建内存数据库\"></a>连接到特定DSN，创建内存数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttisql</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure>\n<p>或者直接在ttisql中指定DSN名称：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br><span class=\"line\">[oracle@timesten-hol ~]$ ttisql my_ttdb</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"DSN=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>问题：重复运行<code>connect “dsn=ttdb_name”</code>命令可以看到命令行中显示了多了连接，这是什么作用呢？</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con1: Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con2: Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con3: Command&gt; </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"查看内存数据库的内存分配及容量\"><a href=\"#查看内存数据库的内存分配及容量\" class=\"headerlink\" title=\"查看内存数据库的内存分配及容量\"></a>查看内存数据库的内存分配及容量</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; dssize</span><br><span class=\"line\"></span><br><span class=\"line\">  PERM_ALLOCATED_SIZE:      40960</span><br><span class=\"line\">  PERM_IN_USE_SIZE:         9453</span><br><span class=\"line\">  PERM_IN_USE_HIGH_WATER:   9453</span><br><span class=\"line\">  TEMP_ALLOCATED_SIZE:      32768</span><br><span class=\"line\">  TEMP_IN_USE_SIZE:         9442</span><br><span class=\"line\">  TEMP_IN_USE_HIGH_WATER:   9505</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Host命令可以调用操作系统级别的指令\"><a href=\"#使用Host命令可以调用操作系统级别的指令\" class=\"headerlink\" title=\"使用Host命令可以调用操作系统级别的指令\"></a>使用Host命令可以调用操作系统级别的指令</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ttstatus;</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:37:28 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 6522 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 6531 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Data store /u01/ttdata/datastores/my_ttdb</span><br><span class=\"line\">There are 12 connections to the data store</span><br><span class=\"line\">Shared Memory KEY 0x1200c904 ID 2785297</span><br><span class=\"line\">PL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000</span><br><span class=\"line\">Type            PID     Context             Connection Name              ConnID</span><br><span class=\"line\">Process         6973    0x0000000000c72c00  my_ttdb                           1</span><br><span class=\"line\">Subdaemon       6529    0x00000000012d3360  Manager                         142</span><br><span class=\"line\">Subdaemon       6529    0x000000000132a1e0  Rollback                        141</span><br><span class=\"line\">Subdaemon       6529    0x000000000140b360  HistGC                          139</span><br><span class=\"line\">Subdaemon       6529    0x0000000001420070  AsyncMV                         140</span><br><span class=\"line\">Subdaemon       6529    0x00000000014b4e00  Log Marker                      136</span><br><span class=\"line\">Subdaemon       6529    0x0000000001509a30  Deadlock Detector               135</span><br><span class=\"line\">Subdaemon       6529    0x000000000151e620  Flusher                         134</span><br><span class=\"line\">Subdaemon       6529    0x0000000001533210  Checkpoint                      133</span><br><span class=\"line\">Subdaemon       6529    0x00000000016286b0  Monitor                         132</span><br><span class=\"line\">Subdaemon       6529    0x00007f95880208e0  Aging                           138</span><br><span class=\"line\">Subdaemon       6529    0x00007f958808f900  IndexGC                         137</span><br><span class=\"line\">Replication policy  : Manual</span><br><span class=\"line\">Cache Agent policy  : Manual</span><br><span class=\"line\">PL/SQL enabled.</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改RAM策略\"><a href=\"#修改RAM策略\" class=\"headerlink\" title=\"修改RAM策略\"></a>修改RAM策略</h3><blockquote>\n<p>上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为<code>inUse</code>的情况，下面会讲到当RAM策略设置为<code>Manual</code>时创建内存数据库的过程。</p>\n<p><code>Manual</code>策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而<code>inUse</code>策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。</p>\n</blockquote>\n<h4 id=\"查看当前RAM策略\"><a href=\"#查看当前RAM策略\" class=\"headerlink\" title=\"查看当前RAM策略\"></a>查看当前RAM策略</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : inUse</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改RAM策略为手动模式（Manual）\"><a href=\"#修改RAM策略为手动模式（Manual）\" class=\"headerlink\" title=\"修改RAM策略为手动模式（Manual）\"></a>修改RAM策略为手动模式（Manual）</h4><blockquote>\n<p>手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : False</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class=\"line\">The <span class=\"built_in\">command</span> failed.</span><br><span class=\"line\">Done.</span><br><span class=\"line\">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure>\n<h4 id=\"向内存中装载数据\"><a href=\"#向内存中装载数据\" class=\"headerlink\" title=\"向内存中装载数据\"></a>向内存中装载数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -ramload my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : True</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br><span class=\"line\">Command&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从内存中卸载数据\"><a href=\"#从内存中卸载数据\" class=\"headerlink\" title=\"从内存中卸载数据\"></a>从内存中卸载数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : False</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class=\"line\">The <span class=\"built_in\">command</span> failed.</span><br><span class=\"line\">Done.</span><br><span class=\"line\">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志和检查点\"><a href=\"#日志和检查点\" class=\"headerlink\" title=\"日志和检查点\"></a>日志和检查点</h3><h4 id=\"查看日志文件，提交之前会预写日志\"><a href=\"#查看日志文件，提交之前会预写日志\" class=\"headerlink\" title=\"查看日志文件，提交之前会预写日志\"></a>查看日志文件，<strong><u>提交之前会预写日志</u></strong></h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ls -al /u03/ttdata/logs/my*</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看检查点\"><a href=\"#查看检查点\" class=\"headerlink\" title=\"查看检查点\"></a>查看检查点</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ls -al /u02/ttdata/datastores/my*</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1</span><br></pre></td></tr></table></figure>\n<h4 id=\"手动更新检查点文件\"><a href=\"#手动更新检查点文件\" class=\"headerlink\" title=\"手动更新检查点文件\"></a>手动更新检查点文件</h4><blockquote>\n<p>非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。</p>\n<p>如下调用检查点文件：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; call ttckpt;</span><br><span class=\"line\">Command&gt; call ttckpt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ttisql基本命令——用户操作\"><a href=\"#ttisql基本命令——用户操作\" class=\"headerlink\" title=\"ttisql基本命令——用户操作\"></a>ttisql基本命令——用户操作</h3><h4 id=\"创建用户，可在表sys-all-users中查找所有的用户信息\"><a href=\"#创建用户，可在表sys-all-users中查找所有的用户信息\" class=\"headerlink\" title=\"创建用户，可在表sys.all_users中查找所有的用户信息\"></a>创建用户，可在表<code>sys.all_users</code>中查找所有的用户信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; select * from sys.all_users;</span><br><span class=\"line\">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class=\"line\">6 rows found.</span><br><span class=\"line\">Command&gt; create user tthr identified by tthr;</span><br><span class=\"line\"></span><br><span class=\"line\">User created.</span><br><span class=\"line\"></span><br><span class=\"line\">Command&gt; select * from sys.all_users;</span><br><span class=\"line\">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class=\"line\">&lt; TTHR, 12, 2018-09-28 23:11:57.126074 &gt;</span><br><span class=\"line\">7 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"给用户分配权限\"><a href=\"#给用户分配权限\" class=\"headerlink\" title=\"给用户分配权限\"></a>给用户分配权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; grant create session to tthr;</span><br><span class=\"line\">Command&gt; grant create table to tthr;</span><br><span class=\"line\">Command&gt; grant create view to tthr;</span><br><span class=\"line\">Command&gt; grant create sequence to tthr;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看当前数据库系统内用户权限\"><a href=\"#查看当前数据库系统内用户权限\" class=\"headerlink\" title=\"查看当前数据库系统内用户权限\"></a>查看当前数据库系统内用户权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">9 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤回用户权限\"><a href=\"#撤回用户权限\" class=\"headerlink\" title=\"撤回用户权限\"></a>撤回用户权限</h4><blockquote>\n<p>以下示例展示了如何从用户撤回权限（赋予<code>delete any table</code>权限后再撤回该权限）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; grant delete any table to tthr;</span><br><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, DELETE ANY TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">10 rows found.</span><br><span class=\"line\">Command&gt; revoke delete any table from tthr;</span><br><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">9 rows found.</span><br></pre></td></tr></table></figure>\n<h3 id=\"ttisql基本命令——数据库对象操作\"><a href=\"#ttisql基本命令——数据库对象操作\" class=\"headerlink\" title=\"ttisql基本命令——数据库对象操作\"></a>ttisql基本命令——数据库对象操作</h3><h4 id=\"关闭自动提交\"><a href=\"#关闭自动提交\" class=\"headerlink\" title=\"关闭自动提交\"></a>关闭自动提交</h4><blockquote>\n<p>意即每次执行事务后，均需要执行<code>commit</code>以提交事务。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; autocommit off;</span><br></pre></td></tr></table></figure>\n<h4 id=\"建表、插入数据\"><a href=\"#建表、插入数据\" class=\"headerlink\" title=\"建表、插入数据\"></a>建表、插入数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; create table ttemployees</span><br><span class=\"line\">       &gt; (employee_id NUMBER(6) NOT NULL,</span><br><span class=\"line\">       &gt; last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB,</span><br><span class=\"line\">       &gt; PRIMARY KEY (employee_id) )</span><br><span class=\"line\">       &gt; UNIQUE HASH ON (employee_id) PAGES = 1;</span><br><span class=\"line\">Command&gt; insert into ttemployees values (1, &apos;Smith&apos;, &apos;2009-02-23&apos;, &apos;excellent&apos;); </span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; insert into ttemployees values (2, &apos;King&apos;, &apos;2005-08-05&apos;, &apos;great&apos;);</span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; insert into ttemployees values (3, &apos;Taylor&apos;, &apos;2012-01-28&apos;, EMPTY_CLOB());</span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; commit;</span><br></pre></td></tr></table></figure>\n<h4 id=\"一些命令总结\"><a href=\"#一些命令总结\" class=\"headerlink\" title=\"一些命令总结\"></a>一些命令总结</h4><blockquote>\n<ul>\n<li>tables and alltables - Lists tables</li>\n<li>indexes and allindexes - Lists indexes</li>\n<li>views and allviews - Lists views</li>\n<li>sequences and allsequences - Lists sequences</li>\n<li>synonyms and allsynonyms - Lists synonyms</li>\n<li>functions and allfunctions - Lists PL/SQL functions</li>\n<li>procedures and allprocedures - Lists PL/SQL procedures</li>\n<li>packages and allpackages - Lists PL/SQL packages</li>\n</ul>\n</blockquote>\n<h3 id=\"PLSQL编程\"><a href=\"#PLSQL编程\" class=\"headerlink\" title=\"PLSQL编程\"></a>PLSQL编程</h3><h4 id=\"创建plsqldb、pls用户、运行sql脚本\"><a href=\"#创建plsqldb、pls用户、运行sql脚本\" class=\"headerlink\" title=\"创建plsqldb、pls用户、运行sql脚本\"></a>创建plsqldb、pls用户、运行sql脚本</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">call</span> ttOptUpdateStats;</span><br><span class=\"line\">// 更新统计数据，用于分析生成最优执行计划</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用sql-developer连接TimesTen和Oracle\"><a href=\"#使用sql-developer连接TimesTen和Oracle\" class=\"headerlink\" title=\"使用sql developer连接TimesTen和Oracle\"></a>使用sql developer连接TimesTen和Oracle</h4><p>配置如下：</p>\n<p><img src=\"/images/image-20181018140355729.png\" alt=\"TimesTen数据库连接配置\"></p>\n<p><img src=\"/images/image-20181018140412582.png\" alt=\"Oracle数据库连接配置\"></p>\n<h4 id=\"plsql语法\"><a href=\"#plsql语法\" class=\"headerlink\" title=\"plsql语法\"></a>plsql语法</h4><blockquote>\n<h2 id=\"What-Is-a-PL-SQL-Package\"><a href=\"#What-Is-a-PL-SQL-Package\" class=\"headerlink\" title=\"What Is a PL/SQL Package?\"></a>What Is a PL/SQL Package?</h2><p>A <strong>package</strong> is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The <strong>specification</strong> (<strong>spec</strong> for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The <strong>body</strong> fully defines cursors and subprograms, and so implements the spec.</p>\n<p><code>包</code>是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，<code>规范</code>和<code>主体</code>，主体不是必要的。<code>规范</code>是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。<code>主体</code>将完全定义游标和子程序，以此实现<code>规范</code>。</p>\n<p>As <a href=\"https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#5871\" target=\"_blank\" rel=\"noopener\">Figure 9-1</a> shows, you can think of the spec as an operational interface and of the body as a “black box.” You can debug, enhance, or replace a package body without changing the interface (package spec) to the package.</p>\n<p><img src=\"/images/image-20181018143452887.png\" alt=\"包\"></p>\n<p>——<a href=\"https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#362\" target=\"_blank\" rel=\"noopener\">Oracle PL/SQL Package文档</a></p>\n</blockquote>\n<p><code>1_package.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PACKAGE test AS</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Declare a record for the desired EMP fields</span><br><span class=\"line\">  TYPE empRecType IS RECORD (</span><br><span class=\"line\">    r_empno  EMP.EMPNO%TYPE,</span><br><span class=\"line\">      -- 使用EMP表中EMPNO的类型</span><br><span class=\"line\">    r_ename  EMP.ENAME%TYPE,</span><br><span class=\"line\">    r_salary EMP.SAL%TYPE</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Declare a Ref Cursor type</span><br><span class=\"line\">  TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值</span><br><span class=\"line\"></span><br><span class=\"line\">  -- A parameterized cursor，定义</span><br><span class=\"line\">  \t-- 游标</span><br><span class=\"line\">  CURSOR low_paid (num PLS_INTEGER) IS</span><br><span class=\"line\">    SELECT empno </span><br><span class=\"line\">      FROM emp</span><br><span class=\"line\">      WHERE rownum &lt;= num</span><br><span class=\"line\">      ORDER BY sal ASC;</span><br><span class=\"line\">\t-- 过程(IN表示输入，OUT表示输出)</span><br><span class=\"line\">  PROCEDURE ddl_dml</span><br><span class=\"line\">    (myComment IN  VARCHAR2,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER, -- 整型</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE givePayRise</span><br><span class=\"line\">    (num       IN  PLS_INTEGER,</span><br><span class=\"line\">     name      OUT EMP.ENAME%TYPE, </span><br><span class=\"line\">     \t-- name是plsql中的保留字，应该尽量避免使用保留字</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE getCommEmps</span><br><span class=\"line\">    (empRefCur IN OUT EmpCurType,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\">  -- Associative array</span><br><span class=\"line\">  TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type</span><br><span class=\"line\">  INDEX BY PLS_INTEGER; -- indexed by pls_integer</span><br><span class=\"line\">  </span><br><span class=\"line\">  FUNCTION get_sum_multiples</span><br><span class=\"line\">   ( multiple IN PLS_INTEGER,</span><br><span class=\"line\">     num      IN PLS_INTEGER</span><br><span class=\"line\">   ) RETURN sum_multiples;</span><br><span class=\"line\"></span><br><span class=\"line\">END test;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE OR REPLACE PACKAGE BODY test AS</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE ddl_dml</span><br><span class=\"line\">    (myComment IN  VARCHAR2,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    sql_str                    VARCHAR2(256);</span><br><span class=\"line\">    name_already_exists        EXCEPTION;</span><br><span class=\"line\">    insufficient_privileges    EXCEPTION;</span><br><span class=\"line\">    PRAGMA EXCEPTION_INIT(name_already_exists,     -0955);</span><br><span class=\"line\">    PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031);</span><br><span class=\"line\">    seq_value                  number;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">      sql_str := &apos;create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))&apos;;</span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(sql_str);</span><br><span class=\"line\">      execute immediate sql_str;</span><br><span class=\"line\">    EXCEPTION</span><br><span class=\"line\">      WHEN name_already_exists THEN</span><br><span class=\"line\">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore existing table errors&apos;);</span><br><span class=\"line\">      WHEN insufficient_privileges THEN</span><br><span class=\"line\">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore insufficient privileges errors&apos;);</span><br><span class=\"line\">    END;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Cast num_col1 and char_col values</span><br><span class=\"line\">    insert into temp values (1, 1, myComment);</span><br><span class=\"line\"></span><br><span class=\"line\">    commit;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN name_already_exists THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode := 0;</span><br><span class=\"line\">      errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END ddl_dml;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE givePayRise</span><br><span class=\"line\">    (num       IN  PLS_INTEGER,</span><br><span class=\"line\">     name      OUT EMP.ENAME%TYPE,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">   -- Can use PLSQL collections within TimesTen PLSQL</span><br><span class=\"line\">   TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE;</span><br><span class=\"line\">   lowest_paid lowest_paid_type;</span><br><span class=\"line\"></span><br><span class=\"line\">   i           PLS_INTEGER; </span><br><span class=\"line\">   numRows     PLS_INTEGER;</span><br><span class=\"line\">   lucky_index PLS_INTEGER; </span><br><span class=\"line\">   lucky_emp   EMP.EMPNO%TYPE; </span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Initialize the output variable</span><br><span class=\"line\">    name := &apos;Nobody&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Initialize the collection</span><br><span class=\"line\">    lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">    i := 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    -- Constrain the resultset size</span><br><span class=\"line\">    IF num &lt; 1 OR num &gt; 10 THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      -- If bad inputs, default to 5 rows</span><br><span class=\"line\">      numRows := 5;</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">      numRows := num;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- Create the cursor resultset with up to &apos;numRows&apos; rows</span><br><span class=\"line\">    OPEN low_paid( numRows );</span><br><span class=\"line\"></span><br><span class=\"line\">    LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- Get the current empid</span><br><span class=\"line\">      FETCH low_paid INTO lowest_paid(i);</span><br><span class=\"line\"></span><br><span class=\"line\">      EXIT WHEN low_paid%NOTFOUND;</span><br><span class=\"line\"></span><br><span class=\"line\">      -- Increment the PLSQL table index</span><br><span class=\"line\">      i := i + 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Close the cursor</span><br><span class=\"line\">    CLOSE low_paid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- List the subset of lowest paid employees</span><br><span class=\"line\">    FOR j in lowest_paid.FIRST .. numRows LOOP</span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(&apos;  Lowest paid empno &apos; || j || &apos; is &apos; || lowest_paid(j) );</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Randomly choose one of the lowest paid employees for a 10% pay raise.</span><br><span class=\"line\">    lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); </span><br><span class=\"line\">    lucky_emp := lowest_paid(lucky_index);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- Give lucky_emp a 10% pay raise and return their name</span><br><span class=\"line\">    UPDATE emp</span><br><span class=\"line\">      SET sal = sal * 1.1</span><br><span class=\"line\">      WHERE empno = lucky_emp</span><br><span class=\"line\">      RETURNING ename INTO name;</span><br><span class=\"line\"></span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END givePayRise;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE getCommEmps</span><br><span class=\"line\">    (empRefCur IN OUT EmpCurType,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    salesGuy empRecType;</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN </span><br><span class=\"line\"></span><br><span class=\"line\">    DBMS_OUTPUT.PUT_LINE(&apos; &apos;);</span><br><span class=\"line\">    DBMS_OUTPUT.PUT_LINE(&apos;Displaying the refcursor for the sales people&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- The refcursor (empRefCur) result was opened before calling this procedure</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH empRefCur INTO salesGuy;</span><br><span class=\"line\">      EXIT WHEN empRefCur%NOTFOUND;</span><br><span class=\"line\"></span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    CLOSE empRefCur;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END getCommEmps;</span><br><span class=\"line\"></span><br><span class=\"line\">  FUNCTION get_sum_multiples</span><br><span class=\"line\">   ( multiple IN PLS_INTEGER,</span><br><span class=\"line\">     num      IN PLS_INTEGER</span><br><span class=\"line\">   ) RETURN sum_multiples</span><br><span class=\"line\">   IS</span><br><span class=\"line\">     s sum_multiples;</span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\">    FOR i in 1..num LOOP</span><br><span class=\"line\">      s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    RETURN s;</span><br><span class=\"line\">  END get_sum_multiples;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN  -- package initialization goes here</span><br><span class=\"line\">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized package test&apos;);</span><br><span class=\"line\">END test;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>2_call_package.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\"></span><br><span class=\"line\">declare</span><br><span class=\"line\">  errCode      PLS_INTEGER;</span><br><span class=\"line\">  errtext      VARCHAR2(256);</span><br><span class=\"line\">  myRefCur     test.EmpCurType; -- 使用test包中定义的类型</span><br><span class=\"line\">  salesPerson  test.empRecType;</span><br><span class=\"line\">  name         EMP.ENAME%TYPE;</span><br><span class=\"line\">  n           PLS_INTEGER := 5; -- number of multiples to sum for display</span><br><span class=\"line\">  sn          PLS_INTEGER := 10; -- number of multiples to sum</span><br><span class=\"line\">  m           PLS_INTEGER := 3; -- multiple</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">begin</span><br><span class=\"line\"></span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Find some of the lowest paid employees and give a random employee a 10% pay raise&apos;);</span><br><span class=\"line\">    -- Give a lowely paid random employee a 10% pay raise</span><br><span class=\"line\">    test.givePayRise(5, name, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    else</span><br><span class=\"line\">      dbms_output.put_line(name || &apos; got the 10% payraise&apos;);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Open a refcursor</span><br><span class=\"line\">    OPEN myRefCur FOR</span><br><span class=\"line\">      SELECT empno, ename, sal</span><br><span class=\"line\">      FROM emp</span><br><span class=\"line\">      WHERE comm IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- display the resultset of the refcursor</span><br><span class=\"line\">    test.getCommEmps(myRefCur, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Do some DDL and DML in a stored procedure&apos;);</span><br><span class=\"line\">    test.ddl_dml(&apos;hi&apos;, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">    </span><br><span class=\"line\">    -- associative arrays</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Use an associative array to compute the sum of multiples&apos;);</span><br><span class=\"line\">    dbms_output.put_line(</span><br><span class=\"line\">      &apos;Sum of the first &apos; || TO_CHAR(n) || &apos; multiples of &apos; || TO_CHAR(m) </span><br><span class=\"line\">       || &apos; is &apos; ||  TO_CHAR(test.get_sum_multiples (m, sn)(n)));</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>3_create_package_workload.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PACKAGE workload AS</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE oltp_read_only (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2);</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE oltp_read_write (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_c       IN  CHAR,</span><br><span class=\"line\">    v_p       IN  VARCHAR2,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2);</span><br><span class=\"line\"></span><br><span class=\"line\">END workload;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE OR REPLACE PACKAGE BODY workload AS</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Private package variables used for package initialization</span><br><span class=\"line\">  theErrCode PLS_INTEGER   := 0;</span><br><span class=\"line\">  theErrText VARCHAR2(256) := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Using shared package cursors for efficiency</span><br><span class=\"line\">  CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m;</span><br><span class=\"line\"></span><br><span class=\"line\">  CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m</span><br><span class=\"line\">       ORDER BY c;</span><br><span class=\"line\"></span><br><span class=\"line\">  CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT DISTINCT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m</span><br><span class=\"line\">       ORDER BY c;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  -- The workload read only workload</span><br><span class=\"line\">  PROCEDURE oltp_read_only (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the result of the column &apos;c&apos;</span><br><span class=\"line\">    cValue  char(120);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the sum of the rows in (n..m)</span><br><span class=\"line\">    sumK    number(38,0);</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp point query</span><br><span class=\"line\">    FOR i in 1 .. 10 LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class=\"line\">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range query (using a cursor for loop)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class=\"line\">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class=\"line\">      null;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- olpt range SUM() query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class=\"line\">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range ORDER BY query (using explicit fetches)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class=\"line\">    OPEN range_order_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_order_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_order_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range DISTINCT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class=\"line\">    OPEN range_distinct_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_distinct_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_distinct_query;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN NO_DATA_FOUND THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := 0;</span><br><span class=\"line\">      errText  := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END oltp_read_only;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  -- The workload read + write workload</span><br><span class=\"line\">  PROCEDURE oltp_read_write (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_c       IN  CHAR,</span><br><span class=\"line\">    v_p       IN  VARCHAR2,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the result of the column &apos;c&apos;</span><br><span class=\"line\">    cValue  char(120);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the sum of the rows in (n..m)</span><br><span class=\"line\">    sumK    number(38,0);</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp point query</span><br><span class=\"line\">    FOR i in 1 .. 10 LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class=\"line\">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range query (using a cursor for loop)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class=\"line\">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class=\"line\">      null;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- olpt range SUM() query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class=\"line\">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range ORDER BY query (using explict fetches)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class=\"line\">    OPEN range_order_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_order_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_order_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range DISTINCT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class=\"line\">    OPEN range_distinct_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_distinct_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_distinct_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp UPDATES on index column</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on index column&apos;);</span><br><span class=\"line\">    UPDATE sbtest </span><br><span class=\"line\">      SET k = k + 1 </span><br><span class=\"line\">      WHERE id = v_n;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp UPDATES on non-index column</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on non-index column&apos;);</span><br><span class=\"line\">    UPDATE sbtest </span><br><span class=\"line\">      SET c =  v_n</span><br><span class=\"line\">      WHERE id = v_m; </span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp DELETE query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp DELETE query&apos;);</span><br><span class=\"line\">    DELETE FROM sbtest </span><br><span class=\"line\">      WHERE id = v_n;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp INSERT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp INSERT query&apos;);</span><br><span class=\"line\">    INSERT INTO sbtest (id, k, c, pad)</span><br><span class=\"line\">      VALUES (v_n, v_m, v_c, v_p);  </span><br><span class=\"line\"></span><br><span class=\"line\">    -- Commit the changes</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN NO_DATA_FOUND THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := 0;</span><br><span class=\"line\">      errText  := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END oltp_read_write;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN  -- package initialization goes here</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Run the procedures once to initialize everything</span><br><span class=\"line\">  oltp_read_only(1, 1, 10, theErrCode, theErrText );</span><br><span class=\"line\">  oltp_read_write(1, 1, 10, &apos;abc&apos;, &apos;def&apos;, theErrCode, theErrText );</span><br><span class=\"line\"></span><br><span class=\"line\">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized the workload package&apos;);</span><br><span class=\"line\">END workload;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>4_call_workload.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\"></span><br><span class=\"line\">declare</span><br><span class=\"line\">  counter    PLS_INTEGER;</span><br><span class=\"line\">  errCode    PLS_INTEGER;</span><br><span class=\"line\">  errtext    VARCHAR2(256);</span><br><span class=\"line\">  line1      VARCHAR2(256);</span><br><span class=\"line\">  line2      VARCHAR2(256);</span><br><span class=\"line\">  someText   sbtest.c%TYPE;</span><br><span class=\"line\">  moreText   VARCHAR2(256);</span><br><span class=\"line\">  i          PLS_INTEGER;</span><br><span class=\"line\">  iterations PLS_INTEGER;</span><br><span class=\"line\">  startTime  NUMBER;</span><br><span class=\"line\">  endTime    NUMBER;</span><br><span class=\"line\">  duration   NUMBER;</span><br><span class=\"line\">begin</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Initialize the someText string</span><br><span class=\"line\">  line1 := &apos;The quick brown foxy did da jumping thing over that lazy doggy. &apos;;</span><br><span class=\"line\">  line2 := &apos;Question three, who was scott and who or what was tiger?&apos;;</span><br><span class=\"line\">  someText := line1 || line2;</span><br><span class=\"line\">  moreText := &apos;&apos;;</span><br><span class=\"line\"> </span><br><span class=\"line\">  -- Initialize the moreText string</span><br><span class=\"line\">  FOR i in 1 .. 60 LOOP</span><br><span class=\"line\">    moreText := moreText || &apos;a&apos;;</span><br><span class=\"line\">  END LOOP;</span><br><span class=\"line\">  </span><br><span class=\"line\">  -- Get the start time in centi-seconds</span><br><span class=\"line\">  startTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\"></span><br><span class=\"line\">  iterations := 10000;</span><br><span class=\"line\">  for counter in 1 .. iterations LOOP</span><br><span class=\"line\">    workload.oltp_read_only(1, 1, 1100, errCode, errtext);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      exit;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">  end loop;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Get the end time in centi-seconds</span><br><span class=\"line\">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\">  if errCode !=0 then </span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">  end if;</span><br><span class=\"line\">  duration := endTime - startTime;</span><br><span class=\"line\">  IF duration &gt; 0 THEN</span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Called workload.oltp_read_only  &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class=\"line\">  ELSE</span><br><span class=\"line\">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class=\"line\">  END IF;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  iterations := 10000;</span><br><span class=\"line\">  for counter in 1 .. iterations LOOP</span><br><span class=\"line\">    workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      exit;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">  end loop;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Get the end time in centi-seconds</span><br><span class=\"line\">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\"></span><br><span class=\"line\">  if errCode !=0 then </span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">  end if;</span><br><span class=\"line\"></span><br><span class=\"line\">  duration := endTime - startTime;</span><br><span class=\"line\">  IF duration &gt; 0 THEN</span><br><span class=\"line\">    dbms_output.put_line(&apos;Called workload.oltp_read_write &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class=\"line\">  ELSE</span><br><span class=\"line\">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class=\"line\">  END IF;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"内存计算与内存数据库\"><a href=\"#内存计算与内存数据库\" class=\"headerlink\" title=\"内存计算与内存数据库\"></a>内存计算与内存数据库</h1><h2 id=\"第零章\"><a href=\"#第零章\" class=\"headerlink\" title=\"第零章\"></a>第零章</h2><p>OLTP：行存储（记录：元组），联机事务处理</p>\n<p>OLAP：列存储（key-value），联机分析处理</p>\n<h2 id=\"Timesten操作小记\"><a href=\"#Timesten操作小记\" class=\"headerlink\" title=\"Timesten操作小记\"></a>Timesten操作小记</h2>","more":"<h3 id=\"平台\"><a href=\"#平台\" class=\"headerlink\" title=\"平台\"></a>平台</h3><blockquote>\n<p>系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga)</p>\n</blockquote>\n<h3 id=\"创建DSN（Data-Source-Name）\"><a href=\"#创建DSN（Data-Source-Name）\" class=\"headerlink\" title=\"创建DSN（Data Source Name）\"></a>创建DSN（Data Source Name）</h3><blockquote>\n<p>逻辑名，用于标识某一数据库连接</p>\n</blockquote>\n<h4 id=\"打开数据库配置文件-通常称为系统ODBC-INI配置文件\"><a href=\"#打开数据库配置文件-通常称为系统ODBC-INI配置文件\" class=\"headerlink\" title=\"打开数据库配置文件(通常称为系统ODBC.INI配置文件)\"></a>打开数据库配置文件(通常称为<code>系统ODBC.INI配置文件</code>)</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"variable\">$TT_HOME</span>/info</span><br><span class=\"line\">$ gedit sys.odbc.ini</span><br></pre></td></tr></table></figure>\n<h4 id=\"在数据库DSN列表中添加需要新建的数据库名称\"><a href=\"#在数据库DSN列表中添加需要新建的数据库名称\" class=\"headerlink\" title=\"在数据库DSN列表中添加需要新建的数据库名称\"></a>在数据库DSN列表中添加需要新建的数据库名称</h4><figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示</span></span><br><span class=\"line\"><span class=\"section\">[ODBC Data Sources]</span></span><br><span class=\"line\"><span class=\"attr\">my_ttdb</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">TT_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">sampledb_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">cachedb1_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">repdb1_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">repdb2_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Driver</span><br><span class=\"line\"><span class=\"attr\">sampledbCS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">cachedb1CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">repdb1CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br><span class=\"line\"><span class=\"attr\">repdb2CS_1122</span>=TimesTen <span class=\"number\">11.2</span>.<span class=\"number\">2</span> Client Driver</span><br></pre></td></tr></table></figure>\n<h4 id=\"为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\"><a href=\"#为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\" class=\"headerlink\" title=\"为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中\"></a>为2中创建的数据库添加配置，<u><strong>日志文件与检查点文件应存储在不同磁盘中</strong></u></h4><figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置my_ttdb</span></span><br><span class=\"line\"><span class=\"section\">[my_ttdb]</span></span><br><span class=\"line\"><span class=\"comment\"># 数据库监听器驱动位置</span></span><br><span class=\"line\"><span class=\"attr\">Driver</span>=/home/oracle/TimesTen/tt1122/lib/libtten.so </span><br><span class=\"line\"><span class=\"comment\"># DataStore为检查点文件存储位置</span></span><br><span class=\"line\"><span class=\"attr\">DataStore</span>=/u02/ttdata/datastores/my_ttdb </span><br><span class=\"line\"><span class=\"comment\"># LogDir为日志文件存储位置</span></span><br><span class=\"line\"><span class=\"attr\">LogDir</span>=/u03/ttdata/logs</span><br><span class=\"line\"><span class=\"comment\"># 以下两个Size是TimesTen内存数据库的内存分配</span></span><br><span class=\"line\"><span class=\"attr\">PermSize</span>=<span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"attr\">TempSize</span>=<span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"comment\"># 数据库的字符集</span></span><br><span class=\"line\"><span class=\"attr\">DatabaseCharacterSet</span>=AL32UTF8</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客<a href=\"https://blog.csdn.net/stevensxiao/article/details/51050831\" target=\"_blank\" rel=\"noopener\"><strong><u>如何更改TimesTen数据库的大小</u></strong></a>。</p>\n</blockquote>\n<h4 id=\"保存配置文件并关闭\"><a href=\"#保存配置文件并关闭\" class=\"headerlink\" title=\"保存配置文件并关闭\"></a>保存配置文件并关闭</h4><h3 id=\"数据库服务器基本命令\"><a href=\"#数据库服务器基本命令\" class=\"headerlink\" title=\"数据库服务器基本命令\"></a>数据库服务器基本命令</h3><h4 id=\"查看服务器状态\"><a href=\"#查看服务器状态\" class=\"headerlink\" title=\"查看服务器状态\"></a>查看服务器状态</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:08:30 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 2637 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 2646 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动-停止数据库\"><a href=\"#启动-停止数据库\" class=\"headerlink\" title=\"启动/停止数据库\"></a>启动/停止数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttdaemonadmin -stop</span><br><span class=\"line\">TimesTen Daemon stopped.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">ttStatus: Could not connect to the TimesTen daemon.</span><br><span class=\"line\">If the TimesTen daemon is not running, please start it</span><br><span class=\"line\">by running <span class=\"string\">\"ttDaemonAdmin -start\"</span>.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttdaemonadmin -start</span><br><span class=\"line\">TimesTen Daemon startup OK.</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttstatus</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:10:00 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 6522 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 6531 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建TimesTen内存数据库\"><a href=\"#创建TimesTen内存数据库\" class=\"headerlink\" title=\"创建TimesTen内存数据库\"></a>创建TimesTen内存数据库</h3><blockquote>\n<p>默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过<code>ttadmin -RAMPolicy</code>修改，后面会说到。</p>\n<p>也就是说，默认情况下（前提是RAM策略为<code>inUse</code>，下一节会讲到RAM策略的修改），每次在执行<code>connect “dsn=ttdb_name”</code>连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是<code>创建</code>而不是<code>连接到</code>。</p>\n</blockquote>\n<h4 id=\"连接到特定DSN，创建内存数据库\"><a href=\"#连接到特定DSN，创建内存数据库\" class=\"headerlink\" title=\"连接到特定DSN，创建内存数据库\"></a>连接到特定DSN，创建内存数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttisql</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure>\n<p>或者直接在ttisql中指定DSN名称：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br><span class=\"line\">[oracle@timesten-hol ~]$ ttisql my_ttdb</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"DSN=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>问题：重复运行<code>connect “dsn=ttdb_name”</code>命令可以看到命令行中显示了多了连接，这是什么作用呢？</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con1: Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con2: Command&gt; connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">&gt; (Default setting AutoCommit=1)</span><br><span class=\"line\">&gt; con3: Command&gt; </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"查看内存数据库的内存分配及容量\"><a href=\"#查看内存数据库的内存分配及容量\" class=\"headerlink\" title=\"查看内存数据库的内存分配及容量\"></a>查看内存数据库的内存分配及容量</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; dssize</span><br><span class=\"line\"></span><br><span class=\"line\">  PERM_ALLOCATED_SIZE:      40960</span><br><span class=\"line\">  PERM_IN_USE_SIZE:         9453</span><br><span class=\"line\">  PERM_IN_USE_HIGH_WATER:   9453</span><br><span class=\"line\">  TEMP_ALLOCATED_SIZE:      32768</span><br><span class=\"line\">  TEMP_IN_USE_SIZE:         9442</span><br><span class=\"line\">  TEMP_IN_USE_HIGH_WATER:   9505</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Host命令可以调用操作系统级别的指令\"><a href=\"#使用Host命令可以调用操作系统级别的指令\" class=\"headerlink\" title=\"使用Host命令可以调用操作系统级别的指令\"></a>使用Host命令可以调用操作系统级别的指令</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ttstatus;</span><br><span class=\"line\">TimesTen status report as of Thu Sep 27 04:37:28 2018</span><br><span class=\"line\"></span><br><span class=\"line\">Daemon pid 6522 port 53392 instance tt1122</span><br><span class=\"line\">TimesTen server pid 6531 started on port 53393</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Data store /u01/ttdata/datastores/my_ttdb</span><br><span class=\"line\">There are 12 connections to the data store</span><br><span class=\"line\">Shared Memory KEY 0x1200c904 ID 2785297</span><br><span class=\"line\">PL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000</span><br><span class=\"line\">Type            PID     Context             Connection Name              ConnID</span><br><span class=\"line\">Process         6973    0x0000000000c72c00  my_ttdb                           1</span><br><span class=\"line\">Subdaemon       6529    0x00000000012d3360  Manager                         142</span><br><span class=\"line\">Subdaemon       6529    0x000000000132a1e0  Rollback                        141</span><br><span class=\"line\">Subdaemon       6529    0x000000000140b360  HistGC                          139</span><br><span class=\"line\">Subdaemon       6529    0x0000000001420070  AsyncMV                         140</span><br><span class=\"line\">Subdaemon       6529    0x00000000014b4e00  Log Marker                      136</span><br><span class=\"line\">Subdaemon       6529    0x0000000001509a30  Deadlock Detector               135</span><br><span class=\"line\">Subdaemon       6529    0x000000000151e620  Flusher                         134</span><br><span class=\"line\">Subdaemon       6529    0x0000000001533210  Checkpoint                      133</span><br><span class=\"line\">Subdaemon       6529    0x00000000016286b0  Monitor                         132</span><br><span class=\"line\">Subdaemon       6529    0x00007f95880208e0  Aging                           138</span><br><span class=\"line\">Subdaemon       6529    0x00007f958808f900  IndexGC                         137</span><br><span class=\"line\">Replication policy  : Manual</span><br><span class=\"line\">Cache Agent policy  : Manual</span><br><span class=\"line\">PL/SQL enabled.</span><br><span class=\"line\">------------------------------------------------------------------------</span><br><span class=\"line\">Accessible by group oracle</span><br><span class=\"line\">End of report</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改RAM策略\"><a href=\"#修改RAM策略\" class=\"headerlink\" title=\"修改RAM策略\"></a>修改RAM策略</h3><blockquote>\n<p>上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为<code>inUse</code>的情况，下面会讲到当RAM策略设置为<code>Manual</code>时创建内存数据库的过程。</p>\n<p><code>Manual</code>策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而<code>inUse</code>策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。</p>\n</blockquote>\n<h4 id=\"查看当前RAM策略\"><a href=\"#查看当前RAM策略\" class=\"headerlink\" title=\"查看当前RAM策略\"></a>查看当前RAM策略</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : inUse</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改RAM策略为手动模式（Manual）\"><a href=\"#修改RAM策略为手动模式（Manual）\" class=\"headerlink\" title=\"修改RAM策略为手动模式（Manual）\"></a>修改RAM策略为手动模式（Manual）</h4><blockquote>\n<p>手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : False</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class=\"line\">The <span class=\"built_in\">command</span> failed.</span><br><span class=\"line\">Done.</span><br><span class=\"line\">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure>\n<h4 id=\"向内存中装载数据\"><a href=\"#向内存中装载数据\" class=\"headerlink\" title=\"向内存中装载数据\"></a>向内存中装载数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -ramload my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : True</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class=\"line\">(Default setting AutoCommit=1)</span><br><span class=\"line\">Command&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从内存中卸载数据\"><a href=\"#从内存中卸载数据\" class=\"headerlink\" title=\"从内存中卸载数据\"></a>从内存中卸载数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdb</span><br><span class=\"line\">RAM Residence Policy            : manual</span><br><span class=\"line\">Manually Loaded In RAM          : False</span><br><span class=\"line\">Replication Agent Policy        : manual</span><br><span class=\"line\">Replication Manually Started    : False</span><br><span class=\"line\">Cache Agent Policy              : manual</span><br><span class=\"line\">Cache Agent Manually Started    : False</span><br><span class=\"line\">[oracle@timesten-hol info]$ ttisql <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Type ? or <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>, <span class=\"built_in\">type</span> <span class=\"string\">\"exit\"</span> to quit ttIsql.</span><br><span class=\"line\"></span><br><span class=\"line\">connect <span class=\"string\">\"dsn=my_ttdb\"</span>;</span><br><span class=\"line\">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class=\"line\">The <span class=\"built_in\">command</span> failed.</span><br><span class=\"line\">Done.</span><br><span class=\"line\">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure>\n<h3 id=\"日志和检查点\"><a href=\"#日志和检查点\" class=\"headerlink\" title=\"日志和检查点\"></a>日志和检查点</h3><h4 id=\"查看日志文件，提交之前会预写日志\"><a href=\"#查看日志文件，提交之前会预写日志\" class=\"headerlink\" title=\"查看日志文件，提交之前会预写日志\"></a>查看日志文件，<strong><u>提交之前会预写日志</u></strong></h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ls -al /u03/ttdata/logs/my*</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看检查点\"><a href=\"#查看检查点\" class=\"headerlink\" title=\"查看检查点\"></a>查看检查点</h4><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; host ls -al /u02/ttdata/datastores/my*</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0</span><br><span class=\"line\">-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1</span><br></pre></td></tr></table></figure>\n<h4 id=\"手动更新检查点文件\"><a href=\"#手动更新检查点文件\" class=\"headerlink\" title=\"手动更新检查点文件\"></a>手动更新检查点文件</h4><blockquote>\n<p>非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。</p>\n<p>如下调用检查点文件：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; call ttckpt;</span><br><span class=\"line\">Command&gt; call ttckpt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ttisql基本命令——用户操作\"><a href=\"#ttisql基本命令——用户操作\" class=\"headerlink\" title=\"ttisql基本命令——用户操作\"></a>ttisql基本命令——用户操作</h3><h4 id=\"创建用户，可在表sys-all-users中查找所有的用户信息\"><a href=\"#创建用户，可在表sys-all-users中查找所有的用户信息\" class=\"headerlink\" title=\"创建用户，可在表sys.all_users中查找所有的用户信息\"></a>创建用户，可在表<code>sys.all_users</code>中查找所有的用户信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; select * from sys.all_users;</span><br><span class=\"line\">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class=\"line\">6 rows found.</span><br><span class=\"line\">Command&gt; create user tthr identified by tthr;</span><br><span class=\"line\"></span><br><span class=\"line\">User created.</span><br><span class=\"line\"></span><br><span class=\"line\">Command&gt; select * from sys.all_users;</span><br><span class=\"line\">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class=\"line\">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class=\"line\">&lt; TTHR, 12, 2018-09-28 23:11:57.126074 &gt;</span><br><span class=\"line\">7 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"给用户分配权限\"><a href=\"#给用户分配权限\" class=\"headerlink\" title=\"给用户分配权限\"></a>给用户分配权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; grant create session to tthr;</span><br><span class=\"line\">Command&gt; grant create table to tthr;</span><br><span class=\"line\">Command&gt; grant create view to tthr;</span><br><span class=\"line\">Command&gt; grant create sequence to tthr;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看当前数据库系统内用户权限\"><a href=\"#查看当前数据库系统内用户权限\" class=\"headerlink\" title=\"查看当前数据库系统内用户权限\"></a>查看当前数据库系统内用户权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">9 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤回用户权限\"><a href=\"#撤回用户权限\" class=\"headerlink\" title=\"撤回用户权限\"></a>撤回用户权限</h4><blockquote>\n<p>以下示例展示了如何从用户撤回权限（赋予<code>delete any table</code>权限后再撤回该权限）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; grant delete any table to tthr;</span><br><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, DELETE ANY TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">10 rows found.</span><br><span class=\"line\">Command&gt; revoke delete any table from tthr;</span><br><span class=\"line\">Command&gt; select * from sys.dba_sys_privs;</span><br><span class=\"line\">&lt; SYS, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class=\"line\">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class=\"line\">9 rows found.</span><br></pre></td></tr></table></figure>\n<h3 id=\"ttisql基本命令——数据库对象操作\"><a href=\"#ttisql基本命令——数据库对象操作\" class=\"headerlink\" title=\"ttisql基本命令——数据库对象操作\"></a>ttisql基本命令——数据库对象操作</h3><h4 id=\"关闭自动提交\"><a href=\"#关闭自动提交\" class=\"headerlink\" title=\"关闭自动提交\"></a>关闭自动提交</h4><blockquote>\n<p>意即每次执行事务后，均需要执行<code>commit</code>以提交事务。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; autocommit off;</span><br></pre></td></tr></table></figure>\n<h4 id=\"建表、插入数据\"><a href=\"#建表、插入数据\" class=\"headerlink\" title=\"建表、插入数据\"></a>建表、插入数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; create table ttemployees</span><br><span class=\"line\">       &gt; (employee_id NUMBER(6) NOT NULL,</span><br><span class=\"line\">       &gt; last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB,</span><br><span class=\"line\">       &gt; PRIMARY KEY (employee_id) )</span><br><span class=\"line\">       &gt; UNIQUE HASH ON (employee_id) PAGES = 1;</span><br><span class=\"line\">Command&gt; insert into ttemployees values (1, &apos;Smith&apos;, &apos;2009-02-23&apos;, &apos;excellent&apos;); </span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; insert into ttemployees values (2, &apos;King&apos;, &apos;2005-08-05&apos;, &apos;great&apos;);</span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; insert into ttemployees values (3, &apos;Taylor&apos;, &apos;2012-01-28&apos;, EMPTY_CLOB());</span><br><span class=\"line\">1 row inserted.</span><br><span class=\"line\">Command&gt; commit;</span><br></pre></td></tr></table></figure>\n<h4 id=\"一些命令总结\"><a href=\"#一些命令总结\" class=\"headerlink\" title=\"一些命令总结\"></a>一些命令总结</h4><blockquote>\n<ul>\n<li>tables and alltables - Lists tables</li>\n<li>indexes and allindexes - Lists indexes</li>\n<li>views and allviews - Lists views</li>\n<li>sequences and allsequences - Lists sequences</li>\n<li>synonyms and allsynonyms - Lists synonyms</li>\n<li>functions and allfunctions - Lists PL/SQL functions</li>\n<li>procedures and allprocedures - Lists PL/SQL procedures</li>\n<li>packages and allpackages - Lists PL/SQL packages</li>\n</ul>\n</blockquote>\n<h3 id=\"PLSQL编程\"><a href=\"#PLSQL编程\" class=\"headerlink\" title=\"PLSQL编程\"></a>PLSQL编程</h3><h4 id=\"创建plsqldb、pls用户、运行sql脚本\"><a href=\"#创建plsqldb、pls用户、运行sql脚本\" class=\"headerlink\" title=\"创建plsqldb、pls用户、运行sql脚本\"></a>创建plsqldb、pls用户、运行sql脚本</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">call</span> ttOptUpdateStats;</span><br><span class=\"line\">// 更新统计数据，用于分析生成最优执行计划</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用sql-developer连接TimesTen和Oracle\"><a href=\"#使用sql-developer连接TimesTen和Oracle\" class=\"headerlink\" title=\"使用sql developer连接TimesTen和Oracle\"></a>使用sql developer连接TimesTen和Oracle</h4><p>配置如下：</p>\n<p><img src=\"/images/image-20181018140355729.png\" alt=\"TimesTen数据库连接配置\"></p>\n<p><img src=\"/images/image-20181018140412582.png\" alt=\"Oracle数据库连接配置\"></p>\n<h4 id=\"plsql语法\"><a href=\"#plsql语法\" class=\"headerlink\" title=\"plsql语法\"></a>plsql语法</h4><blockquote>\n<h2 id=\"What-Is-a-PL-SQL-Package\"><a href=\"#What-Is-a-PL-SQL-Package\" class=\"headerlink\" title=\"What Is a PL/SQL Package?\"></a>What Is a PL/SQL Package?</h2><p>A <strong>package</strong> is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The <strong>specification</strong> (<strong>spec</strong> for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The <strong>body</strong> fully defines cursors and subprograms, and so implements the spec.</p>\n<p><code>包</code>是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，<code>规范</code>和<code>主体</code>，主体不是必要的。<code>规范</code>是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。<code>主体</code>将完全定义游标和子程序，以此实现<code>规范</code>。</p>\n<p>As <a href=\"https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#5871\" target=\"_blank\" rel=\"noopener\">Figure 9-1</a> shows, you can think of the spec as an operational interface and of the body as a “black box.” You can debug, enhance, or replace a package body without changing the interface (package spec) to the package.</p>\n<p><img src=\"/images/image-20181018143452887.png\" alt=\"包\"></p>\n<p>——<a href=\"https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#362\" target=\"_blank\" rel=\"noopener\">Oracle PL/SQL Package文档</a></p>\n</blockquote>\n<p><code>1_package.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PACKAGE test AS</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Declare a record for the desired EMP fields</span><br><span class=\"line\">  TYPE empRecType IS RECORD (</span><br><span class=\"line\">    r_empno  EMP.EMPNO%TYPE,</span><br><span class=\"line\">      -- 使用EMP表中EMPNO的类型</span><br><span class=\"line\">    r_ename  EMP.ENAME%TYPE,</span><br><span class=\"line\">    r_salary EMP.SAL%TYPE</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Declare a Ref Cursor type</span><br><span class=\"line\">  TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值</span><br><span class=\"line\"></span><br><span class=\"line\">  -- A parameterized cursor，定义</span><br><span class=\"line\">  \t-- 游标</span><br><span class=\"line\">  CURSOR low_paid (num PLS_INTEGER) IS</span><br><span class=\"line\">    SELECT empno </span><br><span class=\"line\">      FROM emp</span><br><span class=\"line\">      WHERE rownum &lt;= num</span><br><span class=\"line\">      ORDER BY sal ASC;</span><br><span class=\"line\">\t-- 过程(IN表示输入，OUT表示输出)</span><br><span class=\"line\">  PROCEDURE ddl_dml</span><br><span class=\"line\">    (myComment IN  VARCHAR2,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER, -- 整型</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE givePayRise</span><br><span class=\"line\">    (num       IN  PLS_INTEGER,</span><br><span class=\"line\">     name      OUT EMP.ENAME%TYPE, </span><br><span class=\"line\">     \t-- name是plsql中的保留字，应该尽量避免使用保留字</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE getCommEmps</span><br><span class=\"line\">    (empRefCur IN OUT EmpCurType,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2); </span><br><span class=\"line\"></span><br><span class=\"line\">  -- Associative array</span><br><span class=\"line\">  TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type</span><br><span class=\"line\">  INDEX BY PLS_INTEGER; -- indexed by pls_integer</span><br><span class=\"line\">  </span><br><span class=\"line\">  FUNCTION get_sum_multiples</span><br><span class=\"line\">   ( multiple IN PLS_INTEGER,</span><br><span class=\"line\">     num      IN PLS_INTEGER</span><br><span class=\"line\">   ) RETURN sum_multiples;</span><br><span class=\"line\"></span><br><span class=\"line\">END test;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE OR REPLACE PACKAGE BODY test AS</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE ddl_dml</span><br><span class=\"line\">    (myComment IN  VARCHAR2,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    sql_str                    VARCHAR2(256);</span><br><span class=\"line\">    name_already_exists        EXCEPTION;</span><br><span class=\"line\">    insufficient_privileges    EXCEPTION;</span><br><span class=\"line\">    PRAGMA EXCEPTION_INIT(name_already_exists,     -0955);</span><br><span class=\"line\">    PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031);</span><br><span class=\"line\">    seq_value                  number;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    BEGIN</span><br><span class=\"line\">      sql_str := &apos;create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))&apos;;</span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(sql_str);</span><br><span class=\"line\">      execute immediate sql_str;</span><br><span class=\"line\">    EXCEPTION</span><br><span class=\"line\">      WHEN name_already_exists THEN</span><br><span class=\"line\">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore existing table errors&apos;);</span><br><span class=\"line\">      WHEN insufficient_privileges THEN</span><br><span class=\"line\">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore insufficient privileges errors&apos;);</span><br><span class=\"line\">    END;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Cast num_col1 and char_col values</span><br><span class=\"line\">    insert into temp values (1, 1, myComment);</span><br><span class=\"line\"></span><br><span class=\"line\">    commit;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN name_already_exists THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode := 0;</span><br><span class=\"line\">      errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END ddl_dml;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE givePayRise</span><br><span class=\"line\">    (num       IN  PLS_INTEGER,</span><br><span class=\"line\">     name      OUT EMP.ENAME%TYPE,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">   -- Can use PLSQL collections within TimesTen PLSQL</span><br><span class=\"line\">   TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE;</span><br><span class=\"line\">   lowest_paid lowest_paid_type;</span><br><span class=\"line\"></span><br><span class=\"line\">   i           PLS_INTEGER; </span><br><span class=\"line\">   numRows     PLS_INTEGER;</span><br><span class=\"line\">   lucky_index PLS_INTEGER; </span><br><span class=\"line\">   lucky_emp   EMP.EMPNO%TYPE; </span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Initialize the output variable</span><br><span class=\"line\">    name := &apos;Nobody&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Initialize the collection</span><br><span class=\"line\">    lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">    i := 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    -- Constrain the resultset size</span><br><span class=\"line\">    IF num &lt; 1 OR num &gt; 10 THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      -- If bad inputs, default to 5 rows</span><br><span class=\"line\">      numRows := 5;</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">      numRows := num;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- Create the cursor resultset with up to &apos;numRows&apos; rows</span><br><span class=\"line\">    OPEN low_paid( numRows );</span><br><span class=\"line\"></span><br><span class=\"line\">    LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- Get the current empid</span><br><span class=\"line\">      FETCH low_paid INTO lowest_paid(i);</span><br><span class=\"line\"></span><br><span class=\"line\">      EXIT WHEN low_paid%NOTFOUND;</span><br><span class=\"line\"></span><br><span class=\"line\">      -- Increment the PLSQL table index</span><br><span class=\"line\">      i := i + 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Close the cursor</span><br><span class=\"line\">    CLOSE low_paid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- List the subset of lowest paid employees</span><br><span class=\"line\">    FOR j in lowest_paid.FIRST .. numRows LOOP</span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(&apos;  Lowest paid empno &apos; || j || &apos; is &apos; || lowest_paid(j) );</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Randomly choose one of the lowest paid employees for a 10% pay raise.</span><br><span class=\"line\">    lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); </span><br><span class=\"line\">    lucky_emp := lowest_paid(lucky_index);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    -- Give lucky_emp a 10% pay raise and return their name</span><br><span class=\"line\">    UPDATE emp</span><br><span class=\"line\">      SET sal = sal * 1.1</span><br><span class=\"line\">      WHERE empno = lucky_emp</span><br><span class=\"line\">      RETURNING ename INTO name;</span><br><span class=\"line\"></span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END givePayRise;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE getCommEmps</span><br><span class=\"line\">    (empRefCur IN OUT EmpCurType,</span><br><span class=\"line\">     errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">     errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    salesGuy empRecType;</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN </span><br><span class=\"line\"></span><br><span class=\"line\">    DBMS_OUTPUT.PUT_LINE(&apos; &apos;);</span><br><span class=\"line\">    DBMS_OUTPUT.PUT_LINE(&apos;Displaying the refcursor for the sales people&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- The refcursor (empRefCur) result was opened before calling this procedure</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH empRefCur INTO salesGuy;</span><br><span class=\"line\">      EXIT WHEN empRefCur%NOTFOUND;</span><br><span class=\"line\"></span><br><span class=\"line\">      DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    CLOSE empRefCur;</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END getCommEmps;</span><br><span class=\"line\"></span><br><span class=\"line\">  FUNCTION get_sum_multiples</span><br><span class=\"line\">   ( multiple IN PLS_INTEGER,</span><br><span class=\"line\">     num      IN PLS_INTEGER</span><br><span class=\"line\">   ) RETURN sum_multiples</span><br><span class=\"line\">   IS</span><br><span class=\"line\">     s sum_multiples;</span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\">    FOR i in 1..num LOOP</span><br><span class=\"line\">      s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    RETURN s;</span><br><span class=\"line\">  END get_sum_multiples;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN  -- package initialization goes here</span><br><span class=\"line\">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized package test&apos;);</span><br><span class=\"line\">END test;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>2_call_package.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\"></span><br><span class=\"line\">declare</span><br><span class=\"line\">  errCode      PLS_INTEGER;</span><br><span class=\"line\">  errtext      VARCHAR2(256);</span><br><span class=\"line\">  myRefCur     test.EmpCurType; -- 使用test包中定义的类型</span><br><span class=\"line\">  salesPerson  test.empRecType;</span><br><span class=\"line\">  name         EMP.ENAME%TYPE;</span><br><span class=\"line\">  n           PLS_INTEGER := 5; -- number of multiples to sum for display</span><br><span class=\"line\">  sn          PLS_INTEGER := 10; -- number of multiples to sum</span><br><span class=\"line\">  m           PLS_INTEGER := 3; -- multiple</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">begin</span><br><span class=\"line\"></span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Find some of the lowest paid employees and give a random employee a 10% pay raise&apos;);</span><br><span class=\"line\">    -- Give a lowely paid random employee a 10% pay raise</span><br><span class=\"line\">    test.givePayRise(5, name, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    else</span><br><span class=\"line\">      dbms_output.put_line(name || &apos; got the 10% payraise&apos;);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Open a refcursor</span><br><span class=\"line\">    OPEN myRefCur FOR</span><br><span class=\"line\">      SELECT empno, ename, sal</span><br><span class=\"line\">      FROM emp</span><br><span class=\"line\">      WHERE comm IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- display the resultset of the refcursor</span><br><span class=\"line\">    test.getCommEmps(myRefCur, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\"></span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Do some DDL and DML in a stored procedure&apos;);</span><br><span class=\"line\">    test.ddl_dml(&apos;hi&apos;, errCode, errText);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">    </span><br><span class=\"line\">    -- associative arrays</span><br><span class=\"line\">    dbms_output.put_line(&apos; &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Use an associative array to compute the sum of multiples&apos;);</span><br><span class=\"line\">    dbms_output.put_line(</span><br><span class=\"line\">      &apos;Sum of the first &apos; || TO_CHAR(n) || &apos; multiples of &apos; || TO_CHAR(m) </span><br><span class=\"line\">       || &apos; is &apos; ||  TO_CHAR(test.get_sum_multiples (m, sn)(n)));</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>3_create_package_workload.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE OR REPLACE PACKAGE workload AS</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE oltp_read_only (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2);</span><br><span class=\"line\"></span><br><span class=\"line\">  PROCEDURE oltp_read_write (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_c       IN  CHAR,</span><br><span class=\"line\">    v_p       IN  VARCHAR2,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2);</span><br><span class=\"line\"></span><br><span class=\"line\">END workload;</span><br><span class=\"line\">/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE OR REPLACE PACKAGE BODY workload AS</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Private package variables used for package initialization</span><br><span class=\"line\">  theErrCode PLS_INTEGER   := 0;</span><br><span class=\"line\">  theErrText VARCHAR2(256) := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Using shared package cursors for efficiency</span><br><span class=\"line\">  CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m;</span><br><span class=\"line\"></span><br><span class=\"line\">  CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m</span><br><span class=\"line\">       ORDER BY c;</span><br><span class=\"line\"></span><br><span class=\"line\">  CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class=\"line\">     SELECT DISTINCT c </span><br><span class=\"line\">       FROM sbtest </span><br><span class=\"line\">       WHERE id BETWEEN n AND m</span><br><span class=\"line\">       ORDER BY c;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  -- The workload read only workload</span><br><span class=\"line\">  PROCEDURE oltp_read_only (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the result of the column &apos;c&apos;</span><br><span class=\"line\">    cValue  char(120);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the sum of the rows in (n..m)</span><br><span class=\"line\">    sumK    number(38,0);</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp point query</span><br><span class=\"line\">    FOR i in 1 .. 10 LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class=\"line\">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range query (using a cursor for loop)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class=\"line\">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class=\"line\">      null;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- olpt range SUM() query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class=\"line\">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range ORDER BY query (using explicit fetches)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class=\"line\">    OPEN range_order_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_order_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_order_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range DISTINCT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class=\"line\">    OPEN range_distinct_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_distinct_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_distinct_query;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN NO_DATA_FOUND THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := 0;</span><br><span class=\"line\">      errText  := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END oltp_read_only;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  -- The workload read + write workload</span><br><span class=\"line\">  PROCEDURE oltp_read_write (</span><br><span class=\"line\">    v_id      IN  PLS_INTEGER,</span><br><span class=\"line\">    v_n       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_m       IN  PLS_INTEGER,</span><br><span class=\"line\">    v_c       IN  CHAR,</span><br><span class=\"line\">    v_p       IN  VARCHAR2,</span><br><span class=\"line\">    errCode   OUT PLS_INTEGER,</span><br><span class=\"line\">    errText   OUT VARCHAR2) IS</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the result of the column &apos;c&apos;</span><br><span class=\"line\">    cValue  char(120);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- Store the sum of the rows in (n..m)</span><br><span class=\"line\">    sumK    number(38,0);</span><br><span class=\"line\"></span><br><span class=\"line\">  BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">    errCode := 0;</span><br><span class=\"line\">    errtext := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp point query</span><br><span class=\"line\">    FOR i in 1 .. 10 LOOP</span><br><span class=\"line\"></span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class=\"line\">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class=\"line\">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range query (using a cursor for loop)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class=\"line\">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class=\"line\">      null;</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- olpt range SUM() query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class=\"line\">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range ORDER BY query (using explict fetches)</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class=\"line\">    OPEN range_order_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_order_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_order_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp range DISTINCT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class=\"line\">    OPEN range_distinct_query(v_n, v_m);</span><br><span class=\"line\">    LOOP</span><br><span class=\"line\">      FETCH range_distinct_query INTO cValue;</span><br><span class=\"line\">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class=\"line\">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    CLOSE range_distinct_query;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp UPDATES on index column</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on index column&apos;);</span><br><span class=\"line\">    UPDATE sbtest </span><br><span class=\"line\">      SET k = k + 1 </span><br><span class=\"line\">      WHERE id = v_n;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp UPDATES on non-index column</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on non-index column&apos;);</span><br><span class=\"line\">    UPDATE sbtest </span><br><span class=\"line\">      SET c =  v_n</span><br><span class=\"line\">      WHERE id = v_m; </span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp DELETE query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp DELETE query&apos;);</span><br><span class=\"line\">    DELETE FROM sbtest </span><br><span class=\"line\">      WHERE id = v_n;</span><br><span class=\"line\"></span><br><span class=\"line\">    -- oltp INSERT query</span><br><span class=\"line\">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp INSERT query&apos;);</span><br><span class=\"line\">    INSERT INTO sbtest (id, k, c, pad)</span><br><span class=\"line\">      VALUES (v_n, v_m, v_c, v_p);  </span><br><span class=\"line\"></span><br><span class=\"line\">    -- Commit the changes</span><br><span class=\"line\">    COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">  EXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN NO_DATA_FOUND THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := 0;</span><br><span class=\"line\">      errText  := &apos;OK&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    WHEN OTHERS THEN</span><br><span class=\"line\"></span><br><span class=\"line\">      errCode  := SQLCODE;</span><br><span class=\"line\">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class=\"line\"></span><br><span class=\"line\">  END oltp_read_write;</span><br><span class=\"line\"></span><br><span class=\"line\">BEGIN  -- package initialization goes here</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Run the procedures once to initialize everything</span><br><span class=\"line\">  oltp_read_only(1, 1, 10, theErrCode, theErrText );</span><br><span class=\"line\">  oltp_read_write(1, 1, 10, &apos;abc&apos;, &apos;def&apos;, theErrCode, theErrText );</span><br><span class=\"line\"></span><br><span class=\"line\">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized the workload package&apos;);</span><br><span class=\"line\">END workload;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p><code>4_call_workload.sql:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set serveroutput on;</span><br><span class=\"line\"></span><br><span class=\"line\">declare</span><br><span class=\"line\">  counter    PLS_INTEGER;</span><br><span class=\"line\">  errCode    PLS_INTEGER;</span><br><span class=\"line\">  errtext    VARCHAR2(256);</span><br><span class=\"line\">  line1      VARCHAR2(256);</span><br><span class=\"line\">  line2      VARCHAR2(256);</span><br><span class=\"line\">  someText   sbtest.c%TYPE;</span><br><span class=\"line\">  moreText   VARCHAR2(256);</span><br><span class=\"line\">  i          PLS_INTEGER;</span><br><span class=\"line\">  iterations PLS_INTEGER;</span><br><span class=\"line\">  startTime  NUMBER;</span><br><span class=\"line\">  endTime    NUMBER;</span><br><span class=\"line\">  duration   NUMBER;</span><br><span class=\"line\">begin</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Initialize the someText string</span><br><span class=\"line\">  line1 := &apos;The quick brown foxy did da jumping thing over that lazy doggy. &apos;;</span><br><span class=\"line\">  line2 := &apos;Question three, who was scott and who or what was tiger?&apos;;</span><br><span class=\"line\">  someText := line1 || line2;</span><br><span class=\"line\">  moreText := &apos;&apos;;</span><br><span class=\"line\"> </span><br><span class=\"line\">  -- Initialize the moreText string</span><br><span class=\"line\">  FOR i in 1 .. 60 LOOP</span><br><span class=\"line\">    moreText := moreText || &apos;a&apos;;</span><br><span class=\"line\">  END LOOP;</span><br><span class=\"line\">  </span><br><span class=\"line\">  -- Get the start time in centi-seconds</span><br><span class=\"line\">  startTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\"></span><br><span class=\"line\">  iterations := 10000;</span><br><span class=\"line\">  for counter in 1 .. iterations LOOP</span><br><span class=\"line\">    workload.oltp_read_only(1, 1, 1100, errCode, errtext);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      exit;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">  end loop;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Get the end time in centi-seconds</span><br><span class=\"line\">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\">  if errCode !=0 then </span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">  end if;</span><br><span class=\"line\">  duration := endTime - startTime;</span><br><span class=\"line\">  IF duration &gt; 0 THEN</span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Called workload.oltp_read_only  &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class=\"line\">  ELSE</span><br><span class=\"line\">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class=\"line\">  END IF;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  iterations := 10000;</span><br><span class=\"line\">  for counter in 1 .. iterations LOOP</span><br><span class=\"line\">    workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext);</span><br><span class=\"line\">    if errCode != 0 then</span><br><span class=\"line\">      exit;</span><br><span class=\"line\">    end if;</span><br><span class=\"line\">  end loop;</span><br><span class=\"line\"></span><br><span class=\"line\">  -- Get the end time in centi-seconds</span><br><span class=\"line\">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class=\"line\"></span><br><span class=\"line\">  if errCode !=0 then </span><br><span class=\"line\">    dbms_output.put_line(&apos;  &apos;);</span><br><span class=\"line\">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class=\"line\">  end if;</span><br><span class=\"line\"></span><br><span class=\"line\">  duration := endTime - startTime;</span><br><span class=\"line\">  IF duration &gt; 0 THEN</span><br><span class=\"line\">    dbms_output.put_line(&apos;Called workload.oltp_read_write &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class=\"line\">  ELSE</span><br><span class=\"line\">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class=\"line\">  END IF;</span><br><span class=\"line\">end;</span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>"},{"title":"Hadoop - 云计算期末项目","date":"2018-12-31T09:31:32.000Z","_content":"\n## 系统架构\n\n### 集群架构图\n\n![image-20181228192856958](/images/image-20181228192856958-5996536.png)\n\n\n### <a name=\"a1\">集群机器</a>\n\n| 主机名  | 内存 |       IP        |       软件        |                           运行进程                           |\n| :-----: |  :-----: | :-------------: | :---------------: | :----------------------------------------------------------: |\n|  node0  |  512MB  | 192.168.137.200 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node1  |  512MB  | 192.168.137.201 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node2  |  512MB  | 192.168.137.202 |     ZooKeeper     |                        QuorumPeerMain                        |\n| master  |  2GB  | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 |  2GB  | 192.168.137.10  |    Hadoop,Hive    | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1  |  1GB  | 192.168.137.101 |      Hadoop       |               JournalNode,DataNode,NodeManager               |\n| slave2  |  1GB  | 192.168.137.102 |      Hadoop       |                     DataNode,NodeManager                     |\n| slave3  |  1GB  | 192.168.137.103 |      Hadoop       |                     DataNode,NodeManager                     |\n|  host   |  8GB  |  192.168.137.1  |    应用服务器     |                                                              |\n\n## 集群搭建\n\n### 简介\n\n集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群<sub>~~(因机器内存不够，特地为此买了内存条及SSD)~~</sub>，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。\n\n### 虚拟机创建\n\n此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。\n\n首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的`Host-Only`连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。\n\n在主机网络设置中共享网络：\n\n![image-20181228201105314](/images/image-20181228201105314-5999065.png)\n\n在VirtualBox中执行以下操作设置主机连接方式：\n\n![image-20181228200129326](/images/image-20181228200129326-5998489.png)\n\n在虚拟机终端执行以下操作：\n\n```sh\n# 修改虚拟机的IP、子网掩码\nvim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n# 修改为以下内容\nTYPE=Ethernet\nIPADDR=192.168.137.100\nNETMASK=255.255.255.0\n# 保存退出\n# 修改网关地址\nvim /etc/sysconfig/network\n# 修改为以下内容\nNETWORKING=yes\nGATEWAY=192.168.137.1\n# 保存退出\n# 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP\nhostnamectl set-hostname master\n# 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全\nsystemctl stop firewalld\nsystemctl disable firewalld\n# 重启网络服务\nsystemctl restart network\n# 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功\nping 192.168.137.1\n# 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105\nping 61.135.169.105\n# 修改hosts文件，添加局域网中其他主机的主机名与ip的映射\nvim /etc/hosts\n# 修改为以下内容\n192.168.137.100 master\n192.168.137.10 master1\n192.168.137.101 slave1\n192.168.137.102 slave2\n192.168.137.103 slave3\n192.168.137.200 node0\n192.168.137.201 node1\n192.168.137.202 node2\n0.0.0.0 localhost\n# 保存退出\n```\n\n至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：\n\n```sh\n# 首先添加Hadoop和Hive相关环境变量\nvim /etc/profile\n# 添加下列内容\nexport HADOOP_MAPRED_HOME=/usr/local/hadoop\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\nexport HIVE_HOME=/usr/local/hive\nexport PATH=$HIVE_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH\n# 保存退出，并使环境变量生效\nsource /etc/profile\n```\n\nHadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。\n\n### 虚拟机复制\n\n上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。\n\n#### 网络配置\n\n对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：\n\n- 修改IP\n\n  ```sh\n  vim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的IP将`IPADDR`项修改为对应的IP\n\n- 修改主机名\n\n  ```sh\n  hostnamectl set-hostname XXX\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名\n\n- 重启网络服务\n\n  ```sh\n  systemctl restart network\n  ```\n  \n- ping各个节点测试是否成功\n\n  ```sh\n  ping master\n  ping master1\n  ping slave1\n  ping slave2\n  ping slave3\n  ping node0\n  ping node1\n  ping node2\n  ping 192.168.137.1\n  ping 61.135.169.105\n  ```\n\n#### Hadoop配置\n\n##### 修改core-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/core-site.xml\n```\n\n- 作用：Hadoop集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n          <property>\n                  <name>fs.defaultFS</name>\n                  <value>hdfs://ns</value>\n          </property>\n          <property>\n                  <name>hadoop.tmp.dir</name>\n                  <value>/var/hadoop</value>\n          </property> \n          <property>\n                  <name>dfs.permissions.enabled</name>\n                  <value>true</value>\n          </property> \n          <!-- 指定zookeeper地址 -->\n          <property>\n                  <name>ha.zookeeper.quorum</name>\n                  <value>node0:2181,node1:2182,node2:2181</value>\n          </property>\n      \t<!-- 允许访问此hdfs的主机和群组，此处设置为任意 -->\n          <property>\n                  <name>hadoop.proxyuser.root.hosts</name>\n                  <value>*</value>\n          </property>\n          <property>\n                  <name>hadoop.proxyuser.root.groups</name>\n                  <value>*</value>\n          </property>\n  </configuration>\n  ```\n\n##### 修改hdfs-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n```\n\n-  作用：hdfs集群配置文件\n\n-  需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      \t<!-- 指定dfs文件存储位置 -->\n          <property>\n                  <name>dfs.data.dir</name>\n                  <value>/var/hadoop-data</value>\n          </property>\n      \t<!-- 指定文件备份份数 -->\n          <property>\n                  <name>dfs.replication</name>\n                  <value>2</value>\n          </property>\n      \t<!-- 指定机器运行情况检查时间间隔 -->\n          <property>\n                  <name>dfs.namenode.heartbead.recheck-interval</name>\n                  <value>3000000ms</value>\n          </property>\n          <!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 -->\n          <property>\n                  <name>dfs.nameservices</name>\n                  <value>ns</value>\n          </property>\n          <!-- NS下面的NameNode -->\n          <property>\n                  <name>dfs.ha.namenodes.ns</name>\n                  <value>nn1,nn2</value>\n          </property>\n          <!-- nn1的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn1</name>\n                  <value>master:9000</value>\n          </property>\n          <!-- nn1的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn1</name>\n                  <value>master:50070</value>\n          </property>\n          <!-- nn2的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn2</name>\n                  <value>master1:9000</value>\n          </property>\n          <!-- nn2的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn2</name>\n                  <value>master1:50070</value>\n          </property>\n          <!-- 指定NameNode的元数据在JournalNode上的存放位置 -->\n          <property>\n                  <name>dfs.namenode.shared.edits.dir</name>\n                  <value>qjournal://master:8485;master1:8485;slave1:8485/ns</value>\n          </property>\n          <!-- 指定JournalNode在本地磁盘存放数据的位置 -->\n          <property>\n                  <name>dfs.journalnode.edits.dir</name>\n                  <value>/usr/local/hadoop/journaldata</value>\n          </property>\n      \t<!-- 开启机器故障自动切换主从机器 -->\n          <property>\n                  <name>dfs.ha.automatic-failover.enabled</name>\n                  <value>true</value>\n          </property>\n      \t<!-- 指定failover切换的方法(java类的名称) -->\n          <property>\n                  <name>dfs.client.failover.proxy.provider.ns</name>\n              <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n          </property>\n      \t<!-- 指定failover切换的方法，这里使用ssh通信方式交换 -->\n          <property>\n                  <name>dfs.ha.fencing.methods</name>\n                  <value>\n                  sshfence\n                  shell(/bin/true)\n                  </value>\n          </property>\n      \t<!-- ssh切换方法需要指定私钥文件位置 -->\n          <property>\n                  <name>dfs.ha.fencing.ssh.private-key-files</name>\n                  <value>/root/.ssh/id_rsa</value>\n          </property>\n  </configuration>\n  ```\n\n-  注意\n\n   -  假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   -  当使用jdbc访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n##### 修改slaves文件\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/slaves\n```\n\n- 作用：为各个master指定为其工作的slave\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```txt\n  slave1\n  slave2\n  slave3\n  ```\n\n##### 修改yarn-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/yarn-site.xml\n```\n\n- 作用：yarn集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      <!-- 启用yarn集群的高可用机制 -->\n      <property>\n          <name>yarn.resourcemanager.ha.enabled</name>\n          <value>true</value>\n      </property>\n      <!-- 指定ResourceManager集群id，可为任意字串 -->\n      <property>\n          <name>yarn.resourcemanager.cluster-id</name>\n          <value>yrc</value>\n      </property>\n      <!-- 指定两台ResourceManager的名称 -->\n      <property>\n          <name>yarn.resourcemanager.ha.rm-ids</name>\n          <value>rm1,rm2</value>\n      </property>\n      <!-- 指定两台ResourceManager的主机名 -->\n      <property>\n          <name>yarn.resourcemanager.hostname.rm1</name>\n          <value>master</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.hostname.rm2</name>\n          <value>master1</value>\n      </property>\n      <!-- 指定两台ResourceManager的web端口，正常情况为8088 -->\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm1</name>\n          <value>master:8088</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm2</name>\n          <value>master1:8088</value>\n      </property>\n      <!-- 指定管理集群的Zookeeper集群的地址及对应端口 -->\n      <property>\n          <name>yarn.resourcemanager.zk-address</name>\n          <value>node0:2181,node1:2181,node2:2181</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.aux-services</name>\n          <value>mapreduce_shuffle</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.auxservices.mapreduce.shuffle.class</name>\n          <value>org.apache.hadoop.mapred.ShuffleHandler</value>\n      </property>\n      <!-- 指定jar包路径 -->\n      <property>\n          <name>yarn.application.classpath</name>\n          <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n      </property>\n  </configuration>\n  ```\n\n##### 修改mapred-site.xml\n\n- 作用：指定MapReduce操作的基本属性\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```xml\n  <configuration>\n  <property>\n      <name>mapreduce.framework.name</name>\n      <value>yarn</value>\n  </property>\n  <property>\n      <name>mapreduce.application.classpath</name>\n      <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n  </property>\n  </configuration>\n  ```\n\n- 注意：\n\n  - MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce\n  - 此项若是不配，一些job只会在本机跑，而不会分发给其他机器\n\n##### 修改hive-site.xml\n\n```sh\nvim $HIVE_HOME/conf/hive-site.xml\n```\n\n- 作用：hive的基本配置\n\n- 需要修改的机器：master、master1\n\n- 内容：\n\n  - 修改`hive.server2.webui.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.webui.host</name>\n          <value>${hostname}</value>\n          <description>The host address the HiveServer2 WebUI will listen on</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.bind.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.thrift.bind.host</name>\n          <value>${hostname}</value>\n          <description>Bind host on which to run the HiveServer2 Thrift service.</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.zookeeper.namespace`\n\n      ```xml\n      <property>\n          <name>hive.server2.zookeeper.namespace</name>\n          <value>hiveserver2</value>\n          <description>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.</description>\n      </property>\n      ```\n\n      注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。\n\n  - 修改`javax.jdo.option.ConnectionURL`、`javax.jdo.option.ConnectionPassword`和`javax.jdo.option.ConnectionDriverName`\n\n      ```xml\n      <property>\n          <name>javax.jdo.option.ConnectionURL</name>\n              <value>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</value>\n          <description>\n            JDBC connect string for a JDBC metastore.\n            To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.\n            For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.\n          </description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionPassword</name>\n              <value>root</value>\n          <description>password to use against metastore database</description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionDriverName</name>\n              <value>com.mysql.jdbc.Driver</value>\n          <description>Driver class name for a JDBC metastore</description>\n      </property>\n      ```\n\n      这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(~~此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据~~)。\n\n      另外，mysql的连接jar包需要下载并复制到hive的lib目录下。\n\n至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。\n\n#### Zookeeper配置\n\n对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：\n\n```sh\nvim /usr/local/zookeeper/conf/zoo.cfg\n# 添加一下内容\nserver.1=192.168.137.200:2888:3888\nserver.2=192.168.137.201:2888:3888\nserver.3=192.168.137.202:2888:3888\n# 保存并关闭\n```\n\n#### ssh免密登录配置\n\n- 作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的\n\n- 需要修改的机器：所有机器\n\n- 内容：\n\n  ```sh\n  # 进入用户目录下的`.ssh`目录\n  cd\n  cd .ssh/\n  # 创建公钥私钥对\n  ssh-keygen -t rsa\n  # 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍\n  ssh-copy-id ${hostname}\n  ```\n\n至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。\n\n### 集群启动\n\n#### 初始化数据库\n\n在master机器上执行以下操作以初始化数据库：\n\n```sh\ncd $HIVE_HOME\nschematool -initSchema -dbType mysql\n```\n\n此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。\n\n#### 启动集群\n\n在master机器上执行以下操作以启动集群：\n\n```sh\n\n```\n\n## 项目功能需求\n\n### 项目主题\n\n**超市销售管理系统**\n\n### 功能简介\n\n#### 商品进货\n\n**功能点说明**：超市管理员查询供应商，并根据结果输入从该供应商进货的商品信息\n\n**数据需求**：查询供应商，新增进货记录，新增商品\n\n#### 查询商品\n\n**功能点说明**：超市管理员通过商品名搜索库存中的所有相关商品\n\n**数据需求**：查询商品\n\n#### 生成订单\n\n功能点说明：超市管理员查询相应商品并将其添加至订单中，添加完毕后生成订单\n\n数据需求：查询商品，新增购买记录，新增订单\n\n### 概念设计\n\n基于面向对象的思想，我们在分析数据需求的时候简单地将我们的系统分为两个模块：进货和购买，这两个模块都以商品为核心。因此在构建实体-联系模型时，我们也根据这个思想出发，将E-R图分为了两个模块。\n\n#### 总体E-R图\n\n![image-20181231170852678](/images/image-20181231170852678-6247332.png)\n\n#### 进货模块E-R图\n\n![image-20181231170913607](/images/image-20181231170913607-6247353.png)\n\n进货模块主要包含两个实体集，公司（Corporation）和商品（Commodity）。商品中包含着超市库存商品的信息如商品名称、数量、价格，公司类包含供应商的信息如公司名称、地址、国家等。两个实体之间有着关系集供应（Supply），表示某商品从某公司进货。由于一种商品可能从多个公司进货，一个公司也可能供应多种商品，因此他们之间的关系应该是多对多。供应关系集同时还具有属性，表示进货的信息包括数量、成本、时间。\n\n#### 购买模块E-R图\n\n![image-20181231170937495](/images/image-20181231170937495-6247377.png)\n\n购买模块包含的实体集有商品（Commodity）和订单（Bill）。订单表示一次完整购买的总订单（包含购买的所有商品情况），包含的信息有总价、折扣、实际价格等。商品和订单之间有关系集购买（Purchase），由于一个订单包含多个商品，一个商品也会被多次购买，因此这个关系是多对多的。同时，购买关系还具有属性，表示订单中的每一种商品购买的数量和小计价格。\n\n### 逻辑设计\n\n#### 表设计\n\n根据E-R模型的转化，我们生成了5张表，分别是：Corporation（公司），Supply（供应），Commodity（商品），Purchase（购买），Bill（订单）。表的详细设计如下：\n\n##### Commodity表\n\n| 字段名   | 数据类型 | 长度 | 说明       | 备注 |\n| -------- | -------- | ---- | ---------- | ---- |\n| ID       | number   | 10   | 商品的ID   | PK   |\n| name     | varchar  | 20   | 商品名称   |      |\n| quantity | decimal  | 10,2 | 商品库存量 |      |\n| price    | decimal  | 10,2 | 商品单价   |      |\n\n##### Corporation表\n\n| 字段名   | 数据类型 | 长度 | 说明         | 备注 |\n| -------- | -------- | ---- | ------------ | ---- |\n| ID       | number   | 10   | 公司的ID     | PK   |\n| name     | varchar  | 20   | 公司名称     |      |\n| address  | varchar  | 20   | 公司地址     |      |\n| country  | varchar  | 10   | 公司所在国家 |      |\n| business | varchar  | 10   | 公司业务     |      |\n\n##### Bill表\n\n| 字段名     | 数据类型 | 长度 | 说明         | 备注 |\n| ---------- | -------- | ---- | ------------ | ---- |\n| ID         | number   | 10   | 订单的ID     | PK   |\n| totalprice | decimal  | 10,2 | 订单总价     |      |\n| discount   | decimal  | 10,2 | 订单折扣     |      |\n| finalprice | decimal  | 10,2 | 订单实际总价 |      |\n| realpay    | decimal  | 10,2 | 顾客付款     |      |\n| charge     | decimal  | 10,2 | 找钱         |      |\n\n##### Supply表\n\n|  字段名   | 数据类型 | 长度 | 说明           | 备注                            |\n| :---------- | :--------- | ---- | :---------------- | --------------------------- |\n|   corID   | number   | 10   | 供应公司的ID   | PK;   FK，参照于Corporation的ID |\n| productID | number   | 10   | 商品的ID       | PK；FK，参照于Commodity的ID     |\n|  amount   | decimal  | 10,2 | 商品供应数量   |                                 |\n| totalcost | number   | 6    | 商品供应总成本 |                                 |\n| supplydate | datetime | 0 | 供应日期 |  |\n\n##### Purchase表\n\n| 字段名    | 数据类型 | 长度 | 说明               | 备注                    |\n| --------- | -------- | ---- | ------------------ | ----------------------- |\n| productID | number   | 10   | 购买商品的ID      | PK；参照于Commodity的ID |\n| billID    | number   | 10   | 订单ID           | PK；参照于Bill的ID      |\n| amount    | decimal  | 10,2 | 购买该商品数量     |                         |\n| sumprice  | decimal  | 10,2 | 购买该商品小计价格 |                         |\n\n\n#### 数据库关系图\n\n根据表的设计和之间的外码约束，绘制出数据库的关系图：\n\n![image-20181231171547272](/images/image-20181231171547272-6247747.png)\n\n### Hive中的实际存储\n\n经过多次尝试与实验，发现Hive中实际上是不支持表间外键联系的，因此我们在实际存储上述的表结构时将所有的外键均去除了。\n\n> 这引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表结构的特殊性，使得\b使用人员方便针对各种功能设计所需的信息表，而非使用传统的符合3NF或者其他范式的表结构，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一(其消除了由于大量表间连接时而产生的冗余操作，这是很典型的以**空间**换取**时间**的策略)。\n\n## 项目实现方法\n\n整个项目我们使用传统的JavaWeb框架。后端使用Servlet处理数据交互，使用JDBC连接Zookeeper管理的Hiveserver2集群；前端使用Bootstrap框架完成基本的项目展示功能：\n\n![1](/images/1.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图1：查看库存\n\n![2](/images/2.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图2：查看历史账单\n\n![3](/images/3.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：创建新账单\n\n我们深知本项目重点在分布式集群而非前端展示上，因此我们组将95%的精力放在项目的理论理解、环境搭建、性能提升以及实践使用上。\n\n## 项目亮点\n\n### HA的原理理解及实现\n\nHA的实现是我们组在搭建集群时遇到的最大的难题，如何协调其主次关系、如何保证网络通信、如何确定哪些进程应该运行在哪些合适的机器上，举个例子：在我们完成集群搭建到了最后启动Hive时，启动了两个Hive客户端进程和两个Hiveserver2服务端进程，而两个Hive客户端又共用了同一个MySQL服务器，导致jdbc在连接Zookeeper时会随机访问到两个Hive客户端，这导致了数据库数据时而一致、时而不一致，后来我们在Hive的配置文件将其连接Hive客户端改为同一个后将其解决了。诸如此类的小问题我们遇到了很多很多，最后都一一得到了解决。\n\n### Hive与MySQL的横向对比\n\n我们发现Hadoop集群启动后，前端与后端进行数据交互的速度很慢，于是我们使用MySQL与Hive做了简单的对比，结果很让我们困惑：MySQL的执行时间基本上是远远快于Hive的执行时间的。\n\n我们从以下角度进行了思考与实验：\n\n首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为\"操作\"不是造成二者执行时间差异的原因；\n\n其次，Hive官网有句话\b\"Hive在大型数据集上会表现出优越的性能\"，考虑到我们的项目数据集\b中，最多的数据集是数百万条的商品库存数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：将数据量从10W变化到1000W，然后观察在等量的数据量变化上，二者执行时间的变化，得到下表：\n\n| 数据库类型     | 10W数据 | 1000W数据 |\n| -------------- | ------: | :-------: |\n| MySQL          |     9ms |   271ms   |\n| Hive(textfile) |  1428ms |  5100ms   |\n\n就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。\n\n然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件。\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，因此我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点。存储中源数据文件大小为872MB，当使用textfile格式存储时，Hive会将我们导入的文件原封不动的移动到hdfs的Hive数据文件目录下，而使用ORCFile格式存储时文件大小只有260MB大小，这是其优点之一：**文件压缩**。至于性能，我们执行了上述同样的实验：\n\n| 数据库类型     | 10W数据 | 1000W数据 |\n| -------------- | ------: | :-------: |\n| MySQL          |     9ms |   271ms   |\n| Hive(textfile) |  1428ms |  5100ms   |\n| Hive(ORC)      |   110ms |   126ms   |\n\n结果显而易见，当数据达到\b数百万量级时，Hive在存储模式**较优**的使用方法下已经要比MySQL要稍显胜势了。\n\n通过以上两点我们不难总结出以下几点：\n\n- 限制Hive的效率的因素：\n\n  - 数据量\n\n    在百万数据量以下时，Hadoop是很难发挥出其优点的\n\n  - \b计算框架\n\n    Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使Hive执行效率更上一层\n\n  - 网络通信\n\n    由于我们的集群搭建在虚拟机中，其间数据通过真实的网络通信传输，虽然少了中间光纤传递的过程，但是在建立连接到发送数据到取消连接这一过程所耗费的时间都是很难被忽略的，因此生产环境下的Hadoop集群对网络带宽的要求是很高的\n\n- 百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选\n\n- 千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优\n","source":"_posts/云计算期末项目文档.md","raw":"---\ntitle: Hadoop - 云计算期末项目\ndate: 2018-12-31 17:31:32\ntags:\n\t- Hadoop\n\t- 云计算\ncategories:\n    - 分布式与云计算\n---\n\n## 系统架构\n\n### 集群架构图\n\n![image-20181228192856958](/images/image-20181228192856958-5996536.png)\n\n\n### <a name=\"a1\">集群机器</a>\n\n| 主机名  | 内存 |       IP        |       软件        |                           运行进程                           |\n| :-----: |  :-----: | :-------------: | :---------------: | :----------------------------------------------------------: |\n|  node0  |  512MB  | 192.168.137.200 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node1  |  512MB  | 192.168.137.201 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node2  |  512MB  | 192.168.137.202 |     ZooKeeper     |                        QuorumPeerMain                        |\n| master  |  2GB  | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 |  2GB  | 192.168.137.10  |    Hadoop,Hive    | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1  |  1GB  | 192.168.137.101 |      Hadoop       |               JournalNode,DataNode,NodeManager               |\n| slave2  |  1GB  | 192.168.137.102 |      Hadoop       |                     DataNode,NodeManager                     |\n| slave3  |  1GB  | 192.168.137.103 |      Hadoop       |                     DataNode,NodeManager                     |\n|  host   |  8GB  |  192.168.137.1  |    应用服务器     |                                                              |\n\n## 集群搭建\n\n### 简介\n\n集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群<sub>~~(因机器内存不够，特地为此买了内存条及SSD)~~</sub>，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。\n\n### 虚拟机创建\n\n此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。\n\n首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的`Host-Only`连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。\n\n在主机网络设置中共享网络：\n\n![image-20181228201105314](/images/image-20181228201105314-5999065.png)\n\n在VirtualBox中执行以下操作设置主机连接方式：\n\n![image-20181228200129326](/images/image-20181228200129326-5998489.png)\n\n在虚拟机终端执行以下操作：\n\n```sh\n# 修改虚拟机的IP、子网掩码\nvim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n# 修改为以下内容\nTYPE=Ethernet\nIPADDR=192.168.137.100\nNETMASK=255.255.255.0\n# 保存退出\n# 修改网关地址\nvim /etc/sysconfig/network\n# 修改为以下内容\nNETWORKING=yes\nGATEWAY=192.168.137.1\n# 保存退出\n# 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP\nhostnamectl set-hostname master\n# 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全\nsystemctl stop firewalld\nsystemctl disable firewalld\n# 重启网络服务\nsystemctl restart network\n# 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功\nping 192.168.137.1\n# 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105\nping 61.135.169.105\n# 修改hosts文件，添加局域网中其他主机的主机名与ip的映射\nvim /etc/hosts\n# 修改为以下内容\n192.168.137.100 master\n192.168.137.10 master1\n192.168.137.101 slave1\n192.168.137.102 slave2\n192.168.137.103 slave3\n192.168.137.200 node0\n192.168.137.201 node1\n192.168.137.202 node2\n0.0.0.0 localhost\n# 保存退出\n```\n\n至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：\n\n```sh\n# 首先添加Hadoop和Hive相关环境变量\nvim /etc/profile\n# 添加下列内容\nexport HADOOP_MAPRED_HOME=/usr/local/hadoop\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\nexport HIVE_HOME=/usr/local/hive\nexport PATH=$HIVE_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH\n# 保存退出，并使环境变量生效\nsource /etc/profile\n```\n\nHadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。\n\n### 虚拟机复制\n\n上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。\n\n#### 网络配置\n\n对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：\n\n- 修改IP\n\n  ```sh\n  vim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的IP将`IPADDR`项修改为对应的IP\n\n- 修改主机名\n\n  ```sh\n  hostnamectl set-hostname XXX\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名\n\n- 重启网络服务\n\n  ```sh\n  systemctl restart network\n  ```\n  \n- ping各个节点测试是否成功\n\n  ```sh\n  ping master\n  ping master1\n  ping slave1\n  ping slave2\n  ping slave3\n  ping node0\n  ping node1\n  ping node2\n  ping 192.168.137.1\n  ping 61.135.169.105\n  ```\n\n#### Hadoop配置\n\n##### 修改core-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/core-site.xml\n```\n\n- 作用：Hadoop集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n          <property>\n                  <name>fs.defaultFS</name>\n                  <value>hdfs://ns</value>\n          </property>\n          <property>\n                  <name>hadoop.tmp.dir</name>\n                  <value>/var/hadoop</value>\n          </property> \n          <property>\n                  <name>dfs.permissions.enabled</name>\n                  <value>true</value>\n          </property> \n          <!-- 指定zookeeper地址 -->\n          <property>\n                  <name>ha.zookeeper.quorum</name>\n                  <value>node0:2181,node1:2182,node2:2181</value>\n          </property>\n      \t<!-- 允许访问此hdfs的主机和群组，此处设置为任意 -->\n          <property>\n                  <name>hadoop.proxyuser.root.hosts</name>\n                  <value>*</value>\n          </property>\n          <property>\n                  <name>hadoop.proxyuser.root.groups</name>\n                  <value>*</value>\n          </property>\n  </configuration>\n  ```\n\n##### 修改hdfs-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n```\n\n-  作用：hdfs集群配置文件\n\n-  需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      \t<!-- 指定dfs文件存储位置 -->\n          <property>\n                  <name>dfs.data.dir</name>\n                  <value>/var/hadoop-data</value>\n          </property>\n      \t<!-- 指定文件备份份数 -->\n          <property>\n                  <name>dfs.replication</name>\n                  <value>2</value>\n          </property>\n      \t<!-- 指定机器运行情况检查时间间隔 -->\n          <property>\n                  <name>dfs.namenode.heartbead.recheck-interval</name>\n                  <value>3000000ms</value>\n          </property>\n          <!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 -->\n          <property>\n                  <name>dfs.nameservices</name>\n                  <value>ns</value>\n          </property>\n          <!-- NS下面的NameNode -->\n          <property>\n                  <name>dfs.ha.namenodes.ns</name>\n                  <value>nn1,nn2</value>\n          </property>\n          <!-- nn1的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn1</name>\n                  <value>master:9000</value>\n          </property>\n          <!-- nn1的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn1</name>\n                  <value>master:50070</value>\n          </property>\n          <!-- nn2的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn2</name>\n                  <value>master1:9000</value>\n          </property>\n          <!-- nn2的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn2</name>\n                  <value>master1:50070</value>\n          </property>\n          <!-- 指定NameNode的元数据在JournalNode上的存放位置 -->\n          <property>\n                  <name>dfs.namenode.shared.edits.dir</name>\n                  <value>qjournal://master:8485;master1:8485;slave1:8485/ns</value>\n          </property>\n          <!-- 指定JournalNode在本地磁盘存放数据的位置 -->\n          <property>\n                  <name>dfs.journalnode.edits.dir</name>\n                  <value>/usr/local/hadoop/journaldata</value>\n          </property>\n      \t<!-- 开启机器故障自动切换主从机器 -->\n          <property>\n                  <name>dfs.ha.automatic-failover.enabled</name>\n                  <value>true</value>\n          </property>\n      \t<!-- 指定failover切换的方法(java类的名称) -->\n          <property>\n                  <name>dfs.client.failover.proxy.provider.ns</name>\n              <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n          </property>\n      \t<!-- 指定failover切换的方法，这里使用ssh通信方式交换 -->\n          <property>\n                  <name>dfs.ha.fencing.methods</name>\n                  <value>\n                  sshfence\n                  shell(/bin/true)\n                  </value>\n          </property>\n      \t<!-- ssh切换方法需要指定私钥文件位置 -->\n          <property>\n                  <name>dfs.ha.fencing.ssh.private-key-files</name>\n                  <value>/root/.ssh/id_rsa</value>\n          </property>\n  </configuration>\n  ```\n\n-  注意\n\n   -  假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   -  当使用jdbc访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n##### 修改slaves文件\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/slaves\n```\n\n- 作用：为各个master指定为其工作的slave\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```txt\n  slave1\n  slave2\n  slave3\n  ```\n\n##### 修改yarn-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/yarn-site.xml\n```\n\n- 作用：yarn集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      <!-- 启用yarn集群的高可用机制 -->\n      <property>\n          <name>yarn.resourcemanager.ha.enabled</name>\n          <value>true</value>\n      </property>\n      <!-- 指定ResourceManager集群id，可为任意字串 -->\n      <property>\n          <name>yarn.resourcemanager.cluster-id</name>\n          <value>yrc</value>\n      </property>\n      <!-- 指定两台ResourceManager的名称 -->\n      <property>\n          <name>yarn.resourcemanager.ha.rm-ids</name>\n          <value>rm1,rm2</value>\n      </property>\n      <!-- 指定两台ResourceManager的主机名 -->\n      <property>\n          <name>yarn.resourcemanager.hostname.rm1</name>\n          <value>master</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.hostname.rm2</name>\n          <value>master1</value>\n      </property>\n      <!-- 指定两台ResourceManager的web端口，正常情况为8088 -->\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm1</name>\n          <value>master:8088</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm2</name>\n          <value>master1:8088</value>\n      </property>\n      <!-- 指定管理集群的Zookeeper集群的地址及对应端口 -->\n      <property>\n          <name>yarn.resourcemanager.zk-address</name>\n          <value>node0:2181,node1:2181,node2:2181</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.aux-services</name>\n          <value>mapreduce_shuffle</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.auxservices.mapreduce.shuffle.class</name>\n          <value>org.apache.hadoop.mapred.ShuffleHandler</value>\n      </property>\n      <!-- 指定jar包路径 -->\n      <property>\n          <name>yarn.application.classpath</name>\n          <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n      </property>\n  </configuration>\n  ```\n\n##### 修改mapred-site.xml\n\n- 作用：指定MapReduce操作的基本属性\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```xml\n  <configuration>\n  <property>\n      <name>mapreduce.framework.name</name>\n      <value>yarn</value>\n  </property>\n  <property>\n      <name>mapreduce.application.classpath</name>\n      <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n  </property>\n  </configuration>\n  ```\n\n- 注意：\n\n  - MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce\n  - 此项若是不配，一些job只会在本机跑，而不会分发给其他机器\n\n##### 修改hive-site.xml\n\n```sh\nvim $HIVE_HOME/conf/hive-site.xml\n```\n\n- 作用：hive的基本配置\n\n- 需要修改的机器：master、master1\n\n- 内容：\n\n  - 修改`hive.server2.webui.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.webui.host</name>\n          <value>${hostname}</value>\n          <description>The host address the HiveServer2 WebUI will listen on</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.bind.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.thrift.bind.host</name>\n          <value>${hostname}</value>\n          <description>Bind host on which to run the HiveServer2 Thrift service.</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.zookeeper.namespace`\n\n      ```xml\n      <property>\n          <name>hive.server2.zookeeper.namespace</name>\n          <value>hiveserver2</value>\n          <description>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.</description>\n      </property>\n      ```\n\n      注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。\n\n  - 修改`javax.jdo.option.ConnectionURL`、`javax.jdo.option.ConnectionPassword`和`javax.jdo.option.ConnectionDriverName`\n\n      ```xml\n      <property>\n          <name>javax.jdo.option.ConnectionURL</name>\n              <value>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</value>\n          <description>\n            JDBC connect string for a JDBC metastore.\n            To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.\n            For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.\n          </description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionPassword</name>\n              <value>root</value>\n          <description>password to use against metastore database</description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionDriverName</name>\n              <value>com.mysql.jdbc.Driver</value>\n          <description>Driver class name for a JDBC metastore</description>\n      </property>\n      ```\n\n      这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(~~此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据~~)。\n\n      另外，mysql的连接jar包需要下载并复制到hive的lib目录下。\n\n至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。\n\n#### Zookeeper配置\n\n对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：\n\n```sh\nvim /usr/local/zookeeper/conf/zoo.cfg\n# 添加一下内容\nserver.1=192.168.137.200:2888:3888\nserver.2=192.168.137.201:2888:3888\nserver.3=192.168.137.202:2888:3888\n# 保存并关闭\n```\n\n#### ssh免密登录配置\n\n- 作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的\n\n- 需要修改的机器：所有机器\n\n- 内容：\n\n  ```sh\n  # 进入用户目录下的`.ssh`目录\n  cd\n  cd .ssh/\n  # 创建公钥私钥对\n  ssh-keygen -t rsa\n  # 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍\n  ssh-copy-id ${hostname}\n  ```\n\n至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。\n\n### 集群启动\n\n#### 初始化数据库\n\n在master机器上执行以下操作以初始化数据库：\n\n```sh\ncd $HIVE_HOME\nschematool -initSchema -dbType mysql\n```\n\n此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。\n\n#### 启动集群\n\n在master机器上执行以下操作以启动集群：\n\n```sh\n\n```\n\n## 项目功能需求\n\n### 项目主题\n\n**超市销售管理系统**\n\n### 功能简介\n\n#### 商品进货\n\n**功能点说明**：超市管理员查询供应商，并根据结果输入从该供应商进货的商品信息\n\n**数据需求**：查询供应商，新增进货记录，新增商品\n\n#### 查询商品\n\n**功能点说明**：超市管理员通过商品名搜索库存中的所有相关商品\n\n**数据需求**：查询商品\n\n#### 生成订单\n\n功能点说明：超市管理员查询相应商品并将其添加至订单中，添加完毕后生成订单\n\n数据需求：查询商品，新增购买记录，新增订单\n\n### 概念设计\n\n基于面向对象的思想，我们在分析数据需求的时候简单地将我们的系统分为两个模块：进货和购买，这两个模块都以商品为核心。因此在构建实体-联系模型时，我们也根据这个思想出发，将E-R图分为了两个模块。\n\n#### 总体E-R图\n\n![image-20181231170852678](/images/image-20181231170852678-6247332.png)\n\n#### 进货模块E-R图\n\n![image-20181231170913607](/images/image-20181231170913607-6247353.png)\n\n进货模块主要包含两个实体集，公司（Corporation）和商品（Commodity）。商品中包含着超市库存商品的信息如商品名称、数量、价格，公司类包含供应商的信息如公司名称、地址、国家等。两个实体之间有着关系集供应（Supply），表示某商品从某公司进货。由于一种商品可能从多个公司进货，一个公司也可能供应多种商品，因此他们之间的关系应该是多对多。供应关系集同时还具有属性，表示进货的信息包括数量、成本、时间。\n\n#### 购买模块E-R图\n\n![image-20181231170937495](/images/image-20181231170937495-6247377.png)\n\n购买模块包含的实体集有商品（Commodity）和订单（Bill）。订单表示一次完整购买的总订单（包含购买的所有商品情况），包含的信息有总价、折扣、实际价格等。商品和订单之间有关系集购买（Purchase），由于一个订单包含多个商品，一个商品也会被多次购买，因此这个关系是多对多的。同时，购买关系还具有属性，表示订单中的每一种商品购买的数量和小计价格。\n\n### 逻辑设计\n\n#### 表设计\n\n根据E-R模型的转化，我们生成了5张表，分别是：Corporation（公司），Supply（供应），Commodity（商品），Purchase（购买），Bill（订单）。表的详细设计如下：\n\n##### Commodity表\n\n| 字段名   | 数据类型 | 长度 | 说明       | 备注 |\n| -------- | -------- | ---- | ---------- | ---- |\n| ID       | number   | 10   | 商品的ID   | PK   |\n| name     | varchar  | 20   | 商品名称   |      |\n| quantity | decimal  | 10,2 | 商品库存量 |      |\n| price    | decimal  | 10,2 | 商品单价   |      |\n\n##### Corporation表\n\n| 字段名   | 数据类型 | 长度 | 说明         | 备注 |\n| -------- | -------- | ---- | ------------ | ---- |\n| ID       | number   | 10   | 公司的ID     | PK   |\n| name     | varchar  | 20   | 公司名称     |      |\n| address  | varchar  | 20   | 公司地址     |      |\n| country  | varchar  | 10   | 公司所在国家 |      |\n| business | varchar  | 10   | 公司业务     |      |\n\n##### Bill表\n\n| 字段名     | 数据类型 | 长度 | 说明         | 备注 |\n| ---------- | -------- | ---- | ------------ | ---- |\n| ID         | number   | 10   | 订单的ID     | PK   |\n| totalprice | decimal  | 10,2 | 订单总价     |      |\n| discount   | decimal  | 10,2 | 订单折扣     |      |\n| finalprice | decimal  | 10,2 | 订单实际总价 |      |\n| realpay    | decimal  | 10,2 | 顾客付款     |      |\n| charge     | decimal  | 10,2 | 找钱         |      |\n\n##### Supply表\n\n|  字段名   | 数据类型 | 长度 | 说明           | 备注                            |\n| :---------- | :--------- | ---- | :---------------- | --------------------------- |\n|   corID   | number   | 10   | 供应公司的ID   | PK;   FK，参照于Corporation的ID |\n| productID | number   | 10   | 商品的ID       | PK；FK，参照于Commodity的ID     |\n|  amount   | decimal  | 10,2 | 商品供应数量   |                                 |\n| totalcost | number   | 6    | 商品供应总成本 |                                 |\n| supplydate | datetime | 0 | 供应日期 |  |\n\n##### Purchase表\n\n| 字段名    | 数据类型 | 长度 | 说明               | 备注                    |\n| --------- | -------- | ---- | ------------------ | ----------------------- |\n| productID | number   | 10   | 购买商品的ID      | PK；参照于Commodity的ID |\n| billID    | number   | 10   | 订单ID           | PK；参照于Bill的ID      |\n| amount    | decimal  | 10,2 | 购买该商品数量     |                         |\n| sumprice  | decimal  | 10,2 | 购买该商品小计价格 |                         |\n\n\n#### 数据库关系图\n\n根据表的设计和之间的外码约束，绘制出数据库的关系图：\n\n![image-20181231171547272](/images/image-20181231171547272-6247747.png)\n\n### Hive中的实际存储\n\n经过多次尝试与实验，发现Hive中实际上是不支持表间外键联系的，因此我们在实际存储上述的表结构时将所有的外键均去除了。\n\n> 这引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表结构的特殊性，使得\b使用人员方便针对各种功能设计所需的信息表，而非使用传统的符合3NF或者其他范式的表结构，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一(其消除了由于大量表间连接时而产生的冗余操作，这是很典型的以**空间**换取**时间**的策略)。\n\n## 项目实现方法\n\n整个项目我们使用传统的JavaWeb框架。后端使用Servlet处理数据交互，使用JDBC连接Zookeeper管理的Hiveserver2集群；前端使用Bootstrap框架完成基本的项目展示功能：\n\n![1](/images/1.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图1：查看库存\n\n![2](/images/2.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图2：查看历史账单\n\n![3](/images/3.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：创建新账单\n\n我们深知本项目重点在分布式集群而非前端展示上，因此我们组将95%的精力放在项目的理论理解、环境搭建、性能提升以及实践使用上。\n\n## 项目亮点\n\n### HA的原理理解及实现\n\nHA的实现是我们组在搭建集群时遇到的最大的难题，如何协调其主次关系、如何保证网络通信、如何确定哪些进程应该运行在哪些合适的机器上，举个例子：在我们完成集群搭建到了最后启动Hive时，启动了两个Hive客户端进程和两个Hiveserver2服务端进程，而两个Hive客户端又共用了同一个MySQL服务器，导致jdbc在连接Zookeeper时会随机访问到两个Hive客户端，这导致了数据库数据时而一致、时而不一致，后来我们在Hive的配置文件将其连接Hive客户端改为同一个后将其解决了。诸如此类的小问题我们遇到了很多很多，最后都一一得到了解决。\n\n### Hive与MySQL的横向对比\n\n我们发现Hadoop集群启动后，前端与后端进行数据交互的速度很慢，于是我们使用MySQL与Hive做了简单的对比，结果很让我们困惑：MySQL的执行时间基本上是远远快于Hive的执行时间的。\n\n我们从以下角度进行了思考与实验：\n\n首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为\"操作\"不是造成二者执行时间差异的原因；\n\n其次，Hive官网有句话\b\"Hive在大型数据集上会表现出优越的性能\"，考虑到我们的项目数据集\b中，最多的数据集是数百万条的商品库存数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：将数据量从10W变化到1000W，然后观察在等量的数据量变化上，二者执行时间的变化，得到下表：\n\n| 数据库类型     | 10W数据 | 1000W数据 |\n| -------------- | ------: | :-------: |\n| MySQL          |     9ms |   271ms   |\n| Hive(textfile) |  1428ms |  5100ms   |\n\n就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。\n\n然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件。\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，因此我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点。存储中源数据文件大小为872MB，当使用textfile格式存储时，Hive会将我们导入的文件原封不动的移动到hdfs的Hive数据文件目录下，而使用ORCFile格式存储时文件大小只有260MB大小，这是其优点之一：**文件压缩**。至于性能，我们执行了上述同样的实验：\n\n| 数据库类型     | 10W数据 | 1000W数据 |\n| -------------- | ------: | :-------: |\n| MySQL          |     9ms |   271ms   |\n| Hive(textfile) |  1428ms |  5100ms   |\n| Hive(ORC)      |   110ms |   126ms   |\n\n结果显而易见，当数据达到\b数百万量级时，Hive在存储模式**较优**的使用方法下已经要比MySQL要稍显胜势了。\n\n通过以上两点我们不难总结出以下几点：\n\n- 限制Hive的效率的因素：\n\n  - 数据量\n\n    在百万数据量以下时，Hadoop是很难发挥出其优点的\n\n  - \b计算框架\n\n    Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使Hive执行效率更上一层\n\n  - 网络通信\n\n    由于我们的集群搭建在虚拟机中，其间数据通过真实的网络通信传输，虽然少了中间光纤传递的过程，但是在建立连接到发送数据到取消连接这一过程所耗费的时间都是很难被忽略的，因此生产环境下的Hadoop集群对网络带宽的要求是很高的\n\n- 百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选\n\n- 千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优\n","slug":"云计算期末项目文档","published":1,"updated":"2021-05-16T11:00:29.634Z","_id":"ckfukja9q0010szxodvtxpx3y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"集群架构图\"><a href=\"#集群架构图\" class=\"headerlink\" title=\"集群架构图\"></a>集群架构图</h3><p><img src=\"/images/image-20181228192856958-5996536.png\" alt=\"image-20181228192856958\"></p>\n<h3 id=\"集群机器\"><a href=\"#集群机器\" class=\"headerlink\" title=\"集群机器\"></a><a name=\"a1\">集群机器</a></h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">8GB</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群<sub><del>(因机器内存不够，特地为此买了内存条及SSD)</del></sub>，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。</p>\n<h3 id=\"虚拟机创建\"><a href=\"#虚拟机创建\" class=\"headerlink\" title=\"虚拟机创建\"></a>虚拟机创建</h3><p>此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。</p>\n<p>首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的<code>Host-Only</code>连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。</p>\n<p>在主机网络设置中共享网络：</p>\n<p><img src=\"/images/image-20181228201105314-5999065.png\" alt=\"image-20181228201105314\"></p>\n<p>在VirtualBox中执行以下操作设置主机连接方式：</p>\n<p><img src=\"/images/image-20181228200129326-5998489.png\" alt=\"image-20181228200129326\"></p>\n<p>在虚拟机终端执行以下操作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改虚拟机的IP、子网掩码</span></span><br><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">IPADDR=192.168.137.100</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改网关地址</span></span><br><span class=\"line\">vim /etc/sysconfig/network</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">GATEWAY=192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP</span></span><br><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname master</span><br><span class=\"line\"><span class=\"comment\"># 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"><span class=\"comment\"># 重启网络服务</span></span><br><span class=\"line\">systemctl restart network</span><br><span class=\"line\"><span class=\"comment\"># 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功</span></span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105</span></span><br><span class=\"line\">ping 61.135.169.105</span><br><span class=\"line\"><span class=\"comment\"># 修改hosts文件，添加局域网中其他主机的主机名与ip的映射</span></span><br><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">192.168.137.100 master</span><br><span class=\"line\">192.168.137.10 master1</span><br><span class=\"line\">192.168.137.101 slave1</span><br><span class=\"line\">192.168.137.102 slave2</span><br><span class=\"line\">192.168.137.103 slave3</span><br><span class=\"line\">192.168.137.200 node0</span><br><span class=\"line\">192.168.137.201 node1</span><br><span class=\"line\">192.168.137.202 node2</span><br><span class=\"line\">0.0.0.0 localhost</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br></pre></td></tr></table></figure>\n<p>至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先添加Hadoop和Hive相关环境变量</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 添加下列内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_MAPRED_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HIVE_HOME=/usr/<span class=\"built_in\">local</span>/hive</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HIVE_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 保存退出，并使环境变量生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<p>Hadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。</p>\n<h3 id=\"虚拟机复制\"><a href=\"#虚拟机复制\" class=\"headerlink\" title=\"虚拟机复制\"></a>虚拟机复制</h3><p>上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。</p>\n<h4 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h4><p>对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：</p>\n<ul>\n<li><p>修改IP</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的IP将<code>IPADDR</code>项修改为对应的IP</p>\n</li>\n<li><p>修改主机名</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname XXX</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名</p>\n</li>\n<li><p>重启网络服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ping各个节点测试是否成功</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping master</span><br><span class=\"line\">ping master1</span><br><span class=\"line\">ping slave1</span><br><span class=\"line\">ping slave2</span><br><span class=\"line\">ping slave3</span><br><span class=\"line\">ping node0</span><br><span class=\"line\">ping node1</span><br><span class=\"line\">ping node2</span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\">ping 61.135.169.105</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Hadoop配置\"><a href=\"#Hadoop配置\" class=\"headerlink\" title=\"Hadoop配置\"></a>Hadoop配置</h4><h5 id=\"修改core-site-xml\"><a href=\"#修改core-site-xml\" class=\"headerlink\" title=\"修改core-site.xml\"></a>修改core-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：Hadoop集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.permissions.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>ha.zookeeper.quorum<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2182,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 允许访问此hdfs的主机和群组，此处设置为任意 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改hdfs-site-xml\"><a href=\"#修改hdfs-site-xml\" class=\"headerlink\" title=\"修改hdfs-site.xml\"></a>修改hdfs-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hdfs集群配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定dfs文件存储位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop-data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定文件备份份数 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定机器运行情况检查时间间隔 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.heartbead.recheck-interval<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>3000000ms<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.nameservices<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- NS下面的NameNode --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.namenodes.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>nn1,nn2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>qjournal://master:8485;master1:8485;slave1:8485/ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.journalnode.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/journaldata<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 开启机器故障自动切换主从机器 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法(java类的名称) --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法，这里使用ssh通信方式交换 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.methods<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                sshfence</span><br><span class=\"line\">                shell(/bin/true)</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- ssh切换方法需要指定私钥文件位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/root/.ssh/id_rsa<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<ul>\n<li>假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用jdbc访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"修改slaves文件\"><a href=\"#修改slaves文件\" class=\"headerlink\" title=\"修改slaves文件\"></a>修改slaves文件</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/slaves</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：为各个master指定为其工作的slave</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">slave1</span><br><span class=\"line\">slave2</span><br><span class=\"line\">slave3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改yarn-site-xml\"><a href=\"#修改yarn-site-xml\" class=\"headerlink\" title=\"修改yarn-site.xml\"></a>修改yarn-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：yarn集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用yarn集群的高可用机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定ResourceManager集群id，可为任意字串 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yrc<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>rm1,rm2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的主机名 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的web端口，正常情况为8088 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定管理集群的Zookeeper集群的地址及对应端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2181,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定jar包路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改mapred-site-xml\"><a href=\"#修改mapred-site-xml\" class=\"headerlink\" title=\"修改mapred-site.xml\"></a>修改mapred-site.xml</h5><ul>\n<li><p>作用：指定MapReduce操作的基本属性</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce</li>\n<li>此项若是不配，一些job只会在本机跑，而不会分发给其他机器</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"修改hive-site-xml\"><a href=\"#修改hive-site-xml\" class=\"headerlink\" title=\"修改hive-site.xml\"></a>修改hive-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HIVE_HOME</span>/conf/hive-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hive的基本配置</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容：</p>\n<ul>\n<li><p>修改<code>hive.server2.webui.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.webui.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The host address the HiveServer2 WebUI will listen on<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.bind.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.thrift.bind.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Bind host on which to run the HiveServer2 Thrift service.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.zookeeper.namespace</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.zookeeper.namespace<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hiveserver2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。</p>\n</li>\n<li><p>修改<code>javax.jdo.option.ConnectionURL</code>、<code>javax.jdo.option.ConnectionPassword</code>和<code>javax.jdo.option.ConnectionDriverName</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">      JDBC connect string for a JDBC metastore.</span><br><span class=\"line\">      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class=\"line\">      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>password to use against metastore database<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Driver class name for a JDBC metastore<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(<del>此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据</del>)。</p>\n<p>  另外，mysql的连接jar包需要下载并复制到hive的lib目录下。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。</p>\n<h4 id=\"Zookeeper配置\"><a href=\"#Zookeeper配置\" class=\"headerlink\" title=\"Zookeeper配置\"></a>Zookeeper配置</h4><p>对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"built_in\">local</span>/zookeeper/conf/zoo.cfg</span><br><span class=\"line\"><span class=\"comment\"># 添加一下内容</span></span><br><span class=\"line\">server.1=192.168.137.200:2888:3888</span><br><span class=\"line\">server.2=192.168.137.201:2888:3888</span><br><span class=\"line\">server.3=192.168.137.202:2888:3888</span><br><span class=\"line\"><span class=\"comment\"># 保存并关闭</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ssh免密登录配置\"><a href=\"#ssh免密登录配置\" class=\"headerlink\" title=\"ssh免密登录配置\"></a>ssh免密登录配置</h4><ul>\n<li><p>作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的</p>\n</li>\n<li><p>需要修改的机器：所有机器</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入用户目录下的`.ssh`目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> .ssh/</span><br><span class=\"line\"><span class=\"comment\"># 创建公钥私钥对</span></span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\"># 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍</span></span><br><span class=\"line\">ssh-copy-id <span class=\"variable\">$&#123;hostname&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。</p>\n<h3 id=\"集群启动\"><a href=\"#集群启动\" class=\"headerlink\" title=\"集群启动\"></a>集群启动</h3><h4 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h4><p>在master机器上执行以下操作以初始化数据库：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HIVE_HOME</span></span><br><span class=\"line\">schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure>\n<p>此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。</p>\n<h4 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h4><p>在master机器上执行以下操作以启动集群：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"项目功能需求\"><a href=\"#项目功能需求\" class=\"headerlink\" title=\"项目功能需求\"></a>项目功能需求</h2><h3 id=\"项目主题\"><a href=\"#项目主题\" class=\"headerlink\" title=\"项目主题\"></a>项目主题</h3><p><strong>超市销售管理系统</strong></p>\n<h3 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h3><h4 id=\"商品进货\"><a href=\"#商品进货\" class=\"headerlink\" title=\"商品进货\"></a>商品进货</h4><p><strong>功能点说明</strong>：超市管理员查询供应商，并根据结果输入从该供应商进货的商品信息</p>\n<p><strong>数据需求</strong>：查询供应商，新增进货记录，新增商品</p>\n<h4 id=\"查询商品\"><a href=\"#查询商品\" class=\"headerlink\" title=\"查询商品\"></a>查询商品</h4><p><strong>功能点说明</strong>：超市管理员通过商品名搜索库存中的所有相关商品</p>\n<p><strong>数据需求</strong>：查询商品</p>\n<h4 id=\"生成订单\"><a href=\"#生成订单\" class=\"headerlink\" title=\"生成订单\"></a>生成订单</h4><p>功能点说明：超市管理员查询相应商品并将其添加至订单中，添加完毕后生成订单</p>\n<p>数据需求：查询商品，新增购买记录，新增订单</p>\n<h3 id=\"概念设计\"><a href=\"#概念设计\" class=\"headerlink\" title=\"概念设计\"></a>概念设计</h3><p>基于面向对象的思想，我们在分析数据需求的时候简单地将我们的系统分为两个模块：进货和购买，这两个模块都以商品为核心。因此在构建实体-联系模型时，我们也根据这个思想出发，将E-R图分为了两个模块。</p>\n<h4 id=\"总体E-R图\"><a href=\"#总体E-R图\" class=\"headerlink\" title=\"总体E-R图\"></a>总体E-R图</h4><p><img src=\"/images/image-20181231170852678-6247332.png\" alt=\"image-20181231170852678\"></p>\n<h4 id=\"进货模块E-R图\"><a href=\"#进货模块E-R图\" class=\"headerlink\" title=\"进货模块E-R图\"></a>进货模块E-R图</h4><p><img src=\"/images/image-20181231170913607-6247353.png\" alt=\"image-20181231170913607\"></p>\n<p>进货模块主要包含两个实体集，公司（Corporation）和商品（Commodity）。商品中包含着超市库存商品的信息如商品名称、数量、价格，公司类包含供应商的信息如公司名称、地址、国家等。两个实体之间有着关系集供应（Supply），表示某商品从某公司进货。由于一种商品可能从多个公司进货，一个公司也可能供应多种商品，因此他们之间的关系应该是多对多。供应关系集同时还具有属性，表示进货的信息包括数量、成本、时间。</p>\n<h4 id=\"购买模块E-R图\"><a href=\"#购买模块E-R图\" class=\"headerlink\" title=\"购买模块E-R图\"></a>购买模块E-R图</h4><p><img src=\"/images/image-20181231170937495-6247377.png\" alt=\"image-20181231170937495\"></p>\n<p>购买模块包含的实体集有商品（Commodity）和订单（Bill）。订单表示一次完整购买的总订单（包含购买的所有商品情况），包含的信息有总价、折扣、实际价格等。商品和订单之间有关系集购买（Purchase），由于一个订单包含多个商品，一个商品也会被多次购买，因此这个关系是多对多的。同时，购买关系还具有属性，表示订单中的每一种商品购买的数量和小计价格。</p>\n<h3 id=\"逻辑设计\"><a href=\"#逻辑设计\" class=\"headerlink\" title=\"逻辑设计\"></a>逻辑设计</h3><h4 id=\"表设计\"><a href=\"#表设计\" class=\"headerlink\" title=\"表设计\"></a>表设计</h4><p>根据E-R模型的转化，我们生成了5张表，分别是：Corporation（公司），Supply（供应），Commodity（商品），Purchase（购买），Bill（订单）。表的详细设计如下：</p>\n<h5 id=\"Commodity表\"><a href=\"#Commodity表\" class=\"headerlink\" title=\"Commodity表\"></a>Commodity表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>商品的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>20</td>\n<td>商品名称</td>\n<td></td>\n</tr>\n<tr>\n<td>quantity</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>商品库存量</td>\n<td></td>\n</tr>\n<tr>\n<td>price</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>商品单价</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Corporation表\"><a href=\"#Corporation表\" class=\"headerlink\" title=\"Corporation表\"></a>Corporation表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>公司的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>20</td>\n<td>公司名称</td>\n<td></td>\n</tr>\n<tr>\n<td>address</td>\n<td>varchar</td>\n<td>20</td>\n<td>公司地址</td>\n<td></td>\n</tr>\n<tr>\n<td>country</td>\n<td>varchar</td>\n<td>10</td>\n<td>公司所在国家</td>\n<td></td>\n</tr>\n<tr>\n<td>business</td>\n<td>varchar</td>\n<td>10</td>\n<td>公司业务</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Bill表\"><a href=\"#Bill表\" class=\"headerlink\" title=\"Bill表\"></a>Bill表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>订单的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>totalprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单总价</td>\n<td></td>\n</tr>\n<tr>\n<td>discount</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单折扣</td>\n<td></td>\n</tr>\n<tr>\n<td>finalprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单实际总价</td>\n<td></td>\n</tr>\n<tr>\n<td>realpay</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>顾客付款</td>\n<td></td>\n</tr>\n<tr>\n<td>charge</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>找钱</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Supply表\"><a href=\"#Supply表\" class=\"headerlink\" title=\"Supply表\"></a>Supply表</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段名</th>\n<th style=\"text-align:left\">数据类型</th>\n<th>长度</th>\n<th style=\"text-align:left\">说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">corID</td>\n<td style=\"text-align:left\">number</td>\n<td>10</td>\n<td style=\"text-align:left\">供应公司的ID</td>\n<td>PK;   FK，参照于Corporation的ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">productID</td>\n<td style=\"text-align:left\">number</td>\n<td>10</td>\n<td style=\"text-align:left\">商品的ID</td>\n<td>PK；FK，参照于Commodity的ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">amount</td>\n<td style=\"text-align:left\">decimal</td>\n<td>10,2</td>\n<td style=\"text-align:left\">商品供应数量</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">totalcost</td>\n<td style=\"text-align:left\">number</td>\n<td>6</td>\n<td style=\"text-align:left\">商品供应总成本</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">supplydate</td>\n<td style=\"text-align:left\">datetime</td>\n<td>0</td>\n<td style=\"text-align:left\">供应日期</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Purchase表\"><a href=\"#Purchase表\" class=\"headerlink\" title=\"Purchase表\"></a>Purchase表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>productID</td>\n<td>number</td>\n<td>10</td>\n<td>购买商品的ID</td>\n<td>PK；参照于Commodity的ID</td>\n</tr>\n<tr>\n<td>billID</td>\n<td>number</td>\n<td>10</td>\n<td>订单ID</td>\n<td>PK；参照于Bill的ID</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>购买该商品数量</td>\n<td></td>\n</tr>\n<tr>\n<td>sumprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>购买该商品小计价格</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"数据库关系图\"><a href=\"#数据库关系图\" class=\"headerlink\" title=\"数据库关系图\"></a>数据库关系图</h4><p>根据表的设计和之间的外码约束，绘制出数据库的关系图：</p>\n<p><img src=\"/images/image-20181231171547272-6247747.png\" alt=\"image-20181231171547272\"></p>\n<h3 id=\"Hive中的实际存储\"><a href=\"#Hive中的实际存储\" class=\"headerlink\" title=\"Hive中的实际存储\"></a>Hive中的实际存储</h3><p>经过多次尝试与实验，发现Hive中实际上是不支持表间外键联系的，因此我们在实际存储上述的表结构时将所有的外键均去除了。</p>\n<blockquote>\n<p>这引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表结构的特殊性，使得\b使用人员方便针对各种功能设计所需的信息表，而非使用传统的符合3NF或者其他范式的表结构，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一(其消除了由于大量表间连接时而产生的冗余操作，这是很典型的以<strong>空间</strong>换取<strong>时间</strong>的策略)。</p>\n</blockquote>\n<h2 id=\"项目实现方法\"><a href=\"#项目实现方法\" class=\"headerlink\" title=\"项目实现方法\"></a>项目实现方法</h2><p>整个项目我们使用传统的JavaWeb框架。后端使用Servlet处理数据交互，使用JDBC连接Zookeeper管理的Hiveserver2集群；前端使用Bootstrap框架完成基本的项目展示功能：</p>\n<p><img src=\"/images/1.png\" alt=\"1\"></p>\n<p>​                                            图1：查看库存</p>\n<p><img src=\"/images/2.png\" alt=\"2\"></p>\n<p>​                                            图2：查看历史账单</p>\n<p><img src=\"/images/3.png\" alt=\"3\"></p>\n<p>​                                            图3：创建新账单</p>\n<p>我们深知本项目重点在分布式集群而非前端展示上，因此我们组将95%的精力放在项目的理论理解、环境搭建、性能提升以及实践使用上。</p>\n<h2 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h2><h3 id=\"HA的原理理解及实现\"><a href=\"#HA的原理理解及实现\" class=\"headerlink\" title=\"HA的原理理解及实现\"></a>HA的原理理解及实现</h3><p>HA的实现是我们组在搭建集群时遇到的最大的难题，如何协调其主次关系、如何保证网络通信、如何确定哪些进程应该运行在哪些合适的机器上，举个例子：在我们完成集群搭建到了最后启动Hive时，启动了两个Hive客户端进程和两个Hiveserver2服务端进程，而两个Hive客户端又共用了同一个MySQL服务器，导致jdbc在连接Zookeeper时会随机访问到两个Hive客户端，这导致了数据库数据时而一致、时而不一致，后来我们在Hive的配置文件将其连接Hive客户端改为同一个后将其解决了。诸如此类的小问题我们遇到了很多很多，最后都一一得到了解决。</p>\n<h3 id=\"Hive与MySQL的横向对比\"><a href=\"#Hive与MySQL的横向对比\" class=\"headerlink\" title=\"Hive与MySQL的横向对比\"></a>Hive与MySQL的横向对比</h3><p>我们发现Hadoop集群启动后，前端与后端进行数据交互的速度很慢，于是我们使用MySQL与Hive做了简单的对比，结果很让我们困惑：MySQL的执行时间基本上是远远快于Hive的执行时间的。</p>\n<p>我们从以下角度进行了思考与实验：</p>\n<p>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；</p>\n<p>其次，Hive官网有句话\b”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集\b中，最多的数据集是数百万条的商品库存数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：将数据量从10W变化到1000W，然后观察在等量的数据量变化上，二者执行时间的变化，得到下表：</p>\n<table>\n<thead>\n<tr>\n<th>数据库类型</th>\n<th style=\"text-align:right\">10W数据</th>\n<th style=\"text-align:center\">1000W数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MySQL</td>\n<td style=\"text-align:right\">9ms</td>\n<td style=\"text-align:center\">271ms</td>\n</tr>\n<tr>\n<td>Hive(textfile)</td>\n<td style=\"text-align:right\">1428ms</td>\n<td style=\"text-align:center\">5100ms</td>\n</tr>\n</tbody>\n</table>\n<p>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。</p>\n<p>然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件。\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，因此我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点。存储中源数据文件大小为872MB，当使用textfile格式存储时，Hive会将我们导入的文件原封不动的移动到hdfs的Hive数据文件目录下，而使用ORCFile格式存储时文件大小只有260MB大小，这是其优点之一：<strong>文件压缩</strong>。至于性能，我们执行了上述同样的实验：</p>\n<table>\n<thead>\n<tr>\n<th>数据库类型</th>\n<th style=\"text-align:right\">10W数据</th>\n<th style=\"text-align:center\">1000W数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MySQL</td>\n<td style=\"text-align:right\">9ms</td>\n<td style=\"text-align:center\">271ms</td>\n</tr>\n<tr>\n<td>Hive(textfile)</td>\n<td style=\"text-align:right\">1428ms</td>\n<td style=\"text-align:center\">5100ms</td>\n</tr>\n<tr>\n<td>Hive(ORC)</td>\n<td style=\"text-align:right\">110ms</td>\n<td style=\"text-align:center\">126ms</td>\n</tr>\n</tbody>\n</table>\n<p>结果显而易见，当数据达到\b数百万量级时，Hive在存储模式<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。</p>\n<p>通过以上两点我们不难总结出以下几点：</p>\n<ul>\n<li><p>限制Hive的效率的因素：</p>\n<ul>\n<li><p>数据量</p>\n<p>在百万数据量以下时，Hadoop是很难发挥出其优点的</p>\n</li>\n<li><p>\b计算框架</p>\n<p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使Hive执行效率更上一层</p>\n</li>\n<li><p>网络通信</p>\n<p>由于我们的集群搭建在虚拟机中，其间数据通过真实的网络通信传输，虽然少了中间光纤传递的过程，但是在建立连接到发送数据到取消连接这一过程所耗费的时间都是很难被忽略的，因此生产环境下的Hadoop集群对网络带宽的要求是很高的</p>\n</li>\n</ul>\n</li>\n<li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p>\n</li>\n<li><p>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"集群架构图\"><a href=\"#集群架构图\" class=\"headerlink\" title=\"集群架构图\"></a>集群架构图</h3><p><img src=\"/images/image-20181228192856958-5996536.png\" alt=\"image-20181228192856958\"></p>\n<h3 id=\"集群机器\"><a href=\"#集群机器\" class=\"headerlink\" title=\"集群机器\"></a><a name=\"a1\">集群机器</a></h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">8GB</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群<sub><del>(因机器内存不够，特地为此买了内存条及SSD)</del></sub>，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。</p>\n<h3 id=\"虚拟机创建\"><a href=\"#虚拟机创建\" class=\"headerlink\" title=\"虚拟机创建\"></a>虚拟机创建</h3><p>此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。</p>\n<p>首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的<code>Host-Only</code>连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。</p>\n<p>在主机网络设置中共享网络：</p>\n<p><img src=\"/images/image-20181228201105314-5999065.png\" alt=\"image-20181228201105314\"></p>\n<p>在VirtualBox中执行以下操作设置主机连接方式：</p>\n<p><img src=\"/images/image-20181228200129326-5998489.png\" alt=\"image-20181228200129326\"></p>\n<p>在虚拟机终端执行以下操作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改虚拟机的IP、子网掩码</span></span><br><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">IPADDR=192.168.137.100</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改网关地址</span></span><br><span class=\"line\">vim /etc/sysconfig/network</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">GATEWAY=192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP</span></span><br><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname master</span><br><span class=\"line\"><span class=\"comment\"># 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"><span class=\"comment\"># 重启网络服务</span></span><br><span class=\"line\">systemctl restart network</span><br><span class=\"line\"><span class=\"comment\"># 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功</span></span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105</span></span><br><span class=\"line\">ping 61.135.169.105</span><br><span class=\"line\"><span class=\"comment\"># 修改hosts文件，添加局域网中其他主机的主机名与ip的映射</span></span><br><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">192.168.137.100 master</span><br><span class=\"line\">192.168.137.10 master1</span><br><span class=\"line\">192.168.137.101 slave1</span><br><span class=\"line\">192.168.137.102 slave2</span><br><span class=\"line\">192.168.137.103 slave3</span><br><span class=\"line\">192.168.137.200 node0</span><br><span class=\"line\">192.168.137.201 node1</span><br><span class=\"line\">192.168.137.202 node2</span><br><span class=\"line\">0.0.0.0 localhost</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br></pre></td></tr></table></figure>\n<p>至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先添加Hadoop和Hive相关环境变量</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 添加下列内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_MAPRED_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HIVE_HOME=/usr/<span class=\"built_in\">local</span>/hive</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HIVE_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 保存退出，并使环境变量生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<p>Hadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。</p>\n<h3 id=\"虚拟机复制\"><a href=\"#虚拟机复制\" class=\"headerlink\" title=\"虚拟机复制\"></a>虚拟机复制</h3><p>上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。</p>\n<h4 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h4><p>对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：</p>\n<ul>\n<li><p>修改IP</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的IP将<code>IPADDR</code>项修改为对应的IP</p>\n</li>\n<li><p>修改主机名</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname XXX</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名</p>\n</li>\n<li><p>重启网络服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ping各个节点测试是否成功</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping master</span><br><span class=\"line\">ping master1</span><br><span class=\"line\">ping slave1</span><br><span class=\"line\">ping slave2</span><br><span class=\"line\">ping slave3</span><br><span class=\"line\">ping node0</span><br><span class=\"line\">ping node1</span><br><span class=\"line\">ping node2</span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\">ping 61.135.169.105</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Hadoop配置\"><a href=\"#Hadoop配置\" class=\"headerlink\" title=\"Hadoop配置\"></a>Hadoop配置</h4><h5 id=\"修改core-site-xml\"><a href=\"#修改core-site-xml\" class=\"headerlink\" title=\"修改core-site.xml\"></a>修改core-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：Hadoop集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.permissions.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>ha.zookeeper.quorum<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2182,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 允许访问此hdfs的主机和群组，此处设置为任意 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改hdfs-site-xml\"><a href=\"#修改hdfs-site-xml\" class=\"headerlink\" title=\"修改hdfs-site.xml\"></a>修改hdfs-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hdfs集群配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定dfs文件存储位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop-data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定文件备份份数 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定机器运行情况检查时间间隔 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.heartbead.recheck-interval<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>3000000ms<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.nameservices<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- NS下面的NameNode --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.namenodes.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>nn1,nn2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>qjournal://master:8485;master1:8485;slave1:8485/ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.journalnode.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/journaldata<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 开启机器故障自动切换主从机器 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法(java类的名称) --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法，这里使用ssh通信方式交换 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.methods<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                sshfence</span><br><span class=\"line\">                shell(/bin/true)</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- ssh切换方法需要指定私钥文件位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/root/.ssh/id_rsa<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<ul>\n<li>假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用jdbc访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"修改slaves文件\"><a href=\"#修改slaves文件\" class=\"headerlink\" title=\"修改slaves文件\"></a>修改slaves文件</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/slaves</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：为各个master指定为其工作的slave</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">slave1</span><br><span class=\"line\">slave2</span><br><span class=\"line\">slave3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改yarn-site-xml\"><a href=\"#修改yarn-site-xml\" class=\"headerlink\" title=\"修改yarn-site.xml\"></a>修改yarn-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：yarn集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用yarn集群的高可用机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定ResourceManager集群id，可为任意字串 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yrc<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>rm1,rm2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的主机名 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的web端口，正常情况为8088 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定管理集群的Zookeeper集群的地址及对应端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2181,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定jar包路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"修改mapred-site-xml\"><a href=\"#修改mapred-site-xml\" class=\"headerlink\" title=\"修改mapred-site.xml\"></a>修改mapred-site.xml</h5><ul>\n<li><p>作用：指定MapReduce操作的基本属性</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce</li>\n<li>此项若是不配，一些job只会在本机跑，而不会分发给其他机器</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"修改hive-site-xml\"><a href=\"#修改hive-site-xml\" class=\"headerlink\" title=\"修改hive-site.xml\"></a>修改hive-site.xml</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HIVE_HOME</span>/conf/hive-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hive的基本配置</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容：</p>\n<ul>\n<li><p>修改<code>hive.server2.webui.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.webui.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The host address the HiveServer2 WebUI will listen on<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.bind.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.thrift.bind.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Bind host on which to run the HiveServer2 Thrift service.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.zookeeper.namespace</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.zookeeper.namespace<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hiveserver2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。</p>\n</li>\n<li><p>修改<code>javax.jdo.option.ConnectionURL</code>、<code>javax.jdo.option.ConnectionPassword</code>和<code>javax.jdo.option.ConnectionDriverName</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">      JDBC connect string for a JDBC metastore.</span><br><span class=\"line\">      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class=\"line\">      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>password to use against metastore database<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Driver class name for a JDBC metastore<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(<del>此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据</del>)。</p>\n<p>  另外，mysql的连接jar包需要下载并复制到hive的lib目录下。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。</p>\n<h4 id=\"Zookeeper配置\"><a href=\"#Zookeeper配置\" class=\"headerlink\" title=\"Zookeeper配置\"></a>Zookeeper配置</h4><p>对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"built_in\">local</span>/zookeeper/conf/zoo.cfg</span><br><span class=\"line\"><span class=\"comment\"># 添加一下内容</span></span><br><span class=\"line\">server.1=192.168.137.200:2888:3888</span><br><span class=\"line\">server.2=192.168.137.201:2888:3888</span><br><span class=\"line\">server.3=192.168.137.202:2888:3888</span><br><span class=\"line\"><span class=\"comment\"># 保存并关闭</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ssh免密登录配置\"><a href=\"#ssh免密登录配置\" class=\"headerlink\" title=\"ssh免密登录配置\"></a>ssh免密登录配置</h4><ul>\n<li><p>作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的</p>\n</li>\n<li><p>需要修改的机器：所有机器</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入用户目录下的`.ssh`目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> .ssh/</span><br><span class=\"line\"><span class=\"comment\"># 创建公钥私钥对</span></span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\"># 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍</span></span><br><span class=\"line\">ssh-copy-id <span class=\"variable\">$&#123;hostname&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。</p>\n<h3 id=\"集群启动\"><a href=\"#集群启动\" class=\"headerlink\" title=\"集群启动\"></a>集群启动</h3><h4 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h4><p>在master机器上执行以下操作以初始化数据库：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HIVE_HOME</span></span><br><span class=\"line\">schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure>\n<p>此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。</p>\n<h4 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h4><p>在master机器上执行以下操作以启动集群：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"项目功能需求\"><a href=\"#项目功能需求\" class=\"headerlink\" title=\"项目功能需求\"></a>项目功能需求</h2><h3 id=\"项目主题\"><a href=\"#项目主题\" class=\"headerlink\" title=\"项目主题\"></a>项目主题</h3><p><strong>超市销售管理系统</strong></p>\n<h3 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h3><h4 id=\"商品进货\"><a href=\"#商品进货\" class=\"headerlink\" title=\"商品进货\"></a>商品进货</h4><p><strong>功能点说明</strong>：超市管理员查询供应商，并根据结果输入从该供应商进货的商品信息</p>\n<p><strong>数据需求</strong>：查询供应商，新增进货记录，新增商品</p>\n<h4 id=\"查询商品\"><a href=\"#查询商品\" class=\"headerlink\" title=\"查询商品\"></a>查询商品</h4><p><strong>功能点说明</strong>：超市管理员通过商品名搜索库存中的所有相关商品</p>\n<p><strong>数据需求</strong>：查询商品</p>\n<h4 id=\"生成订单\"><a href=\"#生成订单\" class=\"headerlink\" title=\"生成订单\"></a>生成订单</h4><p>功能点说明：超市管理员查询相应商品并将其添加至订单中，添加完毕后生成订单</p>\n<p>数据需求：查询商品，新增购买记录，新增订单</p>\n<h3 id=\"概念设计\"><a href=\"#概念设计\" class=\"headerlink\" title=\"概念设计\"></a>概念设计</h3><p>基于面向对象的思想，我们在分析数据需求的时候简单地将我们的系统分为两个模块：进货和购买，这两个模块都以商品为核心。因此在构建实体-联系模型时，我们也根据这个思想出发，将E-R图分为了两个模块。</p>\n<h4 id=\"总体E-R图\"><a href=\"#总体E-R图\" class=\"headerlink\" title=\"总体E-R图\"></a>总体E-R图</h4><p><img src=\"/images/image-20181231170852678-6247332.png\" alt=\"image-20181231170852678\"></p>\n<h4 id=\"进货模块E-R图\"><a href=\"#进货模块E-R图\" class=\"headerlink\" title=\"进货模块E-R图\"></a>进货模块E-R图</h4><p><img src=\"/images/image-20181231170913607-6247353.png\" alt=\"image-20181231170913607\"></p>\n<p>进货模块主要包含两个实体集，公司（Corporation）和商品（Commodity）。商品中包含着超市库存商品的信息如商品名称、数量、价格，公司类包含供应商的信息如公司名称、地址、国家等。两个实体之间有着关系集供应（Supply），表示某商品从某公司进货。由于一种商品可能从多个公司进货，一个公司也可能供应多种商品，因此他们之间的关系应该是多对多。供应关系集同时还具有属性，表示进货的信息包括数量、成本、时间。</p>\n<h4 id=\"购买模块E-R图\"><a href=\"#购买模块E-R图\" class=\"headerlink\" title=\"购买模块E-R图\"></a>购买模块E-R图</h4><p><img src=\"/images/image-20181231170937495-6247377.png\" alt=\"image-20181231170937495\"></p>\n<p>购买模块包含的实体集有商品（Commodity）和订单（Bill）。订单表示一次完整购买的总订单（包含购买的所有商品情况），包含的信息有总价、折扣、实际价格等。商品和订单之间有关系集购买（Purchase），由于一个订单包含多个商品，一个商品也会被多次购买，因此这个关系是多对多的。同时，购买关系还具有属性，表示订单中的每一种商品购买的数量和小计价格。</p>\n<h3 id=\"逻辑设计\"><a href=\"#逻辑设计\" class=\"headerlink\" title=\"逻辑设计\"></a>逻辑设计</h3><h4 id=\"表设计\"><a href=\"#表设计\" class=\"headerlink\" title=\"表设计\"></a>表设计</h4><p>根据E-R模型的转化，我们生成了5张表，分别是：Corporation（公司），Supply（供应），Commodity（商品），Purchase（购买），Bill（订单）。表的详细设计如下：</p>\n<h5 id=\"Commodity表\"><a href=\"#Commodity表\" class=\"headerlink\" title=\"Commodity表\"></a>Commodity表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>商品的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>20</td>\n<td>商品名称</td>\n<td></td>\n</tr>\n<tr>\n<td>quantity</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>商品库存量</td>\n<td></td>\n</tr>\n<tr>\n<td>price</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>商品单价</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Corporation表\"><a href=\"#Corporation表\" class=\"headerlink\" title=\"Corporation表\"></a>Corporation表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>公司的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>20</td>\n<td>公司名称</td>\n<td></td>\n</tr>\n<tr>\n<td>address</td>\n<td>varchar</td>\n<td>20</td>\n<td>公司地址</td>\n<td></td>\n</tr>\n<tr>\n<td>country</td>\n<td>varchar</td>\n<td>10</td>\n<td>公司所在国家</td>\n<td></td>\n</tr>\n<tr>\n<td>business</td>\n<td>varchar</td>\n<td>10</td>\n<td>公司业务</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Bill表\"><a href=\"#Bill表\" class=\"headerlink\" title=\"Bill表\"></a>Bill表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID</td>\n<td>number</td>\n<td>10</td>\n<td>订单的ID</td>\n<td>PK</td>\n</tr>\n<tr>\n<td>totalprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单总价</td>\n<td></td>\n</tr>\n<tr>\n<td>discount</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单折扣</td>\n<td></td>\n</tr>\n<tr>\n<td>finalprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>订单实际总价</td>\n<td></td>\n</tr>\n<tr>\n<td>realpay</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>顾客付款</td>\n<td></td>\n</tr>\n<tr>\n<td>charge</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>找钱</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Supply表\"><a href=\"#Supply表\" class=\"headerlink\" title=\"Supply表\"></a>Supply表</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段名</th>\n<th style=\"text-align:left\">数据类型</th>\n<th>长度</th>\n<th style=\"text-align:left\">说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">corID</td>\n<td style=\"text-align:left\">number</td>\n<td>10</td>\n<td style=\"text-align:left\">供应公司的ID</td>\n<td>PK;   FK，参照于Corporation的ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">productID</td>\n<td style=\"text-align:left\">number</td>\n<td>10</td>\n<td style=\"text-align:left\">商品的ID</td>\n<td>PK；FK，参照于Commodity的ID</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">amount</td>\n<td style=\"text-align:left\">decimal</td>\n<td>10,2</td>\n<td style=\"text-align:left\">商品供应数量</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">totalcost</td>\n<td style=\"text-align:left\">number</td>\n<td>6</td>\n<td style=\"text-align:left\">商品供应总成本</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">supplydate</td>\n<td style=\"text-align:left\">datetime</td>\n<td>0</td>\n<td style=\"text-align:left\">供应日期</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Purchase表\"><a href=\"#Purchase表\" class=\"headerlink\" title=\"Purchase表\"></a>Purchase表</h5><table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>长度</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>productID</td>\n<td>number</td>\n<td>10</td>\n<td>购买商品的ID</td>\n<td>PK；参照于Commodity的ID</td>\n</tr>\n<tr>\n<td>billID</td>\n<td>number</td>\n<td>10</td>\n<td>订单ID</td>\n<td>PK；参照于Bill的ID</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>购买该商品数量</td>\n<td></td>\n</tr>\n<tr>\n<td>sumprice</td>\n<td>decimal</td>\n<td>10,2</td>\n<td>购买该商品小计价格</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"数据库关系图\"><a href=\"#数据库关系图\" class=\"headerlink\" title=\"数据库关系图\"></a>数据库关系图</h4><p>根据表的设计和之间的外码约束，绘制出数据库的关系图：</p>\n<p><img src=\"/images/image-20181231171547272-6247747.png\" alt=\"image-20181231171547272\"></p>\n<h3 id=\"Hive中的实际存储\"><a href=\"#Hive中的实际存储\" class=\"headerlink\" title=\"Hive中的实际存储\"></a>Hive中的实际存储</h3><p>经过多次尝试与实验，发现Hive中实际上是不支持表间外键联系的，因此我们在实际存储上述的表结构时将所有的外键均去除了。</p>\n<blockquote>\n<p>这引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表结构的特殊性，使得\b使用人员方便针对各种功能设计所需的信息表，而非使用传统的符合3NF或者其他范式的表结构，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一(其消除了由于大量表间连接时而产生的冗余操作，这是很典型的以<strong>空间</strong>换取<strong>时间</strong>的策略)。</p>\n</blockquote>\n<h2 id=\"项目实现方法\"><a href=\"#项目实现方法\" class=\"headerlink\" title=\"项目实现方法\"></a>项目实现方法</h2><p>整个项目我们使用传统的JavaWeb框架。后端使用Servlet处理数据交互，使用JDBC连接Zookeeper管理的Hiveserver2集群；前端使用Bootstrap框架完成基本的项目展示功能：</p>\n<p><img src=\"/images/1.png\" alt=\"1\"></p>\n<p>​                                            图1：查看库存</p>\n<p><img src=\"/images/2.png\" alt=\"2\"></p>\n<p>​                                            图2：查看历史账单</p>\n<p><img src=\"/images/3.png\" alt=\"3\"></p>\n<p>​                                            图3：创建新账单</p>\n<p>我们深知本项目重点在分布式集群而非前端展示上，因此我们组将95%的精力放在项目的理论理解、环境搭建、性能提升以及实践使用上。</p>\n<h2 id=\"项目亮点\"><a href=\"#项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a>项目亮点</h2><h3 id=\"HA的原理理解及实现\"><a href=\"#HA的原理理解及实现\" class=\"headerlink\" title=\"HA的原理理解及实现\"></a>HA的原理理解及实现</h3><p>HA的实现是我们组在搭建集群时遇到的最大的难题，如何协调其主次关系、如何保证网络通信、如何确定哪些进程应该运行在哪些合适的机器上，举个例子：在我们完成集群搭建到了最后启动Hive时，启动了两个Hive客户端进程和两个Hiveserver2服务端进程，而两个Hive客户端又共用了同一个MySQL服务器，导致jdbc在连接Zookeeper时会随机访问到两个Hive客户端，这导致了数据库数据时而一致、时而不一致，后来我们在Hive的配置文件将其连接Hive客户端改为同一个后将其解决了。诸如此类的小问题我们遇到了很多很多，最后都一一得到了解决。</p>\n<h3 id=\"Hive与MySQL的横向对比\"><a href=\"#Hive与MySQL的横向对比\" class=\"headerlink\" title=\"Hive与MySQL的横向对比\"></a>Hive与MySQL的横向对比</h3><p>我们发现Hadoop集群启动后，前端与后端进行数据交互的速度很慢，于是我们使用MySQL与Hive做了简单的对比，结果很让我们困惑：MySQL的执行时间基本上是远远快于Hive的执行时间的。</p>\n<p>我们从以下角度进行了思考与实验：</p>\n<p>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；</p>\n<p>其次，Hive官网有句话\b”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集\b中，最多的数据集是数百万条的商品库存数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：将数据量从10W变化到1000W，然后观察在等量的数据量变化上，二者执行时间的变化，得到下表：</p>\n<table>\n<thead>\n<tr>\n<th>数据库类型</th>\n<th style=\"text-align:right\">10W数据</th>\n<th style=\"text-align:center\">1000W数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MySQL</td>\n<td style=\"text-align:right\">9ms</td>\n<td style=\"text-align:center\">271ms</td>\n</tr>\n<tr>\n<td>Hive(textfile)</td>\n<td style=\"text-align:right\">1428ms</td>\n<td style=\"text-align:center\">5100ms</td>\n</tr>\n</tbody>\n</table>\n<p>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。</p>\n<p>然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件。\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，因此我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点。存储中源数据文件大小为872MB，当使用textfile格式存储时，Hive会将我们导入的文件原封不动的移动到hdfs的Hive数据文件目录下，而使用ORCFile格式存储时文件大小只有260MB大小，这是其优点之一：<strong>文件压缩</strong>。至于性能，我们执行了上述同样的实验：</p>\n<table>\n<thead>\n<tr>\n<th>数据库类型</th>\n<th style=\"text-align:right\">10W数据</th>\n<th style=\"text-align:center\">1000W数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MySQL</td>\n<td style=\"text-align:right\">9ms</td>\n<td style=\"text-align:center\">271ms</td>\n</tr>\n<tr>\n<td>Hive(textfile)</td>\n<td style=\"text-align:right\">1428ms</td>\n<td style=\"text-align:center\">5100ms</td>\n</tr>\n<tr>\n<td>Hive(ORC)</td>\n<td style=\"text-align:right\">110ms</td>\n<td style=\"text-align:center\">126ms</td>\n</tr>\n</tbody>\n</table>\n<p>结果显而易见，当数据达到\b数百万量级时，Hive在存储模式<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。</p>\n<p>通过以上两点我们不难总结出以下几点：</p>\n<ul>\n<li><p>限制Hive的效率的因素：</p>\n<ul>\n<li><p>数据量</p>\n<p>在百万数据量以下时，Hadoop是很难发挥出其优点的</p>\n</li>\n<li><p>\b计算框架</p>\n<p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使Hive执行效率更上一层</p>\n</li>\n<li><p>网络通信</p>\n<p>由于我们的集群搭建在虚拟机中，其间数据通过真实的网络通信传输，虽然少了中间光纤传递的过程，但是在建立连接到发送数据到取消连接这一过程所耗费的时间都是很难被忽略的，因此生产环境下的Hadoop集群对网络带宽的要求是很高的</p>\n</li>\n</ul>\n</li>\n<li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p>\n</li>\n<li><p>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</p>\n</li>\n</ul>\n"},{"title":"数据库与内存数据库实验报告","date":"2019-03-05T12:34:59.000Z","_content":"\n## 一、实验前准备\n\n### 机器配置\n\n![image-20190114060005845](/images/image-20190114060005845.png)\n\n<!-- more -->\n\n### 时间计算标准\n\n#### SQL执行过程\n\n首先，本实验的目的是优化数据库，减少数据库语句执行的时间，在此之前，我们要明白一点`数据库执行时间`这句话包含了哪些东西。我们从数据库执行一条SQL语句的过程来看，对于MySQL、Oracle、TimesTen这些具有内部优化的数据库来说，一般的执行步骤是：\n\n![image-20190113214926175](/images/image-20190113214926175.png)\n\n而我们的关注点应放在语句执行这一步骤上。\n\n#### 语句执行步骤进一步深入\n\n##### MySQL\n\nMySQL的执行时间为以下项目的加和：\n\n| State                   | Desription                     |\n| ----------------------- | ------------------------------ |\n| 1. Checking permissions | 检查用户的权限                 |\n| 2. Opening tables       | 打开表                         |\n| 3. Init                 | 初始化过程                     |\n| 4. System lock          | 获取锁                         |\n| 5. Optimizing           | 优化SQL语句                    |\n| 6. Statistics           | 分析SQL语句                    |\n| 7. Preparing            | 准备执行条件                   |\n| 8. Executing            | 执行SQL语句                    |\n| 9. Sending data         | 进行磁盘的IO以及数据的发送返回 |\n| 10. End                 | 执行结束                       |\n| 11. Closing tables      | 关闭表                         |\n| 12. Freeing items       | 释放资源                       |\n| 13. Cleaning up         | 清理缓存以及临时空间           |\n\n##### Oracle\n\n一条SQL语句在进入`语句执行`这一步骤之后，若不在高速缓存中，数据库会从数据文件中把`所在位置`移动到`高速缓存`中而后返回给客户端。这也就意味着，同一条语句在以后的执行中都只从高速缓存取数据（前提是高速缓存`未被清除`）。这样想的话，我们要做的优化应该是一条SQL语句在第一次进入数据库时数据库作出的应答。\n\n那么，我们通过数据库工具来查看执行的SQL语句的时间应该是不准的：**因为我们不知道这条语句是不是第一次执行，或者说我们不知道高速缓存中有没有我们需要的数据**。这里我们选择使用Oracle的执行计划来看SQL语句的准确的执行过程以及其`开销`。如下图：\n\n![image-20190113211220925](/images/image-20190113211220925.png)\n\n我们的关注点在上图中的`COST`，cost是Oracle里判定效率的唯一标准，Oracle的优化器会计算当前SQL语句的最低cost方案，而后为其选择执行计划。Oracle中定义了语句的一次执行开销`cost = CPU cost + IO cost`，对于cost，我们可以理解为一次过程所需要访问的Block数量，那么执行时间就是`t = Block数量 * Block处理时间`。\n\n后续实验过程中的Oracle部分我们都是通过执行计划及cost来做对比。为此我们写了一个procedure来记录一条语句执行计划中记录的cost：\n\n```plsql\n-- 计算query的cost\ncreate or replace procedure calc_cost(query_ varchar2, func_ number, desc_ varchar2) is\n  cpu_cost number := 0;\n  io_cost number := 0;\n  cost_ number := 0;\n  -- 一条SQL语句的唯一标识\n  hash_v number := 0;\n  -- 获取上述标识\n  select_v_sql varchar2(255) := 'select hash_value into :x from v$sql a where a.SQL_TEXT like '':y''';\n  -- 获取cost\n  select_v_sql_plan varchar2(255) := 'select max(cpu_cost) , max(io_cost) into :x :y from V$SQL_PLAN a where hash_value=:z';\n  -- 结果保存\n  insert_result varchar2(255) := 'insert into t_cost_record values(:x,:y,:z,:a,:b,:c)';\nbegin\n  execute immediate select_v_sql using hash_v, query_;\n  execute immediate select_v_sql_plan using cpu_cost, io_cost, cost_;\n  execute immediate insert_result using id_seq.nextval, func_, cpu_cost, io_cost, cost_, desc_;\nend;\n```\n\n##### TimesTen\n\n对于TimesTen来说，不如Oracle的优化器来的智能，它完全靠速度制胜。Oracle中我们讨论了执行时间`t = Block数量 * Block处理时间`，TimesTen就是在Block处理时间上有很大的优势。遗憾的是TimesTen中没有作为本身的高速缓存这一说，这也就意味着一条SQL语句进入TimesTen时都要经过`SQL Prepare -> SQL Execution -> SQL Fetch `这一完整的过程，如下：\n\n![image-20190114052126486](/images/image-20190114052126486.png)\n\n## 二、MySQL实验过程\n\n功能：查询电影评论平均分排行前一百的电影\n\n### SQL语句\n\n```mysql\nselect  m.name_, sum(c1.score) as movie_avg_comment_score\nfrom movie m  , comment_1 c1\nwhere m.id_ = c1.movie_id\ngroup by m.name_\norder by movie_avg_comment_score desc\nlimit 100;\n```\n\n### 仅有主键索引\n\n执行之后得到如下的时间消耗：\n\n![time_3.2_4min](/images/time_3.2_4min.png)\n\n这个时间相比其他数据库慢得多（oracle 约4s)，不符合预期的耗时，且在执行时mysqld的cpu占用率非常高。于是根据以下步骤查看sql执行慢的原因。\n\n### MySQL进程表\n\n使用`show processlist`命令查看正在执行的sql语句列表：\n\n![process_list](/images/process_list.png)\n\n可以看到当前执行的语句就是我们的目标语句，并且没有其他语句在与当前查询语句竞争资源，所以应该把语句执行过慢点原因定位到查询语句本身。\n\n### 解释执行计划\n\n通过查看process list得知对应语句有问题之后，使用`describe`命令查看当前SQL语句的执行计划，MySQL的执行计划与其他相关参数：\n\n![explain_3.2](/images/explain_3.2.png)\n\n可以看到在执行计划中，movie表有可选的主码索引，但是在这个场景中mysql并没有选择使用主码索引，没有使用索引是导致时间过慢点一个原因，于是可以考虑在电影名字字段上建立索引。\n\n### 执行过程\n\n为了进一步查看SQL语句具体的系统能耗分布，我们选择使用`profiling`来分析我们SQL语句的执行过程，在没有创建其他索引的情况下我们得到如下的时间消耗分析：\n\n![detail_3.2](/images/detail_3.2.png)\n\n我们可以看到其中能耗占比最高的是 `Sending data`项，查看官方文档相关解释：\n\n> The thread is reading and processing rows for a `SELECT` statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.\n>\n> 该线程正在读取和处理SELECT语句的行，并将数据发送到客户端。 由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态\n\n所以这个与我们的磁盘IO的速度以及网络的传输速度有关，磁盘的IO除了受到硬件本身的限制之外还会与数据库的索引有关，更换性能更好的磁盘或者建立适当的索引以减少磁盘IO数量都可以提高查询语句的执行速度。\n\n### 建立索引\n\n根据以上分析过程得到的结论，我们在电影表的名字字段上建立合适的索引，我们在mysql中选择了B-Tree索引。\n\n建立索引之后再查看相同SQL语句的执行计划：\n\n![explain_3.2_index](/images/explain_3.2_index.png)\n\n`key`字段上的值从原来的`null` 变成了我们刚刚创建的索引。\n\n执行该SQL语句，并在结束后使用`Profiling`查看优化后的执行时间：\n\nsending data: 从磁盘读取数据，将数据返回，表示磁盘IO\n\ncreate index：使用临时表来处理select语句\n\n![detail_index_3.2](/images/detail_index_3.2.png)\n\n可以看到`Sending data`的值明显小于优化前，总的执行时间也变为优化前的1/5，所以增加索引能够在很大程度上加快查询的速度。\n\n### 实验结论\n\n综合其他实验，在大数据的处理上MySQL数据库的性能远不如ORACLE及TIMESTEN数据库，有数十倍的耗时差距，而且MySQL作为一个轻量级的数据库，支持的索引类型也少于其他两个数据库，在SQL语句的优化方面也不如ORACLE数据库那般强大。所以在当前的实验环境下我们更倾向于使用ORACLE数据库与TIMESTEN数据库进行对比。\n\n## 三、Oracle实验过程\n\n### 实验1：SQL各子句条件顺序对查询效率的影响\n\n#### 查询语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_ FROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID AND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国' AND T_MOVIE.SCORE_>6;\n```\n\n#### 实验方式\n\n通过对MySQL、Oracle、TimesTen中SQL语句中select、from、where子句的排序顺序进行调换，观察执行计划的改变\n\n#### 实验结果\n\n1. SELECT子句中，结果集的排序方式不会影响执行计划\n2. FROM子句中，各个表的排序方式不会影响执行计划\n3. WHERE子句中，各个条件的排序方式不会影响执行计划，优化器会首先将筛选条件应用于表进行过滤，最后逐次执行表的连接。\n\n#### 分析\n\n自Oracle6以来，一直采用RBO（Rule-Based Optimization 基于规则的优化器），其基于一套严格死板的使用规则。由于其对于规则的崇尚性，SQL语句的写法则尤为重要。而自Oracle8以来，Oracle引入了一种新的优化方式，即CBO（Cost-Based Optimization 基于代价的优化器），从Oracle 10g开始RBO被完全舍弃。使用CBO优化器时，对SQL语句的要求变得没有那么苛刻，优化器会选择开销比较小的方式执行，而不由用户所写的表的顺序、条件的顺序决定。MySQL与TimesTen的优化器也是如此，有其自己的选择。\n\n> ##### 连接方式和连接顺序\n>\n> **连接顺序**：连接顺序表明以哪张表为驱动表来连接其他表的先后顺序。即以某张表为基点，根据其中的信息再去访问其他的表。\n>\n> **连接方式**：简单来讲，就是两个表获得满足条件的数据时的连接过程。主要有三种表连接方式，嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）。\n>\n> ###### 排序-合并连接\n>\n> 假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)\n>\n> 内部连接过程：\n>\n> a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序\n>\n> b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序\n>\n> c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）\n>\n> 延伸：\n>\n> 如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。\n>\n> 故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。**不过遗憾的是**，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。\n>\n> 排序-合并连接的表无驱动顺序，谁在前面都可以；\n>\n> 排序-合并连接**适用**的连接条件有： **<   <=   =   >   >= ，不适用**的连接条件有： **<>    like**\n>\n> ###### 嵌套循环\n>\n> 内部连接过程：\n>\n> a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n>\n> b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n>\n> c) ……\n>\n> 若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。\n>\n> 因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。\n>\n> 嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：**可以先返回已经连接的行**，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。\n>\n> 应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。\n>\n> ###### 哈希连接\n>\n> **哈希连接只适用于等值连接（即连接条件为  =  ）**\n>\n> HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；\n>\n> 内部连接过程简述：\n>\n> a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）\n>\n> b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据\n\n### 实验2：B树索引与位图索引的比较\n\n#### sql语句\n\n```sql\n-- 小基数\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>6;\n-- 大基数\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_ACTOR,T_ACT,T_MOVIE\nWHERE T_ACTOR.NAME_='Tom Byron'\nAND T_MOVIE.SCORE_>6\nAND T_ACTOR.ID_=T_ACT.ACTOR_ID\nAND T_MOVIE.ID_=T_ACT.MOVIE_ID;\n```\n\n#### 索引语句\n\n```sql\n-- B树\nCREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);\nCREATE INDEX IX_MOVIE_NAME ON T_MOVIE(NAME_);\nCREATE INDEX IX_ACTOR_NAME ON T_ACTOR(NAME_);\n-- BitMap\nCREATE BITMAP INDEX IXBM_MOVIE_NAME ON T_MOVIE(NAME_);\nCREATE BITMAP INDEX IXBM_MOVIE_SCORE ON T_MOVIE(SCORE_);\nCREATE BITMAP INDEX IXBM_ACTOR_NAME ON T_ACTOR(NAME_);\n```\n\n#### 查询消耗\n\nB树索引（小基数）\n\n![B树索引](/images/1-B%E6%A0%91%E7%B4%A2%E5%BC%95.png)\n\n位图索引（小基数）\n\n![位图索引](/images/1-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png)\n\n不加索引（大基数）\n\n![image-20190113230831573](/images/image-20190113230831573.png)\n\nB树索引（大基数）\n\n![image-20190113230717837](/images/image-20190113230717837.png)\n\n位图索引（大基数）\n\n![image-20190113230627090](/images/image-20190113230627090.png)\n\n#### 分析\n\n即使在字段基数较大的情况下，位图索引依然有比B树索引更好的表现。但是有个问题，创建位图索引时所需的时间更长。此外，由于表中该字段的更改都会导致对位图的修改，所以位图索引不适用于并发的情况。\n\n### 实验3：Oracle优化器对索引的选择\n\n> #### 关于索引\n>\n> ##### 索引类型\n>\n> - B树索引（默认的索引）\n>\n> ```sql\n> CREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);\n> ```\n>\n> - 位图索引：以位图的形式存储每个值对应的的一组rowid\n>\n> ```sql\n> CREATE BITMAP INDEX IXBM_REGION_NAME ON T_REGION(NAME_);\n> ```\n>\n> - 基于函数的索引：利于对某个字段查询时需要同时使用函数或计算的情景\n>\n> ```sql\n> CREATE INDEX upper_ix ON employees (UPPER(last_name)); \n> ```\n>\n> - 分区索引：本地分区索引的分区完全依赖于其索引所在表，而全局分区索引的分区机制和表分区可能一样也可能不一样\n>\n>   - range范围分区\n>\n>   ```sql\n>   CREATE INDEX cost_ix ON sales (amount_sold)\n>    GLOBAL PARTITION BY RANGE (amount_sold)\n>       (PARTITION p1 VALUES LESS THAN (1000),\n>        PARTITION p2 VALUES LESS THAN (2500),\n>        PARTITION p3 VALUES LESS THAN (MAXVALUE));\n>   ```\n>\n>   - hash哈希分区\n>\n>   ```sql\n>   CREATE INDEX cust_last_name_ix ON customers (cust_last_name)\n>   GLOBAL PARTITION BY HASH (cust_last_name)\n>   PARTITIONS 4;\n>   ```\n>\n>   - list列表分区：一个分区对应指定列的特定的值，以列举的方式进行分区\n>   - 组合分区（range-hash，range-list）\n>\n> ##### 什么时候用索引\n>\n> 对于Oracle的CBO来说，只有在使用索引能提高效率（估算的效率）时才会使用索引。对于程序员自己进行数据库管理的时候，一般有：\n>\n> **需要使用索引来优化查询的情况：**\n>\n> - 一个属性的值分布非常广，变化的范围跨度很大。\n> - 一般来说，常常需要被用在SQL语句的where中的限制条件的属性最好为其建立索引。\n> - 表经常被访问且需要访问的数据量仅占一部分。\n>\n> **不适合用索引的情况：**\n>\n> - 表很小\n> - 表经常被更新\n> - 属性不经常作为where中的限制条件的属性存在\n> - 查询得到的数据占总量的很大部分\n>\n> 对于数据经常更新的情况，DBA要定时进行索引的重构（rebuild）以维持索引的可用性。\n>\n> ##### 影响优化器决策的因素\n>\n> - 进行全表扫描需要读取的数据块数量；\n> - 进行索引查询需要读取的数据块数量，这主要是基于对WHERE子句谓词返回的记录数目估计；\n> - 进行全表扫描时多块读的相关开销，以及为满足索引查询进行的单块读的开销；\n> - 内存中对缓存中的索引块和数据块数目的假设。\n>\n> ##### 索引失效的可能原因\n>\n> 以下是一些常见的定义了索引当Oracle并未使用的原因：\n>\n> - 不等于情况，即“<>”\n> - 字符串匹配like中百分号在第一位的情况，即“%XXX”\n> - 表没有进行分析更新统计信息\n> - 使用复合索引但单独引用且非复合索引的第一属性\n> - 对索引进行计算，此时需要建立索引函数\n> - 属性为字符串但在where中没有加引号\n> - 使用not in，not exists\n> - 使用了其他索引\n>\n> #### 强制使用索引\n>\n> 如果想要强制使用索引，则可以在查询语句的select单词后加上/\\*+index (tablename indexname)*/，这样可以规定Oracle选择使用indexname的索引的执行计划。该方法已在前面实验中使用，不再赘述。\n\n#### sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>6;\n```\n\n#### 查询消耗\n\n不用索引（不论是B树索引还是位图索引都不使用）\n\n![3-不用索引](/images/3-%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95.png)\n\n强制使用B树索引\n\n![3-强制B树](/images/3-%E5%BC%BA%E5%88%B6B%E6%A0%91.png)\n\n强制使用位图索引\n\n![3-强制位图](/images/3-%E5%BC%BA%E5%88%B6%E4%BD%8D%E5%9B%BE.png)\n\n#### sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>9;\n```\n\n#### 查询消耗\n\nB树索引（未使用）\n\n![3-B树](/images/3-B%E6%A0%91.png)\n\n位图索引\n\n![3-位图](/images/3-%E4%BD%8D%E5%9B%BE.png)\n\n#### 分析\n\n由此可见，即使在有索引的情况下，oracle优化器也可能选择不使用索引。CBO优化器会对每种执行计划计算一个COST，并采用COST最小的执行计划。如果一个表有索引或多种索引，其会选择最好的一种索引方式扫描表，或者甚至不用索引而用全局扫描方式。\n\n另外对于符合筛选条件的数据，当占全表的比例越小、数据量越小时，使用索引的可能性越大。如在这次实验中，条件为\"T_MOVIE.SCORE_ >9\"时会使用索引，而\"T_MOVIE.SCORE_ >6\"时不会。\n\n此外，由于位图索引导致的COST要小于B树索引，因此在相同的查询中，使用位图索引的可能性比B树索引更大。\n\n### 实验4：Oracle分区索引\n\n#### sql语句\n\n```sql\nSELECT T_COMMENT.SUMMARY_,T_COMMENT.SCORE_,T_COMMENT.TIME_\nFROM T_COMMENT,T_MOVIE\nWHERE T_MOVIE.ID_=T_COMMENT.MOVIE_ID\nAND T_COMMENT.SCORE_>6\nAND T_MOVIE.NAME_='Blindsided';\n```\n\n#### 实验结果\n\n1. 未分区表+无索引\n\n   ![5-1-1](/images/5-1-1.png)\n\n2. 未分区表+B树索引\n\n   ![5-2](/images/5-2.png)\n\n3. 未分区表+位图索引\n\n   ![5-3](/images/5-3.png)\n\n4. 分区表+无索引\n\n   ![5-4-1](/images/5-4-1.png)\n\n5. 分区表+全局不分区B树索引\n\n   ![5-5-1](/images/5-5-1.png)\n\n6. 分区表+本地(哈希分区)B树索引\n\n   ![5-6](/images/5-6.png)\n\n7. 分区表+本地(哈希分区)位图索引\n\n   ![5-7](/images/5-7.png)\n\n8. 分区表+全局哈希分区索引\n\n   ![5-8](/images/5-8.png)\n\n9. 分区表+全局范围分区索引\n\n   ![5-9](/images/5-9.png)\n\n#### 分析\n\n1. 在未建索引时，分区表的COST是未分区表的十倍多。原因是分区所依据的键（字段）不是直接的查询条件——我们以评论表的movie_id字段为依据建哈希分区表，但在查询的时候并不直接以movie_id为查询条件。导致连接表的时候，需要访问多个分区，反而造成COST大大增长。\n\n   后来我们重新设计一个以movie_id为查询条件的sql语句，结果显示分区表的COST大约是未分区表的1/4（一共分了4个区），证明在以分区依据的字段为直接查询条件时，分区表能够体现比较好的性能，能够避免对一部分数据的访问。\n\n2. 在分区表上建索引比在未分区表上建索引后的开销更小，不论分区表上的索引是全局还是本地，不论是否是分区索引。在我们的实验场景中，尽管movie_id不是直接的查询条件而是join表的条件，但是在添加索引后，依然能够大大减少join表的开销从而提升效率。\n\n3. 在我们的实验场景中，全局的分区索引，不论是哈希分区还是范围分区，COST是一样的。\n\n4. 本地索引的效率略微比全局索引的效率好。根据查到的资料，本地索引的可维护性好，能够自动维护，不需要人工干预，但因把索引分成多个分区导致每次的索引访问都需要遍历所有索引分区，所以索引访问性能下降。因此比较适合OLAP系统。而全局索引的可维护性差，分区表发生改变时，需要用命令手动更新索引，但索引访问性能比本地分区索引要好。因此比较适合OLTP系统。\n\n### 实验5：Oracle使用复合索引\n\n#### SQL语句\n\n```SQL\nselect T_COMMENT_1.SUMMARY_, T_COMMENT_1.SCORE_\nfrom T_COMMENT_1, T_MOVIE\nwhere T_MOVIE.ID_ = T_COMMENT_1.MOVIE_ID and T_COMMENT_1.SCORE_ > 7 and T_MOVIE.NAME_ = 'The Notebook';\n```\n\n第一次查询：T_COMMENT_1上只有主键的唯一索引。\n\n第二次查询：在MOVIE_ID上建立一个B-tree索引COMMENT_1_MOVIE。\n\n```sql\ncreate index COMMENT_1_MOVIE on T_COMMENT_1(MOVIE_ID);\n```\n\n第三次查询：使第二次的索引invisible，在SCORE_上建立一个B-tree索引T_COMMENT_SCORE_INDEX。\n\n```SQL\nalter index COMMENT_1_MOVIE invisible;\ncreate index T_COMMENT_SCORE_INDEX on T_COMMENT_1(SCORE_);\n```\n\n第四次查询：将第二次和第三次的索引都保持为visible，在MOVIE_ID和SCORE_上建立一个复合索引COMMENT_1_MOVIE_SCORE。\n\n```SQL\nalter index COMMENT_1_MOVIE visible;\ncreate index COMMENT_1_MOVIE_SCORE on T_COMMENT_1(MOVIE_ID, SCORE_);\n```\n\n#### 实验结果\n\n**第一次查询：**\n\n![屏幕快照 2019-01-13 下午10.48.45](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.48.45.png)\n\n全表扫描，花销很大\n\n**第二次查询：**\n\n![屏幕快照 2019-01-13 下午10.47.49](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.47.49.png)\n\n利用在MOVIE_ID上的索引，在T_COMMENT_1中访问的数据量和花销都大幅度下降。\n\n**第三次查询：**\n\n![屏幕快照 2019-01-13 下午10.50.07](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.50.07.png)\n\n如果只有在SCORE_上的索引，根据CBO，Oracle并没有使用这个索引，而是依旧使用全表扫描，可知该索引并没有提升性能。\n\n易知，如果在这个时候将MOVIE_ID上的索引设为visible，Oracle会使用MOVIE_ID上的索引。\n\n**第四次查询：**\n\n![屏幕快照 2019-01-13 下午10.57.10](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.57.10.png)\n\nOracle使用了复合索引，尽管在当前问题下COST花销与只有MOVIE_ID的索引差不多，但是其访问的记录数（CARDINALITY）显著减小，体现了复合索引给查询带来的性能提升。\n\n### 实验6：物化视图对SQL查询性能的提升\n\n#### SQL语句\n\n**原始查询语句：**\n\n```SQL\nselect T_DIRECTOR.NAME_, T_MOVIE.NAME_ MOVIE_NAME, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_ and T_DIRECTOR.NAME_ like '黑泽明%'\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_ ;\n```\n\n创建一个**普通视图**：\n\n```SQL\nCREATE VIEW DIRECTOR_MOVIE_FAKE\nAS\nselect T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;\n```\n\n使用普通视图进行查询：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE_FAKE where NAME_ like '黑泽明%';\n```\n\n创建**物化视图**：\n\n```SQL\nCREATE MATERIALIZED VIEW DIRECTOR_MOVIE\nBUILD IMMEDIATE\nREFRESH FORCE\nON DEMAND\nENABLE QUERY REWRITE\nAS\nselect T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;\n```\n\n设置**创建时生成数据**，**按需要刷新**，**刷新方式为FORCE**。\n\n根据视图进行如上查询：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE where NAME_ like '黑泽明%';\n```\n\n由于物化视图与表类似，可以给其建立索引，以下给导演名**建立索引**：\n\n```sql\nCREATE BITMAP INDEX DIRECTOR_MOVIE_INAME_INDEX ON DIRECTOR_MOVIE (NAME_);\n```\n\n**再次使用物化视图查询**：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE where NAME_ like '黑泽明%';\n```\n\n#### 实验结果\n\n**使用原始查询：**\n\n![屏幕快照 2019-01-14 上午12.27.37](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png)\n\n具有极大的花销。\n\n**创建视图后的查询：**\n\n![屏幕快照 2019-01-14 上午12.30.46](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png)\n\n其执行计划与**原始查询**一致。\n\n**创建物化视图后的查询：**\n\n![屏幕快照 2019-01-14 上午12.33.27](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.33.27.png)\n\n其**直接在物化视图中进行查询**，执行计划即为简单，花销大幅度减小。\n\n**给物化视图创建索引后的查询：**\n\n![屏幕快照 2019-01-14 上午12.35.22](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.35.22.png)\n\n建立索引后通过范围索引扫描该物化视图进行查询，其COST数字小得令人惊奇。\n\n#### 分析\n\n1.建立普通视图并不能提升性能。因为普通是虚拟的，对视图的操作实际都转变为了对各表的SQL操作，其与原始查询完全一致。\n\n2.物化视图是一种物理表，对于物化视图的查询是直接的，跟表一样。因此建立物化视图可以大幅度减小花销，但是同时，物化视图也会产生大量的维护成本。因此程序员应该根据实际情况建立物化视图以优化查询。\n\n3.物化视图同样可以增添索引，增加索引后Oracle对物化视图可以通过索引进行扫描，进一步提高效率。\n\n> ##### 物化视图与普通视图\n>\n> 视图只是一种虚拟表。实际上，**对视图的查询真正转换成了相应的SQL语句再对各表进行连接查询，因此其性能提升有限，只是方便了使用**。\n>\n> 而物化视图是实质化的视图，是**物理表**，可以像表一样进行查询，建立索引，占用真正的存储空间，需要被刷新。\n>\n> ##### 刷新模式\n>\n> **on demand：**顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性;\n>\n> **on commit**：提交触发，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢。\n>\n> 创建物化视图时未作指定，则Oracle按 on demand 模式来创建。\n>\n> ##### 刷新方法\n>\n> **完全刷新（COMPLETE）**： 会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。 \n>\n> **快速刷新（FAST）**： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。\n>\n> **FORCE方式**： 这是默认的数据刷新方式。Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。\n\n### 实验7：Oracle In Memory性能分析\n\n#### Sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, SUM(T_COMMENT_2.SCORE_) s FROM T_MOVIE,T_COMMENT_2 WHERE T_MOVIE.ID_=T_COMMENT_2.MOVIE_ID GROUP BY T_MOVIE.NAME_ ORDER BY s DESC;\n```\n\n#### 设置In Memory\n\n```sql\nALTER TABLE T_MOVIE.NAME_ IN MEMORY;\n```\n\n#### 实验结果\n\n**原始查询**：\n\n![no-inmemory](/images/no-inmemory.png)\n\n**In Memory查询：**\n\n![inmemory](/images/inmemory.png)\n\n#### 结果分析\n\n遗憾的是与想象的不同，Oracle和Oracle In Memory在COST上面结果相同，但是事实上在我们同样的实验环境下测试二者时间时，In Memory确实会比Oracle好很多。其实简单思考一下，这是应该的，前面我们说过执行时间`t = Block数量 * Block处理时间`，不难知道差距还是出在Block处理时间上。\n\n### 实验8：Oracle执行计划浅析(Oracle表的访问方式)\n\n对T_MOVIE表进行查询，其本身有在其主码(ID_)上的UNIQUE INDEX和LENGTH\\_上的B-tree INDEX。\n\n#### 根据UNIQUE INDEX（ID_）返回唯一记录\n\n```SQL\nselect * from T_MOVIE where ID_ = 20050;\n```\n\n![屏幕快照 2019-01-13 下午9.14.59](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.14.59.png)\n\n使用的是索引唯一扫描\n\n#### 根据ID_返回少部分记录\n\n```SQL\nselect * from T_MOVIE where ID_ < 10;\n```\n\n![屏幕快照 2019-01-13 下午9.25.22](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.25.22.png)\n\n使用的是索引范围扫描\n\n#### 根据LENGTH_返回大量数据\n\n```SQL\nselect * from T_MOVIE where LENGTH_ <100;\n```\n\n![image-20190114004746346](/images/image-20190114004746346.png)\n\n#### 全查询MOVIE\\_和TYPE\\_返回其ID_\n\n**全查询MOVIE_：**\n\n```SQL\nselect ID_ from T_MOVIE;\n```\n\n![屏幕快照 2019-01-13 下午9.32.45](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.32.45.png)\n\n采用的是索引快速扫描（因为数据量较多）\n\n![屏幕快照 2019-01-13 下午9.38.39](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.38.39.png)\n\n且返回结果无顺序（从578开始，一段有序，即代表是一个索引数据块）。\n\n**全查询TYPE_:**\n\n```SQL\nselect ID_ from T_TYPE;\n```\n\n![屏幕快照 2019-01-13 下午9.35.11](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.35.11.png)\n\n采用的是索引全扫描（因为数据量较小）\n\n![屏幕快照 2019-01-13 下午9.37.57](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.37.57.png)\n\n返回结果有顺序\n\n> ### 执行计划中的访问方式\n>\n> 访问方式即分为全表扫描（TABLE ACCESS FULL）和各种类型索引扫描（TABLE INDEX SCAN）。Oracle会根据表和索引的信息，推算执行的SQL语句从表中取多少数据以及这些数据是怎么分布的。\n>\n> #### TABLE ACCESS FULL（全表扫描）\n>\n> **Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 where限制条件**。全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作来提升吞吐量。**数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上**。\n>\n> #### TABLE ACCESS ROWID（通过ROWID的表存取）\n>\n> **ROWID是由Oracle自动加在表中每行最后的一列伪列**，表中并不会物理存储ROWID的值。程序员可以像使用其它列一样使用它，但不能对该列的值进行增、删、改操作。一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。\n>\n> ROWID可以被视为每条记录的“指针”。**它指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法**。\n>\n> #### TABLE ACCESS BY INDEX SCAN（索引扫描）\n>\n> 在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。因此索引扫描其实分为两步：扫描索引得到对应的ROWID；通过ROWID定位到具体的行读取数据。\n>\n> 索引扫描主要分为以下几种：\n>\n> ##### INDEX UNIQUE SCAN 索引唯一扫描\n>\n> 对应UNIQUE INDEX（唯一性索引）的扫描方式，其**只会应用在返回一条记录的情况下**。该点在之前的实验中已经描述。\n>\n> ##### INDEX RANGE SCAN 索引范围扫描\n>\n> 主要是使用在需要返回多行记录的情况下，常见为以下三种：\n>\n> - 在唯一索引列上使用了范围操作符（如：>   <   <>   >=   <=   between）\n> - 在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）\n> - 对非唯一索引列上进行的任何查询\n>\n> 如果在查询的过程中需要访问的记录数很多，分布很广，这个时候Oracle会根据CBO原则认为使用索引的花销可能比全表扫描大，会使用全表扫描。\n>\n> ##### INDEX FULL SCAN 索引全扫描\n>\n> 进行全索引扫描时，查询出的数据都必须从索引中可以直接得到。其常发生在要查询的列包含唯一索引且需要对表中的所有数据都要查询。**索引全扫描返回的结果有顺序。**\n>\n> ##### INDEX FAST FULL SCAN 索引快速全扫描\n>\n> 索引快速全扫描与索引全扫描类似，只是其在查找索引时会用一种更为快速的方式（简单来说是根据索引块的物理顺序而省去较为繁琐的逻辑顺序），其更适合于数据量大的表进行全查询，**其一个特点就是返回的记录不按照顺序。**\n\n## 四、TimesTen实验过程\n\n### 实验概述\n\n调用自己改写的 AliTT11.sql，查看 SQLPrepare，SQLExecute，FetchLoop 的查询时间；\n\n所有实验中，查询时间分为增加索引前、增加索引后、按照 timesten 建议添加索引三类，针对每一类时间分别有第一次执行时间和之后的平均查询时间两种；\n\n在首次执行查询语句时，timesten首先需要对语句进行预编译，因此首次执行的 SQLPrepare 时间相比之后的时间较长，之后的准备时间就相应缩短了很多。\n\n### 实验1\n\n#### 实验内容\n\n某地区评分6以上的所有电影的名字和上映时间\n\n#### 查询语句\n\n```sql\nSELECT DBIM.T_MOVIE.NAME_, DBIM.T_MOVIE.YEAR_\nFROM DBIM.T_MOVIE, DBIM.T_MOVIE_REGION, DBIM.T_REGION\nWHERE DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID\nAND DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID\nAND DBIM.T_REGION.NAME_ = '美国'\nAND DBIM.T_MOVIE.SCORE_ > 6;\n```\n\n#### 添加的索引\n\n| 表明         | 列名      | 索引类型 | 是否唯一 |\n| ------------ | --------- | -------- | -------- |\n| Movie        | id_       | hash     | unique   |\n| Movie        | score_    | range    |          |\n| Region       | id_       | hash     | unique   |\n| Movie_region | region_id | hash     |          |\n| Movie_region | movie_id  | hash     |          |\n\n#### 查询时间\n\n| 时间类型   | Before1  | Before2  | After1   | After2   | 建议1    | 建议2    | 提高百分比 |\n| ---------- | -------- | -------- | -------- | -------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001845 | 0.000059 | 0.000878 | 0.000054 | 0.000807 | 0.000055 |            |\n| SQLExecute | 0.075809 | 0.061819 | 0.000037 | 0.000025 | 0.000034 | 0.000025 | 99.96%     |\n| FetchLoop  | 0.000004 | 0.000002 | 0.000002 | 0.000001 | 0.000003 | 0.000002 |            |\n\n- 执行计划 (before)\n\n![11b](/images/11b.PNG)\n\n- 执行计划 (after)\n\n![11a](/images/11a.PNG)\n\n#### 原因分析\n\n添加索引后速度大大提升，因为在 region 表中指定了查询条件，添加索引后可以快速从表项中匹配到指定条件的项；在添加之前，timesten 自动帮我们在 movie 表上的 id 字段上添加了临时哈希索引，除此之外，我们额外为几个 where 条件语句的查询字段都增加了索引， 因此提高了效率。\n\n执行计划\n\n- before\n\n  在两层嵌套循环中，顺序执行在region表中的查询、region表与联系表的join，循环结束后生成一个指定地区内的所有电影联系表；内层嵌套完成后，通过散列索引匹配movie表与内存循环生成的联系表，join筛选后生成结果列表\n\n- after\n\n  添加索引之后，过程与添加之前相同，但由于内层循环内使用散列索引而不是顺序执行，因此查询速度比较快，加上没有临时创建索引的时间开销，所以相比之下大大提高了查询效率。\n\n### 实验2\n\n#### 实验内容\n\n所有地区全部电影的平均评分排行榜（前100）\n\n#### 查询语句\n\n```sql\nSELECT * FROM (SELECT DBIM.T_REGION.NAME_, SUM(DBIM.T_MOVIE.SCORE_) s\nFROM DBIM.T_REGION, DBIM.T_MOVIE_REGION, DBIM.T_MOVIE\nWHERE DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID\nAND DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID\nGROUP BY DBIM.T_REGION.NAME_\nORDER BY s DESC) WHERE ROWNUM < 101;\n```\n\n#### 添加的索引\n\n| 表明         | 列名      | 索引类型 | 是否唯一 |\n| ------------ | --------- | -------- | -------- |\n| Movie        | id_       | hash     | unique   |\n| Movie        | score_    | range    |          |\n| Region       | name_     | hash     | unique   |\n| Region       | id_       | hash     | unique   |\n| Movie_region | region_id | hash     |          |\n| Movie_region | movie_id  | hash     |          |\n\n#### 查询时间\n\n| 时间类型   | Before(1) | Before(2) | After(1) | After(2) | 建议(1)  | 建议(2)  | 提高百分比 |\n| ---------- | --------- | --------- | -------- | -------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001253  | 0.000081  | 0.001004 | 0.000054 | 0.000985 | 0.000056 |            |\n| SQLExecute | 0.353111  | 0.335902  | 0.337983 | 0.313458 | 0.313004 | 0.312695 | 7%         |\n| FetchLoop  | 0.000045  | 0.000020  | 0.000018 | 0.000018 | 0.000018 | 0.000017 |            |\n\n- 执行计划 (before)\n\n![12b](/images/12b.PNG)\n\n- 执行计划 (after)\n\n![12a](/images/12a.PNG)\n\n#### 原因分析\n\n添加索引之前，timesten 自动在 movie 和 region 表的 id 字段上都设置了相应的哈希索引，而我们添加索引后与添加之前的执行计划中的索引项没有差别，因此效率几乎没有变化，加上 sum 聚合操作、group by、order by 操作都要进行费时间的全表扫描，所以需要较长时间完成查询。\n\n> ##### 实验1和2分析总结\n>\n> 指定条件的查询：\n>\n> - 建立索引之前\n>\n>   timesten在某个相对较小的表上建立临时索引（散列索引或范围索引），在其他表上进行顺序扫描，执行查询语句中的条件匹配，建立索引的过程会造成时间上的消耗；\n>\n> - 建立索引之后\n>\n>   自己建立的索引覆盖timesten优化建立的索引，由于索引提前建立，因此没有建立索引带来的额外时间开销，而且在此类查询中我们在所有查询涉及字段上都建立了索引（tt自身优化通常只在一个表上建立索引），所以与建立索引之前相比有极大的性能提升。\n>\n> 聚合查询：\n>\n> - 执行计划Before：\n>\n>   先顺序扫描关系表act的记录字段id，利用临时HASH索引 actor.id_，将act表中对应记录与act的记录通过字段相连；对(这些/该)拼接记录逐条利用临时HASH索引 movie.id ,接上movie表中符合条件的记录字段。\n>\n> - 执行计划After：\n>\n>   先顺序扫描关系表movie的记录字段id ，利用HASH索引 act.id_，将act表中对应记录与act的记录通过字段相连；针对第一次hash检索出的 act.id，再对(这些/该)拼接记录逐条利用临时HASH索引 actor.id ,接上actor表中符合条件的记录字段。\n>\n> - 主要原因在于：第一次顺序扫描的关系表act，外码引用actor表的主码(1:1)，movie表(1:1)，hash索引查询唯一记录快；第二次顺序扫描的表为movie表，将对应多条act表里的记录（1:many），对应多个演员(1:many)。\n\n### 实验3：AWT\n\n#### 创建 AWT 直写缓存组\n\n- 缓存表\n  - t_moive\n  - t_comment_1\n- 选择理由\n  - 动态缓存组适用于不从 oracle 中预加载数据的场景\n  - Movie 表和评论表体量较大，不需要从 oracle 中提前加载\n\n#### 测试 AWT 修改数据\n\n- 修改电影评论表\n\n- 修改语句\n\n  ```mysql\n  UPDATE DBIM.T_COMMENT_1\n  SET SUMMARY_='A'\n  WHERE DBIM.T_COMMENT_1.SCORE_>8\n  AND DBIM.T_COMMENT_1.MOVIE_ID = 1;\n  ```\n\n- 踩坑\n\n  - update语句指定修改的表名后，set字段不需要再次声明表名（否则报错）\n  - 修改数据前要开启 replication agent\n  - 执行update语句后要提交事务\n\n### 实验4：查看不同数据类型对查询效率的影响\n\n#### 表字节大小\n\n| 表名    | 行数    | 字节大小                | 有数据类型映射的字节大小 | 节约百分比 |\n| ------- | ------- | ----------------------- | ------------------------ | ---------- |\n| Movie   | 292352  | 47301232（nomapping）   | 26293000（optimal）      | 45%        |\n| Comment | 9805336 | 2528884600（nomapping） | 404967952（optimal）     | 84%        |\n\n#### 压缩设置\n\n![image-20190114062154430](/images/image-20190114062154430.png)\n\n#### 数据类型映射结果\n\n| 表     | 字段  | noMapping         | standardMapping   | aggressive       |\n| ------ | ----- | ----------------- | ----------------- | ---------------- |\n| Region | id_   | NUMBER(11,0)      | TT_BIGINT         | TT_SMALINT       |\n| Region | name_ | VARCHAR(255 BYTE) | VARCHAR(255 BYTE) | VARCHAR(80 BYTE) |\n\n#### 结果分析\n\n- 对相同的表来说，从 oracle 导入 timesten 中如果不进行压缩（nomapping），与进行最优化数据类型映射+aggressive mapping + optimal compression 相比，大约浪费了45%的空间；\n- 对于不同数量级的表来说，千万数量级的 comment 表不进行压缩时浪费84%所有的空间，比十万数量级的 movie 表浪费的空间多了接近一倍。\n\n### 实验5：根据优化建议建立索引\n\n#### SQL语句\n\n```sql\nCommand> call ttIndexAdviceCaptureOutput(0);\n< 6, create index T_MOVIE_i1 on DBIM.T_MOVIE(ID_); >\n< 7, create index T_COMMENT_1_i2 on DBIM.T_COMMENT_1(MOVIE_ID,SCORE_); >\n2 rows found.\n```\n\n#### 实验对象\n\n- 实验3.2语句\n\n#### 实验结果\n\n- Before：自己建立索引后的查询时间\n- After：根据 timesten 查询优化建议建立索引后的查询时间\n\n| 时间类型   | Before(1) | Before(2) | After(1) | After(2) | 提高百分比 |\n| ---------- | --------- | --------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001527  | 0.000049  | 0.000822 | 0.000049 |            |\n| SQLExecute | 4.139655  | 3.556375  | 3.301318 | 3.302092 | 7.18%      |\n| FetchLoop  | 0.000047  | 0.000027  | 0.000018 | 0.000017 |            |\n","source":"_posts/数据库与内存数据库实验报告.md","raw":"---\ntitle: 数据库与内存数据库实验报告\ndate: 2019-03-05 20:34:59\ntags:\n   - Oracle\n   - Timesten\ncategories:\n   - 数据库\n---\n\n## 一、实验前准备\n\n### 机器配置\n\n![image-20190114060005845](/images/image-20190114060005845.png)\n\n<!-- more -->\n\n### 时间计算标准\n\n#### SQL执行过程\n\n首先，本实验的目的是优化数据库，减少数据库语句执行的时间，在此之前，我们要明白一点`数据库执行时间`这句话包含了哪些东西。我们从数据库执行一条SQL语句的过程来看，对于MySQL、Oracle、TimesTen这些具有内部优化的数据库来说，一般的执行步骤是：\n\n![image-20190113214926175](/images/image-20190113214926175.png)\n\n而我们的关注点应放在语句执行这一步骤上。\n\n#### 语句执行步骤进一步深入\n\n##### MySQL\n\nMySQL的执行时间为以下项目的加和：\n\n| State                   | Desription                     |\n| ----------------------- | ------------------------------ |\n| 1. Checking permissions | 检查用户的权限                 |\n| 2. Opening tables       | 打开表                         |\n| 3. Init                 | 初始化过程                     |\n| 4. System lock          | 获取锁                         |\n| 5. Optimizing           | 优化SQL语句                    |\n| 6. Statistics           | 分析SQL语句                    |\n| 7. Preparing            | 准备执行条件                   |\n| 8. Executing            | 执行SQL语句                    |\n| 9. Sending data         | 进行磁盘的IO以及数据的发送返回 |\n| 10. End                 | 执行结束                       |\n| 11. Closing tables      | 关闭表                         |\n| 12. Freeing items       | 释放资源                       |\n| 13. Cleaning up         | 清理缓存以及临时空间           |\n\n##### Oracle\n\n一条SQL语句在进入`语句执行`这一步骤之后，若不在高速缓存中，数据库会从数据文件中把`所在位置`移动到`高速缓存`中而后返回给客户端。这也就意味着，同一条语句在以后的执行中都只从高速缓存取数据（前提是高速缓存`未被清除`）。这样想的话，我们要做的优化应该是一条SQL语句在第一次进入数据库时数据库作出的应答。\n\n那么，我们通过数据库工具来查看执行的SQL语句的时间应该是不准的：**因为我们不知道这条语句是不是第一次执行，或者说我们不知道高速缓存中有没有我们需要的数据**。这里我们选择使用Oracle的执行计划来看SQL语句的准确的执行过程以及其`开销`。如下图：\n\n![image-20190113211220925](/images/image-20190113211220925.png)\n\n我们的关注点在上图中的`COST`，cost是Oracle里判定效率的唯一标准，Oracle的优化器会计算当前SQL语句的最低cost方案，而后为其选择执行计划。Oracle中定义了语句的一次执行开销`cost = CPU cost + IO cost`，对于cost，我们可以理解为一次过程所需要访问的Block数量，那么执行时间就是`t = Block数量 * Block处理时间`。\n\n后续实验过程中的Oracle部分我们都是通过执行计划及cost来做对比。为此我们写了一个procedure来记录一条语句执行计划中记录的cost：\n\n```plsql\n-- 计算query的cost\ncreate or replace procedure calc_cost(query_ varchar2, func_ number, desc_ varchar2) is\n  cpu_cost number := 0;\n  io_cost number := 0;\n  cost_ number := 0;\n  -- 一条SQL语句的唯一标识\n  hash_v number := 0;\n  -- 获取上述标识\n  select_v_sql varchar2(255) := 'select hash_value into :x from v$sql a where a.SQL_TEXT like '':y''';\n  -- 获取cost\n  select_v_sql_plan varchar2(255) := 'select max(cpu_cost) , max(io_cost) into :x :y from V$SQL_PLAN a where hash_value=:z';\n  -- 结果保存\n  insert_result varchar2(255) := 'insert into t_cost_record values(:x,:y,:z,:a,:b,:c)';\nbegin\n  execute immediate select_v_sql using hash_v, query_;\n  execute immediate select_v_sql_plan using cpu_cost, io_cost, cost_;\n  execute immediate insert_result using id_seq.nextval, func_, cpu_cost, io_cost, cost_, desc_;\nend;\n```\n\n##### TimesTen\n\n对于TimesTen来说，不如Oracle的优化器来的智能，它完全靠速度制胜。Oracle中我们讨论了执行时间`t = Block数量 * Block处理时间`，TimesTen就是在Block处理时间上有很大的优势。遗憾的是TimesTen中没有作为本身的高速缓存这一说，这也就意味着一条SQL语句进入TimesTen时都要经过`SQL Prepare -> SQL Execution -> SQL Fetch `这一完整的过程，如下：\n\n![image-20190114052126486](/images/image-20190114052126486.png)\n\n## 二、MySQL实验过程\n\n功能：查询电影评论平均分排行前一百的电影\n\n### SQL语句\n\n```mysql\nselect  m.name_, sum(c1.score) as movie_avg_comment_score\nfrom movie m  , comment_1 c1\nwhere m.id_ = c1.movie_id\ngroup by m.name_\norder by movie_avg_comment_score desc\nlimit 100;\n```\n\n### 仅有主键索引\n\n执行之后得到如下的时间消耗：\n\n![time_3.2_4min](/images/time_3.2_4min.png)\n\n这个时间相比其他数据库慢得多（oracle 约4s)，不符合预期的耗时，且在执行时mysqld的cpu占用率非常高。于是根据以下步骤查看sql执行慢的原因。\n\n### MySQL进程表\n\n使用`show processlist`命令查看正在执行的sql语句列表：\n\n![process_list](/images/process_list.png)\n\n可以看到当前执行的语句就是我们的目标语句，并且没有其他语句在与当前查询语句竞争资源，所以应该把语句执行过慢点原因定位到查询语句本身。\n\n### 解释执行计划\n\n通过查看process list得知对应语句有问题之后，使用`describe`命令查看当前SQL语句的执行计划，MySQL的执行计划与其他相关参数：\n\n![explain_3.2](/images/explain_3.2.png)\n\n可以看到在执行计划中，movie表有可选的主码索引，但是在这个场景中mysql并没有选择使用主码索引，没有使用索引是导致时间过慢点一个原因，于是可以考虑在电影名字字段上建立索引。\n\n### 执行过程\n\n为了进一步查看SQL语句具体的系统能耗分布，我们选择使用`profiling`来分析我们SQL语句的执行过程，在没有创建其他索引的情况下我们得到如下的时间消耗分析：\n\n![detail_3.2](/images/detail_3.2.png)\n\n我们可以看到其中能耗占比最高的是 `Sending data`项，查看官方文档相关解释：\n\n> The thread is reading and processing rows for a `SELECT` statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.\n>\n> 该线程正在读取和处理SELECT语句的行，并将数据发送到客户端。 由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态\n\n所以这个与我们的磁盘IO的速度以及网络的传输速度有关，磁盘的IO除了受到硬件本身的限制之外还会与数据库的索引有关，更换性能更好的磁盘或者建立适当的索引以减少磁盘IO数量都可以提高查询语句的执行速度。\n\n### 建立索引\n\n根据以上分析过程得到的结论，我们在电影表的名字字段上建立合适的索引，我们在mysql中选择了B-Tree索引。\n\n建立索引之后再查看相同SQL语句的执行计划：\n\n![explain_3.2_index](/images/explain_3.2_index.png)\n\n`key`字段上的值从原来的`null` 变成了我们刚刚创建的索引。\n\n执行该SQL语句，并在结束后使用`Profiling`查看优化后的执行时间：\n\nsending data: 从磁盘读取数据，将数据返回，表示磁盘IO\n\ncreate index：使用临时表来处理select语句\n\n![detail_index_3.2](/images/detail_index_3.2.png)\n\n可以看到`Sending data`的值明显小于优化前，总的执行时间也变为优化前的1/5，所以增加索引能够在很大程度上加快查询的速度。\n\n### 实验结论\n\n综合其他实验，在大数据的处理上MySQL数据库的性能远不如ORACLE及TIMESTEN数据库，有数十倍的耗时差距，而且MySQL作为一个轻量级的数据库，支持的索引类型也少于其他两个数据库，在SQL语句的优化方面也不如ORACLE数据库那般强大。所以在当前的实验环境下我们更倾向于使用ORACLE数据库与TIMESTEN数据库进行对比。\n\n## 三、Oracle实验过程\n\n### 实验1：SQL各子句条件顺序对查询效率的影响\n\n#### 查询语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_ FROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID AND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国' AND T_MOVIE.SCORE_>6;\n```\n\n#### 实验方式\n\n通过对MySQL、Oracle、TimesTen中SQL语句中select、from、where子句的排序顺序进行调换，观察执行计划的改变\n\n#### 实验结果\n\n1. SELECT子句中，结果集的排序方式不会影响执行计划\n2. FROM子句中，各个表的排序方式不会影响执行计划\n3. WHERE子句中，各个条件的排序方式不会影响执行计划，优化器会首先将筛选条件应用于表进行过滤，最后逐次执行表的连接。\n\n#### 分析\n\n自Oracle6以来，一直采用RBO（Rule-Based Optimization 基于规则的优化器），其基于一套严格死板的使用规则。由于其对于规则的崇尚性，SQL语句的写法则尤为重要。而自Oracle8以来，Oracle引入了一种新的优化方式，即CBO（Cost-Based Optimization 基于代价的优化器），从Oracle 10g开始RBO被完全舍弃。使用CBO优化器时，对SQL语句的要求变得没有那么苛刻，优化器会选择开销比较小的方式执行，而不由用户所写的表的顺序、条件的顺序决定。MySQL与TimesTen的优化器也是如此，有其自己的选择。\n\n> ##### 连接方式和连接顺序\n>\n> **连接顺序**：连接顺序表明以哪张表为驱动表来连接其他表的先后顺序。即以某张表为基点，根据其中的信息再去访问其他的表。\n>\n> **连接方式**：简单来讲，就是两个表获得满足条件的数据时的连接过程。主要有三种表连接方式，嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）。\n>\n> ###### 排序-合并连接\n>\n> 假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)\n>\n> 内部连接过程：\n>\n> a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序\n>\n> b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序\n>\n> c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）\n>\n> 延伸：\n>\n> 如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。\n>\n> 故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。**不过遗憾的是**，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。\n>\n> 排序-合并连接的表无驱动顺序，谁在前面都可以；\n>\n> 排序-合并连接**适用**的连接条件有： **<   <=   =   >   >= ，不适用**的连接条件有： **<>    like**\n>\n> ###### 嵌套循环\n>\n> 内部连接过程：\n>\n> a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n>\n> b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中\n>\n> c) ……\n>\n> 若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。\n>\n> 因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。\n>\n> 嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：**可以先返回已经连接的行**，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。\n>\n> 应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。\n>\n> ###### 哈希连接\n>\n> **哈希连接只适用于等值连接（即连接条件为  =  ）**\n>\n> HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；\n>\n> 内部连接过程简述：\n>\n> a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）\n>\n> b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据\n\n### 实验2：B树索引与位图索引的比较\n\n#### sql语句\n\n```sql\n-- 小基数\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>6;\n-- 大基数\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_ACTOR,T_ACT,T_MOVIE\nWHERE T_ACTOR.NAME_='Tom Byron'\nAND T_MOVIE.SCORE_>6\nAND T_ACTOR.ID_=T_ACT.ACTOR_ID\nAND T_MOVIE.ID_=T_ACT.MOVIE_ID;\n```\n\n#### 索引语句\n\n```sql\n-- B树\nCREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);\nCREATE INDEX IX_MOVIE_NAME ON T_MOVIE(NAME_);\nCREATE INDEX IX_ACTOR_NAME ON T_ACTOR(NAME_);\n-- BitMap\nCREATE BITMAP INDEX IXBM_MOVIE_NAME ON T_MOVIE(NAME_);\nCREATE BITMAP INDEX IXBM_MOVIE_SCORE ON T_MOVIE(SCORE_);\nCREATE BITMAP INDEX IXBM_ACTOR_NAME ON T_ACTOR(NAME_);\n```\n\n#### 查询消耗\n\nB树索引（小基数）\n\n![B树索引](/images/1-B%E6%A0%91%E7%B4%A2%E5%BC%95.png)\n\n位图索引（小基数）\n\n![位图索引](/images/1-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png)\n\n不加索引（大基数）\n\n![image-20190113230831573](/images/image-20190113230831573.png)\n\nB树索引（大基数）\n\n![image-20190113230717837](/images/image-20190113230717837.png)\n\n位图索引（大基数）\n\n![image-20190113230627090](/images/image-20190113230627090.png)\n\n#### 分析\n\n即使在字段基数较大的情况下，位图索引依然有比B树索引更好的表现。但是有个问题，创建位图索引时所需的时间更长。此外，由于表中该字段的更改都会导致对位图的修改，所以位图索引不适用于并发的情况。\n\n### 实验3：Oracle优化器对索引的选择\n\n> #### 关于索引\n>\n> ##### 索引类型\n>\n> - B树索引（默认的索引）\n>\n> ```sql\n> CREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);\n> ```\n>\n> - 位图索引：以位图的形式存储每个值对应的的一组rowid\n>\n> ```sql\n> CREATE BITMAP INDEX IXBM_REGION_NAME ON T_REGION(NAME_);\n> ```\n>\n> - 基于函数的索引：利于对某个字段查询时需要同时使用函数或计算的情景\n>\n> ```sql\n> CREATE INDEX upper_ix ON employees (UPPER(last_name)); \n> ```\n>\n> - 分区索引：本地分区索引的分区完全依赖于其索引所在表，而全局分区索引的分区机制和表分区可能一样也可能不一样\n>\n>   - range范围分区\n>\n>   ```sql\n>   CREATE INDEX cost_ix ON sales (amount_sold)\n>    GLOBAL PARTITION BY RANGE (amount_sold)\n>       (PARTITION p1 VALUES LESS THAN (1000),\n>        PARTITION p2 VALUES LESS THAN (2500),\n>        PARTITION p3 VALUES LESS THAN (MAXVALUE));\n>   ```\n>\n>   - hash哈希分区\n>\n>   ```sql\n>   CREATE INDEX cust_last_name_ix ON customers (cust_last_name)\n>   GLOBAL PARTITION BY HASH (cust_last_name)\n>   PARTITIONS 4;\n>   ```\n>\n>   - list列表分区：一个分区对应指定列的特定的值，以列举的方式进行分区\n>   - 组合分区（range-hash，range-list）\n>\n> ##### 什么时候用索引\n>\n> 对于Oracle的CBO来说，只有在使用索引能提高效率（估算的效率）时才会使用索引。对于程序员自己进行数据库管理的时候，一般有：\n>\n> **需要使用索引来优化查询的情况：**\n>\n> - 一个属性的值分布非常广，变化的范围跨度很大。\n> - 一般来说，常常需要被用在SQL语句的where中的限制条件的属性最好为其建立索引。\n> - 表经常被访问且需要访问的数据量仅占一部分。\n>\n> **不适合用索引的情况：**\n>\n> - 表很小\n> - 表经常被更新\n> - 属性不经常作为where中的限制条件的属性存在\n> - 查询得到的数据占总量的很大部分\n>\n> 对于数据经常更新的情况，DBA要定时进行索引的重构（rebuild）以维持索引的可用性。\n>\n> ##### 影响优化器决策的因素\n>\n> - 进行全表扫描需要读取的数据块数量；\n> - 进行索引查询需要读取的数据块数量，这主要是基于对WHERE子句谓词返回的记录数目估计；\n> - 进行全表扫描时多块读的相关开销，以及为满足索引查询进行的单块读的开销；\n> - 内存中对缓存中的索引块和数据块数目的假设。\n>\n> ##### 索引失效的可能原因\n>\n> 以下是一些常见的定义了索引当Oracle并未使用的原因：\n>\n> - 不等于情况，即“<>”\n> - 字符串匹配like中百分号在第一位的情况，即“%XXX”\n> - 表没有进行分析更新统计信息\n> - 使用复合索引但单独引用且非复合索引的第一属性\n> - 对索引进行计算，此时需要建立索引函数\n> - 属性为字符串但在where中没有加引号\n> - 使用not in，not exists\n> - 使用了其他索引\n>\n> #### 强制使用索引\n>\n> 如果想要强制使用索引，则可以在查询语句的select单词后加上/\\*+index (tablename indexname)*/，这样可以规定Oracle选择使用indexname的索引的执行计划。该方法已在前面实验中使用，不再赘述。\n\n#### sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>6;\n```\n\n#### 查询消耗\n\n不用索引（不论是B树索引还是位图索引都不使用）\n\n![3-不用索引](/images/3-%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95.png)\n\n强制使用B树索引\n\n![3-强制B树](/images/3-%E5%BC%BA%E5%88%B6B%E6%A0%91.png)\n\n强制使用位图索引\n\n![3-强制位图](/images/3-%E5%BC%BA%E5%88%B6%E4%BD%8D%E5%9B%BE.png)\n\n#### sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, T_MOVIE.YEAR_\nFROM T_MOVIE,T_MOVIE_REGION,T_REGION\nWHERE T_REGION.ID_=T_MOVIE_REGION.REGION_ID\nAND T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID\nAND T_REGION.NAME_='美国'\nAND T_MOVIE.SCORE_>9;\n```\n\n#### 查询消耗\n\nB树索引（未使用）\n\n![3-B树](/images/3-B%E6%A0%91.png)\n\n位图索引\n\n![3-位图](/images/3-%E4%BD%8D%E5%9B%BE.png)\n\n#### 分析\n\n由此可见，即使在有索引的情况下，oracle优化器也可能选择不使用索引。CBO优化器会对每种执行计划计算一个COST，并采用COST最小的执行计划。如果一个表有索引或多种索引，其会选择最好的一种索引方式扫描表，或者甚至不用索引而用全局扫描方式。\n\n另外对于符合筛选条件的数据，当占全表的比例越小、数据量越小时，使用索引的可能性越大。如在这次实验中，条件为\"T_MOVIE.SCORE_ >9\"时会使用索引，而\"T_MOVIE.SCORE_ >6\"时不会。\n\n此外，由于位图索引导致的COST要小于B树索引，因此在相同的查询中，使用位图索引的可能性比B树索引更大。\n\n### 实验4：Oracle分区索引\n\n#### sql语句\n\n```sql\nSELECT T_COMMENT.SUMMARY_,T_COMMENT.SCORE_,T_COMMENT.TIME_\nFROM T_COMMENT,T_MOVIE\nWHERE T_MOVIE.ID_=T_COMMENT.MOVIE_ID\nAND T_COMMENT.SCORE_>6\nAND T_MOVIE.NAME_='Blindsided';\n```\n\n#### 实验结果\n\n1. 未分区表+无索引\n\n   ![5-1-1](/images/5-1-1.png)\n\n2. 未分区表+B树索引\n\n   ![5-2](/images/5-2.png)\n\n3. 未分区表+位图索引\n\n   ![5-3](/images/5-3.png)\n\n4. 分区表+无索引\n\n   ![5-4-1](/images/5-4-1.png)\n\n5. 分区表+全局不分区B树索引\n\n   ![5-5-1](/images/5-5-1.png)\n\n6. 分区表+本地(哈希分区)B树索引\n\n   ![5-6](/images/5-6.png)\n\n7. 分区表+本地(哈希分区)位图索引\n\n   ![5-7](/images/5-7.png)\n\n8. 分区表+全局哈希分区索引\n\n   ![5-8](/images/5-8.png)\n\n9. 分区表+全局范围分区索引\n\n   ![5-9](/images/5-9.png)\n\n#### 分析\n\n1. 在未建索引时，分区表的COST是未分区表的十倍多。原因是分区所依据的键（字段）不是直接的查询条件——我们以评论表的movie_id字段为依据建哈希分区表，但在查询的时候并不直接以movie_id为查询条件。导致连接表的时候，需要访问多个分区，反而造成COST大大增长。\n\n   后来我们重新设计一个以movie_id为查询条件的sql语句，结果显示分区表的COST大约是未分区表的1/4（一共分了4个区），证明在以分区依据的字段为直接查询条件时，分区表能够体现比较好的性能，能够避免对一部分数据的访问。\n\n2. 在分区表上建索引比在未分区表上建索引后的开销更小，不论分区表上的索引是全局还是本地，不论是否是分区索引。在我们的实验场景中，尽管movie_id不是直接的查询条件而是join表的条件，但是在添加索引后，依然能够大大减少join表的开销从而提升效率。\n\n3. 在我们的实验场景中，全局的分区索引，不论是哈希分区还是范围分区，COST是一样的。\n\n4. 本地索引的效率略微比全局索引的效率好。根据查到的资料，本地索引的可维护性好，能够自动维护，不需要人工干预，但因把索引分成多个分区导致每次的索引访问都需要遍历所有索引分区，所以索引访问性能下降。因此比较适合OLAP系统。而全局索引的可维护性差，分区表发生改变时，需要用命令手动更新索引，但索引访问性能比本地分区索引要好。因此比较适合OLTP系统。\n\n### 实验5：Oracle使用复合索引\n\n#### SQL语句\n\n```SQL\nselect T_COMMENT_1.SUMMARY_, T_COMMENT_1.SCORE_\nfrom T_COMMENT_1, T_MOVIE\nwhere T_MOVIE.ID_ = T_COMMENT_1.MOVIE_ID and T_COMMENT_1.SCORE_ > 7 and T_MOVIE.NAME_ = 'The Notebook';\n```\n\n第一次查询：T_COMMENT_1上只有主键的唯一索引。\n\n第二次查询：在MOVIE_ID上建立一个B-tree索引COMMENT_1_MOVIE。\n\n```sql\ncreate index COMMENT_1_MOVIE on T_COMMENT_1(MOVIE_ID);\n```\n\n第三次查询：使第二次的索引invisible，在SCORE_上建立一个B-tree索引T_COMMENT_SCORE_INDEX。\n\n```SQL\nalter index COMMENT_1_MOVIE invisible;\ncreate index T_COMMENT_SCORE_INDEX on T_COMMENT_1(SCORE_);\n```\n\n第四次查询：将第二次和第三次的索引都保持为visible，在MOVIE_ID和SCORE_上建立一个复合索引COMMENT_1_MOVIE_SCORE。\n\n```SQL\nalter index COMMENT_1_MOVIE visible;\ncreate index COMMENT_1_MOVIE_SCORE on T_COMMENT_1(MOVIE_ID, SCORE_);\n```\n\n#### 实验结果\n\n**第一次查询：**\n\n![屏幕快照 2019-01-13 下午10.48.45](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.48.45.png)\n\n全表扫描，花销很大\n\n**第二次查询：**\n\n![屏幕快照 2019-01-13 下午10.47.49](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.47.49.png)\n\n利用在MOVIE_ID上的索引，在T_COMMENT_1中访问的数据量和花销都大幅度下降。\n\n**第三次查询：**\n\n![屏幕快照 2019-01-13 下午10.50.07](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.50.07.png)\n\n如果只有在SCORE_上的索引，根据CBO，Oracle并没有使用这个索引，而是依旧使用全表扫描，可知该索引并没有提升性能。\n\n易知，如果在这个时候将MOVIE_ID上的索引设为visible，Oracle会使用MOVIE_ID上的索引。\n\n**第四次查询：**\n\n![屏幕快照 2019-01-13 下午10.57.10](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.57.10.png)\n\nOracle使用了复合索引，尽管在当前问题下COST花销与只有MOVIE_ID的索引差不多，但是其访问的记录数（CARDINALITY）显著减小，体现了复合索引给查询带来的性能提升。\n\n### 实验6：物化视图对SQL查询性能的提升\n\n#### SQL语句\n\n**原始查询语句：**\n\n```SQL\nselect T_DIRECTOR.NAME_, T_MOVIE.NAME_ MOVIE_NAME, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_ and T_DIRECTOR.NAME_ like '黑泽明%'\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_ ;\n```\n\n创建一个**普通视图**：\n\n```SQL\nCREATE VIEW DIRECTOR_MOVIE_FAKE\nAS\nselect T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;\n```\n\n使用普通视图进行查询：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE_FAKE where NAME_ like '黑泽明%';\n```\n\n创建**物化视图**：\n\n```SQL\nCREATE MATERIALIZED VIEW DIRECTOR_MOVIE\nBUILD IMMEDIATE\nREFRESH FORCE\nON DEMAND\nENABLE QUERY REWRITE\nAS\nselect T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, AVG(T_COMMENT_1.SCORE_) SCORE\nfrom T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1\nwhere T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID and T_DIRECT.MOVIE_ID = T_MOVIE.ID_ and T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_\ngroup by T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;\n```\n\n设置**创建时生成数据**，**按需要刷新**，**刷新方式为FORCE**。\n\n根据视图进行如上查询：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE where NAME_ like '黑泽明%';\n```\n\n由于物化视图与表类似，可以给其建立索引，以下给导演名**建立索引**：\n\n```sql\nCREATE BITMAP INDEX DIRECTOR_MOVIE_INAME_INDEX ON DIRECTOR_MOVIE (NAME_);\n```\n\n**再次使用物化视图查询**：\n\n```SQL\nselect NAME_, MOVIE_NAME, SCORE from DIRECTOR_MOVIE where NAME_ like '黑泽明%';\n```\n\n#### 实验结果\n\n**使用原始查询：**\n\n![屏幕快照 2019-01-14 上午12.27.37](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png)\n\n具有极大的花销。\n\n**创建视图后的查询：**\n\n![屏幕快照 2019-01-14 上午12.30.46](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png)\n\n其执行计划与**原始查询**一致。\n\n**创建物化视图后的查询：**\n\n![屏幕快照 2019-01-14 上午12.33.27](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.33.27.png)\n\n其**直接在物化视图中进行查询**，执行计划即为简单，花销大幅度减小。\n\n**给物化视图创建索引后的查询：**\n\n![屏幕快照 2019-01-14 上午12.35.22](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.35.22.png)\n\n建立索引后通过范围索引扫描该物化视图进行查询，其COST数字小得令人惊奇。\n\n#### 分析\n\n1.建立普通视图并不能提升性能。因为普通是虚拟的，对视图的操作实际都转变为了对各表的SQL操作，其与原始查询完全一致。\n\n2.物化视图是一种物理表，对于物化视图的查询是直接的，跟表一样。因此建立物化视图可以大幅度减小花销，但是同时，物化视图也会产生大量的维护成本。因此程序员应该根据实际情况建立物化视图以优化查询。\n\n3.物化视图同样可以增添索引，增加索引后Oracle对物化视图可以通过索引进行扫描，进一步提高效率。\n\n> ##### 物化视图与普通视图\n>\n> 视图只是一种虚拟表。实际上，**对视图的查询真正转换成了相应的SQL语句再对各表进行连接查询，因此其性能提升有限，只是方便了使用**。\n>\n> 而物化视图是实质化的视图，是**物理表**，可以像表一样进行查询，建立索引，占用真正的存储空间，需要被刷新。\n>\n> ##### 刷新模式\n>\n> **on demand：**顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性;\n>\n> **on commit**：提交触发，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢。\n>\n> 创建物化视图时未作指定，则Oracle按 on demand 模式来创建。\n>\n> ##### 刷新方法\n>\n> **完全刷新（COMPLETE）**： 会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。 \n>\n> **快速刷新（FAST）**： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。\n>\n> **FORCE方式**： 这是默认的数据刷新方式。Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。\n\n### 实验7：Oracle In Memory性能分析\n\n#### Sql语句\n\n```sql\nSELECT T_MOVIE.NAME_, SUM(T_COMMENT_2.SCORE_) s FROM T_MOVIE,T_COMMENT_2 WHERE T_MOVIE.ID_=T_COMMENT_2.MOVIE_ID GROUP BY T_MOVIE.NAME_ ORDER BY s DESC;\n```\n\n#### 设置In Memory\n\n```sql\nALTER TABLE T_MOVIE.NAME_ IN MEMORY;\n```\n\n#### 实验结果\n\n**原始查询**：\n\n![no-inmemory](/images/no-inmemory.png)\n\n**In Memory查询：**\n\n![inmemory](/images/inmemory.png)\n\n#### 结果分析\n\n遗憾的是与想象的不同，Oracle和Oracle In Memory在COST上面结果相同，但是事实上在我们同样的实验环境下测试二者时间时，In Memory确实会比Oracle好很多。其实简单思考一下，这是应该的，前面我们说过执行时间`t = Block数量 * Block处理时间`，不难知道差距还是出在Block处理时间上。\n\n### 实验8：Oracle执行计划浅析(Oracle表的访问方式)\n\n对T_MOVIE表进行查询，其本身有在其主码(ID_)上的UNIQUE INDEX和LENGTH\\_上的B-tree INDEX。\n\n#### 根据UNIQUE INDEX（ID_）返回唯一记录\n\n```SQL\nselect * from T_MOVIE where ID_ = 20050;\n```\n\n![屏幕快照 2019-01-13 下午9.14.59](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.14.59.png)\n\n使用的是索引唯一扫描\n\n#### 根据ID_返回少部分记录\n\n```SQL\nselect * from T_MOVIE where ID_ < 10;\n```\n\n![屏幕快照 2019-01-13 下午9.25.22](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.25.22.png)\n\n使用的是索引范围扫描\n\n#### 根据LENGTH_返回大量数据\n\n```SQL\nselect * from T_MOVIE where LENGTH_ <100;\n```\n\n![image-20190114004746346](/images/image-20190114004746346.png)\n\n#### 全查询MOVIE\\_和TYPE\\_返回其ID_\n\n**全查询MOVIE_：**\n\n```SQL\nselect ID_ from T_MOVIE;\n```\n\n![屏幕快照 2019-01-13 下午9.32.45](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.32.45.png)\n\n采用的是索引快速扫描（因为数据量较多）\n\n![屏幕快照 2019-01-13 下午9.38.39](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.38.39.png)\n\n且返回结果无顺序（从578开始，一段有序，即代表是一个索引数据块）。\n\n**全查询TYPE_:**\n\n```SQL\nselect ID_ from T_TYPE;\n```\n\n![屏幕快照 2019-01-13 下午9.35.11](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.35.11.png)\n\n采用的是索引全扫描（因为数据量较小）\n\n![屏幕快照 2019-01-13 下午9.37.57](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.37.57.png)\n\n返回结果有顺序\n\n> ### 执行计划中的访问方式\n>\n> 访问方式即分为全表扫描（TABLE ACCESS FULL）和各种类型索引扫描（TABLE INDEX SCAN）。Oracle会根据表和索引的信息，推算执行的SQL语句从表中取多少数据以及这些数据是怎么分布的。\n>\n> #### TABLE ACCESS FULL（全表扫描）\n>\n> **Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 where限制条件**。全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作来提升吞吐量。**数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上**。\n>\n> #### TABLE ACCESS ROWID（通过ROWID的表存取）\n>\n> **ROWID是由Oracle自动加在表中每行最后的一列伪列**，表中并不会物理存储ROWID的值。程序员可以像使用其它列一样使用它，但不能对该列的值进行增、删、改操作。一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。\n>\n> ROWID可以被视为每条记录的“指针”。**它指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法**。\n>\n> #### TABLE ACCESS BY INDEX SCAN（索引扫描）\n>\n> 在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。因此索引扫描其实分为两步：扫描索引得到对应的ROWID；通过ROWID定位到具体的行读取数据。\n>\n> 索引扫描主要分为以下几种：\n>\n> ##### INDEX UNIQUE SCAN 索引唯一扫描\n>\n> 对应UNIQUE INDEX（唯一性索引）的扫描方式，其**只会应用在返回一条记录的情况下**。该点在之前的实验中已经描述。\n>\n> ##### INDEX RANGE SCAN 索引范围扫描\n>\n> 主要是使用在需要返回多行记录的情况下，常见为以下三种：\n>\n> - 在唯一索引列上使用了范围操作符（如：>   <   <>   >=   <=   between）\n> - 在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）\n> - 对非唯一索引列上进行的任何查询\n>\n> 如果在查询的过程中需要访问的记录数很多，分布很广，这个时候Oracle会根据CBO原则认为使用索引的花销可能比全表扫描大，会使用全表扫描。\n>\n> ##### INDEX FULL SCAN 索引全扫描\n>\n> 进行全索引扫描时，查询出的数据都必须从索引中可以直接得到。其常发生在要查询的列包含唯一索引且需要对表中的所有数据都要查询。**索引全扫描返回的结果有顺序。**\n>\n> ##### INDEX FAST FULL SCAN 索引快速全扫描\n>\n> 索引快速全扫描与索引全扫描类似，只是其在查找索引时会用一种更为快速的方式（简单来说是根据索引块的物理顺序而省去较为繁琐的逻辑顺序），其更适合于数据量大的表进行全查询，**其一个特点就是返回的记录不按照顺序。**\n\n## 四、TimesTen实验过程\n\n### 实验概述\n\n调用自己改写的 AliTT11.sql，查看 SQLPrepare，SQLExecute，FetchLoop 的查询时间；\n\n所有实验中，查询时间分为增加索引前、增加索引后、按照 timesten 建议添加索引三类，针对每一类时间分别有第一次执行时间和之后的平均查询时间两种；\n\n在首次执行查询语句时，timesten首先需要对语句进行预编译，因此首次执行的 SQLPrepare 时间相比之后的时间较长，之后的准备时间就相应缩短了很多。\n\n### 实验1\n\n#### 实验内容\n\n某地区评分6以上的所有电影的名字和上映时间\n\n#### 查询语句\n\n```sql\nSELECT DBIM.T_MOVIE.NAME_, DBIM.T_MOVIE.YEAR_\nFROM DBIM.T_MOVIE, DBIM.T_MOVIE_REGION, DBIM.T_REGION\nWHERE DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID\nAND DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID\nAND DBIM.T_REGION.NAME_ = '美国'\nAND DBIM.T_MOVIE.SCORE_ > 6;\n```\n\n#### 添加的索引\n\n| 表明         | 列名      | 索引类型 | 是否唯一 |\n| ------------ | --------- | -------- | -------- |\n| Movie        | id_       | hash     | unique   |\n| Movie        | score_    | range    |          |\n| Region       | id_       | hash     | unique   |\n| Movie_region | region_id | hash     |          |\n| Movie_region | movie_id  | hash     |          |\n\n#### 查询时间\n\n| 时间类型   | Before1  | Before2  | After1   | After2   | 建议1    | 建议2    | 提高百分比 |\n| ---------- | -------- | -------- | -------- | -------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001845 | 0.000059 | 0.000878 | 0.000054 | 0.000807 | 0.000055 |            |\n| SQLExecute | 0.075809 | 0.061819 | 0.000037 | 0.000025 | 0.000034 | 0.000025 | 99.96%     |\n| FetchLoop  | 0.000004 | 0.000002 | 0.000002 | 0.000001 | 0.000003 | 0.000002 |            |\n\n- 执行计划 (before)\n\n![11b](/images/11b.PNG)\n\n- 执行计划 (after)\n\n![11a](/images/11a.PNG)\n\n#### 原因分析\n\n添加索引后速度大大提升，因为在 region 表中指定了查询条件，添加索引后可以快速从表项中匹配到指定条件的项；在添加之前，timesten 自动帮我们在 movie 表上的 id 字段上添加了临时哈希索引，除此之外，我们额外为几个 where 条件语句的查询字段都增加了索引， 因此提高了效率。\n\n执行计划\n\n- before\n\n  在两层嵌套循环中，顺序执行在region表中的查询、region表与联系表的join，循环结束后生成一个指定地区内的所有电影联系表；内层嵌套完成后，通过散列索引匹配movie表与内存循环生成的联系表，join筛选后生成结果列表\n\n- after\n\n  添加索引之后，过程与添加之前相同，但由于内层循环内使用散列索引而不是顺序执行，因此查询速度比较快，加上没有临时创建索引的时间开销，所以相比之下大大提高了查询效率。\n\n### 实验2\n\n#### 实验内容\n\n所有地区全部电影的平均评分排行榜（前100）\n\n#### 查询语句\n\n```sql\nSELECT * FROM (SELECT DBIM.T_REGION.NAME_, SUM(DBIM.T_MOVIE.SCORE_) s\nFROM DBIM.T_REGION, DBIM.T_MOVIE_REGION, DBIM.T_MOVIE\nWHERE DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID\nAND DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID\nGROUP BY DBIM.T_REGION.NAME_\nORDER BY s DESC) WHERE ROWNUM < 101;\n```\n\n#### 添加的索引\n\n| 表明         | 列名      | 索引类型 | 是否唯一 |\n| ------------ | --------- | -------- | -------- |\n| Movie        | id_       | hash     | unique   |\n| Movie        | score_    | range    |          |\n| Region       | name_     | hash     | unique   |\n| Region       | id_       | hash     | unique   |\n| Movie_region | region_id | hash     |          |\n| Movie_region | movie_id  | hash     |          |\n\n#### 查询时间\n\n| 时间类型   | Before(1) | Before(2) | After(1) | After(2) | 建议(1)  | 建议(2)  | 提高百分比 |\n| ---------- | --------- | --------- | -------- | -------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001253  | 0.000081  | 0.001004 | 0.000054 | 0.000985 | 0.000056 |            |\n| SQLExecute | 0.353111  | 0.335902  | 0.337983 | 0.313458 | 0.313004 | 0.312695 | 7%         |\n| FetchLoop  | 0.000045  | 0.000020  | 0.000018 | 0.000018 | 0.000018 | 0.000017 |            |\n\n- 执行计划 (before)\n\n![12b](/images/12b.PNG)\n\n- 执行计划 (after)\n\n![12a](/images/12a.PNG)\n\n#### 原因分析\n\n添加索引之前，timesten 自动在 movie 和 region 表的 id 字段上都设置了相应的哈希索引，而我们添加索引后与添加之前的执行计划中的索引项没有差别，因此效率几乎没有变化，加上 sum 聚合操作、group by、order by 操作都要进行费时间的全表扫描，所以需要较长时间完成查询。\n\n> ##### 实验1和2分析总结\n>\n> 指定条件的查询：\n>\n> - 建立索引之前\n>\n>   timesten在某个相对较小的表上建立临时索引（散列索引或范围索引），在其他表上进行顺序扫描，执行查询语句中的条件匹配，建立索引的过程会造成时间上的消耗；\n>\n> - 建立索引之后\n>\n>   自己建立的索引覆盖timesten优化建立的索引，由于索引提前建立，因此没有建立索引带来的额外时间开销，而且在此类查询中我们在所有查询涉及字段上都建立了索引（tt自身优化通常只在一个表上建立索引），所以与建立索引之前相比有极大的性能提升。\n>\n> 聚合查询：\n>\n> - 执行计划Before：\n>\n>   先顺序扫描关系表act的记录字段id，利用临时HASH索引 actor.id_，将act表中对应记录与act的记录通过字段相连；对(这些/该)拼接记录逐条利用临时HASH索引 movie.id ,接上movie表中符合条件的记录字段。\n>\n> - 执行计划After：\n>\n>   先顺序扫描关系表movie的记录字段id ，利用HASH索引 act.id_，将act表中对应记录与act的记录通过字段相连；针对第一次hash检索出的 act.id，再对(这些/该)拼接记录逐条利用临时HASH索引 actor.id ,接上actor表中符合条件的记录字段。\n>\n> - 主要原因在于：第一次顺序扫描的关系表act，外码引用actor表的主码(1:1)，movie表(1:1)，hash索引查询唯一记录快；第二次顺序扫描的表为movie表，将对应多条act表里的记录（1:many），对应多个演员(1:many)。\n\n### 实验3：AWT\n\n#### 创建 AWT 直写缓存组\n\n- 缓存表\n  - t_moive\n  - t_comment_1\n- 选择理由\n  - 动态缓存组适用于不从 oracle 中预加载数据的场景\n  - Movie 表和评论表体量较大，不需要从 oracle 中提前加载\n\n#### 测试 AWT 修改数据\n\n- 修改电影评论表\n\n- 修改语句\n\n  ```mysql\n  UPDATE DBIM.T_COMMENT_1\n  SET SUMMARY_='A'\n  WHERE DBIM.T_COMMENT_1.SCORE_>8\n  AND DBIM.T_COMMENT_1.MOVIE_ID = 1;\n  ```\n\n- 踩坑\n\n  - update语句指定修改的表名后，set字段不需要再次声明表名（否则报错）\n  - 修改数据前要开启 replication agent\n  - 执行update语句后要提交事务\n\n### 实验4：查看不同数据类型对查询效率的影响\n\n#### 表字节大小\n\n| 表名    | 行数    | 字节大小                | 有数据类型映射的字节大小 | 节约百分比 |\n| ------- | ------- | ----------------------- | ------------------------ | ---------- |\n| Movie   | 292352  | 47301232（nomapping）   | 26293000（optimal）      | 45%        |\n| Comment | 9805336 | 2528884600（nomapping） | 404967952（optimal）     | 84%        |\n\n#### 压缩设置\n\n![image-20190114062154430](/images/image-20190114062154430.png)\n\n#### 数据类型映射结果\n\n| 表     | 字段  | noMapping         | standardMapping   | aggressive       |\n| ------ | ----- | ----------------- | ----------------- | ---------------- |\n| Region | id_   | NUMBER(11,0)      | TT_BIGINT         | TT_SMALINT       |\n| Region | name_ | VARCHAR(255 BYTE) | VARCHAR(255 BYTE) | VARCHAR(80 BYTE) |\n\n#### 结果分析\n\n- 对相同的表来说，从 oracle 导入 timesten 中如果不进行压缩（nomapping），与进行最优化数据类型映射+aggressive mapping + optimal compression 相比，大约浪费了45%的空间；\n- 对于不同数量级的表来说，千万数量级的 comment 表不进行压缩时浪费84%所有的空间，比十万数量级的 movie 表浪费的空间多了接近一倍。\n\n### 实验5：根据优化建议建立索引\n\n#### SQL语句\n\n```sql\nCommand> call ttIndexAdviceCaptureOutput(0);\n< 6, create index T_MOVIE_i1 on DBIM.T_MOVIE(ID_); >\n< 7, create index T_COMMENT_1_i2 on DBIM.T_COMMENT_1(MOVIE_ID,SCORE_); >\n2 rows found.\n```\n\n#### 实验对象\n\n- 实验3.2语句\n\n#### 实验结果\n\n- Before：自己建立索引后的查询时间\n- After：根据 timesten 查询优化建议建立索引后的查询时间\n\n| 时间类型   | Before(1) | Before(2) | After(1) | After(2) | 提高百分比 |\n| ---------- | --------- | --------- | -------- | -------- | ---------- |\n| SQLPrepare | 0.001527  | 0.000049  | 0.000822 | 0.000049 |            |\n| SQLExecute | 4.139655  | 3.556375  | 3.301318 | 3.302092 | 7.18%      |\n| FetchLoop  | 0.000047  | 0.000027  | 0.000018 | 0.000017 |            |\n","slug":"数据库与内存数据库实验报告","published":1,"updated":"2021-05-16T11:00:35.325Z","_id":"ckfukja9u0013szxonm4xi6cu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、实验前准备\"><a href=\"#一、实验前准备\" class=\"headerlink\" title=\"一、实验前准备\"></a>一、实验前准备</h2><h3 id=\"机器配置\"><a href=\"#机器配置\" class=\"headerlink\" title=\"机器配置\"></a>机器配置</h3><p><img src=\"/images/image-20190114060005845.png\" alt=\"image-20190114060005845\"></p>\n<a id=\"more\"></a>\n<h3 id=\"时间计算标准\"><a href=\"#时间计算标准\" class=\"headerlink\" title=\"时间计算标准\"></a>时间计算标准</h3><h4 id=\"SQL执行过程\"><a href=\"#SQL执行过程\" class=\"headerlink\" title=\"SQL执行过程\"></a>SQL执行过程</h4><p>首先，本实验的目的是优化数据库，减少数据库语句执行的时间，在此之前，我们要明白一点<code>数据库执行时间</code>这句话包含了哪些东西。我们从数据库执行一条SQL语句的过程来看，对于MySQL、Oracle、TimesTen这些具有内部优化的数据库来说，一般的执行步骤是：</p>\n<p><img src=\"/images/image-20190113214926175.png\" alt=\"image-20190113214926175\"></p>\n<p>而我们的关注点应放在语句执行这一步骤上。</p>\n<h4 id=\"语句执行步骤进一步深入\"><a href=\"#语句执行步骤进一步深入\" class=\"headerlink\" title=\"语句执行步骤进一步深入\"></a>语句执行步骤进一步深入</h4><h5 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h5><p>MySQL的执行时间为以下项目的加和：</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Desription</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. Checking permissions</td>\n<td>检查用户的权限</td>\n</tr>\n<tr>\n<td>2. Opening tables</td>\n<td>打开表</td>\n</tr>\n<tr>\n<td>3. Init</td>\n<td>初始化过程</td>\n</tr>\n<tr>\n<td>4. System lock</td>\n<td>获取锁</td>\n</tr>\n<tr>\n<td>5. Optimizing</td>\n<td>优化SQL语句</td>\n</tr>\n<tr>\n<td>6. Statistics</td>\n<td>分析SQL语句</td>\n</tr>\n<tr>\n<td>7. Preparing</td>\n<td>准备执行条件</td>\n</tr>\n<tr>\n<td>8. Executing</td>\n<td>执行SQL语句</td>\n</tr>\n<tr>\n<td>9. Sending data</td>\n<td>进行磁盘的IO以及数据的发送返回</td>\n</tr>\n<tr>\n<td>10. End</td>\n<td>执行结束</td>\n</tr>\n<tr>\n<td>11. Closing tables</td>\n<td>关闭表</td>\n</tr>\n<tr>\n<td>12. Freeing items</td>\n<td>释放资源</td>\n</tr>\n<tr>\n<td>13. Cleaning up</td>\n<td>清理缓存以及临时空间</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Oracle\"><a href=\"#Oracle\" class=\"headerlink\" title=\"Oracle\"></a>Oracle</h5><p>一条SQL语句在进入<code>语句执行</code>这一步骤之后，若不在高速缓存中，数据库会从数据文件中把<code>所在位置</code>移动到<code>高速缓存</code>中而后返回给客户端。这也就意味着，同一条语句在以后的执行中都只从高速缓存取数据（前提是高速缓存<code>未被清除</code>）。这样想的话，我们要做的优化应该是一条SQL语句在第一次进入数据库时数据库作出的应答。</p>\n<p>那么，我们通过数据库工具来查看执行的SQL语句的时间应该是不准的：<strong>因为我们不知道这条语句是不是第一次执行，或者说我们不知道高速缓存中有没有我们需要的数据</strong>。这里我们选择使用Oracle的执行计划来看SQL语句的准确的执行过程以及其<code>开销</code>。如下图：</p>\n<p><img src=\"/images/image-20190113211220925.png\" alt=\"image-20190113211220925\"></p>\n<p>我们的关注点在上图中的<code>COST</code>，cost是Oracle里判定效率的唯一标准，Oracle的优化器会计算当前SQL语句的最低cost方案，而后为其选择执行计划。Oracle中定义了语句的一次执行开销<code>cost = CPU cost + IO cost</code>，对于cost，我们可以理解为一次过程所需要访问的Block数量，那么执行时间就是<code>t = Block数量 * Block处理时间</code>。</p>\n<p>后续实验过程中的Oracle部分我们都是通过执行计划及cost来做对比。为此我们写了一个procedure来记录一条语句执行计划中记录的cost：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 计算query的cost</span><br><span class=\"line\">create or replace procedure calc_cost(query_ varchar2, func_ number, desc_ varchar2) is</span><br><span class=\"line\">  cpu_cost number := 0;</span><br><span class=\"line\">  io_cost number := 0;</span><br><span class=\"line\">  cost_ number := 0;</span><br><span class=\"line\">  -- 一条SQL语句的唯一标识</span><br><span class=\"line\">  hash_v number := 0;</span><br><span class=\"line\">  -- 获取上述标识</span><br><span class=\"line\">  select_v_sql varchar2(255) := &apos;select hash_value into :x from v$sql a where a.SQL_TEXT like &apos;&apos;:y&apos;&apos;&apos;;</span><br><span class=\"line\">  -- 获取cost</span><br><span class=\"line\">  select_v_sql_plan varchar2(255) := &apos;select max(cpu_cost) , max(io_cost) into :x :y from V$SQL_PLAN a where hash_value=:z&apos;;</span><br><span class=\"line\">  -- 结果保存</span><br><span class=\"line\">  insert_result varchar2(255) := &apos;insert into t_cost_record values(:x,:y,:z,:a,:b,:c)&apos;;</span><br><span class=\"line\">begin</span><br><span class=\"line\">  execute immediate select_v_sql using hash_v, query_;</span><br><span class=\"line\">  execute immediate select_v_sql_plan using cpu_cost, io_cost, cost_;</span><br><span class=\"line\">  execute immediate insert_result using id_seq.nextval, func_, cpu_cost, io_cost, cost_, desc_;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TimesTen\"><a href=\"#TimesTen\" class=\"headerlink\" title=\"TimesTen\"></a>TimesTen</h5><p>对于TimesTen来说，不如Oracle的优化器来的智能，它完全靠速度制胜。Oracle中我们讨论了执行时间<code>t = Block数量 * Block处理时间</code>，TimesTen就是在Block处理时间上有很大的优势。遗憾的是TimesTen中没有作为本身的高速缓存这一说，这也就意味着一条SQL语句进入TimesTen时都要经过<code>SQL Prepare -&gt; SQL Execution -&gt; SQL Fetch</code>这一完整的过程，如下：</p>\n<p><img src=\"/images/image-20190114052126486.png\" alt=\"image-20190114052126486\"></p>\n<h2 id=\"二、MySQL实验过程\"><a href=\"#二、MySQL实验过程\" class=\"headerlink\" title=\"二、MySQL实验过程\"></a>二、MySQL实验过程</h2><p>功能：查询电影评论平均分排行前一百的电影</p>\n<h3 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select  m.name_, sum(c1.score) as movie_avg_comment_score</span><br><span class=\"line\">from movie m  , comment_1 c1</span><br><span class=\"line\">where m.id_ = c1.movie_id</span><br><span class=\"line\">group by m.name_</span><br><span class=\"line\">order by movie_avg_comment_score desc</span><br><span class=\"line\">limit 100;</span><br></pre></td></tr></table></figure>\n<h3 id=\"仅有主键索引\"><a href=\"#仅有主键索引\" class=\"headerlink\" title=\"仅有主键索引\"></a>仅有主键索引</h3><p>执行之后得到如下的时间消耗：</p>\n<p><img src=\"/images/time_3.2_4min.png\" alt=\"time_3.2_4min\"></p>\n<p>这个时间相比其他数据库慢得多（oracle 约4s)，不符合预期的耗时，且在执行时mysqld的cpu占用率非常高。于是根据以下步骤查看sql执行慢的原因。</p>\n<h3 id=\"MySQL进程表\"><a href=\"#MySQL进程表\" class=\"headerlink\" title=\"MySQL进程表\"></a>MySQL进程表</h3><p>使用<code>show processlist</code>命令查看正在执行的sql语句列表：</p>\n<p><img src=\"/images/process_list.png\" alt=\"process_list\"></p>\n<p>可以看到当前执行的语句就是我们的目标语句，并且没有其他语句在与当前查询语句竞争资源，所以应该把语句执行过慢点原因定位到查询语句本身。</p>\n<h3 id=\"解释执行计划\"><a href=\"#解释执行计划\" class=\"headerlink\" title=\"解释执行计划\"></a>解释执行计划</h3><p>通过查看process list得知对应语句有问题之后，使用<code>describe</code>命令查看当前SQL语句的执行计划，MySQL的执行计划与其他相关参数：</p>\n<p><img src=\"/images/explain_3.2.png\" alt=\"explain_3.2\"></p>\n<p>可以看到在执行计划中，movie表有可选的主码索引，但是在这个场景中mysql并没有选择使用主码索引，没有使用索引是导致时间过慢点一个原因，于是可以考虑在电影名字字段上建立索引。</p>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><p>为了进一步查看SQL语句具体的系统能耗分布，我们选择使用<code>profiling</code>来分析我们SQL语句的执行过程，在没有创建其他索引的情况下我们得到如下的时间消耗分析：</p>\n<p><img src=\"/images/detail_3.2.png\" alt=\"detail_3.2\"></p>\n<p>我们可以看到其中能耗占比最高的是 <code>Sending data</code>项，查看官方文档相关解释：</p>\n<blockquote>\n<p>The thread is reading and processing rows for a <code>SELECT</code> statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.</p>\n<p>该线程正在读取和处理SELECT语句的行，并将数据发送到客户端。 由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态</p>\n</blockquote>\n<p>所以这个与我们的磁盘IO的速度以及网络的传输速度有关，磁盘的IO除了受到硬件本身的限制之外还会与数据库的索引有关，更换性能更好的磁盘或者建立适当的索引以减少磁盘IO数量都可以提高查询语句的执行速度。</p>\n<h3 id=\"建立索引\"><a href=\"#建立索引\" class=\"headerlink\" title=\"建立索引\"></a>建立索引</h3><p>根据以上分析过程得到的结论，我们在电影表的名字字段上建立合适的索引，我们在mysql中选择了B-Tree索引。</p>\n<p>建立索引之后再查看相同SQL语句的执行计划：</p>\n<p><img src=\"/images/explain_3.2_index.png\" alt=\"explain_3.2_index\"></p>\n<p><code>key</code>字段上的值从原来的<code>null</code> 变成了我们刚刚创建的索引。</p>\n<p>执行该SQL语句，并在结束后使用<code>Profiling</code>查看优化后的执行时间：</p>\n<p>sending data: 从磁盘读取数据，将数据返回，表示磁盘IO</p>\n<p>create index：使用临时表来处理select语句</p>\n<p><img src=\"/images/detail_index_3.2.png\" alt=\"detail_index_3.2\"></p>\n<p>可以看到<code>Sending data</code>的值明显小于优化前，总的执行时间也变为优化前的1/5，所以增加索引能够在很大程度上加快查询的速度。</p>\n<h3 id=\"实验结论\"><a href=\"#实验结论\" class=\"headerlink\" title=\"实验结论\"></a>实验结论</h3><p>综合其他实验，在大数据的处理上MySQL数据库的性能远不如ORACLE及TIMESTEN数据库，有数十倍的耗时差距，而且MySQL作为一个轻量级的数据库，支持的索引类型也少于其他两个数据库，在SQL语句的优化方面也不如ORACLE数据库那般强大。所以在当前的实验环境下我们更倾向于使用ORACLE数据库与TIMESTEN数据库进行对比。</p>\n<h2 id=\"三、Oracle实验过程\"><a href=\"#三、Oracle实验过程\" class=\"headerlink\" title=\"三、Oracle实验过程\"></a>三、Oracle实验过程</h2><h3 id=\"实验1：SQL各子句条件顺序对查询效率的影响\"><a href=\"#实验1：SQL各子句条件顺序对查询效率的影响\" class=\"headerlink\" title=\"实验1：SQL各子句条件顺序对查询效率的影响\"></a>实验1：SQL各子句条件顺序对查询效率的影响</h3><h4 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_ <span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID <span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span> <span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验方式\"><a href=\"#实验方式\" class=\"headerlink\" title=\"实验方式\"></a>实验方式</h4><p>通过对MySQL、Oracle、TimesTen中SQL语句中select、from、where子句的排序顺序进行调换，观察执行计划的改变</p>\n<h4 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ol>\n<li>SELECT子句中，结果集的排序方式不会影响执行计划</li>\n<li>FROM子句中，各个表的排序方式不会影响执行计划</li>\n<li>WHERE子句中，各个条件的排序方式不会影响执行计划，优化器会首先将筛选条件应用于表进行过滤，最后逐次执行表的连接。</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>自Oracle6以来，一直采用RBO（Rule-Based Optimization 基于规则的优化器），其基于一套严格死板的使用规则。由于其对于规则的崇尚性，SQL语句的写法则尤为重要。而自Oracle8以来，Oracle引入了一种新的优化方式，即CBO（Cost-Based Optimization 基于代价的优化器），从Oracle 10g开始RBO被完全舍弃。使用CBO优化器时，对SQL语句的要求变得没有那么苛刻，优化器会选择开销比较小的方式执行，而不由用户所写的表的顺序、条件的顺序决定。MySQL与TimesTen的优化器也是如此，有其自己的选择。</p>\n<blockquote>\n<h5 id=\"连接方式和连接顺序\"><a href=\"#连接方式和连接顺序\" class=\"headerlink\" title=\"连接方式和连接顺序\"></a>连接方式和连接顺序</h5><p><strong>连接顺序</strong>：连接顺序表明以哪张表为驱动表来连接其他表的先后顺序。即以某张表为基点，根据其中的信息再去访问其他的表。</p>\n<p><strong>连接方式</strong>：简单来讲，就是两个表获得满足条件的数据时的连接过程。主要有三种表连接方式，嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）。</p>\n<h6 id=\"排序-合并连接\"><a href=\"#排序-合并连接\" class=\"headerlink\" title=\"排序-合并连接\"></a>排序-合并连接</h6><p>假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)</p>\n<p>内部连接过程：</p>\n<p>a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序</p>\n<p>b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序</p>\n<p>c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）</p>\n<p>延伸：</p>\n<p>如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。</p>\n<p>故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。<strong>不过遗憾的是</strong>，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。</p>\n<p>排序-合并连接的表无驱动顺序，谁在前面都可以；</p>\n<p>排序-合并连接<strong>适用</strong>的连接条件有： <strong>&lt;   &lt;=   =   &gt;   &gt;= ，不适用</strong>的连接条件有： <strong>&lt;&gt;    like</strong></p>\n<h6 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h6><p>内部连接过程：</p>\n<p>a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p>\n<p>b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p>\n<p>c) ……</p>\n<p>若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。</p>\n<p>因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。</p>\n<p>嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：<strong>可以先返回已经连接的行</strong>，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。</p>\n<p>应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。</p>\n<h6 id=\"哈希连接\"><a href=\"#哈希连接\" class=\"headerlink\" title=\"哈希连接\"></a>哈希连接</h6><p><strong>哈希连接只适用于等值连接（即连接条件为  =  ）</strong></p>\n<p>HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；</p>\n<p>内部连接过程简述：</p>\n<p>a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）</p>\n<p>b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据</p>\n</blockquote>\n<h3 id=\"实验2：B树索引与位图索引的比较\"><a href=\"#实验2：B树索引与位图索引的比较\" class=\"headerlink\" title=\"实验2：B树索引与位图索引的比较\"></a>实验2：B树索引与位图索引的比较</h3><h4 id=\"sql语句\"><a href=\"#sql语句\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 小基数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 大基数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_ACTOR,T_ACT,T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_ACTOR.NAME_=<span class=\"string\">'Tom Byron'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_ACTOR.ID_=T_ACT.ACTOR_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_ACT.MOVIE_ID;</span><br></pre></td></tr></table></figure>\n<h4 id=\"索引语句\"><a href=\"#索引语句\" class=\"headerlink\" title=\"索引语句\"></a>索引语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- B树</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_MOVIE_SCORE <span class=\"keyword\">ON</span> T_MOVIE(SCORE_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_MOVIE_NAME <span class=\"keyword\">ON</span> T_MOVIE(NAME_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_ACTOR_NAME <span class=\"keyword\">ON</span> T_ACTOR(NAME_);</span><br><span class=\"line\"><span class=\"comment\">-- BitMap</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_MOVIE_NAME <span class=\"keyword\">ON</span> T_MOVIE(NAME_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_MOVIE_SCORE <span class=\"keyword\">ON</span> T_MOVIE(SCORE_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_ACTOR_NAME <span class=\"keyword\">ON</span> T_ACTOR(NAME_);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗\"><a href=\"#查询消耗\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>B树索引（小基数）</p>\n<p><img src=\"/images/1-B%E6%A0%91%E7%B4%A2%E5%BC%95.png\" alt=\"B树索引\"></p>\n<p>位图索引（小基数）</p>\n<p><img src=\"/images/1-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png\" alt=\"位图索引\"></p>\n<p>不加索引（大基数）</p>\n<p><img src=\"/images/image-20190113230831573.png\" alt=\"image-20190113230831573\"></p>\n<p>B树索引（大基数）</p>\n<p><img src=\"/images/image-20190113230717837.png\" alt=\"image-20190113230717837\"></p>\n<p>位图索引（大基数）</p>\n<p><img src=\"/images/image-20190113230627090.png\" alt=\"image-20190113230627090\"></p>\n<h4 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>即使在字段基数较大的情况下，位图索引依然有比B树索引更好的表现。但是有个问题，创建位图索引时所需的时间更长。此外，由于表中该字段的更改都会导致对位图的修改，所以位图索引不适用于并发的情况。</p>\n<h3 id=\"实验3：Oracle优化器对索引的选择\"><a href=\"#实验3：Oracle优化器对索引的选择\" class=\"headerlink\" title=\"实验3：Oracle优化器对索引的选择\"></a>实验3：Oracle优化器对索引的选择</h3><blockquote>\n<h4 id=\"关于索引\"><a href=\"#关于索引\" class=\"headerlink\" title=\"关于索引\"></a>关于索引</h4><h5 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h5><ul>\n<li>B树索引（默认的索引）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>位图索引：以位图的形式存储每个值对应的的一组rowid</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE BITMAP INDEX IXBM_REGION_NAME ON T_REGION(NAME_);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>基于函数的索引：利于对某个字段查询时需要同时使用函数或计算的情景</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE INDEX upper_ix ON employees (UPPER(last_name)); </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>分区索引：本地分区索引的分区完全依赖于其索引所在表，而全局分区索引的分区机制和表分区可能一样也可能不一样</p>\n<ul>\n<li>range范围分区</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;   CREATE INDEX cost_ix ON sales (amount_sold)</span><br><span class=\"line\">&gt;    GLOBAL PARTITION BY RANGE (amount_sold)</span><br><span class=\"line\">&gt;       (PARTITION p1 VALUES LESS THAN (1000),</span><br><span class=\"line\">&gt;        PARTITION p2 VALUES LESS THAN (2500),</span><br><span class=\"line\">&gt;        PARTITION p3 VALUES LESS THAN (MAXVALUE));</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>hash哈希分区</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;   CREATE INDEX cust_last_name_ix ON customers (cust_last_name)</span><br><span class=\"line\">&gt;   GLOBAL PARTITION BY HASH (cust_last_name)</span><br><span class=\"line\">&gt;   PARTITIONS 4;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>list列表分区：一个分区对应指定列的特定的值，以列举的方式进行分区</li>\n<li>组合分区（range-hash，range-list）</li>\n</ul>\n<h5 id=\"什么时候用索引\"><a href=\"#什么时候用索引\" class=\"headerlink\" title=\"什么时候用索引\"></a>什么时候用索引</h5><p>对于Oracle的CBO来说，只有在使用索引能提高效率（估算的效率）时才会使用索引。对于程序员自己进行数据库管理的时候，一般有：</p>\n<p><strong>需要使用索引来优化查询的情况：</strong></p>\n<ul>\n<li>一个属性的值分布非常广，变化的范围跨度很大。</li>\n<li>一般来说，常常需要被用在SQL语句的where中的限制条件的属性最好为其建立索引。</li>\n<li>表经常被访问且需要访问的数据量仅占一部分。</li>\n</ul>\n<p><strong>不适合用索引的情况：</strong></p>\n<ul>\n<li>表很小</li>\n<li>表经常被更新</li>\n<li>属性不经常作为where中的限制条件的属性存在</li>\n<li>查询得到的数据占总量的很大部分</li>\n</ul>\n<p>对于数据经常更新的情况，DBA要定时进行索引的重构（rebuild）以维持索引的可用性。</p>\n<h5 id=\"影响优化器决策的因素\"><a href=\"#影响优化器决策的因素\" class=\"headerlink\" title=\"影响优化器决策的因素\"></a>影响优化器决策的因素</h5><ul>\n<li>进行全表扫描需要读取的数据块数量；</li>\n<li>进行索引查询需要读取的数据块数量，这主要是基于对WHERE子句谓词返回的记录数目估计；</li>\n<li>进行全表扫描时多块读的相关开销，以及为满足索引查询进行的单块读的开销；</li>\n<li>内存中对缓存中的索引块和数据块数目的假设。</li>\n</ul>\n<h5 id=\"索引失效的可能原因\"><a href=\"#索引失效的可能原因\" class=\"headerlink\" title=\"索引失效的可能原因\"></a>索引失效的可能原因</h5><p>以下是一些常见的定义了索引当Oracle并未使用的原因：</p>\n<ul>\n<li>不等于情况，即“&lt;&gt;”</li>\n<li>字符串匹配like中百分号在第一位的情况，即“%XXX”</li>\n<li>表没有进行分析更新统计信息</li>\n<li>使用复合索引但单独引用且非复合索引的第一属性</li>\n<li>对索引进行计算，此时需要建立索引函数</li>\n<li>属性为字符串但在where中没有加引号</li>\n<li>使用not in，not exists</li>\n<li>使用了其他索引</li>\n</ul>\n<h4 id=\"强制使用索引\"><a href=\"#强制使用索引\" class=\"headerlink\" title=\"强制使用索引\"></a>强制使用索引</h4><p>如果想要强制使用索引，则可以在查询语句的select单词后加上/*+index (tablename indexname)*/，这样可以规定Oracle选择使用indexname的索引的执行计划。该方法已在前面实验中使用，不再赘述。</p>\n</blockquote>\n<h4 id=\"sql语句-1\"><a href=\"#sql语句-1\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗-1\"><a href=\"#查询消耗-1\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>不用索引（不论是B树索引还是位图索引都不使用）</p>\n<p><img src=\"/images/3-%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95.png\" alt=\"3-不用索引\"></p>\n<p>强制使用B树索引</p>\n<p><img src=\"/images/3-%E5%BC%BA%E5%88%B6B%E6%A0%91.png\" alt=\"3-强制B树\"></p>\n<p>强制使用位图索引</p>\n<p><img src=\"/images/3-%E5%BC%BA%E5%88%B6%E4%BD%8D%E5%9B%BE.png\" alt=\"3-强制位图\"></p>\n<h4 id=\"sql语句-2\"><a href=\"#sql语句-2\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗-2\"><a href=\"#查询消耗-2\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>B树索引（未使用）</p>\n<p><img src=\"/images/3-B%E6%A0%91.png\" alt=\"3-B树\"></p>\n<p>位图索引</p>\n<p><img src=\"/images/3-%E4%BD%8D%E5%9B%BE.png\" alt=\"3-位图\"></p>\n<h4 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>由此可见，即使在有索引的情况下，oracle优化器也可能选择不使用索引。CBO优化器会对每种执行计划计算一个COST，并采用COST最小的执行计划。如果一个表有索引或多种索引，其会选择最好的一种索引方式扫描表，或者甚至不用索引而用全局扫描方式。</p>\n<p>另外对于符合筛选条件的数据，当占全表的比例越小、数据量越小时，使用索引的可能性越大。如在这次实验中，条件为”T_MOVIE.SCORE_ &gt;9”时会使用索引，而”T_MOVIE.SCORE_ &gt;6”时不会。</p>\n<p>此外，由于位图索引导致的COST要小于B树索引，因此在相同的查询中，使用位图索引的可能性比B树索引更大。</p>\n<h3 id=\"实验4：Oracle分区索引\"><a href=\"#实验4：Oracle分区索引\" class=\"headerlink\" title=\"实验4：Oracle分区索引\"></a>实验4：Oracle分区索引</h3><h4 id=\"sql语句-3\"><a href=\"#sql语句-3\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_COMMENT.SUMMARY_,T_COMMENT.SCORE_,T_COMMENT.TIME_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_COMMENT,T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_MOVIE.ID_=T_COMMENT.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_COMMENT.SCORE_&gt;<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.NAME_=<span class=\"string\">'Blindsided'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-1\"><a href=\"#实验结果-1\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ol>\n<li><p>未分区表+无索引</p>\n<p><img src=\"/images/5-1-1.png\" alt=\"5-1-1\"></p>\n</li>\n<li><p>未分区表+B树索引</p>\n<p><img src=\"/images/5-2.png\" alt=\"5-2\"></p>\n</li>\n<li><p>未分区表+位图索引</p>\n<p><img src=\"/images/5-3.png\" alt=\"5-3\"></p>\n</li>\n<li><p>分区表+无索引</p>\n<p><img src=\"/images/5-4-1.png\" alt=\"5-4-1\"></p>\n</li>\n<li><p>分区表+全局不分区B树索引</p>\n<p><img src=\"/images/5-5-1.png\" alt=\"5-5-1\"></p>\n</li>\n<li><p>分区表+本地(哈希分区)B树索引</p>\n<p><img src=\"/images/5-6.png\" alt=\"5-6\"></p>\n</li>\n<li><p>分区表+本地(哈希分区)位图索引</p>\n<p><img src=\"/images/5-7.png\" alt=\"5-7\"></p>\n</li>\n<li><p>分区表+全局哈希分区索引</p>\n<p><img src=\"/images/5-8.png\" alt=\"5-8\"></p>\n</li>\n<li><p>分区表+全局范围分区索引</p>\n<p><img src=\"/images/5-9.png\" alt=\"5-9\"></p>\n</li>\n</ol>\n<h4 id=\"分析-3\"><a href=\"#分析-3\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ol>\n<li><p>在未建索引时，分区表的COST是未分区表的十倍多。原因是分区所依据的键（字段）不是直接的查询条件——我们以评论表的movie_id字段为依据建哈希分区表，但在查询的时候并不直接以movie_id为查询条件。导致连接表的时候，需要访问多个分区，反而造成COST大大增长。</p>\n<p>后来我们重新设计一个以movie_id为查询条件的sql语句，结果显示分区表的COST大约是未分区表的1/4（一共分了4个区），证明在以分区依据的字段为直接查询条件时，分区表能够体现比较好的性能，能够避免对一部分数据的访问。</p>\n</li>\n<li><p>在分区表上建索引比在未分区表上建索引后的开销更小，不论分区表上的索引是全局还是本地，不论是否是分区索引。在我们的实验场景中，尽管movie_id不是直接的查询条件而是join表的条件，但是在添加索引后，依然能够大大减少join表的开销从而提升效率。</p>\n</li>\n<li><p>在我们的实验场景中，全局的分区索引，不论是哈希分区还是范围分区，COST是一样的。</p>\n</li>\n<li><p>本地索引的效率略微比全局索引的效率好。根据查到的资料，本地索引的可维护性好，能够自动维护，不需要人工干预，但因把索引分成多个分区导致每次的索引访问都需要遍历所有索引分区，所以索引访问性能下降。因此比较适合OLAP系统。而全局索引的可维护性差，分区表发生改变时，需要用命令手动更新索引，但索引访问性能比本地分区索引要好。因此比较适合OLTP系统。</p>\n</li>\n</ol>\n<h3 id=\"实验5：Oracle使用复合索引\"><a href=\"#实验5：Oracle使用复合索引\" class=\"headerlink\" title=\"实验5：Oracle使用复合索引\"></a>实验5：Oracle使用复合索引</h3><h4 id=\"SQL语句-1\"><a href=\"#SQL语句-1\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> T_COMMENT_1.SUMMARY_, T_COMMENT_1.SCORE_</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_COMMENT_1, T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_MOVIE.ID_ = T_COMMENT_1.MOVIE_ID <span class=\"keyword\">and</span> T_COMMENT_1.SCORE_ &gt; <span class=\"number\">7</span> <span class=\"keyword\">and</span> T_MOVIE.NAME_ = <span class=\"string\">'The Notebook'</span>;</span><br></pre></td></tr></table></figure>\n<p>第一次查询：T_COMMENT_1上只有主键的唯一索引。</p>\n<p>第二次查询：在MOVIE_ID上建立一个B-tree索引COMMENT_1_MOVIE。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">on</span> T_COMMENT_1(MOVIE_ID);</span><br></pre></td></tr></table></figure>\n<p>第三次查询：使第二次的索引invisible，在SCORE_上建立一个B-tree索引T_COMMENT_SCORE_INDEX。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">invisible</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> T_COMMENT_SCORE_INDEX <span class=\"keyword\">on</span> T_COMMENT_1(SCORE_);</span><br></pre></td></tr></table></figure>\n<p>第四次查询：将第二次和第三次的索引都保持为visible，在MOVIE_ID和SCORE_上建立一个复合索引COMMENT_1_MOVIE_SCORE。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">visible</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE_SCORE <span class=\"keyword\">on</span> T_COMMENT_1(MOVIE_ID, SCORE_);</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-2\"><a href=\"#实验结果-2\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>第一次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.48.45.png\" alt=\"屏幕快照 2019-01-13 下午10.48.45\"></p>\n<p>全表扫描，花销很大</p>\n<p><strong>第二次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.47.49.png\" alt=\"屏幕快照 2019-01-13 下午10.47.49\"></p>\n<p>利用在MOVIE_ID上的索引，在T_COMMENT_1中访问的数据量和花销都大幅度下降。</p>\n<p><strong>第三次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.50.07.png\" alt=\"屏幕快照 2019-01-13 下午10.50.07\"></p>\n<p>如果只有在SCORE_上的索引，根据CBO，Oracle并没有使用这个索引，而是依旧使用全表扫描，可知该索引并没有提升性能。</p>\n<p>易知，如果在这个时候将MOVIE_ID上的索引设为visible，Oracle会使用MOVIE_ID上的索引。</p>\n<p><strong>第四次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.57.10.png\" alt=\"屏幕快照 2019-01-13 下午10.57.10\"></p>\n<p>Oracle使用了复合索引，尽管在当前问题下COST花销与只有MOVIE_ID的索引差不多，但是其访问的记录数（CARDINALITY）显著减小，体现了复合索引给查询带来的性能提升。</p>\n<h3 id=\"实验6：物化视图对SQL查询性能的提升\"><a href=\"#实验6：物化视图对SQL查询性能的提升\" class=\"headerlink\" title=\"实验6：物化视图对SQL查询性能的提升\"></a>实验6：物化视图对SQL查询性能的提升</h3><h4 id=\"SQL语句-2\"><a href=\"#SQL语句-2\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><p><strong>原始查询语句：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_MOVIE.NAME_ MOVIE_NAME, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_DIRECTOR.NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_ ;</span><br></pre></td></tr></table></figure>\n<p>创建一个<strong>普通视图</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> DIRECTOR_MOVIE_FAKE</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure>\n<p>使用普通视图进行查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE_FAKE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<p>创建<strong>物化视图</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">MATERIALIZED</span> <span class=\"keyword\">VIEW</span> DIRECTOR_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">BUILD</span> <span class=\"keyword\">IMMEDIATE</span></span><br><span class=\"line\"><span class=\"keyword\">REFRESH</span> <span class=\"keyword\">FORCE</span></span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">DEMAND</span></span><br><span class=\"line\"><span class=\"keyword\">ENABLE</span> <span class=\"keyword\">QUERY</span> REWRITE</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure>\n<p>设置<strong>创建时生成数据</strong>，<strong>按需要刷新</strong>，<strong>刷新方式为FORCE</strong>。</p>\n<p>根据视图进行如上查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<p>由于物化视图与表类似，可以给其建立索引，以下给导演名<strong>建立索引</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> DIRECTOR_MOVIE_INAME_INDEX <span class=\"keyword\">ON</span> DIRECTOR_MOVIE (NAME_);</span><br></pre></td></tr></table></figure>\n<p><strong>再次使用物化视图查询</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-3\"><a href=\"#实验结果-3\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>使用原始查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png\" alt=\"屏幕快照 2019-01-14 上午12.27.37\"></p>\n<p>具有极大的花销。</p>\n<p><strong>创建视图后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png\" alt=\"屏幕快照 2019-01-14 上午12.30.46\"></p>\n<p>其执行计划与<strong>原始查询</strong>一致。</p>\n<p><strong>创建物化视图后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.33.27.png\" alt=\"屏幕快照 2019-01-14 上午12.33.27\"></p>\n<p>其<strong>直接在物化视图中进行查询</strong>，执行计划即为简单，花销大幅度减小。</p>\n<p><strong>给物化视图创建索引后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.35.22.png\" alt=\"屏幕快照 2019-01-14 上午12.35.22\"></p>\n<p>建立索引后通过范围索引扫描该物化视图进行查询，其COST数字小得令人惊奇。</p>\n<h4 id=\"分析-4\"><a href=\"#分析-4\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>1.建立普通视图并不能提升性能。因为普通是虚拟的，对视图的操作实际都转变为了对各表的SQL操作，其与原始查询完全一致。</p>\n<p>2.物化视图是一种物理表，对于物化视图的查询是直接的，跟表一样。因此建立物化视图可以大幅度减小花销，但是同时，物化视图也会产生大量的维护成本。因此程序员应该根据实际情况建立物化视图以优化查询。</p>\n<p>3.物化视图同样可以增添索引，增加索引后Oracle对物化视图可以通过索引进行扫描，进一步提高效率。</p>\n<blockquote>\n<h5 id=\"物化视图与普通视图\"><a href=\"#物化视图与普通视图\" class=\"headerlink\" title=\"物化视图与普通视图\"></a>物化视图与普通视图</h5><p>视图只是一种虚拟表。实际上，<strong>对视图的查询真正转换成了相应的SQL语句再对各表进行连接查询，因此其性能提升有限，只是方便了使用</strong>。</p>\n<p>而物化视图是实质化的视图，是<strong>物理表</strong>，可以像表一样进行查询，建立索引，占用真正的存储空间，需要被刷新。</p>\n<h5 id=\"刷新模式\"><a href=\"#刷新模式\" class=\"headerlink\" title=\"刷新模式\"></a>刷新模式</h5><p><strong>on demand：</strong>顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性;</p>\n<p><strong>on commit</strong>：提交触发，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢。</p>\n<p>创建物化视图时未作指定，则Oracle按 on demand 模式来创建。</p>\n<h5 id=\"刷新方法\"><a href=\"#刷新方法\" class=\"headerlink\" title=\"刷新方法\"></a>刷新方法</h5><p><strong>完全刷新（COMPLETE）</strong>： 会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。 </p>\n<p><strong>快速刷新（FAST）</strong>： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。</p>\n<p><strong>FORCE方式</strong>： 这是默认的数据刷新方式。Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。</p>\n</blockquote>\n<h3 id=\"实验7：Oracle-In-Memory性能分析\"><a href=\"#实验7：Oracle-In-Memory性能分析\" class=\"headerlink\" title=\"实验7：Oracle In Memory性能分析\"></a>实验7：Oracle In Memory性能分析</h3><h4 id=\"Sql语句\"><a href=\"#Sql语句\" class=\"headerlink\" title=\"Sql语句\"></a>Sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, <span class=\"keyword\">SUM</span>(T_COMMENT_2.SCORE_) s <span class=\"keyword\">FROM</span> T_MOVIE,T_COMMENT_2 <span class=\"keyword\">WHERE</span> T_MOVIE.ID_=T_COMMENT_2.MOVIE_ID <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> T_MOVIE.NAME_ <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> s <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置In-Memory\"><a href=\"#设置In-Memory\" class=\"headerlink\" title=\"设置In Memory\"></a>设置In Memory</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> T_MOVIE.NAME_ <span class=\"keyword\">IN</span> <span class=\"keyword\">MEMORY</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-4\"><a href=\"#实验结果-4\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>原始查询</strong>：</p>\n<p><img src=\"/images/no-inmemory.png\" alt=\"no-inmemory\"></p>\n<p><strong>In Memory查询：</strong></p>\n<p><img src=\"/images/inmemory.png\" alt=\"inmemory\"></p>\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><p>遗憾的是与想象的不同，Oracle和Oracle In Memory在COST上面结果相同，但是事实上在我们同样的实验环境下测试二者时间时，In Memory确实会比Oracle好很多。其实简单思考一下，这是应该的，前面我们说过执行时间<code>t = Block数量 * Block处理时间</code>，不难知道差距还是出在Block处理时间上。</p>\n<h3 id=\"实验8：Oracle执行计划浅析-Oracle表的访问方式\"><a href=\"#实验8：Oracle执行计划浅析-Oracle表的访问方式\" class=\"headerlink\" title=\"实验8：Oracle执行计划浅析(Oracle表的访问方式)\"></a>实验8：Oracle执行计划浅析(Oracle表的访问方式)</h3><p>对T_MOVIE表进行查询，其本身有在其主码(ID_)上的UNIQUE INDEX和LENGTH_上的B-tree INDEX。</p>\n<h4 id=\"根据UNIQUE-INDEX（ID-）返回唯一记录\"><a href=\"#根据UNIQUE-INDEX（ID-）返回唯一记录\" class=\"headerlink\" title=\"根据UNIQUE INDEX（ID_）返回唯一记录\"></a>根据UNIQUE INDEX（ID_）返回唯一记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> ID_ = <span class=\"number\">20050</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.14.59.png\" alt=\"屏幕快照 2019-01-13 下午9.14.59\"></p>\n<p>使用的是索引唯一扫描</p>\n<h4 id=\"根据ID-返回少部分记录\"><a href=\"#根据ID-返回少部分记录\" class=\"headerlink\" title=\"根据ID_返回少部分记录\"></a>根据ID_返回少部分记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> ID_ &lt; <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.25.22.png\" alt=\"屏幕快照 2019-01-13 下午9.25.22\"></p>\n<p>使用的是索引范围扫描</p>\n<h4 id=\"根据LENGTH-返回大量数据\"><a href=\"#根据LENGTH-返回大量数据\" class=\"headerlink\" title=\"根据LENGTH_返回大量数据\"></a>根据LENGTH_返回大量数据</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> LENGTH_ &lt;<span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/image-20190114004746346.png\" alt=\"image-20190114004746346\"></p>\n<h4 id=\"全查询MOVIE-和TYPE-返回其ID\"><a href=\"#全查询MOVIE-和TYPE-返回其ID\" class=\"headerlink\" title=\"全查询MOVIE_和TYPE_返回其ID_\"></a>全查询MOVIE_和TYPE_返回其ID_</h4><p><strong>全查询MOVIE_：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ID_ <span class=\"keyword\">from</span> T_MOVIE;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.32.45.png\" alt=\"屏幕快照 2019-01-13 下午9.32.45\"></p>\n<p>采用的是索引快速扫描（因为数据量较多）</p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.38.39.png\" alt=\"屏幕快照 2019-01-13 下午9.38.39\"></p>\n<p>且返回结果无顺序（从578开始，一段有序，即代表是一个索引数据块）。</p>\n<p><strong>全查询TYPE_:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ID_ <span class=\"keyword\">from</span> T_TYPE;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.35.11.png\" alt=\"屏幕快照 2019-01-13 下午9.35.11\"></p>\n<p>采用的是索引全扫描（因为数据量较小）</p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.37.57.png\" alt=\"屏幕快照 2019-01-13 下午9.37.57\"></p>\n<p>返回结果有顺序</p>\n<blockquote>\n<h3 id=\"执行计划中的访问方式\"><a href=\"#执行计划中的访问方式\" class=\"headerlink\" title=\"执行计划中的访问方式\"></a>执行计划中的访问方式</h3><p>访问方式即分为全表扫描（TABLE ACCESS FULL）和各种类型索引扫描（TABLE INDEX SCAN）。Oracle会根据表和索引的信息，推算执行的SQL语句从表中取多少数据以及这些数据是怎么分布的。</p>\n<h4 id=\"TABLE-ACCESS-FULL（全表扫描）\"><a href=\"#TABLE-ACCESS-FULL（全表扫描）\" class=\"headerlink\" title=\"TABLE ACCESS FULL（全表扫描）\"></a>TABLE ACCESS FULL（全表扫描）</h4><p><strong>Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 where限制条件</strong>。全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作来提升吞吐量。<strong>数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上</strong>。</p>\n<h4 id=\"TABLE-ACCESS-ROWID（通过ROWID的表存取）\"><a href=\"#TABLE-ACCESS-ROWID（通过ROWID的表存取）\" class=\"headerlink\" title=\"TABLE ACCESS ROWID（通过ROWID的表存取）\"></a>TABLE ACCESS ROWID（通过ROWID的表存取）</h4><p><strong>ROWID是由Oracle自动加在表中每行最后的一列伪列</strong>，表中并不会物理存储ROWID的值。程序员可以像使用其它列一样使用它，但不能对该列的值进行增、删、改操作。一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。</p>\n<p>ROWID可以被视为每条记录的“指针”。<strong>它指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法</strong>。</p>\n<h4 id=\"TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）\"><a href=\"#TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）\" class=\"headerlink\" title=\"TABLE ACCESS BY INDEX SCAN（索引扫描）\"></a>TABLE ACCESS BY INDEX SCAN（索引扫描）</h4><p>在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。因此索引扫描其实分为两步：扫描索引得到对应的ROWID；通过ROWID定位到具体的行读取数据。</p>\n<p>索引扫描主要分为以下几种：</p>\n<h5 id=\"INDEX-UNIQUE-SCAN-索引唯一扫描\"><a href=\"#INDEX-UNIQUE-SCAN-索引唯一扫描\" class=\"headerlink\" title=\"INDEX UNIQUE SCAN 索引唯一扫描\"></a>INDEX UNIQUE SCAN 索引唯一扫描</h5><p>对应UNIQUE INDEX（唯一性索引）的扫描方式，其<strong>只会应用在返回一条记录的情况下</strong>。该点在之前的实验中已经描述。</p>\n<h5 id=\"INDEX-RANGE-SCAN-索引范围扫描\"><a href=\"#INDEX-RANGE-SCAN-索引范围扫描\" class=\"headerlink\" title=\"INDEX RANGE SCAN 索引范围扫描\"></a>INDEX RANGE SCAN 索引范围扫描</h5><p>主要是使用在需要返回多行记录的情况下，常见为以下三种：</p>\n<ul>\n<li>在唯一索引列上使用了范围操作符（如：&gt;   &lt;   &lt;&gt;   &gt;=   &lt;=   between）</li>\n<li>在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）</li>\n<li>对非唯一索引列上进行的任何查询</li>\n</ul>\n<p>如果在查询的过程中需要访问的记录数很多，分布很广，这个时候Oracle会根据CBO原则认为使用索引的花销可能比全表扫描大，会使用全表扫描。</p>\n<h5 id=\"INDEX-FULL-SCAN-索引全扫描\"><a href=\"#INDEX-FULL-SCAN-索引全扫描\" class=\"headerlink\" title=\"INDEX FULL SCAN 索引全扫描\"></a>INDEX FULL SCAN 索引全扫描</h5><p>进行全索引扫描时，查询出的数据都必须从索引中可以直接得到。其常发生在要查询的列包含唯一索引且需要对表中的所有数据都要查询。<strong>索引全扫描返回的结果有顺序。</strong></p>\n<h5 id=\"INDEX-FAST-FULL-SCAN-索引快速全扫描\"><a href=\"#INDEX-FAST-FULL-SCAN-索引快速全扫描\" class=\"headerlink\" title=\"INDEX FAST FULL SCAN 索引快速全扫描\"></a>INDEX FAST FULL SCAN 索引快速全扫描</h5><p>索引快速全扫描与索引全扫描类似，只是其在查找索引时会用一种更为快速的方式（简单来说是根据索引块的物理顺序而省去较为繁琐的逻辑顺序），其更适合于数据量大的表进行全查询，<strong>其一个特点就是返回的记录不按照顺序。</strong></p>\n</blockquote>\n<h2 id=\"四、TimesTen实验过程\"><a href=\"#四、TimesTen实验过程\" class=\"headerlink\" title=\"四、TimesTen实验过程\"></a>四、TimesTen实验过程</h2><h3 id=\"实验概述\"><a href=\"#实验概述\" class=\"headerlink\" title=\"实验概述\"></a>实验概述</h3><p>调用自己改写的 AliTT11.sql，查看 SQLPrepare，SQLExecute，FetchLoop 的查询时间；</p>\n<p>所有实验中，查询时间分为增加索引前、增加索引后、按照 timesten 建议添加索引三类，针对每一类时间分别有第一次执行时间和之后的平均查询时间两种；</p>\n<p>在首次执行查询语句时，timesten首先需要对语句进行预编译，因此首次执行的 SQLPrepare 时间相比之后的时间较长，之后的准备时间就相应缩短了很多。</p>\n<h3 id=\"实验1\"><a href=\"#实验1\" class=\"headerlink\" title=\"实验1\"></a>实验1</h3><h4 id=\"实验内容\"><a href=\"#实验内容\" class=\"headerlink\" title=\"实验内容\"></a>实验内容</h4><p>某地区评分6以上的所有电影的名字和上映时间</p>\n<h4 id=\"查询语句-1\"><a href=\"#查询语句-1\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> DBIM.T_MOVIE.NAME_, DBIM.T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> DBIM.T_MOVIE, DBIM.T_MOVIE_REGION, DBIM.T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_REGION.NAME_ = <span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_MOVIE.SCORE_ &gt; <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加的索引\"><a href=\"#添加的索引\" class=\"headerlink\" title=\"添加的索引\"></a>添加的索引</h4><table>\n<thead>\n<tr>\n<th>表明</th>\n<th>列名</th>\n<th>索引类型</th>\n<th>是否唯一</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie</td>\n<td>score_</td>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>region_id</td>\n<td>hash</td>\n<td></td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>movie_id</td>\n<td>hash</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"查询时间\"><a href=\"#查询时间\" class=\"headerlink\" title=\"查询时间\"></a>查询时间</h4><table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before1</th>\n<th>Before2</th>\n<th>After1</th>\n<th>After2</th>\n<th>建议1</th>\n<th>建议2</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001845</td>\n<td>0.000059</td>\n<td>0.000878</td>\n<td>0.000054</td>\n<td>0.000807</td>\n<td>0.000055</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>0.075809</td>\n<td>0.061819</td>\n<td>0.000037</td>\n<td>0.000025</td>\n<td>0.000034</td>\n<td>0.000025</td>\n<td>99.96%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000004</td>\n<td>0.000002</td>\n<td>0.000002</td>\n<td>0.000001</td>\n<td>0.000003</td>\n<td>0.000002</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>执行计划 (before)</li>\n</ul>\n<p><img src=\"/images/11b.PNG\" alt=\"11b\"></p>\n<ul>\n<li>执行计划 (after)</li>\n</ul>\n<p><img src=\"/images/11a.PNG\" alt=\"11a\"></p>\n<h4 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h4><p>添加索引后速度大大提升，因为在 region 表中指定了查询条件，添加索引后可以快速从表项中匹配到指定条件的项；在添加之前，timesten 自动帮我们在 movie 表上的 id 字段上添加了临时哈希索引，除此之外，我们额外为几个 where 条件语句的查询字段都增加了索引， 因此提高了效率。</p>\n<p>执行计划</p>\n<ul>\n<li><p>before</p>\n<p>在两层嵌套循环中，顺序执行在region表中的查询、region表与联系表的join，循环结束后生成一个指定地区内的所有电影联系表；内层嵌套完成后，通过散列索引匹配movie表与内存循环生成的联系表，join筛选后生成结果列表</p>\n</li>\n<li><p>after</p>\n<p>添加索引之后，过程与添加之前相同，但由于内层循环内使用散列索引而不是顺序执行，因此查询速度比较快，加上没有临时创建索引的时间开销，所以相比之下大大提高了查询效率。</p>\n</li>\n</ul>\n<h3 id=\"实验2\"><a href=\"#实验2\" class=\"headerlink\" title=\"实验2\"></a>实验2</h3><h4 id=\"实验内容-1\"><a href=\"#实验内容-1\" class=\"headerlink\" title=\"实验内容\"></a>实验内容</h4><p>所有地区全部电影的平均评分排行榜（前100）</p>\n<h4 id=\"查询语句-2\"><a href=\"#查询语句-2\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> DBIM.T_REGION.NAME_, <span class=\"keyword\">SUM</span>(DBIM.T_MOVIE.SCORE_) s</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> DBIM.T_REGION, DBIM.T_MOVIE_REGION, DBIM.T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> DBIM.T_REGION.NAME_</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> s <span class=\"keyword\">DESC</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">ROWNUM</span> &lt; <span class=\"number\">101</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加的索引-1\"><a href=\"#添加的索引-1\" class=\"headerlink\" title=\"添加的索引\"></a>添加的索引</h4><table>\n<thead>\n<tr>\n<th>表明</th>\n<th>列名</th>\n<th>索引类型</th>\n<th>是否唯一</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie</td>\n<td>score_</td>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>Region</td>\n<td>name_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>region_id</td>\n<td>hash</td>\n<td></td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>movie_id</td>\n<td>hash</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"查询时间-1\"><a href=\"#查询时间-1\" class=\"headerlink\" title=\"查询时间\"></a>查询时间</h4><table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before(1)</th>\n<th>Before(2)</th>\n<th>After(1)</th>\n<th>After(2)</th>\n<th>建议(1)</th>\n<th>建议(2)</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001253</td>\n<td>0.000081</td>\n<td>0.001004</td>\n<td>0.000054</td>\n<td>0.000985</td>\n<td>0.000056</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>0.353111</td>\n<td>0.335902</td>\n<td>0.337983</td>\n<td>0.313458</td>\n<td>0.313004</td>\n<td>0.312695</td>\n<td>7%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000045</td>\n<td>0.000020</td>\n<td>0.000018</td>\n<td>0.000018</td>\n<td>0.000018</td>\n<td>0.000017</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>执行计划 (before)</li>\n</ul>\n<p><img src=\"/images/12b.PNG\" alt=\"12b\"></p>\n<ul>\n<li>执行计划 (after)</li>\n</ul>\n<p><img src=\"/images/12a.PNG\" alt=\"12a\"></p>\n<h4 id=\"原因分析-1\"><a href=\"#原因分析-1\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h4><p>添加索引之前，timesten 自动在 movie 和 region 表的 id 字段上都设置了相应的哈希索引，而我们添加索引后与添加之前的执行计划中的索引项没有差别，因此效率几乎没有变化，加上 sum 聚合操作、group by、order by 操作都要进行费时间的全表扫描，所以需要较长时间完成查询。</p>\n<blockquote>\n<h5 id=\"实验1和2分析总结\"><a href=\"#实验1和2分析总结\" class=\"headerlink\" title=\"实验1和2分析总结\"></a>实验1和2分析总结</h5><p>指定条件的查询：</p>\n<ul>\n<li><p>建立索引之前</p>\n<p>timesten在某个相对较小的表上建立临时索引（散列索引或范围索引），在其他表上进行顺序扫描，执行查询语句中的条件匹配，建立索引的过程会造成时间上的消耗；</p>\n</li>\n<li><p>建立索引之后</p>\n<p>自己建立的索引覆盖timesten优化建立的索引，由于索引提前建立，因此没有建立索引带来的额外时间开销，而且在此类查询中我们在所有查询涉及字段上都建立了索引（tt自身优化通常只在一个表上建立索引），所以与建立索引之前相比有极大的性能提升。</p>\n</li>\n</ul>\n<p>聚合查询：</p>\n<ul>\n<li><p>执行计划Before：</p>\n<p>先顺序扫描关系表act的记录字段id，利用临时HASH索引 actor.id_，将act表中对应记录与act的记录通过字段相连；对(这些/该)拼接记录逐条利用临时HASH索引 movie.id ,接上movie表中符合条件的记录字段。</p>\n</li>\n<li><p>执行计划After：</p>\n<p>先顺序扫描关系表movie的记录字段id ，利用HASH索引 act.id_，将act表中对应记录与act的记录通过字段相连；针对第一次hash检索出的 act.id，再对(这些/该)拼接记录逐条利用临时HASH索引 actor.id ,接上actor表中符合条件的记录字段。</p>\n</li>\n<li><p>主要原因在于：第一次顺序扫描的关系表act，外码引用actor表的主码(1:1)，movie表(1:1)，hash索引查询唯一记录快；第二次顺序扫描的表为movie表，将对应多条act表里的记录（1:many），对应多个演员(1:many)。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"实验3：AWT\"><a href=\"#实验3：AWT\" class=\"headerlink\" title=\"实验3：AWT\"></a>实验3：AWT</h3><h4 id=\"创建-AWT-直写缓存组\"><a href=\"#创建-AWT-直写缓存组\" class=\"headerlink\" title=\"创建 AWT 直写缓存组\"></a>创建 AWT 直写缓存组</h4><ul>\n<li>缓存表<ul>\n<li>t_moive</li>\n<li>t_comment_1</li>\n</ul>\n</li>\n<li>选择理由<ul>\n<li>动态缓存组适用于不从 oracle 中预加载数据的场景</li>\n<li>Movie 表和评论表体量较大，不需要从 oracle 中提前加载</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"测试-AWT-修改数据\"><a href=\"#测试-AWT-修改数据\" class=\"headerlink\" title=\"测试 AWT 修改数据\"></a>测试 AWT 修改数据</h4><ul>\n<li><p>修改电影评论表</p>\n</li>\n<li><p>修改语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE DBIM.T_COMMENT_1</span><br><span class=\"line\">SET SUMMARY_=&apos;A&apos;</span><br><span class=\"line\">WHERE DBIM.T_COMMENT_1.SCORE_&gt;8</span><br><span class=\"line\">AND DBIM.T_COMMENT_1.MOVIE_ID = 1;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>踩坑</p>\n<ul>\n<li>update语句指定修改的表名后，set字段不需要再次声明表名（否则报错）</li>\n<li>修改数据前要开启 replication agent</li>\n<li>执行update语句后要提交事务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实验4：查看不同数据类型对查询效率的影响\"><a href=\"#实验4：查看不同数据类型对查询效率的影响\" class=\"headerlink\" title=\"实验4：查看不同数据类型对查询效率的影响\"></a>实验4：查看不同数据类型对查询效率的影响</h3><h4 id=\"表字节大小\"><a href=\"#表字节大小\" class=\"headerlink\" title=\"表字节大小\"></a>表字节大小</h4><table>\n<thead>\n<tr>\n<th>表名</th>\n<th>行数</th>\n<th>字节大小</th>\n<th>有数据类型映射的字节大小</th>\n<th>节约百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>292352</td>\n<td>47301232（nomapping）</td>\n<td>26293000（optimal）</td>\n<td>45%</td>\n</tr>\n<tr>\n<td>Comment</td>\n<td>9805336</td>\n<td>2528884600（nomapping）</td>\n<td>404967952（optimal）</td>\n<td>84%</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"压缩设置\"><a href=\"#压缩设置\" class=\"headerlink\" title=\"压缩设置\"></a>压缩设置</h4><p><img src=\"/images/image-20190114062154430.png\" alt=\"image-20190114062154430\"></p>\n<h4 id=\"数据类型映射结果\"><a href=\"#数据类型映射结果\" class=\"headerlink\" title=\"数据类型映射结果\"></a>数据类型映射结果</h4><table>\n<thead>\n<tr>\n<th>表</th>\n<th>字段</th>\n<th>noMapping</th>\n<th>standardMapping</th>\n<th>aggressive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>NUMBER(11,0)</td>\n<td>TT_BIGINT</td>\n<td>TT_SMALINT</td>\n</tr>\n<tr>\n<td>Region</td>\n<td>name_</td>\n<td>VARCHAR(255 BYTE)</td>\n<td>VARCHAR(255 BYTE)</td>\n<td>VARCHAR(80 BYTE)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>对相同的表来说，从 oracle 导入 timesten 中如果不进行压缩（nomapping），与进行最优化数据类型映射+aggressive mapping + optimal compression 相比，大约浪费了45%的空间；</li>\n<li>对于不同数量级的表来说，千万数量级的 comment 表不进行压缩时浪费84%所有的空间，比十万数量级的 movie 表浪费的空间多了接近一倍。</li>\n</ul>\n<h3 id=\"实验5：根据优化建议建立索引\"><a href=\"#实验5：根据优化建议建立索引\" class=\"headerlink\" title=\"实验5：根据优化建议建立索引\"></a>实验5：根据优化建议建立索引</h3><h4 id=\"SQL语句-3\"><a href=\"#SQL语句-3\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; call ttIndexAdviceCaptureOutput(0);</span><br><span class=\"line\">&lt; 6, create index T_MOVIE_i1 on DBIM.T_MOVIE(ID_); &gt;</span><br><span class=\"line\">&lt; 7, create index T_COMMENT_1_i2 on DBIM.T_COMMENT_1(MOVIE_ID,SCORE_); &gt;</span><br><span class=\"line\">2 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验对象\"><a href=\"#实验对象\" class=\"headerlink\" title=\"实验对象\"></a>实验对象</h4><ul>\n<li>实验3.2语句</li>\n</ul>\n<h4 id=\"实验结果-5\"><a href=\"#实验结果-5\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ul>\n<li>Before：自己建立索引后的查询时间</li>\n<li>After：根据 timesten 查询优化建议建立索引后的查询时间</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before(1)</th>\n<th>Before(2)</th>\n<th>After(1)</th>\n<th>After(2)</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001527</td>\n<td>0.000049</td>\n<td>0.000822</td>\n<td>0.000049</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>4.139655</td>\n<td>3.556375</td>\n<td>3.301318</td>\n<td>3.302092</td>\n<td>7.18%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000047</td>\n<td>0.000027</td>\n<td>0.000018</td>\n<td>0.000017</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、实验前准备\"><a href=\"#一、实验前准备\" class=\"headerlink\" title=\"一、实验前准备\"></a>一、实验前准备</h2><h3 id=\"机器配置\"><a href=\"#机器配置\" class=\"headerlink\" title=\"机器配置\"></a>机器配置</h3><p><img src=\"/images/image-20190114060005845.png\" alt=\"image-20190114060005845\"></p>","more":"<h3 id=\"时间计算标准\"><a href=\"#时间计算标准\" class=\"headerlink\" title=\"时间计算标准\"></a>时间计算标准</h3><h4 id=\"SQL执行过程\"><a href=\"#SQL执行过程\" class=\"headerlink\" title=\"SQL执行过程\"></a>SQL执行过程</h4><p>首先，本实验的目的是优化数据库，减少数据库语句执行的时间，在此之前，我们要明白一点<code>数据库执行时间</code>这句话包含了哪些东西。我们从数据库执行一条SQL语句的过程来看，对于MySQL、Oracle、TimesTen这些具有内部优化的数据库来说，一般的执行步骤是：</p>\n<p><img src=\"/images/image-20190113214926175.png\" alt=\"image-20190113214926175\"></p>\n<p>而我们的关注点应放在语句执行这一步骤上。</p>\n<h4 id=\"语句执行步骤进一步深入\"><a href=\"#语句执行步骤进一步深入\" class=\"headerlink\" title=\"语句执行步骤进一步深入\"></a>语句执行步骤进一步深入</h4><h5 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h5><p>MySQL的执行时间为以下项目的加和：</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Desription</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. Checking permissions</td>\n<td>检查用户的权限</td>\n</tr>\n<tr>\n<td>2. Opening tables</td>\n<td>打开表</td>\n</tr>\n<tr>\n<td>3. Init</td>\n<td>初始化过程</td>\n</tr>\n<tr>\n<td>4. System lock</td>\n<td>获取锁</td>\n</tr>\n<tr>\n<td>5. Optimizing</td>\n<td>优化SQL语句</td>\n</tr>\n<tr>\n<td>6. Statistics</td>\n<td>分析SQL语句</td>\n</tr>\n<tr>\n<td>7. Preparing</td>\n<td>准备执行条件</td>\n</tr>\n<tr>\n<td>8. Executing</td>\n<td>执行SQL语句</td>\n</tr>\n<tr>\n<td>9. Sending data</td>\n<td>进行磁盘的IO以及数据的发送返回</td>\n</tr>\n<tr>\n<td>10. End</td>\n<td>执行结束</td>\n</tr>\n<tr>\n<td>11. Closing tables</td>\n<td>关闭表</td>\n</tr>\n<tr>\n<td>12. Freeing items</td>\n<td>释放资源</td>\n</tr>\n<tr>\n<td>13. Cleaning up</td>\n<td>清理缓存以及临时空间</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Oracle\"><a href=\"#Oracle\" class=\"headerlink\" title=\"Oracle\"></a>Oracle</h5><p>一条SQL语句在进入<code>语句执行</code>这一步骤之后，若不在高速缓存中，数据库会从数据文件中把<code>所在位置</code>移动到<code>高速缓存</code>中而后返回给客户端。这也就意味着，同一条语句在以后的执行中都只从高速缓存取数据（前提是高速缓存<code>未被清除</code>）。这样想的话，我们要做的优化应该是一条SQL语句在第一次进入数据库时数据库作出的应答。</p>\n<p>那么，我们通过数据库工具来查看执行的SQL语句的时间应该是不准的：<strong>因为我们不知道这条语句是不是第一次执行，或者说我们不知道高速缓存中有没有我们需要的数据</strong>。这里我们选择使用Oracle的执行计划来看SQL语句的准确的执行过程以及其<code>开销</code>。如下图：</p>\n<p><img src=\"/images/image-20190113211220925.png\" alt=\"image-20190113211220925\"></p>\n<p>我们的关注点在上图中的<code>COST</code>，cost是Oracle里判定效率的唯一标准，Oracle的优化器会计算当前SQL语句的最低cost方案，而后为其选择执行计划。Oracle中定义了语句的一次执行开销<code>cost = CPU cost + IO cost</code>，对于cost，我们可以理解为一次过程所需要访问的Block数量，那么执行时间就是<code>t = Block数量 * Block处理时间</code>。</p>\n<p>后续实验过程中的Oracle部分我们都是通过执行计划及cost来做对比。为此我们写了一个procedure来记录一条语句执行计划中记录的cost：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 计算query的cost</span><br><span class=\"line\">create or replace procedure calc_cost(query_ varchar2, func_ number, desc_ varchar2) is</span><br><span class=\"line\">  cpu_cost number := 0;</span><br><span class=\"line\">  io_cost number := 0;</span><br><span class=\"line\">  cost_ number := 0;</span><br><span class=\"line\">  -- 一条SQL语句的唯一标识</span><br><span class=\"line\">  hash_v number := 0;</span><br><span class=\"line\">  -- 获取上述标识</span><br><span class=\"line\">  select_v_sql varchar2(255) := &apos;select hash_value into :x from v$sql a where a.SQL_TEXT like &apos;&apos;:y&apos;&apos;&apos;;</span><br><span class=\"line\">  -- 获取cost</span><br><span class=\"line\">  select_v_sql_plan varchar2(255) := &apos;select max(cpu_cost) , max(io_cost) into :x :y from V$SQL_PLAN a where hash_value=:z&apos;;</span><br><span class=\"line\">  -- 结果保存</span><br><span class=\"line\">  insert_result varchar2(255) := &apos;insert into t_cost_record values(:x,:y,:z,:a,:b,:c)&apos;;</span><br><span class=\"line\">begin</span><br><span class=\"line\">  execute immediate select_v_sql using hash_v, query_;</span><br><span class=\"line\">  execute immediate select_v_sql_plan using cpu_cost, io_cost, cost_;</span><br><span class=\"line\">  execute immediate insert_result using id_seq.nextval, func_, cpu_cost, io_cost, cost_, desc_;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TimesTen\"><a href=\"#TimesTen\" class=\"headerlink\" title=\"TimesTen\"></a>TimesTen</h5><p>对于TimesTen来说，不如Oracle的优化器来的智能，它完全靠速度制胜。Oracle中我们讨论了执行时间<code>t = Block数量 * Block处理时间</code>，TimesTen就是在Block处理时间上有很大的优势。遗憾的是TimesTen中没有作为本身的高速缓存这一说，这也就意味着一条SQL语句进入TimesTen时都要经过<code>SQL Prepare -&gt; SQL Execution -&gt; SQL Fetch</code>这一完整的过程，如下：</p>\n<p><img src=\"/images/image-20190114052126486.png\" alt=\"image-20190114052126486\"></p>\n<h2 id=\"二、MySQL实验过程\"><a href=\"#二、MySQL实验过程\" class=\"headerlink\" title=\"二、MySQL实验过程\"></a>二、MySQL实验过程</h2><p>功能：查询电影评论平均分排行前一百的电影</p>\n<h3 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select  m.name_, sum(c1.score) as movie_avg_comment_score</span><br><span class=\"line\">from movie m  , comment_1 c1</span><br><span class=\"line\">where m.id_ = c1.movie_id</span><br><span class=\"line\">group by m.name_</span><br><span class=\"line\">order by movie_avg_comment_score desc</span><br><span class=\"line\">limit 100;</span><br></pre></td></tr></table></figure>\n<h3 id=\"仅有主键索引\"><a href=\"#仅有主键索引\" class=\"headerlink\" title=\"仅有主键索引\"></a>仅有主键索引</h3><p>执行之后得到如下的时间消耗：</p>\n<p><img src=\"/images/time_3.2_4min.png\" alt=\"time_3.2_4min\"></p>\n<p>这个时间相比其他数据库慢得多（oracle 约4s)，不符合预期的耗时，且在执行时mysqld的cpu占用率非常高。于是根据以下步骤查看sql执行慢的原因。</p>\n<h3 id=\"MySQL进程表\"><a href=\"#MySQL进程表\" class=\"headerlink\" title=\"MySQL进程表\"></a>MySQL进程表</h3><p>使用<code>show processlist</code>命令查看正在执行的sql语句列表：</p>\n<p><img src=\"/images/process_list.png\" alt=\"process_list\"></p>\n<p>可以看到当前执行的语句就是我们的目标语句，并且没有其他语句在与当前查询语句竞争资源，所以应该把语句执行过慢点原因定位到查询语句本身。</p>\n<h3 id=\"解释执行计划\"><a href=\"#解释执行计划\" class=\"headerlink\" title=\"解释执行计划\"></a>解释执行计划</h3><p>通过查看process list得知对应语句有问题之后，使用<code>describe</code>命令查看当前SQL语句的执行计划，MySQL的执行计划与其他相关参数：</p>\n<p><img src=\"/images/explain_3.2.png\" alt=\"explain_3.2\"></p>\n<p>可以看到在执行计划中，movie表有可选的主码索引，但是在这个场景中mysql并没有选择使用主码索引，没有使用索引是导致时间过慢点一个原因，于是可以考虑在电影名字字段上建立索引。</p>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><p>为了进一步查看SQL语句具体的系统能耗分布，我们选择使用<code>profiling</code>来分析我们SQL语句的执行过程，在没有创建其他索引的情况下我们得到如下的时间消耗分析：</p>\n<p><img src=\"/images/detail_3.2.png\" alt=\"detail_3.2\"></p>\n<p>我们可以看到其中能耗占比最高的是 <code>Sending data</code>项，查看官方文档相关解释：</p>\n<blockquote>\n<p>The thread is reading and processing rows for a <code>SELECT</code> statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.</p>\n<p>该线程正在读取和处理SELECT语句的行，并将数据发送到客户端。 由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态</p>\n</blockquote>\n<p>所以这个与我们的磁盘IO的速度以及网络的传输速度有关，磁盘的IO除了受到硬件本身的限制之外还会与数据库的索引有关，更换性能更好的磁盘或者建立适当的索引以减少磁盘IO数量都可以提高查询语句的执行速度。</p>\n<h3 id=\"建立索引\"><a href=\"#建立索引\" class=\"headerlink\" title=\"建立索引\"></a>建立索引</h3><p>根据以上分析过程得到的结论，我们在电影表的名字字段上建立合适的索引，我们在mysql中选择了B-Tree索引。</p>\n<p>建立索引之后再查看相同SQL语句的执行计划：</p>\n<p><img src=\"/images/explain_3.2_index.png\" alt=\"explain_3.2_index\"></p>\n<p><code>key</code>字段上的值从原来的<code>null</code> 变成了我们刚刚创建的索引。</p>\n<p>执行该SQL语句，并在结束后使用<code>Profiling</code>查看优化后的执行时间：</p>\n<p>sending data: 从磁盘读取数据，将数据返回，表示磁盘IO</p>\n<p>create index：使用临时表来处理select语句</p>\n<p><img src=\"/images/detail_index_3.2.png\" alt=\"detail_index_3.2\"></p>\n<p>可以看到<code>Sending data</code>的值明显小于优化前，总的执行时间也变为优化前的1/5，所以增加索引能够在很大程度上加快查询的速度。</p>\n<h3 id=\"实验结论\"><a href=\"#实验结论\" class=\"headerlink\" title=\"实验结论\"></a>实验结论</h3><p>综合其他实验，在大数据的处理上MySQL数据库的性能远不如ORACLE及TIMESTEN数据库，有数十倍的耗时差距，而且MySQL作为一个轻量级的数据库，支持的索引类型也少于其他两个数据库，在SQL语句的优化方面也不如ORACLE数据库那般强大。所以在当前的实验环境下我们更倾向于使用ORACLE数据库与TIMESTEN数据库进行对比。</p>\n<h2 id=\"三、Oracle实验过程\"><a href=\"#三、Oracle实验过程\" class=\"headerlink\" title=\"三、Oracle实验过程\"></a>三、Oracle实验过程</h2><h3 id=\"实验1：SQL各子句条件顺序对查询效率的影响\"><a href=\"#实验1：SQL各子句条件顺序对查询效率的影响\" class=\"headerlink\" title=\"实验1：SQL各子句条件顺序对查询效率的影响\"></a>实验1：SQL各子句条件顺序对查询效率的影响</h3><h4 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_ <span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID <span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span> <span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验方式\"><a href=\"#实验方式\" class=\"headerlink\" title=\"实验方式\"></a>实验方式</h4><p>通过对MySQL、Oracle、TimesTen中SQL语句中select、from、where子句的排序顺序进行调换，观察执行计划的改变</p>\n<h4 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ol>\n<li>SELECT子句中，结果集的排序方式不会影响执行计划</li>\n<li>FROM子句中，各个表的排序方式不会影响执行计划</li>\n<li>WHERE子句中，各个条件的排序方式不会影响执行计划，优化器会首先将筛选条件应用于表进行过滤，最后逐次执行表的连接。</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>自Oracle6以来，一直采用RBO（Rule-Based Optimization 基于规则的优化器），其基于一套严格死板的使用规则。由于其对于规则的崇尚性，SQL语句的写法则尤为重要。而自Oracle8以来，Oracle引入了一种新的优化方式，即CBO（Cost-Based Optimization 基于代价的优化器），从Oracle 10g开始RBO被完全舍弃。使用CBO优化器时，对SQL语句的要求变得没有那么苛刻，优化器会选择开销比较小的方式执行，而不由用户所写的表的顺序、条件的顺序决定。MySQL与TimesTen的优化器也是如此，有其自己的选择。</p>\n<blockquote>\n<h5 id=\"连接方式和连接顺序\"><a href=\"#连接方式和连接顺序\" class=\"headerlink\" title=\"连接方式和连接顺序\"></a>连接方式和连接顺序</h5><p><strong>连接顺序</strong>：连接顺序表明以哪张表为驱动表来连接其他表的先后顺序。即以某张表为基点，根据其中的信息再去访问其他的表。</p>\n<p><strong>连接方式</strong>：简单来讲，就是两个表获得满足条件的数据时的连接过程。主要有三种表连接方式，嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）。</p>\n<h6 id=\"排序-合并连接\"><a href=\"#排序-合并连接\" class=\"headerlink\" title=\"排序-合并连接\"></a>排序-合并连接</h6><p>假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)</p>\n<p>内部连接过程：</p>\n<p>a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序</p>\n<p>b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序</p>\n<p>c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）</p>\n<p>延伸：</p>\n<p>如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。</p>\n<p>故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。<strong>不过遗憾的是</strong>，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。</p>\n<p>排序-合并连接的表无驱动顺序，谁在前面都可以；</p>\n<p>排序-合并连接<strong>适用</strong>的连接条件有： <strong>&lt;   &lt;=   =   &gt;   &gt;= ，不适用</strong>的连接条件有： <strong>&lt;&gt;    like</strong></p>\n<h6 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h6><p>内部连接过程：</p>\n<p>a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p>\n<p>b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p>\n<p>c) ……</p>\n<p>若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。</p>\n<p>因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。</p>\n<p>嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：<strong>可以先返回已经连接的行</strong>，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。</p>\n<p>应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。</p>\n<h6 id=\"哈希连接\"><a href=\"#哈希连接\" class=\"headerlink\" title=\"哈希连接\"></a>哈希连接</h6><p><strong>哈希连接只适用于等值连接（即连接条件为  =  ）</strong></p>\n<p>HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；</p>\n<p>内部连接过程简述：</p>\n<p>a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）</p>\n<p>b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据</p>\n</blockquote>\n<h3 id=\"实验2：B树索引与位图索引的比较\"><a href=\"#实验2：B树索引与位图索引的比较\" class=\"headerlink\" title=\"实验2：B树索引与位图索引的比较\"></a>实验2：B树索引与位图索引的比较</h3><h4 id=\"sql语句\"><a href=\"#sql语句\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 小基数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 大基数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_ACTOR,T_ACT,T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_ACTOR.NAME_=<span class=\"string\">'Tom Byron'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_ACTOR.ID_=T_ACT.ACTOR_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_ACT.MOVIE_ID;</span><br></pre></td></tr></table></figure>\n<h4 id=\"索引语句\"><a href=\"#索引语句\" class=\"headerlink\" title=\"索引语句\"></a>索引语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- B树</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_MOVIE_SCORE <span class=\"keyword\">ON</span> T_MOVIE(SCORE_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_MOVIE_NAME <span class=\"keyword\">ON</span> T_MOVIE(NAME_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> IX_ACTOR_NAME <span class=\"keyword\">ON</span> T_ACTOR(NAME_);</span><br><span class=\"line\"><span class=\"comment\">-- BitMap</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_MOVIE_NAME <span class=\"keyword\">ON</span> T_MOVIE(NAME_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_MOVIE_SCORE <span class=\"keyword\">ON</span> T_MOVIE(SCORE_);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> IXBM_ACTOR_NAME <span class=\"keyword\">ON</span> T_ACTOR(NAME_);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗\"><a href=\"#查询消耗\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>B树索引（小基数）</p>\n<p><img src=\"/images/1-B%E6%A0%91%E7%B4%A2%E5%BC%95.png\" alt=\"B树索引\"></p>\n<p>位图索引（小基数）</p>\n<p><img src=\"/images/1-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png\" alt=\"位图索引\"></p>\n<p>不加索引（大基数）</p>\n<p><img src=\"/images/image-20190113230831573.png\" alt=\"image-20190113230831573\"></p>\n<p>B树索引（大基数）</p>\n<p><img src=\"/images/image-20190113230717837.png\" alt=\"image-20190113230717837\"></p>\n<p>位图索引（大基数）</p>\n<p><img src=\"/images/image-20190113230627090.png\" alt=\"image-20190113230627090\"></p>\n<h4 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>即使在字段基数较大的情况下，位图索引依然有比B树索引更好的表现。但是有个问题，创建位图索引时所需的时间更长。此外，由于表中该字段的更改都会导致对位图的修改，所以位图索引不适用于并发的情况。</p>\n<h3 id=\"实验3：Oracle优化器对索引的选择\"><a href=\"#实验3：Oracle优化器对索引的选择\" class=\"headerlink\" title=\"实验3：Oracle优化器对索引的选择\"></a>实验3：Oracle优化器对索引的选择</h3><blockquote>\n<h4 id=\"关于索引\"><a href=\"#关于索引\" class=\"headerlink\" title=\"关于索引\"></a>关于索引</h4><h5 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h5><ul>\n<li>B树索引（默认的索引）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>位图索引：以位图的形式存储每个值对应的的一组rowid</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE BITMAP INDEX IXBM_REGION_NAME ON T_REGION(NAME_);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li>基于函数的索引：利于对某个字段查询时需要同时使用函数或计算的情景</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; CREATE INDEX upper_ix ON employees (UPPER(last_name)); </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>分区索引：本地分区索引的分区完全依赖于其索引所在表，而全局分区索引的分区机制和表分区可能一样也可能不一样</p>\n<ul>\n<li>range范围分区</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;   CREATE INDEX cost_ix ON sales (amount_sold)</span><br><span class=\"line\">&gt;    GLOBAL PARTITION BY RANGE (amount_sold)</span><br><span class=\"line\">&gt;       (PARTITION p1 VALUES LESS THAN (1000),</span><br><span class=\"line\">&gt;        PARTITION p2 VALUES LESS THAN (2500),</span><br><span class=\"line\">&gt;        PARTITION p3 VALUES LESS THAN (MAXVALUE));</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>hash哈希分区</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;   CREATE INDEX cust_last_name_ix ON customers (cust_last_name)</span><br><span class=\"line\">&gt;   GLOBAL PARTITION BY HASH (cust_last_name)</span><br><span class=\"line\">&gt;   PARTITIONS 4;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>list列表分区：一个分区对应指定列的特定的值，以列举的方式进行分区</li>\n<li>组合分区（range-hash，range-list）</li>\n</ul>\n<h5 id=\"什么时候用索引\"><a href=\"#什么时候用索引\" class=\"headerlink\" title=\"什么时候用索引\"></a>什么时候用索引</h5><p>对于Oracle的CBO来说，只有在使用索引能提高效率（估算的效率）时才会使用索引。对于程序员自己进行数据库管理的时候，一般有：</p>\n<p><strong>需要使用索引来优化查询的情况：</strong></p>\n<ul>\n<li>一个属性的值分布非常广，变化的范围跨度很大。</li>\n<li>一般来说，常常需要被用在SQL语句的where中的限制条件的属性最好为其建立索引。</li>\n<li>表经常被访问且需要访问的数据量仅占一部分。</li>\n</ul>\n<p><strong>不适合用索引的情况：</strong></p>\n<ul>\n<li>表很小</li>\n<li>表经常被更新</li>\n<li>属性不经常作为where中的限制条件的属性存在</li>\n<li>查询得到的数据占总量的很大部分</li>\n</ul>\n<p>对于数据经常更新的情况，DBA要定时进行索引的重构（rebuild）以维持索引的可用性。</p>\n<h5 id=\"影响优化器决策的因素\"><a href=\"#影响优化器决策的因素\" class=\"headerlink\" title=\"影响优化器决策的因素\"></a>影响优化器决策的因素</h5><ul>\n<li>进行全表扫描需要读取的数据块数量；</li>\n<li>进行索引查询需要读取的数据块数量，这主要是基于对WHERE子句谓词返回的记录数目估计；</li>\n<li>进行全表扫描时多块读的相关开销，以及为满足索引查询进行的单块读的开销；</li>\n<li>内存中对缓存中的索引块和数据块数目的假设。</li>\n</ul>\n<h5 id=\"索引失效的可能原因\"><a href=\"#索引失效的可能原因\" class=\"headerlink\" title=\"索引失效的可能原因\"></a>索引失效的可能原因</h5><p>以下是一些常见的定义了索引当Oracle并未使用的原因：</p>\n<ul>\n<li>不等于情况，即“&lt;&gt;”</li>\n<li>字符串匹配like中百分号在第一位的情况，即“%XXX”</li>\n<li>表没有进行分析更新统计信息</li>\n<li>使用复合索引但单独引用且非复合索引的第一属性</li>\n<li>对索引进行计算，此时需要建立索引函数</li>\n<li>属性为字符串但在where中没有加引号</li>\n<li>使用not in，not exists</li>\n<li>使用了其他索引</li>\n</ul>\n<h4 id=\"强制使用索引\"><a href=\"#强制使用索引\" class=\"headerlink\" title=\"强制使用索引\"></a>强制使用索引</h4><p>如果想要强制使用索引，则可以在查询语句的select单词后加上/*+index (tablename indexname)*/，这样可以规定Oracle选择使用indexname的索引的执行计划。该方法已在前面实验中使用，不再赘述。</p>\n</blockquote>\n<h4 id=\"sql语句-1\"><a href=\"#sql语句-1\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗-1\"><a href=\"#查询消耗-1\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>不用索引（不论是B树索引还是位图索引都不使用）</p>\n<p><img src=\"/images/3-%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95.png\" alt=\"3-不用索引\"></p>\n<p>强制使用B树索引</p>\n<p><img src=\"/images/3-%E5%BC%BA%E5%88%B6B%E6%A0%91.png\" alt=\"3-强制B树\"></p>\n<p>强制使用位图索引</p>\n<p><img src=\"/images/3-%E5%BC%BA%E5%88%B6%E4%BD%8D%E5%9B%BE.png\" alt=\"3-强制位图\"></p>\n<h4 id=\"sql语句-2\"><a href=\"#sql语句-2\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_REGION.NAME_=<span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.SCORE_&gt;<span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询消耗-2\"><a href=\"#查询消耗-2\" class=\"headerlink\" title=\"查询消耗\"></a>查询消耗</h4><p>B树索引（未使用）</p>\n<p><img src=\"/images/3-B%E6%A0%91.png\" alt=\"3-B树\"></p>\n<p>位图索引</p>\n<p><img src=\"/images/3-%E4%BD%8D%E5%9B%BE.png\" alt=\"3-位图\"></p>\n<h4 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>由此可见，即使在有索引的情况下，oracle优化器也可能选择不使用索引。CBO优化器会对每种执行计划计算一个COST，并采用COST最小的执行计划。如果一个表有索引或多种索引，其会选择最好的一种索引方式扫描表，或者甚至不用索引而用全局扫描方式。</p>\n<p>另外对于符合筛选条件的数据，当占全表的比例越小、数据量越小时，使用索引的可能性越大。如在这次实验中，条件为”T_MOVIE.SCORE_ &gt;9”时会使用索引，而”T_MOVIE.SCORE_ &gt;6”时不会。</p>\n<p>此外，由于位图索引导致的COST要小于B树索引，因此在相同的查询中，使用位图索引的可能性比B树索引更大。</p>\n<h3 id=\"实验4：Oracle分区索引\"><a href=\"#实验4：Oracle分区索引\" class=\"headerlink\" title=\"实验4：Oracle分区索引\"></a>实验4：Oracle分区索引</h3><h4 id=\"sql语句-3\"><a href=\"#sql语句-3\" class=\"headerlink\" title=\"sql语句\"></a>sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_COMMENT.SUMMARY_,T_COMMENT.SCORE_,T_COMMENT.TIME_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T_COMMENT,T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T_MOVIE.ID_=T_COMMENT.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_COMMENT.SCORE_&gt;<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> T_MOVIE.NAME_=<span class=\"string\">'Blindsided'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-1\"><a href=\"#实验结果-1\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ol>\n<li><p>未分区表+无索引</p>\n<p><img src=\"/images/5-1-1.png\" alt=\"5-1-1\"></p>\n</li>\n<li><p>未分区表+B树索引</p>\n<p><img src=\"/images/5-2.png\" alt=\"5-2\"></p>\n</li>\n<li><p>未分区表+位图索引</p>\n<p><img src=\"/images/5-3.png\" alt=\"5-3\"></p>\n</li>\n<li><p>分区表+无索引</p>\n<p><img src=\"/images/5-4-1.png\" alt=\"5-4-1\"></p>\n</li>\n<li><p>分区表+全局不分区B树索引</p>\n<p><img src=\"/images/5-5-1.png\" alt=\"5-5-1\"></p>\n</li>\n<li><p>分区表+本地(哈希分区)B树索引</p>\n<p><img src=\"/images/5-6.png\" alt=\"5-6\"></p>\n</li>\n<li><p>分区表+本地(哈希分区)位图索引</p>\n<p><img src=\"/images/5-7.png\" alt=\"5-7\"></p>\n</li>\n<li><p>分区表+全局哈希分区索引</p>\n<p><img src=\"/images/5-8.png\" alt=\"5-8\"></p>\n</li>\n<li><p>分区表+全局范围分区索引</p>\n<p><img src=\"/images/5-9.png\" alt=\"5-9\"></p>\n</li>\n</ol>\n<h4 id=\"分析-3\"><a href=\"#分析-3\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ol>\n<li><p>在未建索引时，分区表的COST是未分区表的十倍多。原因是分区所依据的键（字段）不是直接的查询条件——我们以评论表的movie_id字段为依据建哈希分区表，但在查询的时候并不直接以movie_id为查询条件。导致连接表的时候，需要访问多个分区，反而造成COST大大增长。</p>\n<p>后来我们重新设计一个以movie_id为查询条件的sql语句，结果显示分区表的COST大约是未分区表的1/4（一共分了4个区），证明在以分区依据的字段为直接查询条件时，分区表能够体现比较好的性能，能够避免对一部分数据的访问。</p>\n</li>\n<li><p>在分区表上建索引比在未分区表上建索引后的开销更小，不论分区表上的索引是全局还是本地，不论是否是分区索引。在我们的实验场景中，尽管movie_id不是直接的查询条件而是join表的条件，但是在添加索引后，依然能够大大减少join表的开销从而提升效率。</p>\n</li>\n<li><p>在我们的实验场景中，全局的分区索引，不论是哈希分区还是范围分区，COST是一样的。</p>\n</li>\n<li><p>本地索引的效率略微比全局索引的效率好。根据查到的资料，本地索引的可维护性好，能够自动维护，不需要人工干预，但因把索引分成多个分区导致每次的索引访问都需要遍历所有索引分区，所以索引访问性能下降。因此比较适合OLAP系统。而全局索引的可维护性差，分区表发生改变时，需要用命令手动更新索引，但索引访问性能比本地分区索引要好。因此比较适合OLTP系统。</p>\n</li>\n</ol>\n<h3 id=\"实验5：Oracle使用复合索引\"><a href=\"#实验5：Oracle使用复合索引\" class=\"headerlink\" title=\"实验5：Oracle使用复合索引\"></a>实验5：Oracle使用复合索引</h3><h4 id=\"SQL语句-1\"><a href=\"#SQL语句-1\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> T_COMMENT_1.SUMMARY_, T_COMMENT_1.SCORE_</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_COMMENT_1, T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_MOVIE.ID_ = T_COMMENT_1.MOVIE_ID <span class=\"keyword\">and</span> T_COMMENT_1.SCORE_ &gt; <span class=\"number\">7</span> <span class=\"keyword\">and</span> T_MOVIE.NAME_ = <span class=\"string\">'The Notebook'</span>;</span><br></pre></td></tr></table></figure>\n<p>第一次查询：T_COMMENT_1上只有主键的唯一索引。</p>\n<p>第二次查询：在MOVIE_ID上建立一个B-tree索引COMMENT_1_MOVIE。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">on</span> T_COMMENT_1(MOVIE_ID);</span><br></pre></td></tr></table></figure>\n<p>第三次查询：使第二次的索引invisible，在SCORE_上建立一个B-tree索引T_COMMENT_SCORE_INDEX。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">invisible</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> T_COMMENT_SCORE_INDEX <span class=\"keyword\">on</span> T_COMMENT_1(SCORE_);</span><br></pre></td></tr></table></figure>\n<p>第四次查询：将第二次和第三次的索引都保持为visible，在MOVIE_ID和SCORE_上建立一个复合索引COMMENT_1_MOVIE_SCORE。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE <span class=\"keyword\">visible</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> COMMENT_1_MOVIE_SCORE <span class=\"keyword\">on</span> T_COMMENT_1(MOVIE_ID, SCORE_);</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-2\"><a href=\"#实验结果-2\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>第一次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.48.45.png\" alt=\"屏幕快照 2019-01-13 下午10.48.45\"></p>\n<p>全表扫描，花销很大</p>\n<p><strong>第二次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.47.49.png\" alt=\"屏幕快照 2019-01-13 下午10.47.49\"></p>\n<p>利用在MOVIE_ID上的索引，在T_COMMENT_1中访问的数据量和花销都大幅度下降。</p>\n<p><strong>第三次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.50.07.png\" alt=\"屏幕快照 2019-01-13 下午10.50.07\"></p>\n<p>如果只有在SCORE_上的索引，根据CBO，Oracle并没有使用这个索引，而是依旧使用全表扫描，可知该索引并没有提升性能。</p>\n<p>易知，如果在这个时候将MOVIE_ID上的索引设为visible，Oracle会使用MOVIE_ID上的索引。</p>\n<p><strong>第四次查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.57.10.png\" alt=\"屏幕快照 2019-01-13 下午10.57.10\"></p>\n<p>Oracle使用了复合索引，尽管在当前问题下COST花销与只有MOVIE_ID的索引差不多，但是其访问的记录数（CARDINALITY）显著减小，体现了复合索引给查询带来的性能提升。</p>\n<h3 id=\"实验6：物化视图对SQL查询性能的提升\"><a href=\"#实验6：物化视图对SQL查询性能的提升\" class=\"headerlink\" title=\"实验6：物化视图对SQL查询性能的提升\"></a>实验6：物化视图对SQL查询性能的提升</h3><h4 id=\"SQL语句-2\"><a href=\"#SQL语句-2\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><p><strong>原始查询语句：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_MOVIE.NAME_ MOVIE_NAME, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_DIRECTOR.NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_ ;</span><br></pre></td></tr></table></figure>\n<p>创建一个<strong>普通视图</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> DIRECTOR_MOVIE_FAKE</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure>\n<p>使用普通视图进行查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE_FAKE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<p>创建<strong>物化视图</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">MATERIALIZED</span> <span class=\"keyword\">VIEW</span> DIRECTOR_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">BUILD</span> <span class=\"keyword\">IMMEDIATE</span></span><br><span class=\"line\"><span class=\"keyword\">REFRESH</span> <span class=\"keyword\">FORCE</span></span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">DEMAND</span></span><br><span class=\"line\"><span class=\"keyword\">ENABLE</span> <span class=\"keyword\">QUERY</span> REWRITE</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class=\"keyword\">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class=\"line\"><span class=\"keyword\">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class=\"line\"><span class=\"keyword\">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class=\"keyword\">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class=\"keyword\">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure>\n<p>设置<strong>创建时生成数据</strong>，<strong>按需要刷新</strong>，<strong>刷新方式为FORCE</strong>。</p>\n<p>根据视图进行如上查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<p>由于物化视图与表类似，可以给其建立索引，以下给导演名<strong>建立索引</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">BITMAP</span> <span class=\"keyword\">INDEX</span> DIRECTOR_MOVIE_INAME_INDEX <span class=\"keyword\">ON</span> DIRECTOR_MOVIE (NAME_);</span><br></pre></td></tr></table></figure>\n<p><strong>再次使用物化视图查询</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> NAME_, MOVIE_NAME, SCORE <span class=\"keyword\">from</span> DIRECTOR_MOVIE <span class=\"keyword\">where</span> NAME_ <span class=\"keyword\">like</span> <span class=\"string\">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-3\"><a href=\"#实验结果-3\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>使用原始查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png\" alt=\"屏幕快照 2019-01-14 上午12.27.37\"></p>\n<p>具有极大的花销。</p>\n<p><strong>创建视图后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png\" alt=\"屏幕快照 2019-01-14 上午12.30.46\"></p>\n<p>其执行计划与<strong>原始查询</strong>一致。</p>\n<p><strong>创建物化视图后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.33.27.png\" alt=\"屏幕快照 2019-01-14 上午12.33.27\"></p>\n<p>其<strong>直接在物化视图中进行查询</strong>，执行计划即为简单，花销大幅度减小。</p>\n<p><strong>给物化视图创建索引后的查询：</strong></p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.35.22.png\" alt=\"屏幕快照 2019-01-14 上午12.35.22\"></p>\n<p>建立索引后通过范围索引扫描该物化视图进行查询，其COST数字小得令人惊奇。</p>\n<h4 id=\"分析-4\"><a href=\"#分析-4\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>1.建立普通视图并不能提升性能。因为普通是虚拟的，对视图的操作实际都转变为了对各表的SQL操作，其与原始查询完全一致。</p>\n<p>2.物化视图是一种物理表，对于物化视图的查询是直接的，跟表一样。因此建立物化视图可以大幅度减小花销，但是同时，物化视图也会产生大量的维护成本。因此程序员应该根据实际情况建立物化视图以优化查询。</p>\n<p>3.物化视图同样可以增添索引，增加索引后Oracle对物化视图可以通过索引进行扫描，进一步提高效率。</p>\n<blockquote>\n<h5 id=\"物化视图与普通视图\"><a href=\"#物化视图与普通视图\" class=\"headerlink\" title=\"物化视图与普通视图\"></a>物化视图与普通视图</h5><p>视图只是一种虚拟表。实际上，<strong>对视图的查询真正转换成了相应的SQL语句再对各表进行连接查询，因此其性能提升有限，只是方便了使用</strong>。</p>\n<p>而物化视图是实质化的视图，是<strong>物理表</strong>，可以像表一样进行查询，建立索引，占用真正的存储空间，需要被刷新。</p>\n<h5 id=\"刷新模式\"><a href=\"#刷新模式\" class=\"headerlink\" title=\"刷新模式\"></a>刷新模式</h5><p><strong>on demand：</strong>顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性;</p>\n<p><strong>on commit</strong>：提交触发，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢。</p>\n<p>创建物化视图时未作指定，则Oracle按 on demand 模式来创建。</p>\n<h5 id=\"刷新方法\"><a href=\"#刷新方法\" class=\"headerlink\" title=\"刷新方法\"></a>刷新方法</h5><p><strong>完全刷新（COMPLETE）</strong>： 会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。 </p>\n<p><strong>快速刷新（FAST）</strong>： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。</p>\n<p><strong>FORCE方式</strong>： 这是默认的数据刷新方式。Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。</p>\n</blockquote>\n<h3 id=\"实验7：Oracle-In-Memory性能分析\"><a href=\"#实验7：Oracle-In-Memory性能分析\" class=\"headerlink\" title=\"实验7：Oracle In Memory性能分析\"></a>实验7：Oracle In Memory性能分析</h3><h4 id=\"Sql语句\"><a href=\"#Sql语句\" class=\"headerlink\" title=\"Sql语句\"></a>Sql语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T_MOVIE.NAME_, <span class=\"keyword\">SUM</span>(T_COMMENT_2.SCORE_) s <span class=\"keyword\">FROM</span> T_MOVIE,T_COMMENT_2 <span class=\"keyword\">WHERE</span> T_MOVIE.ID_=T_COMMENT_2.MOVIE_ID <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> T_MOVIE.NAME_ <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> s <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置In-Memory\"><a href=\"#设置In-Memory\" class=\"headerlink\" title=\"设置In Memory\"></a>设置In Memory</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> T_MOVIE.NAME_ <span class=\"keyword\">IN</span> <span class=\"keyword\">MEMORY</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验结果-4\"><a href=\"#实验结果-4\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><p><strong>原始查询</strong>：</p>\n<p><img src=\"/images/no-inmemory.png\" alt=\"no-inmemory\"></p>\n<p><strong>In Memory查询：</strong></p>\n<p><img src=\"/images/inmemory.png\" alt=\"inmemory\"></p>\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><p>遗憾的是与想象的不同，Oracle和Oracle In Memory在COST上面结果相同，但是事实上在我们同样的实验环境下测试二者时间时，In Memory确实会比Oracle好很多。其实简单思考一下，这是应该的，前面我们说过执行时间<code>t = Block数量 * Block处理时间</code>，不难知道差距还是出在Block处理时间上。</p>\n<h3 id=\"实验8：Oracle执行计划浅析-Oracle表的访问方式\"><a href=\"#实验8：Oracle执行计划浅析-Oracle表的访问方式\" class=\"headerlink\" title=\"实验8：Oracle执行计划浅析(Oracle表的访问方式)\"></a>实验8：Oracle执行计划浅析(Oracle表的访问方式)</h3><p>对T_MOVIE表进行查询，其本身有在其主码(ID_)上的UNIQUE INDEX和LENGTH_上的B-tree INDEX。</p>\n<h4 id=\"根据UNIQUE-INDEX（ID-）返回唯一记录\"><a href=\"#根据UNIQUE-INDEX（ID-）返回唯一记录\" class=\"headerlink\" title=\"根据UNIQUE INDEX（ID_）返回唯一记录\"></a>根据UNIQUE INDEX（ID_）返回唯一记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> ID_ = <span class=\"number\">20050</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.14.59.png\" alt=\"屏幕快照 2019-01-13 下午9.14.59\"></p>\n<p>使用的是索引唯一扫描</p>\n<h4 id=\"根据ID-返回少部分记录\"><a href=\"#根据ID-返回少部分记录\" class=\"headerlink\" title=\"根据ID_返回少部分记录\"></a>根据ID_返回少部分记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> ID_ &lt; <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.25.22.png\" alt=\"屏幕快照 2019-01-13 下午9.25.22\"></p>\n<p>使用的是索引范围扫描</p>\n<h4 id=\"根据LENGTH-返回大量数据\"><a href=\"#根据LENGTH-返回大量数据\" class=\"headerlink\" title=\"根据LENGTH_返回大量数据\"></a>根据LENGTH_返回大量数据</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> T_MOVIE <span class=\"keyword\">where</span> LENGTH_ &lt;<span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/image-20190114004746346.png\" alt=\"image-20190114004746346\"></p>\n<h4 id=\"全查询MOVIE-和TYPE-返回其ID\"><a href=\"#全查询MOVIE-和TYPE-返回其ID\" class=\"headerlink\" title=\"全查询MOVIE_和TYPE_返回其ID_\"></a>全查询MOVIE_和TYPE_返回其ID_</h4><p><strong>全查询MOVIE_：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ID_ <span class=\"keyword\">from</span> T_MOVIE;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.32.45.png\" alt=\"屏幕快照 2019-01-13 下午9.32.45\"></p>\n<p>采用的是索引快速扫描（因为数据量较多）</p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.38.39.png\" alt=\"屏幕快照 2019-01-13 下午9.38.39\"></p>\n<p>且返回结果无顺序（从578开始，一段有序，即代表是一个索引数据块）。</p>\n<p><strong>全查询TYPE_:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ID_ <span class=\"keyword\">from</span> T_TYPE;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.35.11.png\" alt=\"屏幕快照 2019-01-13 下午9.35.11\"></p>\n<p>采用的是索引全扫描（因为数据量较小）</p>\n<p><img src=\"/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.37.57.png\" alt=\"屏幕快照 2019-01-13 下午9.37.57\"></p>\n<p>返回结果有顺序</p>\n<blockquote>\n<h3 id=\"执行计划中的访问方式\"><a href=\"#执行计划中的访问方式\" class=\"headerlink\" title=\"执行计划中的访问方式\"></a>执行计划中的访问方式</h3><p>访问方式即分为全表扫描（TABLE ACCESS FULL）和各种类型索引扫描（TABLE INDEX SCAN）。Oracle会根据表和索引的信息，推算执行的SQL语句从表中取多少数据以及这些数据是怎么分布的。</p>\n<h4 id=\"TABLE-ACCESS-FULL（全表扫描）\"><a href=\"#TABLE-ACCESS-FULL（全表扫描）\" class=\"headerlink\" title=\"TABLE ACCESS FULL（全表扫描）\"></a>TABLE ACCESS FULL（全表扫描）</h4><p><strong>Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 where限制条件</strong>。全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作来提升吞吐量。<strong>数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上</strong>。</p>\n<h4 id=\"TABLE-ACCESS-ROWID（通过ROWID的表存取）\"><a href=\"#TABLE-ACCESS-ROWID（通过ROWID的表存取）\" class=\"headerlink\" title=\"TABLE ACCESS ROWID（通过ROWID的表存取）\"></a>TABLE ACCESS ROWID（通过ROWID的表存取）</h4><p><strong>ROWID是由Oracle自动加在表中每行最后的一列伪列</strong>，表中并不会物理存储ROWID的值。程序员可以像使用其它列一样使用它，但不能对该列的值进行增、删、改操作。一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。</p>\n<p>ROWID可以被视为每条记录的“指针”。<strong>它指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法</strong>。</p>\n<h4 id=\"TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）\"><a href=\"#TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）\" class=\"headerlink\" title=\"TABLE ACCESS BY INDEX SCAN（索引扫描）\"></a>TABLE ACCESS BY INDEX SCAN（索引扫描）</h4><p>在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。因此索引扫描其实分为两步：扫描索引得到对应的ROWID；通过ROWID定位到具体的行读取数据。</p>\n<p>索引扫描主要分为以下几种：</p>\n<h5 id=\"INDEX-UNIQUE-SCAN-索引唯一扫描\"><a href=\"#INDEX-UNIQUE-SCAN-索引唯一扫描\" class=\"headerlink\" title=\"INDEX UNIQUE SCAN 索引唯一扫描\"></a>INDEX UNIQUE SCAN 索引唯一扫描</h5><p>对应UNIQUE INDEX（唯一性索引）的扫描方式，其<strong>只会应用在返回一条记录的情况下</strong>。该点在之前的实验中已经描述。</p>\n<h5 id=\"INDEX-RANGE-SCAN-索引范围扫描\"><a href=\"#INDEX-RANGE-SCAN-索引范围扫描\" class=\"headerlink\" title=\"INDEX RANGE SCAN 索引范围扫描\"></a>INDEX RANGE SCAN 索引范围扫描</h5><p>主要是使用在需要返回多行记录的情况下，常见为以下三种：</p>\n<ul>\n<li>在唯一索引列上使用了范围操作符（如：&gt;   &lt;   &lt;&gt;   &gt;=   &lt;=   between）</li>\n<li>在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）</li>\n<li>对非唯一索引列上进行的任何查询</li>\n</ul>\n<p>如果在查询的过程中需要访问的记录数很多，分布很广，这个时候Oracle会根据CBO原则认为使用索引的花销可能比全表扫描大，会使用全表扫描。</p>\n<h5 id=\"INDEX-FULL-SCAN-索引全扫描\"><a href=\"#INDEX-FULL-SCAN-索引全扫描\" class=\"headerlink\" title=\"INDEX FULL SCAN 索引全扫描\"></a>INDEX FULL SCAN 索引全扫描</h5><p>进行全索引扫描时，查询出的数据都必须从索引中可以直接得到。其常发生在要查询的列包含唯一索引且需要对表中的所有数据都要查询。<strong>索引全扫描返回的结果有顺序。</strong></p>\n<h5 id=\"INDEX-FAST-FULL-SCAN-索引快速全扫描\"><a href=\"#INDEX-FAST-FULL-SCAN-索引快速全扫描\" class=\"headerlink\" title=\"INDEX FAST FULL SCAN 索引快速全扫描\"></a>INDEX FAST FULL SCAN 索引快速全扫描</h5><p>索引快速全扫描与索引全扫描类似，只是其在查找索引时会用一种更为快速的方式（简单来说是根据索引块的物理顺序而省去较为繁琐的逻辑顺序），其更适合于数据量大的表进行全查询，<strong>其一个特点就是返回的记录不按照顺序。</strong></p>\n</blockquote>\n<h2 id=\"四、TimesTen实验过程\"><a href=\"#四、TimesTen实验过程\" class=\"headerlink\" title=\"四、TimesTen实验过程\"></a>四、TimesTen实验过程</h2><h3 id=\"实验概述\"><a href=\"#实验概述\" class=\"headerlink\" title=\"实验概述\"></a>实验概述</h3><p>调用自己改写的 AliTT11.sql，查看 SQLPrepare，SQLExecute，FetchLoop 的查询时间；</p>\n<p>所有实验中，查询时间分为增加索引前、增加索引后、按照 timesten 建议添加索引三类，针对每一类时间分别有第一次执行时间和之后的平均查询时间两种；</p>\n<p>在首次执行查询语句时，timesten首先需要对语句进行预编译，因此首次执行的 SQLPrepare 时间相比之后的时间较长，之后的准备时间就相应缩短了很多。</p>\n<h3 id=\"实验1\"><a href=\"#实验1\" class=\"headerlink\" title=\"实验1\"></a>实验1</h3><h4 id=\"实验内容\"><a href=\"#实验内容\" class=\"headerlink\" title=\"实验内容\"></a>实验内容</h4><p>某地区评分6以上的所有电影的名字和上映时间</p>\n<h4 id=\"查询语句-1\"><a href=\"#查询语句-1\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> DBIM.T_MOVIE.NAME_, DBIM.T_MOVIE.YEAR_</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> DBIM.T_MOVIE, DBIM.T_MOVIE_REGION, DBIM.T_REGION</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_REGION.NAME_ = <span class=\"string\">'美国'</span></span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_MOVIE.SCORE_ &gt; <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加的索引\"><a href=\"#添加的索引\" class=\"headerlink\" title=\"添加的索引\"></a>添加的索引</h4><table>\n<thead>\n<tr>\n<th>表明</th>\n<th>列名</th>\n<th>索引类型</th>\n<th>是否唯一</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie</td>\n<td>score_</td>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>region_id</td>\n<td>hash</td>\n<td></td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>movie_id</td>\n<td>hash</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"查询时间\"><a href=\"#查询时间\" class=\"headerlink\" title=\"查询时间\"></a>查询时间</h4><table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before1</th>\n<th>Before2</th>\n<th>After1</th>\n<th>After2</th>\n<th>建议1</th>\n<th>建议2</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001845</td>\n<td>0.000059</td>\n<td>0.000878</td>\n<td>0.000054</td>\n<td>0.000807</td>\n<td>0.000055</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>0.075809</td>\n<td>0.061819</td>\n<td>0.000037</td>\n<td>0.000025</td>\n<td>0.000034</td>\n<td>0.000025</td>\n<td>99.96%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000004</td>\n<td>0.000002</td>\n<td>0.000002</td>\n<td>0.000001</td>\n<td>0.000003</td>\n<td>0.000002</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>执行计划 (before)</li>\n</ul>\n<p><img src=\"/images/11b.PNG\" alt=\"11b\"></p>\n<ul>\n<li>执行计划 (after)</li>\n</ul>\n<p><img src=\"/images/11a.PNG\" alt=\"11a\"></p>\n<h4 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h4><p>添加索引后速度大大提升，因为在 region 表中指定了查询条件，添加索引后可以快速从表项中匹配到指定条件的项；在添加之前，timesten 自动帮我们在 movie 表上的 id 字段上添加了临时哈希索引，除此之外，我们额外为几个 where 条件语句的查询字段都增加了索引， 因此提高了效率。</p>\n<p>执行计划</p>\n<ul>\n<li><p>before</p>\n<p>在两层嵌套循环中，顺序执行在region表中的查询、region表与联系表的join，循环结束后生成一个指定地区内的所有电影联系表；内层嵌套完成后，通过散列索引匹配movie表与内存循环生成的联系表，join筛选后生成结果列表</p>\n</li>\n<li><p>after</p>\n<p>添加索引之后，过程与添加之前相同，但由于内层循环内使用散列索引而不是顺序执行，因此查询速度比较快，加上没有临时创建索引的时间开销，所以相比之下大大提高了查询效率。</p>\n</li>\n</ul>\n<h3 id=\"实验2\"><a href=\"#实验2\" class=\"headerlink\" title=\"实验2\"></a>实验2</h3><h4 id=\"实验内容-1\"><a href=\"#实验内容-1\" class=\"headerlink\" title=\"实验内容\"></a>实验内容</h4><p>所有地区全部电影的平均评分排行榜（前100）</p>\n<h4 id=\"查询语句-2\"><a href=\"#查询语句-2\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> DBIM.T_REGION.NAME_, <span class=\"keyword\">SUM</span>(DBIM.T_MOVIE.SCORE_) s</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> DBIM.T_REGION, DBIM.T_MOVIE_REGION, DBIM.T_MOVIE</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class=\"line\"><span class=\"keyword\">AND</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> DBIM.T_REGION.NAME_</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> s <span class=\"keyword\">DESC</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">ROWNUM</span> &lt; <span class=\"number\">101</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"添加的索引-1\"><a href=\"#添加的索引-1\" class=\"headerlink\" title=\"添加的索引\"></a>添加的索引</h4><table>\n<thead>\n<tr>\n<th>表明</th>\n<th>列名</th>\n<th>索引类型</th>\n<th>是否唯一</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie</td>\n<td>score_</td>\n<td>range</td>\n<td></td>\n</tr>\n<tr>\n<td>Region</td>\n<td>name_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>hash</td>\n<td>unique</td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>region_id</td>\n<td>hash</td>\n<td></td>\n</tr>\n<tr>\n<td>Movie_region</td>\n<td>movie_id</td>\n<td>hash</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"查询时间-1\"><a href=\"#查询时间-1\" class=\"headerlink\" title=\"查询时间\"></a>查询时间</h4><table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before(1)</th>\n<th>Before(2)</th>\n<th>After(1)</th>\n<th>After(2)</th>\n<th>建议(1)</th>\n<th>建议(2)</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001253</td>\n<td>0.000081</td>\n<td>0.001004</td>\n<td>0.000054</td>\n<td>0.000985</td>\n<td>0.000056</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>0.353111</td>\n<td>0.335902</td>\n<td>0.337983</td>\n<td>0.313458</td>\n<td>0.313004</td>\n<td>0.312695</td>\n<td>7%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000045</td>\n<td>0.000020</td>\n<td>0.000018</td>\n<td>0.000018</td>\n<td>0.000018</td>\n<td>0.000017</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>执行计划 (before)</li>\n</ul>\n<p><img src=\"/images/12b.PNG\" alt=\"12b\"></p>\n<ul>\n<li>执行计划 (after)</li>\n</ul>\n<p><img src=\"/images/12a.PNG\" alt=\"12a\"></p>\n<h4 id=\"原因分析-1\"><a href=\"#原因分析-1\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h4><p>添加索引之前，timesten 自动在 movie 和 region 表的 id 字段上都设置了相应的哈希索引，而我们添加索引后与添加之前的执行计划中的索引项没有差别，因此效率几乎没有变化，加上 sum 聚合操作、group by、order by 操作都要进行费时间的全表扫描，所以需要较长时间完成查询。</p>\n<blockquote>\n<h5 id=\"实验1和2分析总结\"><a href=\"#实验1和2分析总结\" class=\"headerlink\" title=\"实验1和2分析总结\"></a>实验1和2分析总结</h5><p>指定条件的查询：</p>\n<ul>\n<li><p>建立索引之前</p>\n<p>timesten在某个相对较小的表上建立临时索引（散列索引或范围索引），在其他表上进行顺序扫描，执行查询语句中的条件匹配，建立索引的过程会造成时间上的消耗；</p>\n</li>\n<li><p>建立索引之后</p>\n<p>自己建立的索引覆盖timesten优化建立的索引，由于索引提前建立，因此没有建立索引带来的额外时间开销，而且在此类查询中我们在所有查询涉及字段上都建立了索引（tt自身优化通常只在一个表上建立索引），所以与建立索引之前相比有极大的性能提升。</p>\n</li>\n</ul>\n<p>聚合查询：</p>\n<ul>\n<li><p>执行计划Before：</p>\n<p>先顺序扫描关系表act的记录字段id，利用临时HASH索引 actor.id_，将act表中对应记录与act的记录通过字段相连；对(这些/该)拼接记录逐条利用临时HASH索引 movie.id ,接上movie表中符合条件的记录字段。</p>\n</li>\n<li><p>执行计划After：</p>\n<p>先顺序扫描关系表movie的记录字段id ，利用HASH索引 act.id_，将act表中对应记录与act的记录通过字段相连；针对第一次hash检索出的 act.id，再对(这些/该)拼接记录逐条利用临时HASH索引 actor.id ,接上actor表中符合条件的记录字段。</p>\n</li>\n<li><p>主要原因在于：第一次顺序扫描的关系表act，外码引用actor表的主码(1:1)，movie表(1:1)，hash索引查询唯一记录快；第二次顺序扫描的表为movie表，将对应多条act表里的记录（1:many），对应多个演员(1:many)。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"实验3：AWT\"><a href=\"#实验3：AWT\" class=\"headerlink\" title=\"实验3：AWT\"></a>实验3：AWT</h3><h4 id=\"创建-AWT-直写缓存组\"><a href=\"#创建-AWT-直写缓存组\" class=\"headerlink\" title=\"创建 AWT 直写缓存组\"></a>创建 AWT 直写缓存组</h4><ul>\n<li>缓存表<ul>\n<li>t_moive</li>\n<li>t_comment_1</li>\n</ul>\n</li>\n<li>选择理由<ul>\n<li>动态缓存组适用于不从 oracle 中预加载数据的场景</li>\n<li>Movie 表和评论表体量较大，不需要从 oracle 中提前加载</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"测试-AWT-修改数据\"><a href=\"#测试-AWT-修改数据\" class=\"headerlink\" title=\"测试 AWT 修改数据\"></a>测试 AWT 修改数据</h4><ul>\n<li><p>修改电影评论表</p>\n</li>\n<li><p>修改语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE DBIM.T_COMMENT_1</span><br><span class=\"line\">SET SUMMARY_=&apos;A&apos;</span><br><span class=\"line\">WHERE DBIM.T_COMMENT_1.SCORE_&gt;8</span><br><span class=\"line\">AND DBIM.T_COMMENT_1.MOVIE_ID = 1;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>踩坑</p>\n<ul>\n<li>update语句指定修改的表名后，set字段不需要再次声明表名（否则报错）</li>\n<li>修改数据前要开启 replication agent</li>\n<li>执行update语句后要提交事务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实验4：查看不同数据类型对查询效率的影响\"><a href=\"#实验4：查看不同数据类型对查询效率的影响\" class=\"headerlink\" title=\"实验4：查看不同数据类型对查询效率的影响\"></a>实验4：查看不同数据类型对查询效率的影响</h3><h4 id=\"表字节大小\"><a href=\"#表字节大小\" class=\"headerlink\" title=\"表字节大小\"></a>表字节大小</h4><table>\n<thead>\n<tr>\n<th>表名</th>\n<th>行数</th>\n<th>字节大小</th>\n<th>有数据类型映射的字节大小</th>\n<th>节约百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Movie</td>\n<td>292352</td>\n<td>47301232（nomapping）</td>\n<td>26293000（optimal）</td>\n<td>45%</td>\n</tr>\n<tr>\n<td>Comment</td>\n<td>9805336</td>\n<td>2528884600（nomapping）</td>\n<td>404967952（optimal）</td>\n<td>84%</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"压缩设置\"><a href=\"#压缩设置\" class=\"headerlink\" title=\"压缩设置\"></a>压缩设置</h4><p><img src=\"/images/image-20190114062154430.png\" alt=\"image-20190114062154430\"></p>\n<h4 id=\"数据类型映射结果\"><a href=\"#数据类型映射结果\" class=\"headerlink\" title=\"数据类型映射结果\"></a>数据类型映射结果</h4><table>\n<thead>\n<tr>\n<th>表</th>\n<th>字段</th>\n<th>noMapping</th>\n<th>standardMapping</th>\n<th>aggressive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Region</td>\n<td>id_</td>\n<td>NUMBER(11,0)</td>\n<td>TT_BIGINT</td>\n<td>TT_SMALINT</td>\n</tr>\n<tr>\n<td>Region</td>\n<td>name_</td>\n<td>VARCHAR(255 BYTE)</td>\n<td>VARCHAR(255 BYTE)</td>\n<td>VARCHAR(80 BYTE)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>对相同的表来说，从 oracle 导入 timesten 中如果不进行压缩（nomapping），与进行最优化数据类型映射+aggressive mapping + optimal compression 相比，大约浪费了45%的空间；</li>\n<li>对于不同数量级的表来说，千万数量级的 comment 表不进行压缩时浪费84%所有的空间，比十万数量级的 movie 表浪费的空间多了接近一倍。</li>\n</ul>\n<h3 id=\"实验5：根据优化建议建立索引\"><a href=\"#实验5：根据优化建议建立索引\" class=\"headerlink\" title=\"实验5：根据优化建议建立索引\"></a>实验5：根据优化建议建立索引</h3><h4 id=\"SQL语句-3\"><a href=\"#SQL语句-3\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command&gt; call ttIndexAdviceCaptureOutput(0);</span><br><span class=\"line\">&lt; 6, create index T_MOVIE_i1 on DBIM.T_MOVIE(ID_); &gt;</span><br><span class=\"line\">&lt; 7, create index T_COMMENT_1_i2 on DBIM.T_COMMENT_1(MOVIE_ID,SCORE_); &gt;</span><br><span class=\"line\">2 rows found.</span><br></pre></td></tr></table></figure>\n<h4 id=\"实验对象\"><a href=\"#实验对象\" class=\"headerlink\" title=\"实验对象\"></a>实验对象</h4><ul>\n<li>实验3.2语句</li>\n</ul>\n<h4 id=\"实验结果-5\"><a href=\"#实验结果-5\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><ul>\n<li>Before：自己建立索引后的查询时间</li>\n<li>After：根据 timesten 查询优化建议建立索引后的查询时间</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>时间类型</th>\n<th>Before(1)</th>\n<th>Before(2)</th>\n<th>After(1)</th>\n<th>After(2)</th>\n<th>提高百分比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQLPrepare</td>\n<td>0.001527</td>\n<td>0.000049</td>\n<td>0.000822</td>\n<td>0.000049</td>\n<td></td>\n</tr>\n<tr>\n<td>SQLExecute</td>\n<td>4.139655</td>\n<td>3.556375</td>\n<td>3.301318</td>\n<td>3.302092</td>\n<td>7.18%</td>\n</tr>\n<tr>\n<td>FetchLoop</td>\n<td>0.000047</td>\n<td>0.000027</td>\n<td>0.000018</td>\n<td>0.000017</td>\n</tr>\n</tbody>\n</table>"},{"title":"数据仓库期末项目文档","date":"2018-12-31T09:32:45.000Z","_content":"\n## 简介\n\n本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。\n\n<!-- more -->\n\n## 系统架构\n\n### Neo4j\n\n- 操作系统：macOS Mojave 10.14.1\n\n- 硬件：Core i5 & 16GB RAM\n\n- 软件：Neo4j Desktop Version 1.1.10 (1.1.10.436)\n\n- 选择理由：\n  - 高性能：Neo4j以图的遍历算法来帮助查询数据，查询时从一个节点开始，根据其连接的关系，快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。\n  - 灵活性：图数据结构的自然伸展特性及其非结构化的数据格式让Neo4j的数据库设计可以具有很大的伸缩性和灵活性，使其可以随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用，因此在项目后期的推进中，我们也可以不断的快速修改neo4j数据库中的内容来满足我们的查询需求。\n  - 直观性：图数据库使用图的形式作为数据库最主要的展现形式，可以更清楚的帮助我们理解整个数据库中数据之间的联系，Cypher语言的灵活性也帮助我们更轻松的操控数据库\n- 存储模型简介：\n  - 本项目中主要建立了Neo4j的两个不同的库，一个库是围绕电影的相关信息，我们在其中存储了和电影有关的所有信息，包括导演，制片人，演员，类别，语言，字幕，编剧等等，节点与节点之间通过不同的关系相连接。第二个库针对合作关系，分别存储了导演，演员，以及类别，通过节点与节点之间的关系，记录他们彼此的合作次数，类别的引入也帮助我们分析导演的执导风格。\n\n- 存储模型：图\n- 性能对比分析：\n  - 数据存储：Neo4j对于图的存储自然是经过特别优化的。不像传统数据库的一条记录一条数据的存储方式，Neo4j的存储方式是：节点的类别，属性，边的类别，属性等都是分开存储的，这将大大有助于提高图形数据库的性能。在Neo4j 中属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。\n  - 数据读写：在Neo4j中，存储节点时，每个节点都有指向其邻居节点的指针，可以让我们在O(1)的时间内找到邻居节点。另外，按照官方的说法，在Neo4j中边是最重要的,是\"first-class entities\"，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历。邻近查询帮助Neo4j始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。\n\n### MySQL\n\n- 操作系统：macOS Mojave 10.14.1 Beta\n\n- 硬件：Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz/ 4 GB 1600 MHz DDR3\n\n- 软件：Docker 1.13.1/ MySQL 5.7\n\n- 选择理由：\n\n  MySQL是时下使用率最高的几款关系型数据库之一，且其体积相较其他关系型数据库更小巧且性能不输大型关系型数据库。关系型数据库是我们最常接触也是在对数据进行存储时会最先想到的数据库类型。我们想要借助关系型数据库以及行式存储对我们的数据进行存储，并通过对应的数据库操作对存储对数据进行分析/查询，实现我们对应的目的。\n\n- 存储模型简介：\n\n  在本项目中我们选择雪花模型作为我们关系型数据库的存储模型。雪花存储模型使用规范化的数据，数据在数据库内部是组织好的，消除冗余以减少数据量。相比之下，星型模型使用的是反规范化的数据，会在存储时存储大量的冗余数据。规范化存储数据同时也带来查询时间上的消耗，其查询更新速度会慢于星型存储模型。但是考虑到我们项目到数据单表最大12万左右，对于这个数量级到数据星型模型的查询速度相比雪花模型没有非常明显的差距，而雪花模型能够帮助我们减少了很多不必要的冗余数据的存储，所以我们选用了雪花模型。我们的数据库设计了实体表与关系表，各个实体表有自己的唯一的主键，实体表之间的联系使用关系表进行关联，减少了很多实体数据的存储，符合第三范式。\n\n- 性能分析：\n\n  在一开始，我们并没有对每个表建立相应的索引，在这种情况下我们单表的query速度在一个可接受的范围内，但是一旦涉及多表联合查询，如查询每个导演执导的电影数量时，需要关联三张表，在这种情况下查询速度非常的慢，因为其中涉及来表的结合与数据的聚合查询。针对联合查询过慢的速度下，我们为每张实体表以及关系表建立主码索引，并且在常用的搜索字段，如电影的上映日期上建立对应的索引，并且在这种大量数据的情况需要先对表建立索引再将数据导入，因为导入数据之后再建立索引会消耗大量的时间。索引建立之后再进行同样的多表联合查询操作，可以发现速度得到了明显的提升，在当前十万级别的数据量下查询耗时基本在五十毫秒之内。所以在MySQL中建立适当的索引能够在很大程度上提升查询的速度，同时也会牺牲一定的查询/更新效率。\n\n  ![ERFinal](/images/ERFinal.png)\n\n\n### Influx\n\n- 操作系统：windows10\n- 硬件：Intel(R) Core(TM) i5-6300HQ CPU @2.30GHz & 8GB RAM\n- 软件：influx1.7.1\n- 选择理由：\n  首先，查询场景中有用到对世界特性比较敏感的数据，例如，根据时间查询等，所以使用influxDB。influxDB继承了LSM Tree的顺序写入的特点，所以写入性能很好（先把大量的数据顺序写，然后持久化到磁盘。）时序数据库每次读取数据都是读取固定series的指定时间范围的连续数据，因为是顺序写入，所以这种读取比较快速。\n- 存储模型简介：\n  influxdb中我们主要存 电影id，电影类别，电影语言，电影观看人数，电影上映时间。其中，将电影类别与电影语言当做tag存储，电影id以及电影观看人数当做field存储，其中上映时间就是时间戳存储。\n- 存储模型：\n ![527DE0D27244EE625AD2D099AACDF4BA](/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png)\n- 性能对比分析：\n  \n  InfluxDB用于存储大量的时间序列数据，并对这些数据进行快速的实时分析。SQL数据库也可以提供时序的功能，但时序并不是其目的。\n  在InfluxDB中，timestamp标识了在任何给定数据series中的单个点。就像关系型数据库中的主键。\n  InfluxDB考虑到schema可能随时间而改变，因此赋予了其便利的动态能力。但是由于在项目中，时间相关的数据较为固定，因此其性能的体现并不是特别好。\n\n### Hive\n\n- 操作系统：macOS Mojave 10.14.1\n\n- 硬件：Core i7 & 16GB RAM\n\n- 软件：Hive 3.1.1 & Hadoop 3.1.1 & MySQL 5.7\n\n- 选择理由：\n\n  Hive首先有很多以上数据库所不具有的优点，如扩展性和容错性，本项目我们选择hive来处理一部分数据主要是作为MySQL数据库的对照。针对我们项目的百万级的数据量来对比分析关系型数据库和分布式数据库在数据量较大时的性能优劣性，以此窥见数据仓库对比于数据库的所展现出来的优点。同时对于项目中的部分功能需求组合采用hive与其他数据库分治的方式，来实现复杂的功能需求，以此来学习工程中数据仓库与普通数据库结合的实现方法。而由于数据量及需求的限制，我们只可窥见数据仓库其作用的冰山一角，希望藉此加深我们对数据仓库的理解。\n\n- 存储模型简介：\n  \n  在hive中我们存储的数据与MySQL中一样。因此建立了与MySQL完全相同的存储结构。另外针对hive本身自带的不同的存储模型，我们还创建了textfile和ORCfile两种表存储结构。\n\n- 分布式架构：\n  \n  ![h](/images/hive_arg.png)\n\n- 性能对比分析：\n\n  \b\b从我们对于MySQL和Hive这两种比较有可比性的数据库之间的对比来说，MySQL的执行时间基本上是远远快于Hive的执行时间的。\n  首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为\"操作\"不是造成二者执行时间差异的原因；\n  其次，Hive官网有句话\b\"Hive在大型数据集上会表现出优越的性能\"，考虑到我们的项目数据集\b中，最多的数据集是700多万条的用户评论数据，而基本功能的实现都是操作在数据量仅有10万余条的电影数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：在等量的数据量变化上，我们比较二者变化前后的执行的时间，得到下表：\n  ![表1](/images/表1.png)\n  就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件，我们创建了t_comment表存储用户评论信息，表数据文件如下：\n  ![h1](/images/hive_textfile1.png)\n  ![h2](/images/hive_textfile2.png)\n  \b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点，我们创建了\bt_comment_orc表，并从t_comment中把数据原封不动的导入进来，可见表数据文件如下：\n  ![h3](/images/hive_orc1.png)\n  不难看到\bORC表文件(260MB)明显比TextFile表文件(705MB)小多了，至于性能，同样对于上述实验，我们添加了ORC表的结果：\n  ![表2](/images/表2.png)\n  结果显而易见，当数据达到\b数百万量级时，Hive**较优**的使用方法下已经要比MySQL要稍显胜势了。\n  通过以上两点以及常识我们不难看出：\n\n  - 限制Hive的效率的因素：\n\n    - 数据量\n\n    - \b计算框架\n\n      Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使\n\n    - 网络通信\n\n      由于我们的集群搭建在Docker容器中，其间数据通过程序写定的程序通道传输而非真实的网络通信，因此暂且看不出网络对执行的影响，而真实场景中，这必是一项重要的考虑因素\n\n  - 百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选\n  - 千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优\n\n  其三，上述操作均是在单表查询的前提下，但是在多表查询情况下Hive的效率如何呢？先看测试结果，我们仅在\"导演-执导-电影\"三表上做了多表查询，执行\"某导演执导电影的数量\"的操作，执行时间记录如下：\n  ![表3](/images/表3.png)\n  此现象引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表是很特殊的，其没有主键、外键同时库中各个表之间的冗余会很明显，这使得\b管理人员方便针对各种功能设计所需的信息表，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一。\n  \n## \b性能对比\n\n![image-20181231003424471](/images/image-20181231003424471.png)![image-20181231003442918](/images/image-20181231003442918-6187682.png)\n\n![image-20181231003457997](/images/image-20181231003457997-6187698.png)![image-20181231003513281](/images/image-20181231003513281-6187713.png)\n\n- 走势变化：\n\n  由图可见，四种数据库中执行时间都是先较多然后减少最后趋于稳定，我们对其分析可能是jdbc在首次连接时需要较多时间进行网络通信，当一次连接建立后，我们并没有关闭该连接，在此基础上程序执行后续的事务才应当是其真实的操作时间。\n\n- 功能对比：\n\n  不同的数据库，在不同的功能需求下各有优劣。举个例子，在查询实体间的关系时，对于完全符合3NF的关系型数据库来说，可能需要多表连接查询，这明显会消耗大量时间，而对于基于relation的数据库例如Neo4j来说，类似查询正是其强项。\n\n## 总结\n\n- 本项目使用了JavaWeb框架，并基于sementicUI进行前端开发。\n- 在数据库选择上，我们使用了Mysql，hive，Neo4j以及influxDB四个不同的数据库进行横向纵向比对，通过实现一定的基本功能搜索以及多表联查，统计他们的性能，查询时间等数据并进行相应的分析，对于不同数据库的优劣势有了更为清晰的了解。\n- 在项目过程中，我们将上课学到的知识应用到实践中，尝试了雪花，星型等不同的存储结构，并根据自己的项目实情选择了最适合我们的项目存储结构。针对不同的实验现象，我们也通过网络等资源来进行辅助学习，帮助我们更好的了解不同数据库以及其不同的存储，读取等方式。\n- 项目过程中，特别感谢老师和助教们的帮助，让我们更为深入了解了数据仓库技术，为我们今后的项目实践打下了扎实的基础。\n\n","source":"_posts/数据仓库期末项目文档.md","raw":"---\ntitle: 数据仓库期末项目文档\ndate: 2018-12-31 17:32:45\ntags:\n  - Neo4j\n\t- MySQL\n  - Influx\n  - Hive\ncategories:\n  - 数据库\n---\n\n## 简介\n\n本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。\n\n<!-- more -->\n\n## 系统架构\n\n### Neo4j\n\n- 操作系统：macOS Mojave 10.14.1\n\n- 硬件：Core i5 & 16GB RAM\n\n- 软件：Neo4j Desktop Version 1.1.10 (1.1.10.436)\n\n- 选择理由：\n  - 高性能：Neo4j以图的遍历算法来帮助查询数据，查询时从一个节点开始，根据其连接的关系，快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。\n  - 灵活性：图数据结构的自然伸展特性及其非结构化的数据格式让Neo4j的数据库设计可以具有很大的伸缩性和灵活性，使其可以随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用，因此在项目后期的推进中，我们也可以不断的快速修改neo4j数据库中的内容来满足我们的查询需求。\n  - 直观性：图数据库使用图的形式作为数据库最主要的展现形式，可以更清楚的帮助我们理解整个数据库中数据之间的联系，Cypher语言的灵活性也帮助我们更轻松的操控数据库\n- 存储模型简介：\n  - 本项目中主要建立了Neo4j的两个不同的库，一个库是围绕电影的相关信息，我们在其中存储了和电影有关的所有信息，包括导演，制片人，演员，类别，语言，字幕，编剧等等，节点与节点之间通过不同的关系相连接。第二个库针对合作关系，分别存储了导演，演员，以及类别，通过节点与节点之间的关系，记录他们彼此的合作次数，类别的引入也帮助我们分析导演的执导风格。\n\n- 存储模型：图\n- 性能对比分析：\n  - 数据存储：Neo4j对于图的存储自然是经过特别优化的。不像传统数据库的一条记录一条数据的存储方式，Neo4j的存储方式是：节点的类别，属性，边的类别，属性等都是分开存储的，这将大大有助于提高图形数据库的性能。在Neo4j 中属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。\n  - 数据读写：在Neo4j中，存储节点时，每个节点都有指向其邻居节点的指针，可以让我们在O(1)的时间内找到邻居节点。另外，按照官方的说法，在Neo4j中边是最重要的,是\"first-class entities\"，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历。邻近查询帮助Neo4j始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。\n\n### MySQL\n\n- 操作系统：macOS Mojave 10.14.1 Beta\n\n- 硬件：Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz/ 4 GB 1600 MHz DDR3\n\n- 软件：Docker 1.13.1/ MySQL 5.7\n\n- 选择理由：\n\n  MySQL是时下使用率最高的几款关系型数据库之一，且其体积相较其他关系型数据库更小巧且性能不输大型关系型数据库。关系型数据库是我们最常接触也是在对数据进行存储时会最先想到的数据库类型。我们想要借助关系型数据库以及行式存储对我们的数据进行存储，并通过对应的数据库操作对存储对数据进行分析/查询，实现我们对应的目的。\n\n- 存储模型简介：\n\n  在本项目中我们选择雪花模型作为我们关系型数据库的存储模型。雪花存储模型使用规范化的数据，数据在数据库内部是组织好的，消除冗余以减少数据量。相比之下，星型模型使用的是反规范化的数据，会在存储时存储大量的冗余数据。规范化存储数据同时也带来查询时间上的消耗，其查询更新速度会慢于星型存储模型。但是考虑到我们项目到数据单表最大12万左右，对于这个数量级到数据星型模型的查询速度相比雪花模型没有非常明显的差距，而雪花模型能够帮助我们减少了很多不必要的冗余数据的存储，所以我们选用了雪花模型。我们的数据库设计了实体表与关系表，各个实体表有自己的唯一的主键，实体表之间的联系使用关系表进行关联，减少了很多实体数据的存储，符合第三范式。\n\n- 性能分析：\n\n  在一开始，我们并没有对每个表建立相应的索引，在这种情况下我们单表的query速度在一个可接受的范围内，但是一旦涉及多表联合查询，如查询每个导演执导的电影数量时，需要关联三张表，在这种情况下查询速度非常的慢，因为其中涉及来表的结合与数据的聚合查询。针对联合查询过慢的速度下，我们为每张实体表以及关系表建立主码索引，并且在常用的搜索字段，如电影的上映日期上建立对应的索引，并且在这种大量数据的情况需要先对表建立索引再将数据导入，因为导入数据之后再建立索引会消耗大量的时间。索引建立之后再进行同样的多表联合查询操作，可以发现速度得到了明显的提升，在当前十万级别的数据量下查询耗时基本在五十毫秒之内。所以在MySQL中建立适当的索引能够在很大程度上提升查询的速度，同时也会牺牲一定的查询/更新效率。\n\n  ![ERFinal](/images/ERFinal.png)\n\n\n### Influx\n\n- 操作系统：windows10\n- 硬件：Intel(R) Core(TM) i5-6300HQ CPU @2.30GHz & 8GB RAM\n- 软件：influx1.7.1\n- 选择理由：\n  首先，查询场景中有用到对世界特性比较敏感的数据，例如，根据时间查询等，所以使用influxDB。influxDB继承了LSM Tree的顺序写入的特点，所以写入性能很好（先把大量的数据顺序写，然后持久化到磁盘。）时序数据库每次读取数据都是读取固定series的指定时间范围的连续数据，因为是顺序写入，所以这种读取比较快速。\n- 存储模型简介：\n  influxdb中我们主要存 电影id，电影类别，电影语言，电影观看人数，电影上映时间。其中，将电影类别与电影语言当做tag存储，电影id以及电影观看人数当做field存储，其中上映时间就是时间戳存储。\n- 存储模型：\n ![527DE0D27244EE625AD2D099AACDF4BA](/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png)\n- 性能对比分析：\n  \n  InfluxDB用于存储大量的时间序列数据，并对这些数据进行快速的实时分析。SQL数据库也可以提供时序的功能，但时序并不是其目的。\n  在InfluxDB中，timestamp标识了在任何给定数据series中的单个点。就像关系型数据库中的主键。\n  InfluxDB考虑到schema可能随时间而改变，因此赋予了其便利的动态能力。但是由于在项目中，时间相关的数据较为固定，因此其性能的体现并不是特别好。\n\n### Hive\n\n- 操作系统：macOS Mojave 10.14.1\n\n- 硬件：Core i7 & 16GB RAM\n\n- 软件：Hive 3.1.1 & Hadoop 3.1.1 & MySQL 5.7\n\n- 选择理由：\n\n  Hive首先有很多以上数据库所不具有的优点，如扩展性和容错性，本项目我们选择hive来处理一部分数据主要是作为MySQL数据库的对照。针对我们项目的百万级的数据量来对比分析关系型数据库和分布式数据库在数据量较大时的性能优劣性，以此窥见数据仓库对比于数据库的所展现出来的优点。同时对于项目中的部分功能需求组合采用hive与其他数据库分治的方式，来实现复杂的功能需求，以此来学习工程中数据仓库与普通数据库结合的实现方法。而由于数据量及需求的限制，我们只可窥见数据仓库其作用的冰山一角，希望藉此加深我们对数据仓库的理解。\n\n- 存储模型简介：\n  \n  在hive中我们存储的数据与MySQL中一样。因此建立了与MySQL完全相同的存储结构。另外针对hive本身自带的不同的存储模型，我们还创建了textfile和ORCfile两种表存储结构。\n\n- 分布式架构：\n  \n  ![h](/images/hive_arg.png)\n\n- 性能对比分析：\n\n  \b\b从我们对于MySQL和Hive这两种比较有可比性的数据库之间的对比来说，MySQL的执行时间基本上是远远快于Hive的执行时间的。\n  首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为\"操作\"不是造成二者执行时间差异的原因；\n  其次，Hive官网有句话\b\"Hive在大型数据集上会表现出优越的性能\"，考虑到我们的项目数据集\b中，最多的数据集是700多万条的用户评论数据，而基本功能的实现都是操作在数据量仅有10万余条的电影数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：在等量的数据量变化上，我们比较二者变化前后的执行的时间，得到下表：\n  ![表1](/images/表1.png)\n  就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件，我们创建了t_comment表存储用户评论信息，表数据文件如下：\n  ![h1](/images/hive_textfile1.png)\n  ![h2](/images/hive_textfile2.png)\n  \b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点，我们创建了\bt_comment_orc表，并从t_comment中把数据原封不动的导入进来，可见表数据文件如下：\n  ![h3](/images/hive_orc1.png)\n  不难看到\bORC表文件(260MB)明显比TextFile表文件(705MB)小多了，至于性能，同样对于上述实验，我们添加了ORC表的结果：\n  ![表2](/images/表2.png)\n  结果显而易见，当数据达到\b数百万量级时，Hive**较优**的使用方法下已经要比MySQL要稍显胜势了。\n  通过以上两点以及常识我们不难看出：\n\n  - 限制Hive的效率的因素：\n\n    - 数据量\n\n    - \b计算框架\n\n      Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使\n\n    - 网络通信\n\n      由于我们的集群搭建在Docker容器中，其间数据通过程序写定的程序通道传输而非真实的网络通信，因此暂且看不出网络对执行的影响，而真实场景中，这必是一项重要的考虑因素\n\n  - 百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选\n  - 千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优\n\n  其三，上述操作均是在单表查询的前提下，但是在多表查询情况下Hive的效率如何呢？先看测试结果，我们仅在\"导演-执导-电影\"三表上做了多表查询，执行\"某导演执导电影的数量\"的操作，执行时间记录如下：\n  ![表3](/images/表3.png)\n  此现象引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表是很特殊的，其没有主键、外键同时库中各个表之间的冗余会很明显，这使得\b管理人员方便针对各种功能设计所需的信息表，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一。\n  \n## \b性能对比\n\n![image-20181231003424471](/images/image-20181231003424471.png)![image-20181231003442918](/images/image-20181231003442918-6187682.png)\n\n![image-20181231003457997](/images/image-20181231003457997-6187698.png)![image-20181231003513281](/images/image-20181231003513281-6187713.png)\n\n- 走势变化：\n\n  由图可见，四种数据库中执行时间都是先较多然后减少最后趋于稳定，我们对其分析可能是jdbc在首次连接时需要较多时间进行网络通信，当一次连接建立后，我们并没有关闭该连接，在此基础上程序执行后续的事务才应当是其真实的操作时间。\n\n- 功能对比：\n\n  不同的数据库，在不同的功能需求下各有优劣。举个例子，在查询实体间的关系时，对于完全符合3NF的关系型数据库来说，可能需要多表连接查询，这明显会消耗大量时间，而对于基于relation的数据库例如Neo4j来说，类似查询正是其强项。\n\n## 总结\n\n- 本项目使用了JavaWeb框架，并基于sementicUI进行前端开发。\n- 在数据库选择上，我们使用了Mysql，hive，Neo4j以及influxDB四个不同的数据库进行横向纵向比对，通过实现一定的基本功能搜索以及多表联查，统计他们的性能，查询时间等数据并进行相应的分析，对于不同数据库的优劣势有了更为清晰的了解。\n- 在项目过程中，我们将上课学到的知识应用到实践中，尝试了雪花，星型等不同的存储结构，并根据自己的项目实情选择了最适合我们的项目存储结构。针对不同的实验现象，我们也通过网络等资源来进行辅助学习，帮助我们更好的了解不同数据库以及其不同的存储，读取等方式。\n- 项目过程中，特别感谢老师和助教们的帮助，让我们更为深入了解了数据仓库技术，为我们今后的项目实践打下了扎实的基础。\n\n","slug":"数据仓库期末项目文档","published":1,"updated":"2021-05-16T11:00:38.152Z","_id":"ckfukja9w0017szxoqfcc2l9h","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。</p>\n<a id=\"more\"></a>\n<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"Neo4j\"><a href=\"#Neo4j\" class=\"headerlink\" title=\"Neo4j\"></a>Neo4j</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1</p>\n</li>\n<li><p>硬件：Core i5 &amp; 16GB RAM</p>\n</li>\n<li><p>软件：Neo4j Desktop Version 1.1.10 (1.1.10.436)</p>\n</li>\n<li><p>选择理由：</p>\n<ul>\n<li>高性能：Neo4j以图的遍历算法来帮助查询数据，查询时从一个节点开始，根据其连接的关系，快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li>\n<li>灵活性：图数据结构的自然伸展特性及其非结构化的数据格式让Neo4j的数据库设计可以具有很大的伸缩性和灵活性，使其可以随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用，因此在项目后期的推进中，我们也可以不断的快速修改neo4j数据库中的内容来满足我们的查询需求。</li>\n<li>直观性：图数据库使用图的形式作为数据库最主要的展现形式，可以更清楚的帮助我们理解整个数据库中数据之间的联系，Cypher语言的灵活性也帮助我们更轻松的操控数据库</li>\n</ul>\n</li>\n<li><p>存储模型简介：</p>\n<ul>\n<li>本项目中主要建立了Neo4j的两个不同的库，一个库是围绕电影的相关信息，我们在其中存储了和电影有关的所有信息，包括导演，制片人，演员，类别，语言，字幕，编剧等等，节点与节点之间通过不同的关系相连接。第二个库针对合作关系，分别存储了导演，演员，以及类别，通过节点与节点之间的关系，记录他们彼此的合作次数，类别的引入也帮助我们分析导演的执导风格。</li>\n</ul>\n</li>\n<li><p>存储模型：图</p>\n</li>\n<li>性能对比分析：<ul>\n<li>数据存储：Neo4j对于图的存储自然是经过特别优化的。不像传统数据库的一条记录一条数据的存储方式，Neo4j的存储方式是：节点的类别，属性，边的类别，属性等都是分开存储的，这将大大有助于提高图形数据库的性能。在Neo4j 中属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。</li>\n<li>数据读写：在Neo4j中，存储节点时，每个节点都有指向其邻居节点的指针，可以让我们在O(1)的时间内找到邻居节点。另外，按照官方的说法，在Neo4j中边是最重要的,是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历。邻近查询帮助Neo4j始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1 Beta</p>\n</li>\n<li><p>硬件：Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz/ 4 GB 1600 MHz DDR3</p>\n</li>\n<li><p>软件：Docker 1.13.1/ MySQL 5.7</p>\n</li>\n<li><p>选择理由：</p>\n<p>MySQL是时下使用率最高的几款关系型数据库之一，且其体积相较其他关系型数据库更小巧且性能不输大型关系型数据库。关系型数据库是我们最常接触也是在对数据进行存储时会最先想到的数据库类型。我们想要借助关系型数据库以及行式存储对我们的数据进行存储，并通过对应的数据库操作对存储对数据进行分析/查询，实现我们对应的目的。</p>\n</li>\n<li><p>存储模型简介：</p>\n<p>在本项目中我们选择雪花模型作为我们关系型数据库的存储模型。雪花存储模型使用规范化的数据，数据在数据库内部是组织好的，消除冗余以减少数据量。相比之下，星型模型使用的是反规范化的数据，会在存储时存储大量的冗余数据。规范化存储数据同时也带来查询时间上的消耗，其查询更新速度会慢于星型存储模型。但是考虑到我们项目到数据单表最大12万左右，对于这个数量级到数据星型模型的查询速度相比雪花模型没有非常明显的差距，而雪花模型能够帮助我们减少了很多不必要的冗余数据的存储，所以我们选用了雪花模型。我们的数据库设计了实体表与关系表，各个实体表有自己的唯一的主键，实体表之间的联系使用关系表进行关联，减少了很多实体数据的存储，符合第三范式。</p>\n</li>\n<li><p>性能分析：</p>\n<p>在一开始，我们并没有对每个表建立相应的索引，在这种情况下我们单表的query速度在一个可接受的范围内，但是一旦涉及多表联合查询，如查询每个导演执导的电影数量时，需要关联三张表，在这种情况下查询速度非常的慢，因为其中涉及来表的结合与数据的聚合查询。针对联合查询过慢的速度下，我们为每张实体表以及关系表建立主码索引，并且在常用的搜索字段，如电影的上映日期上建立对应的索引，并且在这种大量数据的情况需要先对表建立索引再将数据导入，因为导入数据之后再建立索引会消耗大量的时间。索引建立之后再进行同样的多表联合查询操作，可以发现速度得到了明显的提升，在当前十万级别的数据量下查询耗时基本在五十毫秒之内。所以在MySQL中建立适当的索引能够在很大程度上提升查询的速度，同时也会牺牲一定的查询/更新效率。</p>\n<p><img src=\"/images/ERFinal.png\" alt=\"ERFinal\"></p>\n</li>\n</ul>\n<h3 id=\"Influx\"><a href=\"#Influx\" class=\"headerlink\" title=\"Influx\"></a>Influx</h3><ul>\n<li>操作系统：windows10</li>\n<li>硬件：Intel(R) Core(TM) i5-6300HQ CPU @2.30GHz &amp; 8GB RAM</li>\n<li>软件：influx1.7.1</li>\n<li>选择理由：<br>首先，查询场景中有用到对世界特性比较敏感的数据，例如，根据时间查询等，所以使用influxDB。influxDB继承了LSM Tree的顺序写入的特点，所以写入性能很好（先把大量的数据顺序写，然后持久化到磁盘。）时序数据库每次读取数据都是读取固定series的指定时间范围的连续数据，因为是顺序写入，所以这种读取比较快速。</li>\n<li>存储模型简介：<br>influxdb中我们主要存 电影id，电影类别，电影语言，电影观看人数，电影上映时间。其中，将电影类别与电影语言当做tag存储，电影id以及电影观看人数当做field存储，其中上映时间就是时间戳存储。</li>\n<li>存储模型：<br><img src=\"/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png\" alt=\"527DE0D27244EE625AD2D099AACDF4BA\"></li>\n<li><p>性能对比分析：</p>\n<p>InfluxDB用于存储大量的时间序列数据，并对这些数据进行快速的实时分析。SQL数据库也可以提供时序的功能，但时序并不是其目的。<br>在InfluxDB中，timestamp标识了在任何给定数据series中的单个点。就像关系型数据库中的主键。<br>InfluxDB考虑到schema可能随时间而改变，因此赋予了其便利的动态能力。但是由于在项目中，时间相关的数据较为固定，因此其性能的体现并不是特别好。</p>\n</li>\n</ul>\n<h3 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1</p>\n</li>\n<li><p>硬件：Core i7 &amp; 16GB RAM</p>\n</li>\n<li><p>软件：Hive 3.1.1 &amp; Hadoop 3.1.1 &amp; MySQL 5.7</p>\n</li>\n<li><p>选择理由：</p>\n<p>Hive首先有很多以上数据库所不具有的优点，如扩展性和容错性，本项目我们选择hive来处理一部分数据主要是作为MySQL数据库的对照。针对我们项目的百万级的数据量来对比分析关系型数据库和分布式数据库在数据量较大时的性能优劣性，以此窥见数据仓库对比于数据库的所展现出来的优点。同时对于项目中的部分功能需求组合采用hive与其他数据库分治的方式，来实现复杂的功能需求，以此来学习工程中数据仓库与普通数据库结合的实现方法。而由于数据量及需求的限制，我们只可窥见数据仓库其作用的冰山一角，希望藉此加深我们对数据仓库的理解。</p>\n</li>\n<li><p>存储模型简介：</p>\n<p>在hive中我们存储的数据与MySQL中一样。因此建立了与MySQL完全相同的存储结构。另外针对hive本身自带的不同的存储模型，我们还创建了textfile和ORCfile两种表存储结构。</p>\n</li>\n<li><p>分布式架构：</p>\n<p><img src=\"/images/hive_arg.png\" alt=\"h\"></p>\n</li>\n<li><p>性能对比分析：</p>\n<p>\b\b从我们对于MySQL和Hive这两种比较有可比性的数据库之间的对比来说，MySQL的执行时间基本上是远远快于Hive的执行时间的。<br>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；<br>其次，Hive官网有句话\b”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集\b中，最多的数据集是700多万条的用户评论数据，而基本功能的实现都是操作在数据量仅有10万余条的电影数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：在等量的数据量变化上，我们比较二者变化前后的执行的时间，得到下表：<br><img src=\"/images/表1.png\" alt=\"表1\"><br>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件，我们创建了t_comment表存储用户评论信息，表数据文件如下：<br><img src=\"/images/hive_textfile1.png\" alt=\"h1\"><br><img src=\"/images/hive_textfile2.png\" alt=\"h2\"><br>\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点，我们创建了\bt_comment_orc表，并从t_comment中把数据原封不动的导入进来，可见表数据文件如下：<br><img src=\"/images/hive_orc1.png\" alt=\"h3\"><br>不难看到\bORC表文件(260MB)明显比TextFile表文件(705MB)小多了，至于性能，同样对于上述实验，我们添加了ORC表的结果：<br><img src=\"/images/表2.png\" alt=\"表2\"><br>结果显而易见，当数据达到\b数百万量级时，Hive<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。<br>通过以上两点以及常识我们不难看出：</p>\n<ul>\n<li><p>限制Hive的效率的因素：</p>\n<ul>\n<li><p>数据量</p>\n</li>\n<li><p>\b计算框架</p>\n<p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使</p>\n</li>\n<li><p>网络通信</p>\n<p>由于我们的集群搭建在Docker容器中，其间数据通过程序写定的程序通道传输而非真实的网络通信，因此暂且看不出网络对执行的影响，而真实场景中，这必是一项重要的考虑因素</p>\n</li>\n</ul>\n</li>\n<li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p>\n</li>\n<li>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</li>\n</ul>\n<p>其三，上述操作均是在单表查询的前提下，但是在多表查询情况下Hive的效率如何呢？先看测试结果，我们仅在”导演-执导-电影”三表上做了多表查询，执行”某导演执导电影的数量”的操作，执行时间记录如下：<br><img src=\"/images/表3.png\" alt=\"表3\"><br>此现象引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表是很特殊的，其没有主键、外键同时库中各个表之间的冗余会很明显，这使得\b管理人员方便针对各种功能设计所需的信息表，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一。</p>\n</li>\n</ul>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"\b性能对比\"></a>\b性能对比</h2><p><img src=\"/images/image-20181231003424471.png\" alt=\"image-20181231003424471\"><img src=\"/images/image-20181231003442918-6187682.png\" alt=\"image-20181231003442918\"></p>\n<p><img src=\"/images/image-20181231003457997-6187698.png\" alt=\"image-20181231003457997\"><img src=\"/images/image-20181231003513281-6187713.png\" alt=\"image-20181231003513281\"></p>\n<ul>\n<li><p>走势变化：</p>\n<p>由图可见，四种数据库中执行时间都是先较多然后减少最后趋于稳定，我们对其分析可能是jdbc在首次连接时需要较多时间进行网络通信，当一次连接建立后，我们并没有关闭该连接，在此基础上程序执行后续的事务才应当是其真实的操作时间。</p>\n</li>\n<li><p>功能对比：</p>\n<p>不同的数据库，在不同的功能需求下各有优劣。举个例子，在查询实体间的关系时，对于完全符合3NF的关系型数据库来说，可能需要多表连接查询，这明显会消耗大量时间，而对于基于relation的数据库例如Neo4j来说，类似查询正是其强项。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>本项目使用了JavaWeb框架，并基于sementicUI进行前端开发。</li>\n<li>在数据库选择上，我们使用了Mysql，hive，Neo4j以及influxDB四个不同的数据库进行横向纵向比对，通过实现一定的基本功能搜索以及多表联查，统计他们的性能，查询时间等数据并进行相应的分析，对于不同数据库的优劣势有了更为清晰的了解。</li>\n<li>在项目过程中，我们将上课学到的知识应用到实践中，尝试了雪花，星型等不同的存储结构，并根据自己的项目实情选择了最适合我们的项目存储结构。针对不同的实验现象，我们也通过网络等资源来进行辅助学习，帮助我们更好的了解不同数据库以及其不同的存储，读取等方式。</li>\n<li>项目过程中，特别感谢老师和助教们的帮助，让我们更为深入了解了数据仓库技术，为我们今后的项目实践打下了扎实的基础。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。</p>","more":"<h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"Neo4j\"><a href=\"#Neo4j\" class=\"headerlink\" title=\"Neo4j\"></a>Neo4j</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1</p>\n</li>\n<li><p>硬件：Core i5 &amp; 16GB RAM</p>\n</li>\n<li><p>软件：Neo4j Desktop Version 1.1.10 (1.1.10.436)</p>\n</li>\n<li><p>选择理由：</p>\n<ul>\n<li>高性能：Neo4j以图的遍历算法来帮助查询数据，查询时从一个节点开始，根据其连接的关系，快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li>\n<li>灵活性：图数据结构的自然伸展特性及其非结构化的数据格式让Neo4j的数据库设计可以具有很大的伸缩性和灵活性，使其可以随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用，因此在项目后期的推进中，我们也可以不断的快速修改neo4j数据库中的内容来满足我们的查询需求。</li>\n<li>直观性：图数据库使用图的形式作为数据库最主要的展现形式，可以更清楚的帮助我们理解整个数据库中数据之间的联系，Cypher语言的灵活性也帮助我们更轻松的操控数据库</li>\n</ul>\n</li>\n<li><p>存储模型简介：</p>\n<ul>\n<li>本项目中主要建立了Neo4j的两个不同的库，一个库是围绕电影的相关信息，我们在其中存储了和电影有关的所有信息，包括导演，制片人，演员，类别，语言，字幕，编剧等等，节点与节点之间通过不同的关系相连接。第二个库针对合作关系，分别存储了导演，演员，以及类别，通过节点与节点之间的关系，记录他们彼此的合作次数，类别的引入也帮助我们分析导演的执导风格。</li>\n</ul>\n</li>\n<li><p>存储模型：图</p>\n</li>\n<li>性能对比分析：<ul>\n<li>数据存储：Neo4j对于图的存储自然是经过特别优化的。不像传统数据库的一条记录一条数据的存储方式，Neo4j的存储方式是：节点的类别，属性，边的类别，属性等都是分开存储的，这将大大有助于提高图形数据库的性能。在Neo4j 中属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。</li>\n<li>数据读写：在Neo4j中，存储节点时，每个节点都有指向其邻居节点的指针，可以让我们在O(1)的时间内找到邻居节点。另外，按照官方的说法，在Neo4j中边是最重要的,是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历。邻近查询帮助Neo4j始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1 Beta</p>\n</li>\n<li><p>硬件：Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz/ 4 GB 1600 MHz DDR3</p>\n</li>\n<li><p>软件：Docker 1.13.1/ MySQL 5.7</p>\n</li>\n<li><p>选择理由：</p>\n<p>MySQL是时下使用率最高的几款关系型数据库之一，且其体积相较其他关系型数据库更小巧且性能不输大型关系型数据库。关系型数据库是我们最常接触也是在对数据进行存储时会最先想到的数据库类型。我们想要借助关系型数据库以及行式存储对我们的数据进行存储，并通过对应的数据库操作对存储对数据进行分析/查询，实现我们对应的目的。</p>\n</li>\n<li><p>存储模型简介：</p>\n<p>在本项目中我们选择雪花模型作为我们关系型数据库的存储模型。雪花存储模型使用规范化的数据，数据在数据库内部是组织好的，消除冗余以减少数据量。相比之下，星型模型使用的是反规范化的数据，会在存储时存储大量的冗余数据。规范化存储数据同时也带来查询时间上的消耗，其查询更新速度会慢于星型存储模型。但是考虑到我们项目到数据单表最大12万左右，对于这个数量级到数据星型模型的查询速度相比雪花模型没有非常明显的差距，而雪花模型能够帮助我们减少了很多不必要的冗余数据的存储，所以我们选用了雪花模型。我们的数据库设计了实体表与关系表，各个实体表有自己的唯一的主键，实体表之间的联系使用关系表进行关联，减少了很多实体数据的存储，符合第三范式。</p>\n</li>\n<li><p>性能分析：</p>\n<p>在一开始，我们并没有对每个表建立相应的索引，在这种情况下我们单表的query速度在一个可接受的范围内，但是一旦涉及多表联合查询，如查询每个导演执导的电影数量时，需要关联三张表，在这种情况下查询速度非常的慢，因为其中涉及来表的结合与数据的聚合查询。针对联合查询过慢的速度下，我们为每张实体表以及关系表建立主码索引，并且在常用的搜索字段，如电影的上映日期上建立对应的索引，并且在这种大量数据的情况需要先对表建立索引再将数据导入，因为导入数据之后再建立索引会消耗大量的时间。索引建立之后再进行同样的多表联合查询操作，可以发现速度得到了明显的提升，在当前十万级别的数据量下查询耗时基本在五十毫秒之内。所以在MySQL中建立适当的索引能够在很大程度上提升查询的速度，同时也会牺牲一定的查询/更新效率。</p>\n<p><img src=\"/images/ERFinal.png\" alt=\"ERFinal\"></p>\n</li>\n</ul>\n<h3 id=\"Influx\"><a href=\"#Influx\" class=\"headerlink\" title=\"Influx\"></a>Influx</h3><ul>\n<li>操作系统：windows10</li>\n<li>硬件：Intel(R) Core(TM) i5-6300HQ CPU @2.30GHz &amp; 8GB RAM</li>\n<li>软件：influx1.7.1</li>\n<li>选择理由：<br>首先，查询场景中有用到对世界特性比较敏感的数据，例如，根据时间查询等，所以使用influxDB。influxDB继承了LSM Tree的顺序写入的特点，所以写入性能很好（先把大量的数据顺序写，然后持久化到磁盘。）时序数据库每次读取数据都是读取固定series的指定时间范围的连续数据，因为是顺序写入，所以这种读取比较快速。</li>\n<li>存储模型简介：<br>influxdb中我们主要存 电影id，电影类别，电影语言，电影观看人数，电影上映时间。其中，将电影类别与电影语言当做tag存储，电影id以及电影观看人数当做field存储，其中上映时间就是时间戳存储。</li>\n<li>存储模型：<br><img src=\"/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png\" alt=\"527DE0D27244EE625AD2D099AACDF4BA\"></li>\n<li><p>性能对比分析：</p>\n<p>InfluxDB用于存储大量的时间序列数据，并对这些数据进行快速的实时分析。SQL数据库也可以提供时序的功能，但时序并不是其目的。<br>在InfluxDB中，timestamp标识了在任何给定数据series中的单个点。就像关系型数据库中的主键。<br>InfluxDB考虑到schema可能随时间而改变，因此赋予了其便利的动态能力。但是由于在项目中，时间相关的数据较为固定，因此其性能的体现并不是特别好。</p>\n</li>\n</ul>\n<h3 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h3><ul>\n<li><p>操作系统：macOS Mojave 10.14.1</p>\n</li>\n<li><p>硬件：Core i7 &amp; 16GB RAM</p>\n</li>\n<li><p>软件：Hive 3.1.1 &amp; Hadoop 3.1.1 &amp; MySQL 5.7</p>\n</li>\n<li><p>选择理由：</p>\n<p>Hive首先有很多以上数据库所不具有的优点，如扩展性和容错性，本项目我们选择hive来处理一部分数据主要是作为MySQL数据库的对照。针对我们项目的百万级的数据量来对比分析关系型数据库和分布式数据库在数据量较大时的性能优劣性，以此窥见数据仓库对比于数据库的所展现出来的优点。同时对于项目中的部分功能需求组合采用hive与其他数据库分治的方式，来实现复杂的功能需求，以此来学习工程中数据仓库与普通数据库结合的实现方法。而由于数据量及需求的限制，我们只可窥见数据仓库其作用的冰山一角，希望藉此加深我们对数据仓库的理解。</p>\n</li>\n<li><p>存储模型简介：</p>\n<p>在hive中我们存储的数据与MySQL中一样。因此建立了与MySQL完全相同的存储结构。另外针对hive本身自带的不同的存储模型，我们还创建了textfile和ORCfile两种表存储结构。</p>\n</li>\n<li><p>分布式架构：</p>\n<p><img src=\"/images/hive_arg.png\" alt=\"h\"></p>\n</li>\n<li><p>性能对比分析：</p>\n<p>\b\b从我们对于MySQL和Hive这两种比较有可比性的数据库之间的对比来说，MySQL的执行时间基本上是远远快于Hive的执行时间的。<br>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；<br>其次，Hive官网有句话\b”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集\b中，最多的数据集是700多万条的用户评论数据，而基本功能的实现都是操作在数据量仅有10万余条的电影数据，我们猜测是数据量限制了Hive体现其\b优越性。因此我们作了如下实验：在等量的数据量变化上，我们比较二者变化前后的执行的时间，得到下表：<br><img src=\"/images/表1.png\" alt=\"表1\"><br>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而\bHive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。然而在这过程中，\b我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件，我们创建了t_comment表存储用户评论信息，表数据文件如下：<br><img src=\"/images/hive_textfile1.png\" alt=\"h1\"><br><img src=\"/images/hive_textfile2.png\" alt=\"h2\"><br>\b从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点，我们创建了\bt_comment_orc表，并从t_comment中把数据原封不动的导入进来，可见表数据文件如下：<br><img src=\"/images/hive_orc1.png\" alt=\"h3\"><br>不难看到\bORC表文件(260MB)明显比TextFile表文件(705MB)小多了，至于性能，同样对于上述实验，我们添加了ORC表的结果：<br><img src=\"/images/表2.png\" alt=\"表2\"><br>结果显而易见，当数据达到\b数百万量级时，Hive<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。<br>通过以上两点以及常识我们不难看出：</p>\n<ul>\n<li><p>限制Hive的效率的因素：</p>\n<ul>\n<li><p>数据量</p>\n</li>\n<li><p>\b计算框架</p>\n<p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比\b现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使</p>\n</li>\n<li><p>网络通信</p>\n<p>由于我们的集群搭建在Docker容器中，其间数据通过程序写定的程序通道传输而非真实的网络通信，因此暂且看不出网络对执行的影响，而真实场景中，这必是一项重要的考虑因素</p>\n</li>\n</ul>\n</li>\n<li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p>\n</li>\n<li>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</li>\n</ul>\n<p>其三，上述操作均是在单表查询的前提下，但是在多表查询情况下Hive的效率如何呢？先看测试结果，我们仅在”导演-执导-电影”三表上做了多表查询，执行”某导演执导电影的数量”的操作，执行时间记录如下：<br><img src=\"/images/表3.png\" alt=\"表3\"><br>此现象引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表是很特殊的，其没有主键、外键同时库中各个表之间的冗余会很明显，这使得\b管理人员方便针对各种功能设计所需的信息表，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一。</p>\n</li>\n</ul>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"\b性能对比\"></a>\b性能对比</h2><p><img src=\"/images/image-20181231003424471.png\" alt=\"image-20181231003424471\"><img src=\"/images/image-20181231003442918-6187682.png\" alt=\"image-20181231003442918\"></p>\n<p><img src=\"/images/image-20181231003457997-6187698.png\" alt=\"image-20181231003457997\"><img src=\"/images/image-20181231003513281-6187713.png\" alt=\"image-20181231003513281\"></p>\n<ul>\n<li><p>走势变化：</p>\n<p>由图可见，四种数据库中执行时间都是先较多然后减少最后趋于稳定，我们对其分析可能是jdbc在首次连接时需要较多时间进行网络通信，当一次连接建立后，我们并没有关闭该连接，在此基础上程序执行后续的事务才应当是其真实的操作时间。</p>\n</li>\n<li><p>功能对比：</p>\n<p>不同的数据库，在不同的功能需求下各有优劣。举个例子，在查询实体间的关系时，对于完全符合3NF的关系型数据库来说，可能需要多表连接查询，这明显会消耗大量时间，而对于基于relation的数据库例如Neo4j来说，类似查询正是其强项。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>本项目使用了JavaWeb框架，并基于sementicUI进行前端开发。</li>\n<li>在数据库选择上，我们使用了Mysql，hive，Neo4j以及influxDB四个不同的数据库进行横向纵向比对，通过实现一定的基本功能搜索以及多表联查，统计他们的性能，查询时间等数据并进行相应的分析，对于不同数据库的优劣势有了更为清晰的了解。</li>\n<li>在项目过程中，我们将上课学到的知识应用到实践中，尝试了雪花，星型等不同的存储结构，并根据自己的项目实情选择了最适合我们的项目存储结构。针对不同的实验现象，我们也通过网络等资源来进行辅助学习，帮助我们更好的了解不同数据库以及其不同的存储，读取等方式。</li>\n<li>项目过程中，特别感谢老师和助教们的帮助，让我们更为深入了解了数据仓库技术，为我们今后的项目实践打下了扎实的基础。</li>\n</ul>"},{"title":"记一次Win10+Fedora双系统的小折腾","date":"2018-11-06T13:21:10.000Z","_content":"\n### 问题描述\n\n因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。\n我在Google上搜了类似的问题，大多是诸如以下的原因：\n\n<!-- more -->\n\n- 主板供电不足（我使用的是台式机应该不会有这个问题）\n- BIOS中系统时间不正确（我也未曾修改过该时间）\n\n这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在\n\n### 问题出现的环境背景及自己尝试过哪些方法\n\n#### 系统相关信息：\n\n主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中）\n\n#### 尝试过得方法：\n\n 1. 曾使用PE系统中的引导修复工具修复Win10引导，无果\n 2. 在Fedora中安装了`grub工具`尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件`\\Windows\\System32\\winload.efi`上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性）\n 3. 至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果\n\n### 问题截图\n\n![Win10报错](/images/bVbjaD6.jpeg)\n\n如上所示，错误信息提示文件`\\Windows\\System32\\winload.efi`出错，导致我一直陷入找`winload.efi`文件错误的怪圈。\n\n### 问题解决方法\n\n鼓捣大半天，我仍然无法解决此问题，便在[SegmentFault](https://segmentfault.com/q/1010000016923264)上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主[冯恒智](https://segmentfault.com/u/fenghengzhi/)，一言点睛。\n\n#### 具体解决方法如下（划重点）：\n\n在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的**【启动设备】**项下的**启动磁盘**和**启动分区**项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见[此博客](https://blog.csdn.net/testcs_dn/article/details/47904937)）。\n\n![bootice选项](/images/image-20181106214511931.png)\n\n#### 疑问：\n\n我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的**启动磁盘**和**启动分区**两项，而其他都未曾影响？待解……\n\n#### 就很玄学（挠头\n\n#### 11月7日更新\n\nSegmentFault上的答主[冯恒智](https://segmentfault.com/u/fenghengzhi/)又回复了我的问题，如下：\n> 并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了\n","source":"_posts/记一次Win10-Fedora双系统的小折腾.md","raw":"---\ntitle: 记一次Win10+Fedora双系统的小折腾\ndate: 2018-11-06 21:21:10\ntags:\n    - Win10\n    - Linux\n    - 双系统\n    - 引导修复\ncategories:\n    - 小折腾\n---\n\n### 问题描述\n\n因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。\n我在Google上搜了类似的问题，大多是诸如以下的原因：\n\n<!-- more -->\n\n- 主板供电不足（我使用的是台式机应该不会有这个问题）\n- BIOS中系统时间不正确（我也未曾修改过该时间）\n\n这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在\n\n### 问题出现的环境背景及自己尝试过哪些方法\n\n#### 系统相关信息：\n\n主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中）\n\n#### 尝试过得方法：\n\n 1. 曾使用PE系统中的引导修复工具修复Win10引导，无果\n 2. 在Fedora中安装了`grub工具`尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件`\\Windows\\System32\\winload.efi`上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性）\n 3. 至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果\n\n### 问题截图\n\n![Win10报错](/images/bVbjaD6.jpeg)\n\n如上所示，错误信息提示文件`\\Windows\\System32\\winload.efi`出错，导致我一直陷入找`winload.efi`文件错误的怪圈。\n\n### 问题解决方法\n\n鼓捣大半天，我仍然无法解决此问题，便在[SegmentFault](https://segmentfault.com/q/1010000016923264)上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主[冯恒智](https://segmentfault.com/u/fenghengzhi/)，一言点睛。\n\n#### 具体解决方法如下（划重点）：\n\n在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的**【启动设备】**项下的**启动磁盘**和**启动分区**项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见[此博客](https://blog.csdn.net/testcs_dn/article/details/47904937)）。\n\n![bootice选项](/images/image-20181106214511931.png)\n\n#### 疑问：\n\n我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的**启动磁盘**和**启动分区**两项，而其他都未曾影响？待解……\n\n#### 就很玄学（挠头\n\n#### 11月7日更新\n\nSegmentFault上的答主[冯恒智](https://segmentfault.com/u/fenghengzhi/)又回复了我的问题，如下：\n> 并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了\n","slug":"记一次Win10-Fedora双系统的小折腾","published":1,"updated":"2021-05-16T10:40:31.564Z","_id":"ckfukja9y0019szxo4pb96nxk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。<br>我在Google上搜了类似的问题，大多是诸如以下的原因：</p>\n<a id=\"more\"></a>\n<ul>\n<li>主板供电不足（我使用的是台式机应该不会有这个问题）</li>\n<li>BIOS中系统时间不正确（我也未曾修改过该时间）</li>\n</ul>\n<p>这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在</p>\n<h3 id=\"问题出现的环境背景及自己尝试过哪些方法\"><a href=\"#问题出现的环境背景及自己尝试过哪些方法\" class=\"headerlink\" title=\"问题出现的环境背景及自己尝试过哪些方法\"></a>问题出现的环境背景及自己尝试过哪些方法</h3><h4 id=\"系统相关信息：\"><a href=\"#系统相关信息：\" class=\"headerlink\" title=\"系统相关信息：\"></a>系统相关信息：</h4><p>主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中）</p>\n<h4 id=\"尝试过得方法：\"><a href=\"#尝试过得方法：\" class=\"headerlink\" title=\"尝试过得方法：\"></a>尝试过得方法：</h4><ol>\n<li>曾使用PE系统中的引导修复工具修复Win10引导，无果</li>\n<li>在Fedora中安装了<code>grub工具</code>尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件<code>\\Windows\\System32\\winload.efi</code>上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性）</li>\n<li>至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果</li>\n</ol>\n<h3 id=\"问题截图\"><a href=\"#问题截图\" class=\"headerlink\" title=\"问题截图\"></a>问题截图</h3><p><img src=\"/images/bVbjaD6.jpeg\" alt=\"Win10报错\"></p>\n<p>如上所示，错误信息提示文件<code>\\Windows\\System32\\winload.efi</code>出错，导致我一直陷入找<code>winload.efi</code>文件错误的怪圈。</p>\n<h3 id=\"问题解决方法\"><a href=\"#问题解决方法\" class=\"headerlink\" title=\"问题解决方法\"></a>问题解决方法</h3><p>鼓捣大半天，我仍然无法解决此问题，便在<a href=\"https://segmentfault.com/q/1010000016923264\" target=\"_blank\" rel=\"noopener\">SegmentFault</a>上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主<a href=\"https://segmentfault.com/u/fenghengzhi/\" target=\"_blank\" rel=\"noopener\">冯恒智</a>，一言点睛。</p>\n<h4 id=\"具体解决方法如下（划重点）：\"><a href=\"#具体解决方法如下（划重点）：\" class=\"headerlink\" title=\"具体解决方法如下（划重点）：\"></a>具体解决方法如下（划重点）：</h4><p>在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的<strong>【启动设备】</strong>项下的<strong>启动磁盘</strong>和<strong>启动分区</strong>项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见<a href=\"https://blog.csdn.net/testcs_dn/article/details/47904937\" target=\"_blank\" rel=\"noopener\">此博客</a>）。</p>\n<p><img src=\"/images/image-20181106214511931.png\" alt=\"bootice选项\"></p>\n<h4 id=\"疑问：\"><a href=\"#疑问：\" class=\"headerlink\" title=\"疑问：\"></a>疑问：</h4><p>我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的<strong>启动磁盘</strong>和<strong>启动分区</strong>两项，而其他都未曾影响？待解……</p>\n<h4 id=\"就很玄学（挠头\"><a href=\"#就很玄学（挠头\" class=\"headerlink\" title=\"就很玄学（挠头\"></a>就很玄学（挠头</h4><h4 id=\"11月7日更新\"><a href=\"#11月7日更新\" class=\"headerlink\" title=\"11月7日更新\"></a>11月7日更新</h4><p>SegmentFault上的答主<a href=\"https://segmentfault.com/u/fenghengzhi/\" target=\"_blank\" rel=\"noopener\">冯恒智</a>又回复了我的问题，如下：</p>\n<blockquote>\n<p>并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。<br>我在Google上搜了类似的问题，大多是诸如以下的原因：</p>","more":"<ul>\n<li>主板供电不足（我使用的是台式机应该不会有这个问题）</li>\n<li>BIOS中系统时间不正确（我也未曾修改过该时间）</li>\n</ul>\n<p>这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在</p>\n<h3 id=\"问题出现的环境背景及自己尝试过哪些方法\"><a href=\"#问题出现的环境背景及自己尝试过哪些方法\" class=\"headerlink\" title=\"问题出现的环境背景及自己尝试过哪些方法\"></a>问题出现的环境背景及自己尝试过哪些方法</h3><h4 id=\"系统相关信息：\"><a href=\"#系统相关信息：\" class=\"headerlink\" title=\"系统相关信息：\"></a>系统相关信息：</h4><p>主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中）</p>\n<h4 id=\"尝试过得方法：\"><a href=\"#尝试过得方法：\" class=\"headerlink\" title=\"尝试过得方法：\"></a>尝试过得方法：</h4><ol>\n<li>曾使用PE系统中的引导修复工具修复Win10引导，无果</li>\n<li>在Fedora中安装了<code>grub工具</code>尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件<code>\\Windows\\System32\\winload.efi</code>上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性）</li>\n<li>至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果</li>\n</ol>\n<h3 id=\"问题截图\"><a href=\"#问题截图\" class=\"headerlink\" title=\"问题截图\"></a>问题截图</h3><p><img src=\"/images/bVbjaD6.jpeg\" alt=\"Win10报错\"></p>\n<p>如上所示，错误信息提示文件<code>\\Windows\\System32\\winload.efi</code>出错，导致我一直陷入找<code>winload.efi</code>文件错误的怪圈。</p>\n<h3 id=\"问题解决方法\"><a href=\"#问题解决方法\" class=\"headerlink\" title=\"问题解决方法\"></a>问题解决方法</h3><p>鼓捣大半天，我仍然无法解决此问题，便在<a href=\"https://segmentfault.com/q/1010000016923264\" target=\"_blank\" rel=\"noopener\">SegmentFault</a>上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主<a href=\"https://segmentfault.com/u/fenghengzhi/\" target=\"_blank\" rel=\"noopener\">冯恒智</a>，一言点睛。</p>\n<h4 id=\"具体解决方法如下（划重点）：\"><a href=\"#具体解决方法如下（划重点）：\" class=\"headerlink\" title=\"具体解决方法如下（划重点）：\"></a>具体解决方法如下（划重点）：</h4><p>在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的<strong>【启动设备】</strong>项下的<strong>启动磁盘</strong>和<strong>启动分区</strong>项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见<a href=\"https://blog.csdn.net/testcs_dn/article/details/47904937\" target=\"_blank\" rel=\"noopener\">此博客</a>）。</p>\n<p><img src=\"/images/image-20181106214511931.png\" alt=\"bootice选项\"></p>\n<h4 id=\"疑问：\"><a href=\"#疑问：\" class=\"headerlink\" title=\"疑问：\"></a>疑问：</h4><p>我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的<strong>启动磁盘</strong>和<strong>启动分区</strong>两项，而其他都未曾影响？待解……</p>\n<h4 id=\"就很玄学（挠头\"><a href=\"#就很玄学（挠头\" class=\"headerlink\" title=\"就很玄学（挠头\"></a>就很玄学（挠头</h4><h4 id=\"11月7日更新\"><a href=\"#11月7日更新\" class=\"headerlink\" title=\"11月7日更新\"></a>11月7日更新</h4><p>SegmentFault上的答主<a href=\"https://segmentfault.com/u/fenghengzhi/\" target=\"_blank\" rel=\"noopener\">冯恒智</a>又回复了我的问题，如下：</p>\n<blockquote>\n<p>并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了</p>\n</blockquote>"},{"title":"Java - 深入垃圾回收","date":"2019-04-11T02:36:03.000Z","_content":"\n## 可达性分析算法\n\n算法的基本思路是通过一系列称为`GC Roots`的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称作`引用链`。\n\n<!-- more -->\n\n![image-20190408154950595](/images/可达性分析算法.png)\n\n可作为GC Roots的对象包括下面几种：\n\n- **虚拟机栈**(栈帧中的**本地变量表**)中引用的对象\n- 方法区中**类静态属性**引用的对象\n- 方法去中**常量**引用的对象\n- 本地方法栈中`JNI`引用的对象\n\n## 引用\n\n### 强引用\n\n程序代码中普遍存在的，类似于`Object obj = new Object();`这类的引用，**只要强引用还存在，GC永远不会回收掉被引用的对象**。\n\n### 软引用\n\n用来描述一些还**有用但并非必需**的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。可用SoftReference类来实现。\n\n### 弱引用\n\n比软引用强度低，被弱引用关联的对象**只能生存到下一次垃圾收集发生之前**。可用WeakReference类来实现。\n\n### 虚引用\n\n最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\n## 再谈finalize()\n\n即使在上述可达性分析算法中不可达的对象，**也并非是非死不可的**。\n\n### 过程\n\n要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n1. 如果对象在进行可达性分析后没有与`GC Roots`相连接的引用链\n2. 进行筛选，条件是对象是否有必要执行`finalize()`方法。当对象没有覆盖`finalize()`方法，或者`finalize()`方法以及被调用过，则虚拟机认定`没有必要执行`，此时才宣判对象已死\n\n### 再生\n\n当有必要执行`finalize()`方法时，则对象就会有拯救自己的机会，如下：\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n\n    public void isAlive() {\n        System.out.println(\"yes, i am still alive.\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"finalize method executed!\");\n        FinalizeEscapeGC.SAVE_HOOK = this;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SAVE_HOOK = new FinalizeEscapeGC();\n\n        // 对象第一次成功拯救自己\n        SAVE_HOOK = null;\n        System.gc();\n        // 因为finalize方法优先级很低，所以暂停0.5s以等待它\n        TimeUnit.MILLISECONDS.sleep(500);\n        if (SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\"no, i am dead!\");\n        }\n\n        // 下面的代码与上面完全相同，但是此次自救却失败了\n        SAVE_HOOK = null;\n        System.gc();\n        TimeUnit.MILLISECONDS.sleep(500);\n        if (SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\"no, i am dead!\");\n        }\n    }\n}\n/**Output:\nfinalize method executed!\nyes, i am still alive.\nno, i am dead!\n**/.\n```\n\n从上述代码及其结果可看到，`SAVE_HOOK`对象的`finalize()`方法确实被GC触发过，其本身也在垃圾收集之前成功逃脱了。但是注意，由于一个对象的finalize()只会被执行一遍，因此上述代码中第二次将逃脱失败，无法完成自救。\n\n## HotSpot的算法实现\n\n> 关于GC的几种主流实现方法（简单记忆）：\n>\n> - 保守式GC(Conservative GC)：指JVM不记录内存上的某个数据应该被解读为引用类型还是其他类型。\n> - 半保守式GC(Conservative with respect to the roots)：让对象带有足够的元数据\n> - 准确式GC(Exact GC)：提供特定数据结构保存对象引用\n\n### 枚举根节点\n\n枚举根节点这一过程是**必须要停顿所有Java执行线程**，即`Stop The World`。因为要保证这段时间的引用不变性。\n\n`Java`中使用`OopMap`来存储对象引用，以实现`准确性GC`，同时也避免了垃圾回收时需要遍历栈的每个位置。\n\n### 安全点 Safepoint\n\n`Hotspot`虚拟机**只在到达`Safepoint`位置暂停**，以进行GC。\n\n程序中**指令序列复用**的指令，例如方法调用、循环跳转、异常跳转等情况，才会产生`Safepoint`。\n\n在多线程中，有两种中断方案可供选择：\n\n- **抢先式中断**：GC发生时，将所有线程中断，而后让不在安全点上的线程恢复，直到跑到安全点。\n- **主动式中断**：设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时就自己中断挂起。\n\n### 安全区域 Safe Region\n\n安全区域是为了解决**程序`不执行`的时候，程序无法进入安全点的情况**，例如线程处于`Sleep`或者`Blocked`状态时。\n\n安全区域指的是一段代码片段之中，引用关系不会发生变化，因此在这个区域的任何地方开始GC都是安全的。\n\n当线程执行到安全区域的代码中时：\n\n- 首先标识自己已经进入安全区域，此时JVM发起GC时就**无需**询问处于安全区域状态的线程了，直接回收\n- 在线程要离开安全区域时，需要**检查JVM是否已经完成了根节点枚举**，如果完成了则线程继续执行，否则**必须要等待直到收到可以安全离开安全区域的信号为止**。\n\n## 垃圾收集器\n\n### Serial收集器\n\n`Serial收集器`是一个**单线程的收集器**，它**只会使用一个CPU或一条收集线程去完成垃圾收集工作**，同时它进行垃圾收集时，**必须暂停其他所有工作线程**。\n\n### ParNew收集器\n\n`Serial收集器`的**多线程**版本。\n\n目前只有`Serial`和`ParNew`能够与`CMS收集器`配合工作。\n\n### Parallel Scavenge收集器\n\n此收集器的侧重点放在`吞吐量`上，吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即`吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)`。\n\n注意，**吞吐量与垃圾收集速度无太大关系**。\n\n同时采用此类收集器的虚拟机可根据系统运行状况手机性能监控信息，**动态调整参数**以提供最合适的停顿时间或最大的吞吐量。\n\n### Serial Old收集器\n\n`Serial收集器`的老年代版本，两大用途：\n\n1. 与`Parallel Scavenge收集器`搭配使用\n2. 作为`CMS收集器`的后备预案，在并发收集发生`Concurrent Mode Failure`时使用。\n\n### Parallel Old收集器\n\n`Parallel Scavenge收集器`的老年代版本。\n\n### CMS收集器\n\nCMS收集器是一种**以获取最短回收停顿时间为目标**的收集器。\n\n#### 收集过程\n\nCMS收集器收集过程分为4个步骤：\n\n- **初始标记：**需要`Stop The World`，标记GC Roots能直接关联到的对象，速度很快。\n- **并发标记：**不需要`Stop The World`，进行`GC Roots Tracing`。\n- **重新标记：**需要`Stop The World`，标记因用户程序继续运作而导致变动的那一部分对象的标记记录。\n- **并发清除：**不需要`Stop The World`，进行清除。\n\n#### 缺点\n\n- 对CPU资源很敏感，当CPU资源紧张时，用户程序速度下降很明显。\n- 无法处理浮动垃圾，即在标记之后出现的垃圾，只能留到下一次GC时再清理掉。同时使用CMS时，由于需要预留空间给用户线程，因此不能等到老年代几乎全部被填满了再进行收集。此时当CMS预留的内存无法满足程序需要，就会出现一次`Concurrent Mode Failure`失败，这是就使用后备收集器`Serial Old`。\n- 标记-清除算法会产生空间碎片。\n\n### G1收集器(Garbage First)\n\n#### 特点\n\n- 并行和并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\nG1收集器中新生代和老年代不再是物理隔离的，它**将整个Java堆划分为多个大小相等的独立区域(`Region`)**。\n\n由于`Region`之间可能存在相互引用的关系，所以**使用`Remembered Set`来记录从`其他Region`引用`当前Region`的引用信息**，**`Remembered Set`是一种抽象概念，`Card Table`是其一种实现方式**。\n\n实际上，G1相关算法是个很复杂的过程，见[R大的帖子](<https://hllvm-group.iteye.com/group/topic/44381#post-272188>)，需要进一步研究。\n\n#### 收集过程\n\n- 初始标记\n- 并发标记\n- 最终标记\n- 筛选回收\n\n## 内存分配与回收策略\n\n### 对象优先在Eden分配\n\n大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次MinorGC。\n\n### 大对象直接进入老年代\n\n大对象指的是**需要大量连续内存空间的Java对象**，例如很长的字符串以及数组。更糟糕的是产生一群**朝生夕灭**的**短命大对象**。\n\n### 长期存活的对象将进入老年代\n\n虚拟机给每个对象定义了一个`对象年龄计数器`，当年龄增长到阈值时，就可以晋升到老年代。阈值默认为15，也可通过`MaxTenuringThredhold`参数设置。\n\n### 动态对象年龄判断\n\n当`Survivor`空间中**相同年龄所有对象大小总和**大于`Survivor`空间的一半，年龄大于等于该年龄的对象就直接进入老年代。","source":"_posts/深入GC.md","raw":"---\ntitle: Java - 深入垃圾回收\ndate: 2019-04-11 10:36:03\ntags:\n    - 垃圾回收\n    - 可达性分析\n    - HotSpot\ncategories:\n    - Java\n---\n\n## 可达性分析算法\n\n算法的基本思路是通过一系列称为`GC Roots`的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称作`引用链`。\n\n<!-- more -->\n\n![image-20190408154950595](/images/可达性分析算法.png)\n\n可作为GC Roots的对象包括下面几种：\n\n- **虚拟机栈**(栈帧中的**本地变量表**)中引用的对象\n- 方法区中**类静态属性**引用的对象\n- 方法去中**常量**引用的对象\n- 本地方法栈中`JNI`引用的对象\n\n## 引用\n\n### 强引用\n\n程序代码中普遍存在的，类似于`Object obj = new Object();`这类的引用，**只要强引用还存在，GC永远不会回收掉被引用的对象**。\n\n### 软引用\n\n用来描述一些还**有用但并非必需**的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。可用SoftReference类来实现。\n\n### 弱引用\n\n比软引用强度低，被弱引用关联的对象**只能生存到下一次垃圾收集发生之前**。可用WeakReference类来实现。\n\n### 虚引用\n\n最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\n## 再谈finalize()\n\n即使在上述可达性分析算法中不可达的对象，**也并非是非死不可的**。\n\n### 过程\n\n要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n1. 如果对象在进行可达性分析后没有与`GC Roots`相连接的引用链\n2. 进行筛选，条件是对象是否有必要执行`finalize()`方法。当对象没有覆盖`finalize()`方法，或者`finalize()`方法以及被调用过，则虚拟机认定`没有必要执行`，此时才宣判对象已死\n\n### 再生\n\n当有必要执行`finalize()`方法时，则对象就会有拯救自己的机会，如下：\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n\n    public void isAlive() {\n        System.out.println(\"yes, i am still alive.\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"finalize method executed!\");\n        FinalizeEscapeGC.SAVE_HOOK = this;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SAVE_HOOK = new FinalizeEscapeGC();\n\n        // 对象第一次成功拯救自己\n        SAVE_HOOK = null;\n        System.gc();\n        // 因为finalize方法优先级很低，所以暂停0.5s以等待它\n        TimeUnit.MILLISECONDS.sleep(500);\n        if (SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\"no, i am dead!\");\n        }\n\n        // 下面的代码与上面完全相同，但是此次自救却失败了\n        SAVE_HOOK = null;\n        System.gc();\n        TimeUnit.MILLISECONDS.sleep(500);\n        if (SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else {\n            System.out.println(\"no, i am dead!\");\n        }\n    }\n}\n/**Output:\nfinalize method executed!\nyes, i am still alive.\nno, i am dead!\n**/.\n```\n\n从上述代码及其结果可看到，`SAVE_HOOK`对象的`finalize()`方法确实被GC触发过，其本身也在垃圾收集之前成功逃脱了。但是注意，由于一个对象的finalize()只会被执行一遍，因此上述代码中第二次将逃脱失败，无法完成自救。\n\n## HotSpot的算法实现\n\n> 关于GC的几种主流实现方法（简单记忆）：\n>\n> - 保守式GC(Conservative GC)：指JVM不记录内存上的某个数据应该被解读为引用类型还是其他类型。\n> - 半保守式GC(Conservative with respect to the roots)：让对象带有足够的元数据\n> - 准确式GC(Exact GC)：提供特定数据结构保存对象引用\n\n### 枚举根节点\n\n枚举根节点这一过程是**必须要停顿所有Java执行线程**，即`Stop The World`。因为要保证这段时间的引用不变性。\n\n`Java`中使用`OopMap`来存储对象引用，以实现`准确性GC`，同时也避免了垃圾回收时需要遍历栈的每个位置。\n\n### 安全点 Safepoint\n\n`Hotspot`虚拟机**只在到达`Safepoint`位置暂停**，以进行GC。\n\n程序中**指令序列复用**的指令，例如方法调用、循环跳转、异常跳转等情况，才会产生`Safepoint`。\n\n在多线程中，有两种中断方案可供选择：\n\n- **抢先式中断**：GC发生时，将所有线程中断，而后让不在安全点上的线程恢复，直到跑到安全点。\n- **主动式中断**：设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时就自己中断挂起。\n\n### 安全区域 Safe Region\n\n安全区域是为了解决**程序`不执行`的时候，程序无法进入安全点的情况**，例如线程处于`Sleep`或者`Blocked`状态时。\n\n安全区域指的是一段代码片段之中，引用关系不会发生变化，因此在这个区域的任何地方开始GC都是安全的。\n\n当线程执行到安全区域的代码中时：\n\n- 首先标识自己已经进入安全区域，此时JVM发起GC时就**无需**询问处于安全区域状态的线程了，直接回收\n- 在线程要离开安全区域时，需要**检查JVM是否已经完成了根节点枚举**，如果完成了则线程继续执行，否则**必须要等待直到收到可以安全离开安全区域的信号为止**。\n\n## 垃圾收集器\n\n### Serial收集器\n\n`Serial收集器`是一个**单线程的收集器**，它**只会使用一个CPU或一条收集线程去完成垃圾收集工作**，同时它进行垃圾收集时，**必须暂停其他所有工作线程**。\n\n### ParNew收集器\n\n`Serial收集器`的**多线程**版本。\n\n目前只有`Serial`和`ParNew`能够与`CMS收集器`配合工作。\n\n### Parallel Scavenge收集器\n\n此收集器的侧重点放在`吞吐量`上，吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即`吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)`。\n\n注意，**吞吐量与垃圾收集速度无太大关系**。\n\n同时采用此类收集器的虚拟机可根据系统运行状况手机性能监控信息，**动态调整参数**以提供最合适的停顿时间或最大的吞吐量。\n\n### Serial Old收集器\n\n`Serial收集器`的老年代版本，两大用途：\n\n1. 与`Parallel Scavenge收集器`搭配使用\n2. 作为`CMS收集器`的后备预案，在并发收集发生`Concurrent Mode Failure`时使用。\n\n### Parallel Old收集器\n\n`Parallel Scavenge收集器`的老年代版本。\n\n### CMS收集器\n\nCMS收集器是一种**以获取最短回收停顿时间为目标**的收集器。\n\n#### 收集过程\n\nCMS收集器收集过程分为4个步骤：\n\n- **初始标记：**需要`Stop The World`，标记GC Roots能直接关联到的对象，速度很快。\n- **并发标记：**不需要`Stop The World`，进行`GC Roots Tracing`。\n- **重新标记：**需要`Stop The World`，标记因用户程序继续运作而导致变动的那一部分对象的标记记录。\n- **并发清除：**不需要`Stop The World`，进行清除。\n\n#### 缺点\n\n- 对CPU资源很敏感，当CPU资源紧张时，用户程序速度下降很明显。\n- 无法处理浮动垃圾，即在标记之后出现的垃圾，只能留到下一次GC时再清理掉。同时使用CMS时，由于需要预留空间给用户线程，因此不能等到老年代几乎全部被填满了再进行收集。此时当CMS预留的内存无法满足程序需要，就会出现一次`Concurrent Mode Failure`失败，这是就使用后备收集器`Serial Old`。\n- 标记-清除算法会产生空间碎片。\n\n### G1收集器(Garbage First)\n\n#### 特点\n\n- 并行和并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\nG1收集器中新生代和老年代不再是物理隔离的，它**将整个Java堆划分为多个大小相等的独立区域(`Region`)**。\n\n由于`Region`之间可能存在相互引用的关系，所以**使用`Remembered Set`来记录从`其他Region`引用`当前Region`的引用信息**，**`Remembered Set`是一种抽象概念，`Card Table`是其一种实现方式**。\n\n实际上，G1相关算法是个很复杂的过程，见[R大的帖子](<https://hllvm-group.iteye.com/group/topic/44381#post-272188>)，需要进一步研究。\n\n#### 收集过程\n\n- 初始标记\n- 并发标记\n- 最终标记\n- 筛选回收\n\n## 内存分配与回收策略\n\n### 对象优先在Eden分配\n\n大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次MinorGC。\n\n### 大对象直接进入老年代\n\n大对象指的是**需要大量连续内存空间的Java对象**，例如很长的字符串以及数组。更糟糕的是产生一群**朝生夕灭**的**短命大对象**。\n\n### 长期存活的对象将进入老年代\n\n虚拟机给每个对象定义了一个`对象年龄计数器`，当年龄增长到阈值时，就可以晋升到老年代。阈值默认为15，也可通过`MaxTenuringThredhold`参数设置。\n\n### 动态对象年龄判断\n\n当`Survivor`空间中**相同年龄所有对象大小总和**大于`Survivor`空间的一半，年龄大于等于该年龄的对象就直接进入老年代。","slug":"深入GC","published":1,"updated":"2021-05-16T10:42:46.893Z","_id":"ckfukjaa0001cszxoaavqnip6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><p>算法的基本思路是通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称作<code>引用链</code>。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/可达性分析算法.png\" alt=\"image-20190408154950595\"></p>\n<p>可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li><strong>虚拟机栈</strong>(栈帧中的<strong>本地变量表</strong>)中引用的对象</li>\n<li>方法区中<strong>类静态属性</strong>引用的对象</li>\n<li>方法去中<strong>常量</strong>引用的对象</li>\n<li>本地方法栈中<code>JNI</code>引用的对象</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>程序代码中普遍存在的，类似于<code>Object obj = new Object();</code>这类的引用，<strong>只要强引用还存在，GC永远不会回收掉被引用的对象</strong>。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>用来描述一些还<strong>有用但并非必需</strong>的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。可用SoftReference类来实现。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>比软引用强度低，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。可用WeakReference类来实现。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>\n<h2 id=\"再谈finalize\"><a href=\"#再谈finalize\" class=\"headerlink\" title=\"再谈finalize()\"></a>再谈finalize()</h2><p>即使在上述可达性分析算法中不可达的对象，<strong>也并非是非死不可的</strong>。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ol>\n<li>如果对象在进行可达性分析后没有与<code>GC Roots</code>相连接的引用链</li>\n<li>进行筛选，条件是对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法以及被调用过，则虚拟机认定<code>没有必要执行</code>，此时才宣判对象已死</li>\n</ol>\n<h3 id=\"再生\"><a href=\"#再生\" class=\"headerlink\" title=\"再生\"></a>再生</h3><p>当有必要执行<code>finalize()</code>方法时，则对象就会有拯救自己的机会，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"yes, i am still alive.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finalize method executed!\"</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对象第一次成功拯救自己</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// 因为finalize方法优先级很低，所以暂停0.5s以等待它</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, i am dead!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下面的代码与上面完全相同，但是此次自救却失败了</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, i am dead!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**Output:</span></span><br><span class=\"line\"><span class=\"comment\">finalize method executed!</span></span><br><span class=\"line\"><span class=\"comment\">yes, i am still alive.</span></span><br><span class=\"line\"><span class=\"comment\">no, i am dead!</span></span><br><span class=\"line\"><span class=\"comment\">**/</span>.</span><br></pre></td></tr></table></figure>\n<p>从上述代码及其结果可看到，<code>SAVE_HOOK</code>对象的<code>finalize()</code>方法确实被GC触发过，其本身也在垃圾收集之前成功逃脱了。但是注意，由于一个对象的finalize()只会被执行一遍，因此上述代码中第二次将逃脱失败，无法完成自救。</p>\n<h2 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h2><blockquote>\n<p>关于GC的几种主流实现方法（简单记忆）：</p>\n<ul>\n<li>保守式GC(Conservative GC)：指JVM不记录内存上的某个数据应该被解读为引用类型还是其他类型。</li>\n<li>半保守式GC(Conservative with respect to the roots)：让对象带有足够的元数据</li>\n<li>准确式GC(Exact GC)：提供特定数据结构保存对象引用</li>\n</ul>\n</blockquote>\n<h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>枚举根节点这一过程是<strong>必须要停顿所有Java执行线程</strong>，即<code>Stop The World</code>。因为要保证这段时间的引用不变性。</p>\n<p><code>Java</code>中使用<code>OopMap</code>来存储对象引用，以实现<code>准确性GC</code>，同时也避免了垃圾回收时需要遍历栈的每个位置。</p>\n<h3 id=\"安全点-Safepoint\"><a href=\"#安全点-Safepoint\" class=\"headerlink\" title=\"安全点 Safepoint\"></a>安全点 Safepoint</h3><p><code>Hotspot</code>虚拟机<strong>只在到达<code>Safepoint</code>位置暂停</strong>，以进行GC。</p>\n<p>程序中<strong>指令序列复用</strong>的指令，例如方法调用、循环跳转、异常跳转等情况，才会产生<code>Safepoint</code>。</p>\n<p>在多线程中，有两种中断方案可供选择：</p>\n<ul>\n<li><strong>抢先式中断</strong>：GC发生时，将所有线程中断，而后让不在安全点上的线程恢复，直到跑到安全点。</li>\n<li><strong>主动式中断</strong>：设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时就自己中断挂起。</li>\n</ul>\n<h3 id=\"安全区域-Safe-Region\"><a href=\"#安全区域-Safe-Region\" class=\"headerlink\" title=\"安全区域 Safe Region\"></a>安全区域 Safe Region</h3><p>安全区域是为了解决<strong>程序<code>不执行</code>的时候，程序无法进入安全点的情况</strong>，例如线程处于<code>Sleep</code>或者<code>Blocked</code>状态时。</p>\n<p>安全区域指的是一段代码片段之中，引用关系不会发生变化，因此在这个区域的任何地方开始GC都是安全的。</p>\n<p>当线程执行到安全区域的代码中时：</p>\n<ul>\n<li>首先标识自己已经进入安全区域，此时JVM发起GC时就<strong>无需</strong>询问处于安全区域状态的线程了，直接回收</li>\n<li>在线程要离开安全区域时，需要<strong>检查JVM是否已经完成了根节点枚举</strong>，如果完成了则线程继续执行，否则<strong>必须要等待直到收到可以安全离开安全区域的信号为止</strong>。</li>\n</ul>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><p><code>Serial收集器</code>是一个<strong>单线程的收集器</strong>，它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，同时它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>。</p>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><p><code>Serial收集器</code>的<strong>多线程</strong>版本。</p>\n<p>目前只有<code>Serial</code>和<code>ParNew</code>能够与<code>CMS收集器</code>配合工作。</p>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><p>此收集器的侧重点放在<code>吞吐量</code>上，吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即<code>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</code>。</p>\n<p>注意，<strong>吞吐量与垃圾收集速度无太大关系</strong>。</p>\n<p>同时采用此类收集器的虚拟机可根据系统运行状况手机性能监控信息，<strong>动态调整参数</strong>以提供最合适的停顿时间或最大的吞吐量。</p>\n<h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><p><code>Serial收集器</code>的老年代版本，两大用途：</p>\n<ol>\n<li>与<code>Parallel Scavenge收集器</code>搭配使用</li>\n<li>作为<code>CMS收集器</code>的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用。</li>\n</ol>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><p><code>Parallel Scavenge收集器</code>的老年代版本。</p>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。</p>\n<h4 id=\"收集过程\"><a href=\"#收集过程\" class=\"headerlink\" title=\"收集过程\"></a>收集过程</h4><p>CMS收集器收集过程分为4个步骤：</p>\n<ul>\n<li><strong>初始标记：</strong>需要<code>Stop The World</code>，标记GC Roots能直接关联到的对象，速度很快。</li>\n<li><strong>并发标记：</strong>不需要<code>Stop The World</code>，进行<code>GC Roots Tracing</code>。</li>\n<li><strong>重新标记：</strong>需要<code>Stop The World</code>，标记因用户程序继续运作而导致变动的那一部分对象的标记记录。</li>\n<li><strong>并发清除：</strong>不需要<code>Stop The World</code>，进行清除。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>对CPU资源很敏感，当CPU资源紧张时，用户程序速度下降很明显。</li>\n<li>无法处理浮动垃圾，即在标记之后出现的垃圾，只能留到下一次GC时再清理掉。同时使用CMS时，由于需要预留空间给用户线程，因此不能等到老年代几乎全部被填满了再进行收集。此时当CMS预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，这是就使用后备收集器<code>Serial Old</code>。</li>\n<li>标记-清除算法会产生空间碎片。</li>\n</ul>\n<h3 id=\"G1收集器-Garbage-First\"><a href=\"#G1收集器-Garbage-First\" class=\"headerlink\" title=\"G1收集器(Garbage First)\"></a>G1收集器(Garbage First)</h3><h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>并行和并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<p>G1收集器中新生代和老年代不再是物理隔离的，它<strong>将整个Java堆划分为多个大小相等的独立区域(<code>Region</code>)</strong>。</p>\n<p>由于<code>Region</code>之间可能存在相互引用的关系，所以<strong>使用<code>Remembered Set</code>来记录从<code>其他Region</code>引用<code>当前Region</code>的引用信息</strong>，<strong><code>Remembered Set</code>是一种抽象概念，<code>Card Table</code>是其一种实现方式</strong>。</p>\n<p>实际上，G1相关算法是个很复杂的过程，见<a href=\"https://hllvm-group.iteye.com/group/topic/44381#post-272188\" target=\"_blank\" rel=\"noopener\">R大的帖子</a>，需要进一步研究。</p>\n<h4 id=\"收集过程-1\"><a href=\"#收集过程-1\" class=\"headerlink\" title=\"收集过程\"></a>收集过程</h4><ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<h2 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h2><h3 id=\"对象优先在Eden分配\"><a href=\"#对象优先在Eden分配\" class=\"headerlink\" title=\"对象优先在Eden分配\"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次MinorGC。</p>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>大对象指的是<strong>需要大量连续内存空间的Java对象</strong>，例如很长的字符串以及数组。更糟糕的是产生一群<strong>朝生夕灭</strong>的<strong>短命大对象</strong>。</p>\n<h3 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个<code>对象年龄计数器</code>，当年龄增长到阈值时，就可以晋升到老年代。阈值默认为15，也可通过<code>MaxTenuringThredhold</code>参数设置。</p>\n<h3 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h3><p>当<code>Survivor</code>空间中<strong>相同年龄所有对象大小总和</strong>大于<code>Survivor</code>空间的一半，年龄大于等于该年龄的对象就直接进入老年代。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><p>算法的基本思路是通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称作<code>引用链</code>。</p>","more":"<p><img src=\"/images/可达性分析算法.png\" alt=\"image-20190408154950595\"></p>\n<p>可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li><strong>虚拟机栈</strong>(栈帧中的<strong>本地变量表</strong>)中引用的对象</li>\n<li>方法区中<strong>类静态属性</strong>引用的对象</li>\n<li>方法去中<strong>常量</strong>引用的对象</li>\n<li>本地方法栈中<code>JNI</code>引用的对象</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>程序代码中普遍存在的，类似于<code>Object obj = new Object();</code>这类的引用，<strong>只要强引用还存在，GC永远不会回收掉被引用的对象</strong>。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>用来描述一些还<strong>有用但并非必需</strong>的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。可用SoftReference类来实现。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>比软引用强度低，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。可用WeakReference类来实现。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>\n<h2 id=\"再谈finalize\"><a href=\"#再谈finalize\" class=\"headerlink\" title=\"再谈finalize()\"></a>再谈finalize()</h2><p>即使在上述可达性分析算法中不可达的对象，<strong>也并非是非死不可的</strong>。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ol>\n<li>如果对象在进行可达性分析后没有与<code>GC Roots</code>相连接的引用链</li>\n<li>进行筛选，条件是对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法以及被调用过，则虚拟机认定<code>没有必要执行</code>，此时才宣判对象已死</li>\n</ol>\n<h3 id=\"再生\"><a href=\"#再生\" class=\"headerlink\" title=\"再生\"></a>再生</h3><p>当有必要执行<code>finalize()</code>方法时，则对象就会有拯救自己的机会，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"yes, i am still alive.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finalize method executed!\"</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对象第一次成功拯救自己</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// 因为finalize方法优先级很低，所以暂停0.5s以等待它</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, i am dead!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下面的代码与上面完全相同，但是此次自救却失败了</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, i am dead!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**Output:</span></span><br><span class=\"line\"><span class=\"comment\">finalize method executed!</span></span><br><span class=\"line\"><span class=\"comment\">yes, i am still alive.</span></span><br><span class=\"line\"><span class=\"comment\">no, i am dead!</span></span><br><span class=\"line\"><span class=\"comment\">**/</span>.</span><br></pre></td></tr></table></figure>\n<p>从上述代码及其结果可看到，<code>SAVE_HOOK</code>对象的<code>finalize()</code>方法确实被GC触发过，其本身也在垃圾收集之前成功逃脱了。但是注意，由于一个对象的finalize()只会被执行一遍，因此上述代码中第二次将逃脱失败，无法完成自救。</p>\n<h2 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h2><blockquote>\n<p>关于GC的几种主流实现方法（简单记忆）：</p>\n<ul>\n<li>保守式GC(Conservative GC)：指JVM不记录内存上的某个数据应该被解读为引用类型还是其他类型。</li>\n<li>半保守式GC(Conservative with respect to the roots)：让对象带有足够的元数据</li>\n<li>准确式GC(Exact GC)：提供特定数据结构保存对象引用</li>\n</ul>\n</blockquote>\n<h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>枚举根节点这一过程是<strong>必须要停顿所有Java执行线程</strong>，即<code>Stop The World</code>。因为要保证这段时间的引用不变性。</p>\n<p><code>Java</code>中使用<code>OopMap</code>来存储对象引用，以实现<code>准确性GC</code>，同时也避免了垃圾回收时需要遍历栈的每个位置。</p>\n<h3 id=\"安全点-Safepoint\"><a href=\"#安全点-Safepoint\" class=\"headerlink\" title=\"安全点 Safepoint\"></a>安全点 Safepoint</h3><p><code>Hotspot</code>虚拟机<strong>只在到达<code>Safepoint</code>位置暂停</strong>，以进行GC。</p>\n<p>程序中<strong>指令序列复用</strong>的指令，例如方法调用、循环跳转、异常跳转等情况，才会产生<code>Safepoint</code>。</p>\n<p>在多线程中，有两种中断方案可供选择：</p>\n<ul>\n<li><strong>抢先式中断</strong>：GC发生时，将所有线程中断，而后让不在安全点上的线程恢复，直到跑到安全点。</li>\n<li><strong>主动式中断</strong>：设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时就自己中断挂起。</li>\n</ul>\n<h3 id=\"安全区域-Safe-Region\"><a href=\"#安全区域-Safe-Region\" class=\"headerlink\" title=\"安全区域 Safe Region\"></a>安全区域 Safe Region</h3><p>安全区域是为了解决<strong>程序<code>不执行</code>的时候，程序无法进入安全点的情况</strong>，例如线程处于<code>Sleep</code>或者<code>Blocked</code>状态时。</p>\n<p>安全区域指的是一段代码片段之中，引用关系不会发生变化，因此在这个区域的任何地方开始GC都是安全的。</p>\n<p>当线程执行到安全区域的代码中时：</p>\n<ul>\n<li>首先标识自己已经进入安全区域，此时JVM发起GC时就<strong>无需</strong>询问处于安全区域状态的线程了，直接回收</li>\n<li>在线程要离开安全区域时，需要<strong>检查JVM是否已经完成了根节点枚举</strong>，如果完成了则线程继续执行，否则<strong>必须要等待直到收到可以安全离开安全区域的信号为止</strong>。</li>\n</ul>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><p><code>Serial收集器</code>是一个<strong>单线程的收集器</strong>，它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，同时它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>。</p>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><p><code>Serial收集器</code>的<strong>多线程</strong>版本。</p>\n<p>目前只有<code>Serial</code>和<code>ParNew</code>能够与<code>CMS收集器</code>配合工作。</p>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><p>此收集器的侧重点放在<code>吞吐量</code>上，吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即<code>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</code>。</p>\n<p>注意，<strong>吞吐量与垃圾收集速度无太大关系</strong>。</p>\n<p>同时采用此类收集器的虚拟机可根据系统运行状况手机性能监控信息，<strong>动态调整参数</strong>以提供最合适的停顿时间或最大的吞吐量。</p>\n<h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><p><code>Serial收集器</code>的老年代版本，两大用途：</p>\n<ol>\n<li>与<code>Parallel Scavenge收集器</code>搭配使用</li>\n<li>作为<code>CMS收集器</code>的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用。</li>\n</ol>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><p><code>Parallel Scavenge收集器</code>的老年代版本。</p>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。</p>\n<h4 id=\"收集过程\"><a href=\"#收集过程\" class=\"headerlink\" title=\"收集过程\"></a>收集过程</h4><p>CMS收集器收集过程分为4个步骤：</p>\n<ul>\n<li><strong>初始标记：</strong>需要<code>Stop The World</code>，标记GC Roots能直接关联到的对象，速度很快。</li>\n<li><strong>并发标记：</strong>不需要<code>Stop The World</code>，进行<code>GC Roots Tracing</code>。</li>\n<li><strong>重新标记：</strong>需要<code>Stop The World</code>，标记因用户程序继续运作而导致变动的那一部分对象的标记记录。</li>\n<li><strong>并发清除：</strong>不需要<code>Stop The World</code>，进行清除。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>对CPU资源很敏感，当CPU资源紧张时，用户程序速度下降很明显。</li>\n<li>无法处理浮动垃圾，即在标记之后出现的垃圾，只能留到下一次GC时再清理掉。同时使用CMS时，由于需要预留空间给用户线程，因此不能等到老年代几乎全部被填满了再进行收集。此时当CMS预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，这是就使用后备收集器<code>Serial Old</code>。</li>\n<li>标记-清除算法会产生空间碎片。</li>\n</ul>\n<h3 id=\"G1收集器-Garbage-First\"><a href=\"#G1收集器-Garbage-First\" class=\"headerlink\" title=\"G1收集器(Garbage First)\"></a>G1收集器(Garbage First)</h3><h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>并行和并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<p>G1收集器中新生代和老年代不再是物理隔离的，它<strong>将整个Java堆划分为多个大小相等的独立区域(<code>Region</code>)</strong>。</p>\n<p>由于<code>Region</code>之间可能存在相互引用的关系，所以<strong>使用<code>Remembered Set</code>来记录从<code>其他Region</code>引用<code>当前Region</code>的引用信息</strong>，<strong><code>Remembered Set</code>是一种抽象概念，<code>Card Table</code>是其一种实现方式</strong>。</p>\n<p>实际上，G1相关算法是个很复杂的过程，见<a href=\"https://hllvm-group.iteye.com/group/topic/44381#post-272188\" target=\"_blank\" rel=\"noopener\">R大的帖子</a>，需要进一步研究。</p>\n<h4 id=\"收集过程-1\"><a href=\"#收集过程-1\" class=\"headerlink\" title=\"收集过程\"></a>收集过程</h4><ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<h2 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h2><h3 id=\"对象优先在Eden分配\"><a href=\"#对象优先在Eden分配\" class=\"headerlink\" title=\"对象优先在Eden分配\"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次MinorGC。</p>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>大对象指的是<strong>需要大量连续内存空间的Java对象</strong>，例如很长的字符串以及数组。更糟糕的是产生一群<strong>朝生夕灭</strong>的<strong>短命大对象</strong>。</p>\n<h3 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个<code>对象年龄计数器</code>，当年龄增长到阈值时，就可以晋升到老年代。阈值默认为15，也可通过<code>MaxTenuringThredhold</code>参数设置。</p>\n<h3 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h3><p>当<code>Survivor</code>空间中<strong>相同年龄所有对象大小总和</strong>大于<code>Survivor</code>空间的一半，年龄大于等于该年龄的对象就直接进入老年代。</p>"},{"title":"Java - 基础知识","date":"2019-03-06T13:01:30.000Z","_content":"\n## 垃圾回收器—GC\n\n众所周知，Java中的GC负责回收**无用对象占用的内存资源**，但会有特殊情况：假定对象获得了一块\"特殊\"的内存区域（不是使用new创建的），由于**GC只释放那些经由new分配的内存**，所以GC不知道如何释放该对象的这块\"特殊\"内存区域。\n\n<!-- more -->\n\n作为应对，Java允许在类中定义`finalize()`方法，它使得在GC回收该对象内存之前先调用`finalize()`方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在`finalize()`指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。\n\n**关键点：**\n\n1. 对象可能不被垃圾回收\n2. 垃圾回收并不等于\"析构\"\n3. 垃圾回收只与内存有关\n\n### 避免使用finalize()\n\n> \"终结函数无法预料，常常是危险的，总之是多余的。\"《Effective Java》，第20页\n\n在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在**通过某种创建对象以外的方式为对象分配了存储空间**。\n\nNative Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。\n\n可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。\n\n### 终结条件的验证\n\n但是finalize()有个有趣的用法——终结条件。看如下代码：\n\n```java\nclass Book{\n    // Book类，约定其在被回收前必须被签入。\n\tboolean checkedOut = false;\n\tBook(boolean checkedOut){\n\t\tcheckedOut = checkedOut;\n\t}\n\tvoid checkIn(){\n\t\tcheckedOut = false;\n\t}\n\tprotected void finalize(){\n        // 终结条件，对象未被签入\n\t\tif (checkedOut) {\n\t\t\tSystem.out.println(\"Error: checked out\");\n\t\t}\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n        // 创建一个Book对象-novel\n\t\tBook novel = new Book(true);\n        // 将其签入\n\t\tnovel.checkIn();\n        // 创建一个Book对象，此时该对象未被签入\n\t\tnew Book(true);\n        // 强制执行垃圾回收，此时会先执行finalize\n\t\tSystem.gc();\n\t}\n}\n\n/* 输出：\nError: checked out\n*/\n```\n\n我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。\n\n> 注意这里使用的System.gc()强制调用垃圾回收器\n\n若没有finalize()将很难实现这种操作。\n\n### GC如何工作\n\n#### 引用计数（未被使用过）\n\n对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。\n\n缺陷：循环引用不适用，即出现\"对象应该被回收，但引用计数不为0\"的情况，称作\"交互自引用的对象组\"。如下所示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // object1指向的对象引用计数器：1\n        MyObject object1 = new MyObject();\n        // object2指向的对象引用计数器：1\n        MyObject object2 = new MyObject();\n        // object1指向的对象引用计数器：2\n        object1.object = object2;\n        // object2指向的对象引用计数器：2\n        object2.object = object1;\n        // object1指向的对象引用计数器减少为1\n        object1 = null;\n        // object2指向的对象引用计数器减少为1\n        object2 = null;\n    }\n}\n```\n\n我们将`object1`和`object2`赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。\n\n#### 停止-复制（stop-and-copy）\n\n遍历所有**引用**找到所有\"活\"的**对象**，将堆中**所有存活的对象复制到另一个堆中**，没有被复制的便都是垃圾了。\n\n这种策略避免了上述\"交互自引用的对象组\"无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。\n\n**缺陷：效率低**\n\n1. 复制需要在两个堆之间操作，即需要维护多一倍的空间；\n2. 当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。\n\n针对第2个情况，有另外一种策略，如下。\n\n#### 标记-清扫（mark-and-sweep）\n\n同样遍历所有**引用**找到所有\"活\"的**对象**，同时会给该对象进行**标记**，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作\"标记-整理\"。\n\n> 注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。\n>\n> 许多文献中有关于\"垃圾回收器是低优先级的后台进程\"的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展\"停止-复制\"或\"标记-清扫\"工作。\n\n\"标记-清扫\"方式速度相当慢，但是当垃圾很少时，就很快了。\n\n#### 自适应技术\n\nJVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到\"标记-清扫\"方式；同样，JVM也会跟踪\"标记-清扫\"方式，若堆空间出现很多碎片，就会切换回\"停止-复制\"方式。这就是自适应技术。\n\n这是早期Sun版本的垃圾回收器。\n\n#### 分代垃圾收集（Generational Garbage Collection）\n\n上述无论是\"停止-复制\"、\"标记-清扫\"还是\"标记-整理\"对于日益增长的对象列表，效率会逐渐低下。\n\n![image-20190225225057306](/images/image-20190225225057306.png)\n\n堆被分为三代：\n\n- 年轻代(Young Generation)\n\n  内存空间：**eden:S0:S1 = 8:1:1**\n\n  S0和S1**没有先后顺序**，任何一个都可能是**From survivor space**和**To survivor space**\n\n- 年老代(Old Generation)\n\n  内存空间：年老代:年轻代 ≈ 2:1\n\n- 持久代(Permanent Generation)\n\n  用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n下面说明一下对象在分配内存、老化、回收的过程：\n\n1. 首先，任何新对象创建时内存都会分配在年轻代的**eden space**中，**S0**和**S1**两个**幸存者空间(survivor space)**起初都是空的![image-20190225225802212](/images/image-20190225225802212.png)\n\n2. 当eden space满时，会触发第一次**较小的垃圾回收过程(minor garbage collection，minor GC)**\u0001![image-20190225230110077](/images/image-20190225230110077.png)\n\n   > 实际上MinorGC不一定要等到eden space满了才触发\n\n3. eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收![image-20190225230647640](/images/image-20190225230647640.png)\n\n4. 当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象\u0001![image-20190225232204967](/images/image-20190225232204967.png)\n\n5. 再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收![image-20190225232407098](/images/image-20190225232407098.png)\n\n6. 当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代![image-20190225232630665](/images/image-20190225232630665.png)\n\n7. 以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发**完全的垃圾回收(major gabarge collector, major GC)**，清理并压缩该块内存空间。\n\n   major GC被触发的原因：\n\n   1. 年老代（Tenured）被写满\n\n   2. 持久代（Permanent）被写满\n\n   3. System.gc()被显式调用\n\n   4. 上一次GC之后Heap的各域分配策略动态变化\n\n##### HotSpot JVM的垃圾收集器\n\n**Serial收集器（复制算法)**：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n**Serial Old收集器(标记-整理算法)**：老年代单线程收集器，Serial收集器的老年代版本。\n\n**ParNew收集器(停止-复制算法)**：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n**Parallel Scavenge收集器(停止-复制算法)**：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n**Parallel Old收集器(停止-复制算法)**：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n**CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)**：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n【参考：[深入理解JVM(3)——7种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)】\n\n## 可变参数列表\n\nJava中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：\n\n```java\npublic class test{\n\tpublic static void main(String[] args){\n\t\tInteger a = 1;\n\t\tInteger b = 2;\n\t\tInteger c = 3;\n\t\tOther.main(a, b);\n\t\tOther.main(a, b, c);\n        Other.main();\n        Other.main(new Object[]{a, b});\n\t\tOther.main(new Object[]{a, b, c});\n\t}\n}\n\nclass Other{\n\tpublic static void main(Object... args){\n\t\tfor (Object s : args){\n\t\t\tSystem.out.println(s + \" \");\n\t\t}\n\t}\n}\n```\n\n如上所示，当输入不同个数参数时，编译器会自动将其**转换成数组**，当参数本身就是数组时，编译器又**不会进行转换**，直接传递给函数。参数为空时编译器便**直接传递一个空Object数组**。\n\n### 可变参数列表的重载\n\n```java\npublic class test{\n\tstatic void f(Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(String... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf('a', 'b');\n\t\tf(\"a\", \"b\");\n\t\tf();\n\t}\n}\n```\n\n如上，函数有`f(Character... args)`和`f(String... args)`两种重载方式，此时`f('a', 'b')`和`f(\"a\", \"b\")`都可正常调用，但是`f()`会报错，即两种重载都匹配。\n\n此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：\n\n```java\npublic class test{\n\tstatic void f(float i, Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(Character... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf(1, 'a');\n\t\tf('a', 'b');\n\t}\n}\n```\n\n如上，编译器也会报错，`f('a', 'b')`可匹配两个函数，(可能是)因为`char`类型可提升至`float`类型从而匹配第一个重载函数。\n\n此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。\n\n```java\npublic class test{\n\tstatic void f(float i, Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(char i, Character... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf(1, 'a');\n\t\tf('a', 'b');\n\t}\n}\n```\n\n这种用法比较奇怪，因此\"你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它\"（《Java编程思想》105页）。\n\n## 内部类\n\n### 内部类对象对外围类对象的访问\n\n当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。\n\n```java\ninterface Selector {\n    boolean end();\n    Object current();\n    void next();\n}\n\npublic class Sequence {\n    private Object[] items;\n    private int next = 0;\n    public Sequence(int size) { items = new Object[size]; }\n    public void add(Object x){\n        if (next < items.length){\n            items[next++] = x;\n        }\n    }\n    private class SequenceSelector implements Selector {\n        private int i = 0;\n        public boolean end() { return i == items.length; }\n        public Object current() { return items[i]; }\n        public void next() { if(i < items.length) i++; }\n    }\n    public Selector selector(){\n        return new SequenceSelector();\n    } \n    public static void main(String[] args){\n        Sequence sequence = new Sequence(10);\n        for (int i = 0; i < 10; i++){\n            sequence.add(Integer.toString(i));\n        }\n        Selector selector = sequence.selector();\n        while(!selector.end()){\n            System.out.print(selector.current() + \" \");\n            selector.next();\n        }\n    }\n}\n```\n\nSequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。\n\n### 内部类与静态内部类（嵌套类）\n\n#### 创建方法\n\n```java\n// 内部类：DotNew.java\npublic class DotNew {\n    class Inner {\n        Inner(){\n            System.out.println(\"创建内部类\");\n        }\n    }\n    public static void main(String [] args){\n        DotNew dn = new DotNew();\n        DotNew.Inner dni = dn.new Inner();\n    }\n}\n\n// 静态内部类：DotNewStatic.java\npublic class DotNewStatic {\n    static class Inner {\n        Inner() {\n            System.out.println(\"创建静态内部类\");\n        }\n    }\n    public static void main(String[] args){\n        DotNewStatic.Inner inner = new DotNewStatic.Inner();\n    }\n}\n```\n\n### 匿名内部类\n\nJava支持**创建一个继承自某基类的匿名类的对象**，通过new表达式返回的引用被**自动向上转型为对基类的引用**。\n\n匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。\n\n注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是`final`，如下：\n\n```java\n// Destination.java\npublic interface Destination{\n    String readLabel();\n}\n\n// Parcel9.java\npublic class Parcel9 {\n    public Destination destination(final String dest){// 外部变量dest被引用时需声明为final，否则产生编译时错误\n        return new Destination(){\n            private String label = dest;\n            @Override\n            public String readLabel() {\n                return label;\n            }\n        };\n    }\n    public static void main(String[] args){\n        Parcel9 p = new Parcel9();\n        Destination d = p.destination(\"Tasmania\");\n        System.out.println(d.readLabel());\n    }\n}\n```\n\n> 但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。\n\n> **为什么匿名内部类访问外部变量必须是final的？**\n>\n> 1. 为了避免**外部方法修改引用导致内部类得到的引用值不一致**和**内部类修改引用而导致外部方法的参数值在修改前和修改后不一致**\n>\n> 2. 保证回调函数回调时可访问到变量（**待研究**）\n>\n> 3. 反编译查看其实现细节：\n>\n>    ```java\n>    // 源代码\n>    public interface MyInterface {\n>        void doSomething();\n>    }\n>    public class TryUsingAnonymousClass {\n>        public void useMyInterface() {\n>            final Integer number = 123;\n>            System.out.println(number);\n>    \n>            MyInterface myInterface = new MyInterface() {\n>                @Override\n>                public void doSomething() {\n>                    System.out.println(number);\n>                }\n>            };\n>            myInterface.doSomething();\n>    \n>            System.out.println(number);\n>        }\n>    }\n>    \n>    // 反编译结果\n>    class TryUsingAnonymousClass$1\n>            implements MyInterface {\n>        private final TryUsingAnonymousClass this$0;\n>        private final Integer paramInteger;\n>    \n>        TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) {\n>            this.this$0 = this$0;\n>            this.paramInteger = paramInteger;\n>        }\n>    \n>        public void doSomething() {\n>            System.out.println(this.paramInteger);\n>        }\n>    }\n>    ```\n>\n>    注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时**实际上是做了个\"拷贝\"**或者说**\"赋值\"**。若可以更改，则会造成数据不一致。\n\n## RTTI\n\nRTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是**多态的基础**，由**Class类实现**。\n\n### Class对象\n\n每当编写并且编译一个类时，在与类同名的`.class`文件中会自动产生一个`Class对象`。实现此过程的JVM子系统被称作**类加载器**。\n\nClass对象仅在需要的时候才被加载，也就是所有的类都是**只在对其第一次使用时**，动态加载到JVM中的。所谓第一次使用指的是**对类的非常量静态域的第一次引用。**\n\n- 要注意，**类的构造器**是**隐性非常量静态域**，所以使用new操作符生成对象也是产生这样的Class类引用。\n\n- 与此同时，还可以使用`Class.forName(类名)`产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常`ClassNotFoundException`。比如在JDBC连接数据库时常常用到的`Class.forName(\"com.mysql.jdbc.Driver\")`，就是告诉JVM去加载MySQL驱动。\n\n- 当已经拥有某个类型的对象（实例）时，可通过调用`getClass()`方法来获取该类型的Class引用。\n\n- 另一种方法，使用**类字面变量**。通过使用`类名.class`可获取此类的Class对象的引用，但是注意，此时**此Class对象还未被初始化**，还需要等到上述的`对类的非常量静态域的第一次引用`这一操作执行时才被初始化。\n\n  > 使用.class方法获取Class对象引用实际包含三个步骤：\n  >\n  > 1. **加载**：类加载器创建Class对象\n  > 2. **链接**\n  > 3. **初始化**：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块\n  >\n  > 考虑如下代码：\n  >\n  > ```java\n  > import java.util.Random;\n  > \n  > class Initable {\n  >     static final int staticFinal = 1;\n  >     static final int staticFinal2 = ClassInitialization.rand.nextInt(1000);\n  >     static {\n  >         System.out.println(\"Initializing Initable\");\n  >     }\n  > }\n  > \n  > class Initable2 {\n  >     static int staticNonFinal = 2;\n  >     static {\n  >         System.out.println(\"Initializing Initable2\");\n  >     }\n  > }\n  > \n  > class Initable3 {\n  >     static int staticNonFinal = 3;\n  >     static {\n  >         System.out.println(\"Initializing Initable3\");\n  >     }\n  > }\n  > \n  > public class ClassInitialization {\n  >     public static Random rand = new Random(47);\n  >     public static void main(String[] args) throws ClassNotFoundException {\n  >         // 创建Initable的Class对象的引用，Class对象未初始化\n  >         Class initable = Initable.class;\n  >         // 仍然未初始化，因Initable.staticFinal是常数\n  >         System.out.println(Initable.staticFinal);\n  >         // 触发了Initable的Class对象的初始化\n  >         System.out.println(Initable.staticFinal2);\n  >         // 触发了Initable2的Class对象的初始化\n  >         System.out.println(Initable2.staticNonFinal);\n  >         // 创建Initable3的Class对象的引用，同时会初始化此Class对象\n  >         Class initable3 = Class.forName(\"Initable3\");\n  >         // 此时已初始化，无需再次初始化\n  >         System.out.println(Initable3.staticNonFinal);\n  >     }\n  > }\n  > ```\n\n另外，当我拥有某个Class对象c的时候，我虽然**不知道它确切类型**，但是可以使用`c.newInstance()`来正确地获取c代表的类型的实例。**但是此方法要求对应的类**。\n\n### 泛化的Class对象引用\n\nClass对象可以通过`Class<Type>`的方法产生特定类型的类引用，创建了**使用类型限定后**的Class对象引用**不能再赋值给除本身和子类的其他的Class对象**。\n\n> 注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如`Integer`继承自`Number`，而`Integer Class对象`却不是`Number Class对象`的子类。\n\n使用通配符`Class<?>`优于平凡的`Class`（实际上是等价的），而且会免除编译器警告，看图：![image-20190308105552914](/images/image-20190308105552914.png)\n\n一种更好的用法，`Class<? extends Type>`，这种类型限定比直接`Class<Type>`好的地方在于他产生的Class对象引用**可赋值给Type本身及子类的Class对象**，这种继承关系**是Type所属的继承关系**而**不是对应的Class对象的继承关系**。\n\n### 转型语法（不常用）\n\n```java\nclass Building{}\nclass House extends Building {}\n\npublic class ClassCasts {\n    public static void main(String[] args){\n        Building b = new Building();\n        Class<House> houseType = House.class;\n        House h = houseType.cast(b);\n        h = (House) b;\n    }\n}\n```\n\n如上，使用`houseType.cast(b)`和`(House) b`效果一样，但是执行的工作却不同，具体内部实现尚未学习到。\n\n### 动态的类型检测\n\n#### obj instanceof ClassType\n\n返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。\n\n#### ClassType.isInstance()\n\n返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。\n\n#### 区别\n\n区别主要是后者与前者动态等价，看代码：\n\n```java\nclass Father{}\nclass Son extends Father{}\n\npublic class DynamicEqual {\n    public static void main(String[] args){\n        Father father = new Father();\n        Son son = new Son();\n        // instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称\n        // if (son instanceof father.getClass()){\n        //     ...\n        // }\n        // isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。\n        if (father.getClass().isInstance(son)){\n            System.out.println(\"isInstance is Dynamic\");\n        }\n    }\n}\n```\n\n#### 优点\n\n`isInstance()`的存在可以替代`instanceof`，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：\n\n- 使用`instanceof`时可能需要使用`switch-case`语句；当需要添加一个子类时，需要修改`switch-case`内部代码。\n- 而使用`isInstance()`时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。\n\n### 反射机制\n\n#### 反射与RTTI的区别\n\n- RTTI：编译器在编译时打开和检查`.class`文件（获取类的Class类对象信息）\n- 反射：JVM在运行时打开和检查`.class`文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取`.class`文件）\n\n#### 类方法提取器\n\n通过Class对象引用：调用`getMethods()`方法获取该类及其父类的方法列表，调用`getConstructors()`方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个**非public类的非public方法是无法被获取的**。\n\n#### 接口与类型信息\n\ninterface关键字的一种重要目标就是允许程序员**隔离构件，进而降低耦合性**。\n\n#### 包权限安全吗？\n\n直接看例子：\n\n```java\n// A.java\npublic interface A{\n    void f();\n}\n\n// HiddenC.java\nclass C implements A{\n\n    @Override\n    public void f() {\n        System.out.println(\"public C.f()\");\n    }\n    public void g(){\n        System.out.println(\"public C.g()\");\n    }\n    void u(){\n        System.out.println(\"package C.u()\");\n    }\n    protected void v(){\n        System.out.println(\"protected C.v()\");\n    }\n    private void w(){\n        System.out.println(\"private C.w()\");\n    }\n}\npublic class HiddenC {\n    public static A makeA(){\n        return new C();\n    }\n}\n\n// HiddenImplementation.java\nimport java.lang.reflect.Method;\npublic class HiddenImplementation {\n    public static void main(String[] args) throws Exception {\n        A a = HiddenC.makeA();\n        a.f();\n        System.out.println(a.getClass().getName());\n        callHiddenMethod(a, \"g\");\n        callHiddenMethod(a, \"u\");\n        callHiddenMethod(a, \"v\");\n        callHiddenMethod(a, \"w\");\n    }\n    static void callHiddenMethod(Object a, String methodName) throws Exception{\n        // 获取a中的方法\n        Method g = a.getClass().getDeclaredMethod(methodName);\n        // 修改该方法的权限\n        g.setAccessible(true);\n        // 调用该方法\n        g.invoke(a);\n    }\n}\n/* output\npublic C.f()\nC\npublic C.g()\npackage C.u()\nprotected C.v()\nprivate C.w()\n*///:)\n```\n\n- 当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用`setAccessble(true)`后被调用。\n- 只发布`.class`文件也是没办法避免此问题，`javap -private`命令可以反编译`.class`文件，`-private`参数约定显示所有的成员\n- 同样，内部类和匿名内部类也是没办法避免此情况\n\n## 泛型\n\n### 指定类型有保证吗？\n\n> 在泛型代码内部，无法获得任何有关泛型参数类型的信息。\n\n例如对于`ArrayList<String>`和`ArrayList<Integer>`，二者的实例调用`.getClass()`获取的Class对象时相同的，如下：\n\n```java\nimport java.util.ArrayList;\n\npublic class Erase{\n    public static void main(String[] args){\n        Class<?> s = new ArrayList<String>().getClass();\n        Class<?> i = new ArrayList<Integer>().getClass();\n        System.out.println(s == i);\n        System.out.println(s.getName());\n        System.out.println(s.getTypeParameters());\n    }\n}\n/* Output:\ntrue\njava.util.ArrayList\n[Ljava.lang.reflect.TypeVariable;@68f7aae2\n*///\n```\n\n但是，如果在一个`ArrayList<String>`类型的实例中添加`Integer`会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：\n\n```java\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nclass Apple{\n    @Override\n    public String toString(){\n        return \"This is an apple\";\n    }\n}\n\npublic class ReflectAdd{\n    public static void main(String[] args) throws Exception{\n        ArrayList<String> strings = new ArrayList<>();\n        Class<?> s = strings.getClass();\n        Method method = s.getMethod(\"add\", Object.class);\n        method.invoke(strings, 1);\n        method.invoke(strings, \"2\");\n        method.invoke(strings, 3);\n        method.invoke(strings, new Apple());\n        System.out.println(Arrays.toString(strings.toArray()));\n        for (Object o : strings){\n            System.out.println(o.getClass());\n        }\n    }\n}\n/* Output:\n[1, 2, 3, This is an apple]\nclass java.lang.Integer\nclass java.lang.String\nclass java.lang.Integer\nclass Apple\n*///\n```\n\n我们可以看到上述代码使用反射机制成功的在`ArrayList<String>`里面添加了`Integer`，原因在于`ArrayList`的泛型实现`ArrayList<E>`使其被擦除为`ArrayList<Object>`，从而通过反射机制找到其`add(E e)`方法时，实际上是`add(Object o)`，而我们代码中的`Method method = s.getMethod(\"add\", Object.class);`恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。\n\n### 与C++的区别\n\n**C++:**\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> class Manipulator {\n    T obj;\npublic :\n    Manipulator(T x) { obj = x; }\n    void manipulate() { obj.f(); }\n    void manipulate2() { obj.noF(); }\n};\n\nclass HasF {\npublic:\n    void f(){\n        cout << \"HasF()::f()\" << endl;\n    }\n};\n\nclass DontHaveF{\npublic:\n    void noF(){\n        cout << \"Don't have f()\" << endl;\n    }\n};\n\nint main(){\n    HasF hf;\n    Manipulator<HasF> manipulator(hf);\n    manipulator.manipulate();\n    // manipulator.manipulate2();  无法编译\n    DontHaveF dhf;\n    Manipulator<DontHaveF> manipulator2(dhf);\n    // manipulator2.manipulate();  无法编译\n    manipulator2.manipulate2();\n}\n/* Output:\nHasF()::f()\nDon't have f()\n*///\n```\n\n模板类`Manipulator`在编译时期便可以检测到函数`f()`、`noF()`是在类型参数<T>中存在的，这是在编译器看到声明`Manipulator<HasF> manipulator(hf)`和`Manipulator<DontHaveF> manipulator2(dhf)`所产生的结果。\n\n然而Java中却无法实现这样的操作：\n\n**Java:**\n\n```java\n// HasF.java\npublic class HasF{\n    public void f(){\n        System.out.println(\"HasF.f();\");\n    }\n}\n\n// Manipulation.java\nimport java.lang.reflect.Method;\n\nclass Manipulator<T> {\n    private T obj;\n    public Manipulator(T x) {\n        obj = x;\n    }\n    public void manipulate(){\n        obj.f() // 会报编译错误\n    }\n}\n\npublic class Manipulation{\n    public static void main(String[] args){\n        HasF hf = new HasF();\n        Manipulator<HasF> manipulation = new Manipulator<HasF>(hf);\n        manipulation.manipulate();\n    }\n}\n```\n\n由于Java在编译过程中，`Manipulator<T>`是无法确定其类型参数，只知道他是一个`Object实例`，因此obj**只能调用Object基类所有的公开方法**。若想实现C++的操作有两种办法(目前我已知的只有这两种)。\n\n- 为`T`限定参数类型（给定边界），即声明时指定其所继承的基类：\n\n  ```java\n  class Manipulator<T extends HasF>{\n      ...\n  }\n  ```\n\n- 使用反射机制调用` f()`\n\n  ```java\n  import java.lang.reflect.Method;\n  \n  class Manipulator<T> {\n      private T obj;\n      public Manipulator(T x) {\n          obj = x;\n      }\n      public void manipulate() throws Exception{\n          Class<?> oc = obj.getClass();\n          Method method = oc.getMethod(\"f\");\n          method.invoke(obj);\n      }\n  }\n  \n  public class Manipulation{\n      public static void main(String[] args) throws Exception{\n          HasF hf = new HasF();\n          Manipulator<HasF> manipulation = new Manipulator<HasF>(hf);\n          manipulation.manipulate();\n      }\n  }\n  /* Output:\n  HasF.f();\n  *///\n  ```\n\n### 擦除带来的问题\n\n> 擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。\n\n泛型**不能用于显式地引用运行时类型的操作之中**，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。\n\n也就是说，需要时刻提醒自己，我只是**看起来好像拥有**有关参数的类型信息而已。实际上，**它只是一个Object！**\n\n### 边界\n\n既然编译器会`擦除`类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的`边界`：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。\n\n### 通配符\n\n```java\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Fruit{}\nclass Apple extends Fruit{}\nclass Jonathan extends Apple{}\nclass Orange extends Fruit{}\n\npublic class CompilerIntelligence{\n    public static void main(String[] args){\n        List<? extends Fruit> flist = Arrays.asList(new Apple());\n        Apple a = (Apple) flist.get(0);\n        // Orange o = (Orange) flist.get(0); 运行时错误\n        // flist.add(new Fruit());  编译错误\n        // flist.add(new Apple());  编译错误\n        System.out.println(flist.contains(a));\n        System.out.println(flist.contains(new Apple()));\n        System.out.println(flist.indexOf(new Apple()));\n    }\n}\n/*\ntrue\nfalse\n-1\n*///\n```\n\n对于使用了通配符的`List<? extends Fruit> flist`来说，其需要用到类型参数的方法例如`add()`参数也变成了`<? extends Fruit>`，然而编译器并不能知道这里需要哪一个具体的子类型，于是**编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。**\n\n## 容器\n\n完整的容器分类法：\n\n![image-20190312200304819](/images/image-20190312200304819.png)\n\n### HashMap\n\n`HashMap`采用了链地址法，也就是**数组+链表**的方式。主干是一个`Entry`数组，链表是为了解决哈希冲突而存在的。`HashMap`中的链表越少，性能越好。\n\n#### Entry数组长度为2的次幂\n\n- 由于在计算`key`的`插入位置`时用到了`hash & (length-1)`，`hash`是`key`计算出来的哈希值，想象一下当`length`不为2的次幂时，`length-1`的二进制必然有`0位`，那么意味着该位为`0`的位置永远不可能被当做`插入位置`，造成了严重的空间浪费。\n- 由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即`equal()`操作多了起来，效率也就慢了。\n\n#### resize\n\n`HashMap`当`Entry`数组元素超过`数组大小*loadFactor`时，就会进行数组扩容。`loadFactor`默认值为0.75。此时`Entry`数组大小会扩大一倍，保证了2的次幂大小。\n\n扩容的时候所有的`key`需要重新计算哈希值。\n\n#### JDK1.8优化\n\n由于1.8之前的`HashMap`在`hash`冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。\n\n### HashTable\n\n`HashTable`在结构上与`HashMap`基本相同，下面总结其不同点：\n\n- `HashMap`可有`null key`，`HashTable`获取`null key`会报空指针异常\n- `HashTable`有`synchronized`方法同步，线程安全；`HashMap`线程不安全\n- `Hash`值计算方法不同\n- `HashTable`初始大小为`11`，扩容机制为`2*old+1`；`HashMap`初始大小为`16`，扩容机制为`2*old`\n\n### ConcurrentHashMap\n\n`JDK1.7`版本中的`ConcurrentHashMap`比`HashMap`多了一层`Segment`，其中`Segment`继承于`ReentrantLock`：**一次`put`操作会调用`scanAndLockForPut()`方法自旋获取锁**；**而一次`get`操作则不需要加锁，`value`用`volatile`关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效**。\n\n`JDK1.8`版本移除了`segment`，有一个`Node`数组相当于`HashMap`中的`Entry`数组。同时采用了`CAS+synchronized关键字`进行`put`操作。`put`操作步骤如下：\n\n- 根据`key`计算出`hashcode`；\n- 判断是否需要进行初始化；\n- `f` 即为当前 `key` 定位出的 `Node`，如果为空表示当前位置可以写入数据，利用 `CAS` 尝试写入，失败则自旋保证成功；\n- 判断是否需要进行扩容；\n- 如果都不满足，则利用 `synchronized` 锁写入数据；\n- 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。\n\n## 线程\n\n### Brian Goetz的线程同步规则\n\n> 如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，**读写线程**都必须用相同的监视器锁同步。\n\n### Executor\n\nExecutor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class CachedThreadPool {\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++){\n            exec.execute(new LiftOff());\n        }\n        exec.shutdown();\n    }\n}\n/* Output:\n#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).\n*///\n```\n\n### 线程池\n\n线程池的作用是**限制系统中执行线程的数量**，根据系统情况可以**自动或手动**设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。\n\n- `newSingleThreadExecutor()`：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。\n- `newFixedThreadPool()`：创建固定大小的线程池。\n- `newCachedThreadPool()`：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。\n- `newScheduledThreadPool()`：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。\n\n### 任务的返回值\n\n通常实现`Runnable`接口的类是没有返回值的，要想任务在完成时返回一个值可实现`Callable<T>`接口，其泛型类型参数表示方法`call()`的返回值，并且需要使用`ExecutorService.submit()`方法调用他。\n\n```java\nimport java.util.ArrayList;\nimport java.util.concurrent.*;\n\nclass TaskWithResult implements Callable<String> {\n    private int id;\n\n    public TaskWithResult(int id) {\n        this.id = id;\n    }\n\n    public String call() {\n        return \"result of TaskWithResult\" + id;\n    }\n}\n\npublic class CallableDemo {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        ArrayList<Future<String>> results = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            results.add(exec.submit(new TaskWithResult(i)));\n        }\n        for (Future<String> fs : results) {\n            try {\n                System.out.println(fs.get());\n            } catch (InterruptedException | ExecutionException e) {\n                System.err.println(e);\n            } finally {\n                exec.shutdown();\n            }\n        }\n    }\n}\n/* Output：\nresult of TaskWithResult0\nresult of TaskWithResult1\nresult of TaskWithResult2\nresult of TaskWithResult3\nresult of TaskWithResult4\nresult of TaskWithResult5\nresult of TaskWithResult6\nresult of TaskWithResult7\nresult of TaskWithResult8\nresult of TaskWithResult9\n*///\n```\n\n`ExecutorService`对象的`submit()`方法会返回一个`Future<T>`对象，泛型类型参数即是实现`Callable<T>`的类型参数。`get()`方法会返回结果，若任务未完成，`get()`会阻塞。\n\n### 优先级\n\n优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。\n\n但是注意优先级高的线程也有几率比优先级底的线程执行的少。\n\n优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。\n\n### Thread.yield()可靠吗？\n\n`Thread.yield()`源码中提及了该方法的效果：**当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。**意即此处的`让步`只是一厢情愿，发出让步的线程同样可以继续执行。\n\n### 后台线程\n\n后台线程**并不属于程序中不可或缺的部分**。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。\n\n执行`main()`就是一个非后台线程，当`main()`没有执行结束时，程序就不会终止。\n\n后台线程创建的线程也将是后台线程。\n\n同时要注意在后台线程的`run()`方法中若有`finally`子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。\n\n### Thread还是Runnable\n\n创建多线程任务可以继承`Thread`类重写其`run()`方法，也可以实现`Runnable`接口实现其`run()`方法。\n\n实际应用中，`Runnable`还是比较有优势的：\n\n- 避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）\n- 多个线程区处理同一资源，而非独立处理（这句话有问题）\n\n注意，一开始在理解这里的时候我出现了误解，什么叫**处理同一资源**，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了**(待确认)**，如下：\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass TestThread extends Thread {\n    private int val = 10;\n    public void run(){\n        while(true){\n            System.out.println(Thread.currentThread() + \"-- val: \" + val--);\n            Thread.yield();\n            if  (val <= 0)\n                return;\n        }\n    }\n}\n\nclass TestRunnable implements Runnable {\n    private int val = 10;\n    @Override\n    public void run() {\n        while(true){\n            System.out.println(Thread.currentThread() + \"-- val: \" + val--);\n            Thread.yield();\n            if (val <= 0)\n                return;\n        }\n    }    \n}\n\npublic class TestRunnableAndThread {\n    public static void main(String[] args){\n        Runnable runnable = new TestRunnable();\n        Thread thread = new TestThread();\n        // a.只有1个线程处理一个数据\n        thread.start();\n        thread.start();\n        thread.start();\n        thread.start();\n        thread.start();\n        // b.5个不同线程处理不同数据\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        // c.5个不同线程处理相同数据\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        // d.5个不同线程处理相同数据\n        ExecutorService execRun = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execRun.execute(runnable);\n        // e.5个不同线程处理5个不同数据\n        ExecutorService execRun2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execRun2.execute(new TestRunnable());\n        // f.5个不同线程处理相同数据\n        ExecutorService execThread = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++){\n            execThread.execute(thread);\n        }\n        // g.5个不同线程处理5个不同数据\n        ExecutorService execThread2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execThread2.execute(new TestThread());\n        // i.5个不同线程处理相同数据\n        ExecutorService execThread2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execThread2.execute(new Thread(runnable));\n\n        execRun.shutdown();\n        execRun2.shutdown();\n        execThread.shutdown();\n        execThread2.shutdown();\n    }\n}\n```\n\n其中：**c、d、i**实际上是相同的，**b、g**是相同的，而**a**和**f**看起来相同，但是实际作用却差别很大，待研究。\n\n实际上，**a**是错误的用法，**b**、**c**基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个**线程安全的外部对象**。\n\n### 共享资源\n\n#### Synchronized\n\n冲突是多线程问题必须解决的任务，Java使用`synchronized`关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当**某一个任务第一次给该对象加锁时，计数变为1**，此后**只有这个相同的任务能继续给该对象加锁**，计数会递增；**每当离开一个synchronized方法时，计数递减**，直到计数变为0时，对象被解锁。要注意，**每个访问该临界资源的方法都必须被同步**，否则就不会正确地工作。\n\n通常`synchronized`关键字标识方法时，是在`this`上面同步，也可在方法中使用`synchronized(synObject){}`域，**以在特定的对象上同步**，因此不同对象上的锁是相互无关的。\n\n#### Lock\n\nLock对象必须被显式地创建、锁定和释放。\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MutexEvenGenerator {\n    private int currentEvenValue = 0;\n    // 显式声明\n    private Lock lock = new ReentrantLock();\n    public int next() {\n        // lock()方法创建临界资源\n        lock.lock();\n        try {\n            ++currentEvenValue;\n            Thread.yield();\n            ++currentEvenValue;\n            // return语句必须出现在try子句中\n            return currentEvenValue;\n        }finally {\n            // unlock()方法完成清理工作\n            lock.unlock();\n        }\n    }\n}\n```\n\n与`synchronize`相比，显式的`Lock`优点在于可以使用`finally子句`将系统维护在正常的状态，而在使用`synchronize`关键字时，某些事物失败了就会抛出异常。\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\npublic class AttemptLocking{\n    private ReentrantLock lock = new ReentrantLock();\n    public void untimed() {\n        boolean captured = lock.tryLock();\n        try {\n            System.out.println(\"untimed - tryLock(): \" + captured);\n            System.out.println(\"untimed - isHeldByCurrentThread(): \" + lock.isHeldByCurrentThread());\n        } finally {\n            if (captured) \n                lock.unlock();\n        }\n    }\n    public void timed() {\n        boolean captured = false;\n        try {\n            captured = lock.tryLock(2, TimeUnit.SECONDS);\n        } catch(InterruptedException e){\n            throw new RuntimeException(e);\n        }\n        try {\n            System.out.println(\"timed - tryLock(2, TimeUnit.SECONDS): \" + captured);\n            System.out.println(\"timed - isHeldByCurrentThread(): \" + lock.isHeldByCurrentThread());\n        } finally {\n            if (captured)\n                lock.unlock();\n        }\n    }\n    public static void main(String[] args){\n        final AttemptLocking al = new AttemptLocking();\n        al.untimed();\n        al.timed();\n        // 匿名内部类创建单独的Thread来获取锁，而未释放\n        new Thread(){\n            {setDaemon(true);}\n            public void run(){\n                al.lock.lock();\n                System.out.println(\"acquired\");\n                System.out.println(\"main - isHeldByCurrentThread(): \" + al.lock.isHeldByCurrentThread());\n            }\n        }.start();\n        Thread.yield();\n        al.untimed();\n        al.timed();\n    }\n}\n/* Output:\nuntimed - tryLock(): true\nuntimed - isHeldByCurrentThread(): true\ntimed - tryLock(2, TimeUnit.SECONDS): true\ntimed - isHeldByCurrentThread(): true\nacquired\nmain - isHeldByCurrentThread(): true\nuntimed - tryLock(): false\nuntimed - isHeldByCurrentThread(): false\ntimed - tryLock(2, TimeUnit.SECONDS): false\ntimed - isHeldByCurrentThread(): false\n*///\n```\n\n看代码就很容易理解了。\n\n#### 原子性与易变性\n\n原子操作**有可能无需同步机制**，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是**不可视的**，因此不同的任务对应用状态有不同的视图。\n\n**volatile关键字**确保了前面提及的可视性，以及当一个域被声明为volatile时，那么**只要对这个域产生了写操作，所有的读操作都可以看到这个修改**。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。\n\n所以**非volatile域**上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。\n\n因此多个任务在同时访问某个域时，**要么使用volatile关键字限定，要么经由同步机制访问**，以保证一致性。\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class AtomicityTest implements Runnable {\n    private int i = 0;\n    public int getValue() { \n        return i;\n    }\n    private void evenIncrement() {\n            i++; i++;\n    }\n    @Override\n    public void run() {\n        while (true)\n            evenIncrement();\n    }\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        AtomicityTest at = new AtomicityTest();\n        exec.execute(at);\n        while (true){\n            int val = at.getValue();\n            if (val%2 != 0){\n                System.out.println(val);\n                System.exit(0);\n            }\n        }\n    }\n}\n```\n\n看上面这个例子，程序找到奇数时便终止，理想状态下，通过`evenIncrement()`加2，`i`应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时`i`也不是`volatile`的，因此还存在可视性问题（当然，这里仅仅使用`volatile`限定`i`是不够的，因为`i++`操作不是原子性的）。下面使用`Lock`显式加锁以实现同步：\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class AtomicityTest implements Runnable {\n    private int i = 0;\n    private Lock lock = new ReentrantLock();\n    public int getValue() { \n        try {\n            lock.lock();\n            return i; \n        } finally {\n            lock.unlock();\n        }\n    }\n    private void evenIncrement() { \n        try {\n            lock.lock();\n            i++; i++; \n        } finally {\n            lock.unlock();\n        }\n    }\n    @Override\n    public void run() {\n        while (true)\n            evenIncrement();\n    }\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        AtomicityTest at = new AtomicityTest();\n        exec.execute(at);\n        while (true){\n            int val = at.getValue();\n            System.out.println(val);\n            if (val%2 != 0){\n                System.out.println(val);\n                System.exit(0);\n            }\n        }\n    }\n}\n```\n\n### 原子类\n\n上面说到**原子操作是较少的**，而`JSE5`引入了`AtomicInteger`、`AtomicLong`、`AtomicReference`等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。\n\n### ReetrantLock\n\nReentrantLock是一个**可重入**的**互斥锁**，又被称为\"**独占锁**\"。\n\n> **可重入锁**指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。\n>\n> **独占锁**指的是同一时间点锁只能被一个线程获取。\n\n同时ReentrantLock也分为**公平锁**和**非公平锁**，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。\n\n### ReentrantReedWriteLock\n\n顾名思义，ReentrantReadWriteLock维护了**读取锁**和**写入锁**。\n\n读取锁用于只读操作，是**共享锁**，能被多个线程获取；\n\n写入锁用于写入操作，是**独占锁**，只能被一个线程获取。\n\n### 线程状态\n\n- 新建（new）\n- 就绪（Runnable）\n- 阻塞（Blocked）\n  - 调用`sleep(milliseconds)`方法使任务休眠\n  - 调用`wait()`方法挂起\n  - 等待输入输出完成\n  - 获取锁失败\n- 死亡（Dead）\n\n### 线程协作\n\n#### wait()\n\n与`sleep()`和`yield()`不同，调用`wait()`时**需要释放当前线程获取的锁**，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了`notifyAll()`方法时，线程被唤醒。\n\n但是要注意，使用`wait()`的时候需要用`while`循环包围：\n\n- 为了检查线程是否被意外唤醒\n\n#### notifyAll()\n\n`notifyAll()`用来唤醒等待**某个锁**的所有**挂起的任务**。`等待某个锁`指的是某些需要获取共同的锁的线程，`notifyAll()`可以唤醒这些线程，而不是程序中所有被挂起的线程。\n\n### 死锁\n\n多个并发进程因争夺系统资源而产生相互等待的现象。\n\n四个必要条件：\n\n- 互斥\n- 占有且等待\n- 不可抢占\n- 循环等待\n\n### 免锁容器\n\n免锁容器的策略是：对容器的修改可以与读取操作**同时发生**，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。\n\n这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。\n\n#### 乐观锁\n\n每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。\n\n#### 悲观锁\n\n每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。`synchronized`关键字的实现就是悲观锁。\n\n#### CAS(Compare And Swap)技术\n\nCAS是用来实现乐观锁的一种方法，原理见[这里](https://www.jianshu.com/p/ae25eb3cfb5d)。\n\nCAS机制使用3个基本操作数：**内存地址`V`**，**旧的预期值`A`**，**要修改的新值`B`**。\n\n更新一个变量的时候，只有当`A`和`V`的实际值相同时，才会将`V`对应的值修改为`B`。\n\n缺点：\n\n- ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化\n- 循环时间长开销大\n- 只能保证一个共享变量的原子性\n\n未完~","source":"_posts/深入学习Java（更新中）.md","raw":"---\ntitle: Java - 基础知识\ndate: 2019-03-06 21:01:30\ntags:\n    - 垃圾回收\n    - 泛型编程\n    - 容器\ncategories:\n    - Java\n---\n\n## 垃圾回收器—GC\n\n众所周知，Java中的GC负责回收**无用对象占用的内存资源**，但会有特殊情况：假定对象获得了一块\"特殊\"的内存区域（不是使用new创建的），由于**GC只释放那些经由new分配的内存**，所以GC不知道如何释放该对象的这块\"特殊\"内存区域。\n\n<!-- more -->\n\n作为应对，Java允许在类中定义`finalize()`方法，它使得在GC回收该对象内存之前先调用`finalize()`方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在`finalize()`指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。\n\n**关键点：**\n\n1. 对象可能不被垃圾回收\n2. 垃圾回收并不等于\"析构\"\n3. 垃圾回收只与内存有关\n\n### 避免使用finalize()\n\n> \"终结函数无法预料，常常是危险的，总之是多余的。\"《Effective Java》，第20页\n\n在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在**通过某种创建对象以外的方式为对象分配了存储空间**。\n\nNative Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。\n\n可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。\n\n### 终结条件的验证\n\n但是finalize()有个有趣的用法——终结条件。看如下代码：\n\n```java\nclass Book{\n    // Book类，约定其在被回收前必须被签入。\n\tboolean checkedOut = false;\n\tBook(boolean checkedOut){\n\t\tcheckedOut = checkedOut;\n\t}\n\tvoid checkIn(){\n\t\tcheckedOut = false;\n\t}\n\tprotected void finalize(){\n        // 终结条件，对象未被签入\n\t\tif (checkedOut) {\n\t\t\tSystem.out.println(\"Error: checked out\");\n\t\t}\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n        // 创建一个Book对象-novel\n\t\tBook novel = new Book(true);\n        // 将其签入\n\t\tnovel.checkIn();\n        // 创建一个Book对象，此时该对象未被签入\n\t\tnew Book(true);\n        // 强制执行垃圾回收，此时会先执行finalize\n\t\tSystem.gc();\n\t}\n}\n\n/* 输出：\nError: checked out\n*/\n```\n\n我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。\n\n> 注意这里使用的System.gc()强制调用垃圾回收器\n\n若没有finalize()将很难实现这种操作。\n\n### GC如何工作\n\n#### 引用计数（未被使用过）\n\n对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。\n\n缺陷：循环引用不适用，即出现\"对象应该被回收，但引用计数不为0\"的情况，称作\"交互自引用的对象组\"。如下所示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // object1指向的对象引用计数器：1\n        MyObject object1 = new MyObject();\n        // object2指向的对象引用计数器：1\n        MyObject object2 = new MyObject();\n        // object1指向的对象引用计数器：2\n        object1.object = object2;\n        // object2指向的对象引用计数器：2\n        object2.object = object1;\n        // object1指向的对象引用计数器减少为1\n        object1 = null;\n        // object2指向的对象引用计数器减少为1\n        object2 = null;\n    }\n}\n```\n\n我们将`object1`和`object2`赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。\n\n#### 停止-复制（stop-and-copy）\n\n遍历所有**引用**找到所有\"活\"的**对象**，将堆中**所有存活的对象复制到另一个堆中**，没有被复制的便都是垃圾了。\n\n这种策略避免了上述\"交互自引用的对象组\"无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。\n\n**缺陷：效率低**\n\n1. 复制需要在两个堆之间操作，即需要维护多一倍的空间；\n2. 当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。\n\n针对第2个情况，有另外一种策略，如下。\n\n#### 标记-清扫（mark-and-sweep）\n\n同样遍历所有**引用**找到所有\"活\"的**对象**，同时会给该对象进行**标记**，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作\"标记-整理\"。\n\n> 注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。\n>\n> 许多文献中有关于\"垃圾回收器是低优先级的后台进程\"的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展\"停止-复制\"或\"标记-清扫\"工作。\n\n\"标记-清扫\"方式速度相当慢，但是当垃圾很少时，就很快了。\n\n#### 自适应技术\n\nJVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到\"标记-清扫\"方式；同样，JVM也会跟踪\"标记-清扫\"方式，若堆空间出现很多碎片，就会切换回\"停止-复制\"方式。这就是自适应技术。\n\n这是早期Sun版本的垃圾回收器。\n\n#### 分代垃圾收集（Generational Garbage Collection）\n\n上述无论是\"停止-复制\"、\"标记-清扫\"还是\"标记-整理\"对于日益增长的对象列表，效率会逐渐低下。\n\n![image-20190225225057306](/images/image-20190225225057306.png)\n\n堆被分为三代：\n\n- 年轻代(Young Generation)\n\n  内存空间：**eden:S0:S1 = 8:1:1**\n\n  S0和S1**没有先后顺序**，任何一个都可能是**From survivor space**和**To survivor space**\n\n- 年老代(Old Generation)\n\n  内存空间：年老代:年轻代 ≈ 2:1\n\n- 持久代(Permanent Generation)\n\n  用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n下面说明一下对象在分配内存、老化、回收的过程：\n\n1. 首先，任何新对象创建时内存都会分配在年轻代的**eden space**中，**S0**和**S1**两个**幸存者空间(survivor space)**起初都是空的![image-20190225225802212](/images/image-20190225225802212.png)\n\n2. 当eden space满时，会触发第一次**较小的垃圾回收过程(minor garbage collection，minor GC)**\u0001![image-20190225230110077](/images/image-20190225230110077.png)\n\n   > 实际上MinorGC不一定要等到eden space满了才触发\n\n3. eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收![image-20190225230647640](/images/image-20190225230647640.png)\n\n4. 当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象\u0001![image-20190225232204967](/images/image-20190225232204967.png)\n\n5. 再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收![image-20190225232407098](/images/image-20190225232407098.png)\n\n6. 当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代![image-20190225232630665](/images/image-20190225232630665.png)\n\n7. 以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发**完全的垃圾回收(major gabarge collector, major GC)**，清理并压缩该块内存空间。\n\n   major GC被触发的原因：\n\n   1. 年老代（Tenured）被写满\n\n   2. 持久代（Permanent）被写满\n\n   3. System.gc()被显式调用\n\n   4. 上一次GC之后Heap的各域分配策略动态变化\n\n##### HotSpot JVM的垃圾收集器\n\n**Serial收集器（复制算法)**：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n\n**Serial Old收集器(标记-整理算法)**：老年代单线程收集器，Serial收集器的老年代版本。\n\n**ParNew收集器(停止-复制算法)**：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n\n**Parallel Scavenge收集器(停止-复制算法)**：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n\n**Parallel Old收集器(停止-复制算法)**：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n\n**CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)**：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择\n\n【参考：[深入理解JVM(3)——7种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)】\n\n## 可变参数列表\n\nJava中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：\n\n```java\npublic class test{\n\tpublic static void main(String[] args){\n\t\tInteger a = 1;\n\t\tInteger b = 2;\n\t\tInteger c = 3;\n\t\tOther.main(a, b);\n\t\tOther.main(a, b, c);\n        Other.main();\n        Other.main(new Object[]{a, b});\n\t\tOther.main(new Object[]{a, b, c});\n\t}\n}\n\nclass Other{\n\tpublic static void main(Object... args){\n\t\tfor (Object s : args){\n\t\t\tSystem.out.println(s + \" \");\n\t\t}\n\t}\n}\n```\n\n如上所示，当输入不同个数参数时，编译器会自动将其**转换成数组**，当参数本身就是数组时，编译器又**不会进行转换**，直接传递给函数。参数为空时编译器便**直接传递一个空Object数组**。\n\n### 可变参数列表的重载\n\n```java\npublic class test{\n\tstatic void f(Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(String... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf('a', 'b');\n\t\tf(\"a\", \"b\");\n\t\tf();\n\t}\n}\n```\n\n如上，函数有`f(Character... args)`和`f(String... args)`两种重载方式，此时`f('a', 'b')`和`f(\"a\", \"b\")`都可正常调用，但是`f()`会报错，即两种重载都匹配。\n\n此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：\n\n```java\npublic class test{\n\tstatic void f(float i, Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(Character... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf(1, 'a');\n\t\tf('a', 'b');\n\t}\n}\n```\n\n如上，编译器也会报错，`f('a', 'b')`可匹配两个函数，(可能是)因为`char`类型可提升至`float`类型从而匹配第一个重载函数。\n\n此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。\n\n```java\npublic class test{\n\tstatic void f(float i, Character... args){\n\t\tSystem.out.println(\"first\");\n\t}\n\tstatic void f(char i, Character... args){\n\t\tSystem.out.println(\"second\");\n\t}\n\tpublic static void main(String[] args){\n\t\tf(1, 'a');\n\t\tf('a', 'b');\n\t}\n}\n```\n\n这种用法比较奇怪，因此\"你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它\"（《Java编程思想》105页）。\n\n## 内部类\n\n### 内部类对象对外围类对象的访问\n\n当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。\n\n```java\ninterface Selector {\n    boolean end();\n    Object current();\n    void next();\n}\n\npublic class Sequence {\n    private Object[] items;\n    private int next = 0;\n    public Sequence(int size) { items = new Object[size]; }\n    public void add(Object x){\n        if (next < items.length){\n            items[next++] = x;\n        }\n    }\n    private class SequenceSelector implements Selector {\n        private int i = 0;\n        public boolean end() { return i == items.length; }\n        public Object current() { return items[i]; }\n        public void next() { if(i < items.length) i++; }\n    }\n    public Selector selector(){\n        return new SequenceSelector();\n    } \n    public static void main(String[] args){\n        Sequence sequence = new Sequence(10);\n        for (int i = 0; i < 10; i++){\n            sequence.add(Integer.toString(i));\n        }\n        Selector selector = sequence.selector();\n        while(!selector.end()){\n            System.out.print(selector.current() + \" \");\n            selector.next();\n        }\n    }\n}\n```\n\nSequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。\n\n### 内部类与静态内部类（嵌套类）\n\n#### 创建方法\n\n```java\n// 内部类：DotNew.java\npublic class DotNew {\n    class Inner {\n        Inner(){\n            System.out.println(\"创建内部类\");\n        }\n    }\n    public static void main(String [] args){\n        DotNew dn = new DotNew();\n        DotNew.Inner dni = dn.new Inner();\n    }\n}\n\n// 静态内部类：DotNewStatic.java\npublic class DotNewStatic {\n    static class Inner {\n        Inner() {\n            System.out.println(\"创建静态内部类\");\n        }\n    }\n    public static void main(String[] args){\n        DotNewStatic.Inner inner = new DotNewStatic.Inner();\n    }\n}\n```\n\n### 匿名内部类\n\nJava支持**创建一个继承自某基类的匿名类的对象**，通过new表达式返回的引用被**自动向上转型为对基类的引用**。\n\n匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。\n\n注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是`final`，如下：\n\n```java\n// Destination.java\npublic interface Destination{\n    String readLabel();\n}\n\n// Parcel9.java\npublic class Parcel9 {\n    public Destination destination(final String dest){// 外部变量dest被引用时需声明为final，否则产生编译时错误\n        return new Destination(){\n            private String label = dest;\n            @Override\n            public String readLabel() {\n                return label;\n            }\n        };\n    }\n    public static void main(String[] args){\n        Parcel9 p = new Parcel9();\n        Destination d = p.destination(\"Tasmania\");\n        System.out.println(d.readLabel());\n    }\n}\n```\n\n> 但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。\n\n> **为什么匿名内部类访问外部变量必须是final的？**\n>\n> 1. 为了避免**外部方法修改引用导致内部类得到的引用值不一致**和**内部类修改引用而导致外部方法的参数值在修改前和修改后不一致**\n>\n> 2. 保证回调函数回调时可访问到变量（**待研究**）\n>\n> 3. 反编译查看其实现细节：\n>\n>    ```java\n>    // 源代码\n>    public interface MyInterface {\n>        void doSomething();\n>    }\n>    public class TryUsingAnonymousClass {\n>        public void useMyInterface() {\n>            final Integer number = 123;\n>            System.out.println(number);\n>    \n>            MyInterface myInterface = new MyInterface() {\n>                @Override\n>                public void doSomething() {\n>                    System.out.println(number);\n>                }\n>            };\n>            myInterface.doSomething();\n>    \n>            System.out.println(number);\n>        }\n>    }\n>    \n>    // 反编译结果\n>    class TryUsingAnonymousClass$1\n>            implements MyInterface {\n>        private final TryUsingAnonymousClass this$0;\n>        private final Integer paramInteger;\n>    \n>        TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) {\n>            this.this$0 = this$0;\n>            this.paramInteger = paramInteger;\n>        }\n>    \n>        public void doSomething() {\n>            System.out.println(this.paramInteger);\n>        }\n>    }\n>    ```\n>\n>    注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时**实际上是做了个\"拷贝\"**或者说**\"赋值\"**。若可以更改，则会造成数据不一致。\n\n## RTTI\n\nRTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是**多态的基础**，由**Class类实现**。\n\n### Class对象\n\n每当编写并且编译一个类时，在与类同名的`.class`文件中会自动产生一个`Class对象`。实现此过程的JVM子系统被称作**类加载器**。\n\nClass对象仅在需要的时候才被加载，也就是所有的类都是**只在对其第一次使用时**，动态加载到JVM中的。所谓第一次使用指的是**对类的非常量静态域的第一次引用。**\n\n- 要注意，**类的构造器**是**隐性非常量静态域**，所以使用new操作符生成对象也是产生这样的Class类引用。\n\n- 与此同时，还可以使用`Class.forName(类名)`产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常`ClassNotFoundException`。比如在JDBC连接数据库时常常用到的`Class.forName(\"com.mysql.jdbc.Driver\")`，就是告诉JVM去加载MySQL驱动。\n\n- 当已经拥有某个类型的对象（实例）时，可通过调用`getClass()`方法来获取该类型的Class引用。\n\n- 另一种方法，使用**类字面变量**。通过使用`类名.class`可获取此类的Class对象的引用，但是注意，此时**此Class对象还未被初始化**，还需要等到上述的`对类的非常量静态域的第一次引用`这一操作执行时才被初始化。\n\n  > 使用.class方法获取Class对象引用实际包含三个步骤：\n  >\n  > 1. **加载**：类加载器创建Class对象\n  > 2. **链接**\n  > 3. **初始化**：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块\n  >\n  > 考虑如下代码：\n  >\n  > ```java\n  > import java.util.Random;\n  > \n  > class Initable {\n  >     static final int staticFinal = 1;\n  >     static final int staticFinal2 = ClassInitialization.rand.nextInt(1000);\n  >     static {\n  >         System.out.println(\"Initializing Initable\");\n  >     }\n  > }\n  > \n  > class Initable2 {\n  >     static int staticNonFinal = 2;\n  >     static {\n  >         System.out.println(\"Initializing Initable2\");\n  >     }\n  > }\n  > \n  > class Initable3 {\n  >     static int staticNonFinal = 3;\n  >     static {\n  >         System.out.println(\"Initializing Initable3\");\n  >     }\n  > }\n  > \n  > public class ClassInitialization {\n  >     public static Random rand = new Random(47);\n  >     public static void main(String[] args) throws ClassNotFoundException {\n  >         // 创建Initable的Class对象的引用，Class对象未初始化\n  >         Class initable = Initable.class;\n  >         // 仍然未初始化，因Initable.staticFinal是常数\n  >         System.out.println(Initable.staticFinal);\n  >         // 触发了Initable的Class对象的初始化\n  >         System.out.println(Initable.staticFinal2);\n  >         // 触发了Initable2的Class对象的初始化\n  >         System.out.println(Initable2.staticNonFinal);\n  >         // 创建Initable3的Class对象的引用，同时会初始化此Class对象\n  >         Class initable3 = Class.forName(\"Initable3\");\n  >         // 此时已初始化，无需再次初始化\n  >         System.out.println(Initable3.staticNonFinal);\n  >     }\n  > }\n  > ```\n\n另外，当我拥有某个Class对象c的时候，我虽然**不知道它确切类型**，但是可以使用`c.newInstance()`来正确地获取c代表的类型的实例。**但是此方法要求对应的类**。\n\n### 泛化的Class对象引用\n\nClass对象可以通过`Class<Type>`的方法产生特定类型的类引用，创建了**使用类型限定后**的Class对象引用**不能再赋值给除本身和子类的其他的Class对象**。\n\n> 注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如`Integer`继承自`Number`，而`Integer Class对象`却不是`Number Class对象`的子类。\n\n使用通配符`Class<?>`优于平凡的`Class`（实际上是等价的），而且会免除编译器警告，看图：![image-20190308105552914](/images/image-20190308105552914.png)\n\n一种更好的用法，`Class<? extends Type>`，这种类型限定比直接`Class<Type>`好的地方在于他产生的Class对象引用**可赋值给Type本身及子类的Class对象**，这种继承关系**是Type所属的继承关系**而**不是对应的Class对象的继承关系**。\n\n### 转型语法（不常用）\n\n```java\nclass Building{}\nclass House extends Building {}\n\npublic class ClassCasts {\n    public static void main(String[] args){\n        Building b = new Building();\n        Class<House> houseType = House.class;\n        House h = houseType.cast(b);\n        h = (House) b;\n    }\n}\n```\n\n如上，使用`houseType.cast(b)`和`(House) b`效果一样，但是执行的工作却不同，具体内部实现尚未学习到。\n\n### 动态的类型检测\n\n#### obj instanceof ClassType\n\n返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。\n\n#### ClassType.isInstance()\n\n返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。\n\n#### 区别\n\n区别主要是后者与前者动态等价，看代码：\n\n```java\nclass Father{}\nclass Son extends Father{}\n\npublic class DynamicEqual {\n    public static void main(String[] args){\n        Father father = new Father();\n        Son son = new Son();\n        // instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称\n        // if (son instanceof father.getClass()){\n        //     ...\n        // }\n        // isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。\n        if (father.getClass().isInstance(son)){\n            System.out.println(\"isInstance is Dynamic\");\n        }\n    }\n}\n```\n\n#### 优点\n\n`isInstance()`的存在可以替代`instanceof`，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：\n\n- 使用`instanceof`时可能需要使用`switch-case`语句；当需要添加一个子类时，需要修改`switch-case`内部代码。\n- 而使用`isInstance()`时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。\n\n### 反射机制\n\n#### 反射与RTTI的区别\n\n- RTTI：编译器在编译时打开和检查`.class`文件（获取类的Class类对象信息）\n- 反射：JVM在运行时打开和检查`.class`文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取`.class`文件）\n\n#### 类方法提取器\n\n通过Class对象引用：调用`getMethods()`方法获取该类及其父类的方法列表，调用`getConstructors()`方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个**非public类的非public方法是无法被获取的**。\n\n#### 接口与类型信息\n\ninterface关键字的一种重要目标就是允许程序员**隔离构件，进而降低耦合性**。\n\n#### 包权限安全吗？\n\n直接看例子：\n\n```java\n// A.java\npublic interface A{\n    void f();\n}\n\n// HiddenC.java\nclass C implements A{\n\n    @Override\n    public void f() {\n        System.out.println(\"public C.f()\");\n    }\n    public void g(){\n        System.out.println(\"public C.g()\");\n    }\n    void u(){\n        System.out.println(\"package C.u()\");\n    }\n    protected void v(){\n        System.out.println(\"protected C.v()\");\n    }\n    private void w(){\n        System.out.println(\"private C.w()\");\n    }\n}\npublic class HiddenC {\n    public static A makeA(){\n        return new C();\n    }\n}\n\n// HiddenImplementation.java\nimport java.lang.reflect.Method;\npublic class HiddenImplementation {\n    public static void main(String[] args) throws Exception {\n        A a = HiddenC.makeA();\n        a.f();\n        System.out.println(a.getClass().getName());\n        callHiddenMethod(a, \"g\");\n        callHiddenMethod(a, \"u\");\n        callHiddenMethod(a, \"v\");\n        callHiddenMethod(a, \"w\");\n    }\n    static void callHiddenMethod(Object a, String methodName) throws Exception{\n        // 获取a中的方法\n        Method g = a.getClass().getDeclaredMethod(methodName);\n        // 修改该方法的权限\n        g.setAccessible(true);\n        // 调用该方法\n        g.invoke(a);\n    }\n}\n/* output\npublic C.f()\nC\npublic C.g()\npackage C.u()\nprotected C.v()\nprivate C.w()\n*///:)\n```\n\n- 当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用`setAccessble(true)`后被调用。\n- 只发布`.class`文件也是没办法避免此问题，`javap -private`命令可以反编译`.class`文件，`-private`参数约定显示所有的成员\n- 同样，内部类和匿名内部类也是没办法避免此情况\n\n## 泛型\n\n### 指定类型有保证吗？\n\n> 在泛型代码内部，无法获得任何有关泛型参数类型的信息。\n\n例如对于`ArrayList<String>`和`ArrayList<Integer>`，二者的实例调用`.getClass()`获取的Class对象时相同的，如下：\n\n```java\nimport java.util.ArrayList;\n\npublic class Erase{\n    public static void main(String[] args){\n        Class<?> s = new ArrayList<String>().getClass();\n        Class<?> i = new ArrayList<Integer>().getClass();\n        System.out.println(s == i);\n        System.out.println(s.getName());\n        System.out.println(s.getTypeParameters());\n    }\n}\n/* Output:\ntrue\njava.util.ArrayList\n[Ljava.lang.reflect.TypeVariable;@68f7aae2\n*///\n```\n\n但是，如果在一个`ArrayList<String>`类型的实例中添加`Integer`会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：\n\n```java\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nclass Apple{\n    @Override\n    public String toString(){\n        return \"This is an apple\";\n    }\n}\n\npublic class ReflectAdd{\n    public static void main(String[] args) throws Exception{\n        ArrayList<String> strings = new ArrayList<>();\n        Class<?> s = strings.getClass();\n        Method method = s.getMethod(\"add\", Object.class);\n        method.invoke(strings, 1);\n        method.invoke(strings, \"2\");\n        method.invoke(strings, 3);\n        method.invoke(strings, new Apple());\n        System.out.println(Arrays.toString(strings.toArray()));\n        for (Object o : strings){\n            System.out.println(o.getClass());\n        }\n    }\n}\n/* Output:\n[1, 2, 3, This is an apple]\nclass java.lang.Integer\nclass java.lang.String\nclass java.lang.Integer\nclass Apple\n*///\n```\n\n我们可以看到上述代码使用反射机制成功的在`ArrayList<String>`里面添加了`Integer`，原因在于`ArrayList`的泛型实现`ArrayList<E>`使其被擦除为`ArrayList<Object>`，从而通过反射机制找到其`add(E e)`方法时，实际上是`add(Object o)`，而我们代码中的`Method method = s.getMethod(\"add\", Object.class);`恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。\n\n### 与C++的区别\n\n**C++:**\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> class Manipulator {\n    T obj;\npublic :\n    Manipulator(T x) { obj = x; }\n    void manipulate() { obj.f(); }\n    void manipulate2() { obj.noF(); }\n};\n\nclass HasF {\npublic:\n    void f(){\n        cout << \"HasF()::f()\" << endl;\n    }\n};\n\nclass DontHaveF{\npublic:\n    void noF(){\n        cout << \"Don't have f()\" << endl;\n    }\n};\n\nint main(){\n    HasF hf;\n    Manipulator<HasF> manipulator(hf);\n    manipulator.manipulate();\n    // manipulator.manipulate2();  无法编译\n    DontHaveF dhf;\n    Manipulator<DontHaveF> manipulator2(dhf);\n    // manipulator2.manipulate();  无法编译\n    manipulator2.manipulate2();\n}\n/* Output:\nHasF()::f()\nDon't have f()\n*///\n```\n\n模板类`Manipulator`在编译时期便可以检测到函数`f()`、`noF()`是在类型参数<T>中存在的，这是在编译器看到声明`Manipulator<HasF> manipulator(hf)`和`Manipulator<DontHaveF> manipulator2(dhf)`所产生的结果。\n\n然而Java中却无法实现这样的操作：\n\n**Java:**\n\n```java\n// HasF.java\npublic class HasF{\n    public void f(){\n        System.out.println(\"HasF.f();\");\n    }\n}\n\n// Manipulation.java\nimport java.lang.reflect.Method;\n\nclass Manipulator<T> {\n    private T obj;\n    public Manipulator(T x) {\n        obj = x;\n    }\n    public void manipulate(){\n        obj.f() // 会报编译错误\n    }\n}\n\npublic class Manipulation{\n    public static void main(String[] args){\n        HasF hf = new HasF();\n        Manipulator<HasF> manipulation = new Manipulator<HasF>(hf);\n        manipulation.manipulate();\n    }\n}\n```\n\n由于Java在编译过程中，`Manipulator<T>`是无法确定其类型参数，只知道他是一个`Object实例`，因此obj**只能调用Object基类所有的公开方法**。若想实现C++的操作有两种办法(目前我已知的只有这两种)。\n\n- 为`T`限定参数类型（给定边界），即声明时指定其所继承的基类：\n\n  ```java\n  class Manipulator<T extends HasF>{\n      ...\n  }\n  ```\n\n- 使用反射机制调用` f()`\n\n  ```java\n  import java.lang.reflect.Method;\n  \n  class Manipulator<T> {\n      private T obj;\n      public Manipulator(T x) {\n          obj = x;\n      }\n      public void manipulate() throws Exception{\n          Class<?> oc = obj.getClass();\n          Method method = oc.getMethod(\"f\");\n          method.invoke(obj);\n      }\n  }\n  \n  public class Manipulation{\n      public static void main(String[] args) throws Exception{\n          HasF hf = new HasF();\n          Manipulator<HasF> manipulation = new Manipulator<HasF>(hf);\n          manipulation.manipulate();\n      }\n  }\n  /* Output:\n  HasF.f();\n  *///\n  ```\n\n### 擦除带来的问题\n\n> 擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。\n\n泛型**不能用于显式地引用运行时类型的操作之中**，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。\n\n也就是说，需要时刻提醒自己，我只是**看起来好像拥有**有关参数的类型信息而已。实际上，**它只是一个Object！**\n\n### 边界\n\n既然编译器会`擦除`类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的`边界`：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。\n\n### 通配符\n\n```java\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Fruit{}\nclass Apple extends Fruit{}\nclass Jonathan extends Apple{}\nclass Orange extends Fruit{}\n\npublic class CompilerIntelligence{\n    public static void main(String[] args){\n        List<? extends Fruit> flist = Arrays.asList(new Apple());\n        Apple a = (Apple) flist.get(0);\n        // Orange o = (Orange) flist.get(0); 运行时错误\n        // flist.add(new Fruit());  编译错误\n        // flist.add(new Apple());  编译错误\n        System.out.println(flist.contains(a));\n        System.out.println(flist.contains(new Apple()));\n        System.out.println(flist.indexOf(new Apple()));\n    }\n}\n/*\ntrue\nfalse\n-1\n*///\n```\n\n对于使用了通配符的`List<? extends Fruit> flist`来说，其需要用到类型参数的方法例如`add()`参数也变成了`<? extends Fruit>`，然而编译器并不能知道这里需要哪一个具体的子类型，于是**编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。**\n\n## 容器\n\n完整的容器分类法：\n\n![image-20190312200304819](/images/image-20190312200304819.png)\n\n### HashMap\n\n`HashMap`采用了链地址法，也就是**数组+链表**的方式。主干是一个`Entry`数组，链表是为了解决哈希冲突而存在的。`HashMap`中的链表越少，性能越好。\n\n#### Entry数组长度为2的次幂\n\n- 由于在计算`key`的`插入位置`时用到了`hash & (length-1)`，`hash`是`key`计算出来的哈希值，想象一下当`length`不为2的次幂时，`length-1`的二进制必然有`0位`，那么意味着该位为`0`的位置永远不可能被当做`插入位置`，造成了严重的空间浪费。\n- 由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即`equal()`操作多了起来，效率也就慢了。\n\n#### resize\n\n`HashMap`当`Entry`数组元素超过`数组大小*loadFactor`时，就会进行数组扩容。`loadFactor`默认值为0.75。此时`Entry`数组大小会扩大一倍，保证了2的次幂大小。\n\n扩容的时候所有的`key`需要重新计算哈希值。\n\n#### JDK1.8优化\n\n由于1.8之前的`HashMap`在`hash`冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。\n\n### HashTable\n\n`HashTable`在结构上与`HashMap`基本相同，下面总结其不同点：\n\n- `HashMap`可有`null key`，`HashTable`获取`null key`会报空指针异常\n- `HashTable`有`synchronized`方法同步，线程安全；`HashMap`线程不安全\n- `Hash`值计算方法不同\n- `HashTable`初始大小为`11`，扩容机制为`2*old+1`；`HashMap`初始大小为`16`，扩容机制为`2*old`\n\n### ConcurrentHashMap\n\n`JDK1.7`版本中的`ConcurrentHashMap`比`HashMap`多了一层`Segment`，其中`Segment`继承于`ReentrantLock`：**一次`put`操作会调用`scanAndLockForPut()`方法自旋获取锁**；**而一次`get`操作则不需要加锁，`value`用`volatile`关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效**。\n\n`JDK1.8`版本移除了`segment`，有一个`Node`数组相当于`HashMap`中的`Entry`数组。同时采用了`CAS+synchronized关键字`进行`put`操作。`put`操作步骤如下：\n\n- 根据`key`计算出`hashcode`；\n- 判断是否需要进行初始化；\n- `f` 即为当前 `key` 定位出的 `Node`，如果为空表示当前位置可以写入数据，利用 `CAS` 尝试写入，失败则自旋保证成功；\n- 判断是否需要进行扩容；\n- 如果都不满足，则利用 `synchronized` 锁写入数据；\n- 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。\n\n## 线程\n\n### Brian Goetz的线程同步规则\n\n> 如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，**读写线程**都必须用相同的监视器锁同步。\n\n### Executor\n\nExecutor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class CachedThreadPool {\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++){\n            exec.execute(new LiftOff());\n        }\n        exec.shutdown();\n    }\n}\n/* Output:\n#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).\n*///\n```\n\n### 线程池\n\n线程池的作用是**限制系统中执行线程的数量**，根据系统情况可以**自动或手动**设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。\n\n- `newSingleThreadExecutor()`：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。\n- `newFixedThreadPool()`：创建固定大小的线程池。\n- `newCachedThreadPool()`：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。\n- `newScheduledThreadPool()`：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。\n\n### 任务的返回值\n\n通常实现`Runnable`接口的类是没有返回值的，要想任务在完成时返回一个值可实现`Callable<T>`接口，其泛型类型参数表示方法`call()`的返回值，并且需要使用`ExecutorService.submit()`方法调用他。\n\n```java\nimport java.util.ArrayList;\nimport java.util.concurrent.*;\n\nclass TaskWithResult implements Callable<String> {\n    private int id;\n\n    public TaskWithResult(int id) {\n        this.id = id;\n    }\n\n    public String call() {\n        return \"result of TaskWithResult\" + id;\n    }\n}\n\npublic class CallableDemo {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        ArrayList<Future<String>> results = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            results.add(exec.submit(new TaskWithResult(i)));\n        }\n        for (Future<String> fs : results) {\n            try {\n                System.out.println(fs.get());\n            } catch (InterruptedException | ExecutionException e) {\n                System.err.println(e);\n            } finally {\n                exec.shutdown();\n            }\n        }\n    }\n}\n/* Output：\nresult of TaskWithResult0\nresult of TaskWithResult1\nresult of TaskWithResult2\nresult of TaskWithResult3\nresult of TaskWithResult4\nresult of TaskWithResult5\nresult of TaskWithResult6\nresult of TaskWithResult7\nresult of TaskWithResult8\nresult of TaskWithResult9\n*///\n```\n\n`ExecutorService`对象的`submit()`方法会返回一个`Future<T>`对象，泛型类型参数即是实现`Callable<T>`的类型参数。`get()`方法会返回结果，若任务未完成，`get()`会阻塞。\n\n### 优先级\n\n优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。\n\n但是注意优先级高的线程也有几率比优先级底的线程执行的少。\n\n优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。\n\n### Thread.yield()可靠吗？\n\n`Thread.yield()`源码中提及了该方法的效果：**当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。**意即此处的`让步`只是一厢情愿，发出让步的线程同样可以继续执行。\n\n### 后台线程\n\n后台线程**并不属于程序中不可或缺的部分**。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。\n\n执行`main()`就是一个非后台线程，当`main()`没有执行结束时，程序就不会终止。\n\n后台线程创建的线程也将是后台线程。\n\n同时要注意在后台线程的`run()`方法中若有`finally`子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。\n\n### Thread还是Runnable\n\n创建多线程任务可以继承`Thread`类重写其`run()`方法，也可以实现`Runnable`接口实现其`run()`方法。\n\n实际应用中，`Runnable`还是比较有优势的：\n\n- 避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）\n- 多个线程区处理同一资源，而非独立处理（这句话有问题）\n\n注意，一开始在理解这里的时候我出现了误解，什么叫**处理同一资源**，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了**(待确认)**，如下：\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass TestThread extends Thread {\n    private int val = 10;\n    public void run(){\n        while(true){\n            System.out.println(Thread.currentThread() + \"-- val: \" + val--);\n            Thread.yield();\n            if  (val <= 0)\n                return;\n        }\n    }\n}\n\nclass TestRunnable implements Runnable {\n    private int val = 10;\n    @Override\n    public void run() {\n        while(true){\n            System.out.println(Thread.currentThread() + \"-- val: \" + val--);\n            Thread.yield();\n            if (val <= 0)\n                return;\n        }\n    }    \n}\n\npublic class TestRunnableAndThread {\n    public static void main(String[] args){\n        Runnable runnable = new TestRunnable();\n        Thread thread = new TestThread();\n        // a.只有1个线程处理一个数据\n        thread.start();\n        thread.start();\n        thread.start();\n        thread.start();\n        thread.start();\n        // b.5个不同线程处理不同数据\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        new TestThread().start();\n        // c.5个不同线程处理相同数据\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        // d.5个不同线程处理相同数据\n        ExecutorService execRun = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execRun.execute(runnable);\n        // e.5个不同线程处理5个不同数据\n        ExecutorService execRun2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execRun2.execute(new TestRunnable());\n        // f.5个不同线程处理相同数据\n        ExecutorService execThread = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++){\n            execThread.execute(thread);\n        }\n        // g.5个不同线程处理5个不同数据\n        ExecutorService execThread2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execThread2.execute(new TestThread());\n        // i.5个不同线程处理相同数据\n        ExecutorService execThread2 = Executors.newCachedThreadPool();\n        for (int i = 0; i < 5; i++)\n            execThread2.execute(new Thread(runnable));\n\n        execRun.shutdown();\n        execRun2.shutdown();\n        execThread.shutdown();\n        execThread2.shutdown();\n    }\n}\n```\n\n其中：**c、d、i**实际上是相同的，**b、g**是相同的，而**a**和**f**看起来相同，但是实际作用却差别很大，待研究。\n\n实际上，**a**是错误的用法，**b**、**c**基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个**线程安全的外部对象**。\n\n### 共享资源\n\n#### Synchronized\n\n冲突是多线程问题必须解决的任务，Java使用`synchronized`关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当**某一个任务第一次给该对象加锁时，计数变为1**，此后**只有这个相同的任务能继续给该对象加锁**，计数会递增；**每当离开一个synchronized方法时，计数递减**，直到计数变为0时，对象被解锁。要注意，**每个访问该临界资源的方法都必须被同步**，否则就不会正确地工作。\n\n通常`synchronized`关键字标识方法时，是在`this`上面同步，也可在方法中使用`synchronized(synObject){}`域，**以在特定的对象上同步**，因此不同对象上的锁是相互无关的。\n\n#### Lock\n\nLock对象必须被显式地创建、锁定和释放。\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MutexEvenGenerator {\n    private int currentEvenValue = 0;\n    // 显式声明\n    private Lock lock = new ReentrantLock();\n    public int next() {\n        // lock()方法创建临界资源\n        lock.lock();\n        try {\n            ++currentEvenValue;\n            Thread.yield();\n            ++currentEvenValue;\n            // return语句必须出现在try子句中\n            return currentEvenValue;\n        }finally {\n            // unlock()方法完成清理工作\n            lock.unlock();\n        }\n    }\n}\n```\n\n与`synchronize`相比，显式的`Lock`优点在于可以使用`finally子句`将系统维护在正常的状态，而在使用`synchronize`关键字时，某些事物失败了就会抛出异常。\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\npublic class AttemptLocking{\n    private ReentrantLock lock = new ReentrantLock();\n    public void untimed() {\n        boolean captured = lock.tryLock();\n        try {\n            System.out.println(\"untimed - tryLock(): \" + captured);\n            System.out.println(\"untimed - isHeldByCurrentThread(): \" + lock.isHeldByCurrentThread());\n        } finally {\n            if (captured) \n                lock.unlock();\n        }\n    }\n    public void timed() {\n        boolean captured = false;\n        try {\n            captured = lock.tryLock(2, TimeUnit.SECONDS);\n        } catch(InterruptedException e){\n            throw new RuntimeException(e);\n        }\n        try {\n            System.out.println(\"timed - tryLock(2, TimeUnit.SECONDS): \" + captured);\n            System.out.println(\"timed - isHeldByCurrentThread(): \" + lock.isHeldByCurrentThread());\n        } finally {\n            if (captured)\n                lock.unlock();\n        }\n    }\n    public static void main(String[] args){\n        final AttemptLocking al = new AttemptLocking();\n        al.untimed();\n        al.timed();\n        // 匿名内部类创建单独的Thread来获取锁，而未释放\n        new Thread(){\n            {setDaemon(true);}\n            public void run(){\n                al.lock.lock();\n                System.out.println(\"acquired\");\n                System.out.println(\"main - isHeldByCurrentThread(): \" + al.lock.isHeldByCurrentThread());\n            }\n        }.start();\n        Thread.yield();\n        al.untimed();\n        al.timed();\n    }\n}\n/* Output:\nuntimed - tryLock(): true\nuntimed - isHeldByCurrentThread(): true\ntimed - tryLock(2, TimeUnit.SECONDS): true\ntimed - isHeldByCurrentThread(): true\nacquired\nmain - isHeldByCurrentThread(): true\nuntimed - tryLock(): false\nuntimed - isHeldByCurrentThread(): false\ntimed - tryLock(2, TimeUnit.SECONDS): false\ntimed - isHeldByCurrentThread(): false\n*///\n```\n\n看代码就很容易理解了。\n\n#### 原子性与易变性\n\n原子操作**有可能无需同步机制**，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是**不可视的**，因此不同的任务对应用状态有不同的视图。\n\n**volatile关键字**确保了前面提及的可视性，以及当一个域被声明为volatile时，那么**只要对这个域产生了写操作，所有的读操作都可以看到这个修改**。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。\n\n所以**非volatile域**上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。\n\n因此多个任务在同时访问某个域时，**要么使用volatile关键字限定，要么经由同步机制访问**，以保证一致性。\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class AtomicityTest implements Runnable {\n    private int i = 0;\n    public int getValue() { \n        return i;\n    }\n    private void evenIncrement() {\n            i++; i++;\n    }\n    @Override\n    public void run() {\n        while (true)\n            evenIncrement();\n    }\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        AtomicityTest at = new AtomicityTest();\n        exec.execute(at);\n        while (true){\n            int val = at.getValue();\n            if (val%2 != 0){\n                System.out.println(val);\n                System.exit(0);\n            }\n        }\n    }\n}\n```\n\n看上面这个例子，程序找到奇数时便终止，理想状态下，通过`evenIncrement()`加2，`i`应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时`i`也不是`volatile`的，因此还存在可视性问题（当然，这里仅仅使用`volatile`限定`i`是不够的，因为`i++`操作不是原子性的）。下面使用`Lock`显式加锁以实现同步：\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class AtomicityTest implements Runnable {\n    private int i = 0;\n    private Lock lock = new ReentrantLock();\n    public int getValue() { \n        try {\n            lock.lock();\n            return i; \n        } finally {\n            lock.unlock();\n        }\n    }\n    private void evenIncrement() { \n        try {\n            lock.lock();\n            i++; i++; \n        } finally {\n            lock.unlock();\n        }\n    }\n    @Override\n    public void run() {\n        while (true)\n            evenIncrement();\n    }\n    public static void main(String[] args){\n        ExecutorService exec = Executors.newCachedThreadPool();\n        AtomicityTest at = new AtomicityTest();\n        exec.execute(at);\n        while (true){\n            int val = at.getValue();\n            System.out.println(val);\n            if (val%2 != 0){\n                System.out.println(val);\n                System.exit(0);\n            }\n        }\n    }\n}\n```\n\n### 原子类\n\n上面说到**原子操作是较少的**，而`JSE5`引入了`AtomicInteger`、`AtomicLong`、`AtomicReference`等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。\n\n### ReetrantLock\n\nReentrantLock是一个**可重入**的**互斥锁**，又被称为\"**独占锁**\"。\n\n> **可重入锁**指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。\n>\n> **独占锁**指的是同一时间点锁只能被一个线程获取。\n\n同时ReentrantLock也分为**公平锁**和**非公平锁**，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。\n\n### ReentrantReedWriteLock\n\n顾名思义，ReentrantReadWriteLock维护了**读取锁**和**写入锁**。\n\n读取锁用于只读操作，是**共享锁**，能被多个线程获取；\n\n写入锁用于写入操作，是**独占锁**，只能被一个线程获取。\n\n### 线程状态\n\n- 新建（new）\n- 就绪（Runnable）\n- 阻塞（Blocked）\n  - 调用`sleep(milliseconds)`方法使任务休眠\n  - 调用`wait()`方法挂起\n  - 等待输入输出完成\n  - 获取锁失败\n- 死亡（Dead）\n\n### 线程协作\n\n#### wait()\n\n与`sleep()`和`yield()`不同，调用`wait()`时**需要释放当前线程获取的锁**，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了`notifyAll()`方法时，线程被唤醒。\n\n但是要注意，使用`wait()`的时候需要用`while`循环包围：\n\n- 为了检查线程是否被意外唤醒\n\n#### notifyAll()\n\n`notifyAll()`用来唤醒等待**某个锁**的所有**挂起的任务**。`等待某个锁`指的是某些需要获取共同的锁的线程，`notifyAll()`可以唤醒这些线程，而不是程序中所有被挂起的线程。\n\n### 死锁\n\n多个并发进程因争夺系统资源而产生相互等待的现象。\n\n四个必要条件：\n\n- 互斥\n- 占有且等待\n- 不可抢占\n- 循环等待\n\n### 免锁容器\n\n免锁容器的策略是：对容器的修改可以与读取操作**同时发生**，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。\n\n这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。\n\n#### 乐观锁\n\n每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。\n\n#### 悲观锁\n\n每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。`synchronized`关键字的实现就是悲观锁。\n\n#### CAS(Compare And Swap)技术\n\nCAS是用来实现乐观锁的一种方法，原理见[这里](https://www.jianshu.com/p/ae25eb3cfb5d)。\n\nCAS机制使用3个基本操作数：**内存地址`V`**，**旧的预期值`A`**，**要修改的新值`B`**。\n\n更新一个变量的时候，只有当`A`和`V`的实际值相同时，才会将`V`对应的值修改为`B`。\n\n缺点：\n\n- ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化\n- 循环时间长开销大\n- 只能保证一个共享变量的原子性\n\n未完~","slug":"深入学习Java（更新中）","published":1,"updated":"2021-05-16T10:42:02.363Z","_id":"ckfukjaa1001fszxoisla5phb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"垃圾回收器—GC\"><a href=\"#垃圾回收器—GC\" class=\"headerlink\" title=\"垃圾回收器—GC\"></a>垃圾回收器—GC</h2><p>众所周知，Java中的GC负责回收<strong>无用对象占用的内存资源</strong>，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于<strong>GC只释放那些经由new分配的内存</strong>，所以GC不知道如何释放该对象的这块”特殊”内存区域。</p>\n<a id=\"more\"></a>\n<p>作为应对，Java允许在类中定义<code>finalize()</code>方法，它使得在GC回收该对象内存之前先调用<code>finalize()</code>方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在<code>finalize()</code>指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。</p>\n<p><strong>关键点：</strong></p>\n<ol>\n<li>对象可能不被垃圾回收</li>\n<li>垃圾回收并不等于”析构”</li>\n<li>垃圾回收只与内存有关</li>\n</ol>\n<h3 id=\"避免使用finalize\"><a href=\"#避免使用finalize\" class=\"headerlink\" title=\"避免使用finalize()\"></a>避免使用finalize()</h3><blockquote>\n<p>“终结函数无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页</p>\n</blockquote>\n<p>在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在<strong>通过某种创建对象以外的方式为对象分配了存储空间</strong>。</p>\n<p>Native Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。</p>\n<p>可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。</p>\n<h3 id=\"终结条件的验证\"><a href=\"#终结条件的验证\" class=\"headerlink\" title=\"终结条件的验证\"></a>终结条件的验证</h3><p>但是finalize()有个有趣的用法——终结条件。看如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Book类，约定其在被回收前必须被签入。</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> checkedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\tBook(<span class=\"keyword\">boolean</span> checkedOut)&#123;</span><br><span class=\"line\">\t\tcheckedOut = checkedOut;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkIn</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tcheckedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 终结条件，对象未被签入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (checkedOut) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"Error: checked out\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个Book对象-novel</span></span><br><span class=\"line\">\t\tBook novel = <span class=\"keyword\">new</span> Book(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将其签入</span></span><br><span class=\"line\">\t\tnovel.checkIn();</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个Book对象，此时该对象未被签入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Book(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 强制执行垃圾回收，此时会先执行finalize</span></span><br><span class=\"line\">\t\tSystem.gc();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 输出：</span></span><br><span class=\"line\"><span class=\"comment\">Error: checked out</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。</p>\n<blockquote>\n<p>注意这里使用的System.gc()强制调用垃圾回收器</p>\n</blockquote>\n<p>若没有finalize()将很难实现这种操作。</p>\n<h3 id=\"GC如何工作\"><a href=\"#GC如何工作\" class=\"headerlink\" title=\"GC如何工作\"></a>GC如何工作</h3><h4 id=\"引用计数（未被使用过）\"><a href=\"#引用计数（未被使用过）\" class=\"headerlink\" title=\"引用计数（未被使用过）\"></a>引用计数（未被使用过）</h4><p>对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。</p>\n<p>缺陷：循环引用不适用，即出现”对象应该被回收，但引用计数不为0”的情况，称作”交互自引用的对象组”。如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器：1</span></span><br><span class=\"line\">        MyObject object1 = <span class=\"keyword\">new</span> MyObject();</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器：1</span></span><br><span class=\"line\">        MyObject object2 = <span class=\"keyword\">new</span> MyObject();</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器：2</span></span><br><span class=\"line\">        object1.object = object2;</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器：2</span></span><br><span class=\"line\">        object2.object = object1;</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器减少为1</span></span><br><span class=\"line\">        object1 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器减少为1</span></span><br><span class=\"line\">        object2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将<code>object1</code>和<code>object2</code>赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。</p>\n<h4 id=\"停止-复制（stop-and-copy）\"><a href=\"#停止-复制（stop-and-copy）\" class=\"headerlink\" title=\"停止-复制（stop-and-copy）\"></a>停止-复制（stop-and-copy）</h4><p>遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，将堆中<strong>所有存活的对象复制到另一个堆中</strong>，没有被复制的便都是垃圾了。</p>\n<p>这种策略避免了上述”交互自引用的对象组”无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。</p>\n<p><strong>缺陷：效率低</strong></p>\n<ol>\n<li>复制需要在两个堆之间操作，即需要维护多一倍的空间；</li>\n<li>当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。</li>\n</ol>\n<p>针对第2个情况，有另外一种策略，如下。</p>\n<h4 id=\"标记-清扫（mark-and-sweep）\"><a href=\"#标记-清扫（mark-and-sweep）\" class=\"headerlink\" title=\"标记-清扫（mark-and-sweep）\"></a>标记-清扫（mark-and-sweep）</h4><p>同样遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，同时会给该对象进行<strong>标记</strong>，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作”标记-整理”。</p>\n<blockquote>\n<p>注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。</p>\n<p>许多文献中有关于”垃圾回收器是低优先级的后台进程”的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展”停止-复制”或”标记-清扫”工作。</p>\n</blockquote>\n<p>“标记-清扫”方式速度相当慢，但是当垃圾很少时，就很快了。</p>\n<h4 id=\"自适应技术\"><a href=\"#自适应技术\" class=\"headerlink\" title=\"自适应技术\"></a>自适应技术</h4><p>JVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到”标记-清扫”方式；同样，JVM也会跟踪”标记-清扫”方式，若堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是自适应技术。</p>\n<p>这是早期Sun版本的垃圾回收器。</p>\n<h4 id=\"分代垃圾收集（Generational-Garbage-Collection）\"><a href=\"#分代垃圾收集（Generational-Garbage-Collection）\" class=\"headerlink\" title=\"分代垃圾收集（Generational Garbage Collection）\"></a>分代垃圾收集（Generational Garbage Collection）</h4><p>上述无论是”停止-复制”、”标记-清扫”还是”标记-整理”对于日益增长的对象列表，效率会逐渐低下。</p>\n<p><img src=\"/images/image-20190225225057306.png\" alt=\"image-20190225225057306\"></p>\n<p>堆被分为三代：</p>\n<ul>\n<li><p>年轻代(Young Generation)</p>\n<p>内存空间：<strong>eden:S0:S1 = 8:1:1</strong></p>\n<p>S0和S1<strong>没有先后顺序</strong>，任何一个都可能是<strong>From survivor space</strong>和<strong>To survivor space</strong></p>\n</li>\n<li><p>年老代(Old Generation)</p>\n<p>内存空间：年老代:年轻代 ≈ 2:1</p>\n</li>\n<li><p>持久代(Permanent Generation)</p>\n<p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n</li>\n</ul>\n<p>下面说明一下对象在分配内存、老化、回收的过程：</p>\n<ol>\n<li><p>首先，任何新对象创建时内存都会分配在年轻代的<strong>eden space</strong>中，<strong>S0</strong>和<strong>S1</strong>两个<strong>幸存者空间(survivor space)</strong>起初都是空的<img src=\"/images/image-20190225225802212.png\" alt=\"image-20190225225802212\"></p>\n</li>\n<li><p>当eden space满时，会触发第一次<strong>较小的垃圾回收过程(minor garbage collection，minor GC)</strong>\u0001<img src=\"/images/image-20190225230110077.png\" alt=\"image-20190225230110077\"></p>\n<blockquote>\n<p>实际上MinorGC不一定要等到eden space满了才触发</p>\n</blockquote>\n</li>\n<li><p>eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收<img src=\"/images/image-20190225230647640.png\" alt=\"image-20190225230647640\"></p>\n</li>\n<li><p>当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象\u0001<img src=\"/images/image-20190225232204967.png\" alt=\"image-20190225232204967\"></p>\n</li>\n<li><p>再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收<img src=\"/images/image-20190225232407098.png\" alt=\"image-20190225232407098\"></p>\n</li>\n<li><p>当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代<img src=\"/images/image-20190225232630665.png\" alt=\"image-20190225232630665\"></p>\n</li>\n<li><p>以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发<strong>完全的垃圾回收(major gabarge collector, major GC)</strong>，清理并压缩该块内存空间。</p>\n<p>major GC被触发的原因：</p>\n<ol>\n<li><p>年老代（Tenured）被写满</p>\n</li>\n<li><p>持久代（Permanent）被写满</p>\n</li>\n<li><p>System.gc()被显式调用</p>\n</li>\n<li><p>上一次GC之后Heap的各域分配策略动态变化</p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"HotSpot-JVM的垃圾收集器\"><a href=\"#HotSpot-JVM的垃圾收集器\" class=\"headerlink\" title=\"HotSpot JVM的垃圾收集器\"></a>HotSpot JVM的垃圾收集器</h5><p><strong>Serial收集器（复制算法)</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<p><strong>Serial Old收集器(标记-整理算法)</strong>：老年代单线程收集器，Serial收集器的老年代版本。</p>\n<p><strong>ParNew收集器(停止-复制算法)</strong>：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<p><strong>Parallel Scavenge收集器(停止-复制算法)</strong>：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<p><strong>Parallel Old收集器(停止-复制算法)</strong>：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<p><strong>CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)</strong>：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<p>【参考：<a href=\"https://crowhawk.github.io/2017/08/15/jvm_3/\" target=\"_blank\" rel=\"noopener\">深入理解JVM(3)——7种垃圾收集器</a>】</p>\n<h2 id=\"可变参数列表\"><a href=\"#可变参数列表\" class=\"headerlink\" title=\"可变参数列表\"></a>可变参数列表</h2><p>Java中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tInteger a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tInteger b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tInteger c = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tOther.main(a, b);</span><br><span class=\"line\">\t\tOther.main(a, b, c);</span><br><span class=\"line\">        Other.main();</span><br><span class=\"line\">        Other.main(<span class=\"keyword\">new</span> Object[]&#123;a, b&#125;);</span><br><span class=\"line\">\t\tOther.main(<span class=\"keyword\">new</span> Object[]&#123;a, b, c&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Other</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(Object... args)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Object s : args)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(s + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示，当输入不同个数参数时，编译器会自动将其<strong>转换成数组</strong>，当参数本身就是数组时，编译器又<strong>不会进行转换</strong>，直接传递给函数。参数为空时编译器便<strong>直接传递一个空Object数组</strong>。</p>\n<h3 id=\"可变参数列表的重载\"><a href=\"#可变参数列表的重载\" class=\"headerlink\" title=\"可变参数列表的重载\"></a>可变参数列表的重载</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(String... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">\t\tf();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，函数有<code>f(Character... args)</code>和<code>f(String... args)</code>两种重载方式，此时<code>f(&#39;a&#39;, &#39;b&#39;)</code>和<code>f(&quot;a&quot;, &quot;b&quot;)</code>都可正常调用，但是<code>f()</code>会报错，即两种重载都匹配。</p>\n<p>此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">float</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，编译器也会报错，<code>f(&#39;a&#39;, &#39;b&#39;)</code>可匹配两个函数，(可能是)因为<code>char</code>类型可提升至<code>float</code>类型从而匹配第一个重载函数。</p>\n<p>此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">float</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">char</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种用法比较奇怪，因此”你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它”（《Java编程思想》105页）。</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><h3 id=\"内部类对象对外围类对象的访问\"><a href=\"#内部类对象对外围类对象的访问\" class=\"headerlink\" title=\"内部类对象对外围类对象的访问\"></a>内部类对象对外围类对象的访问</h3><p>当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">current</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] items;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> next = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sequence</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123; items = <span class=\"keyword\">new</span> Object[size]; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt; items.length)&#123;</span><br><span class=\"line\">            items[next++] = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SequenceSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> i == items.length; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">current</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> items[i]; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">if</span>(i &lt; items.length) i++; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Selector <span class=\"title\">selector</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SequenceSelector();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Sequence sequence = <span class=\"keyword\">new</span> Sequence(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">            sequence.add(Integer.toString(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Selector selector = sequence.selector();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!selector.end())&#123;</span><br><span class=\"line\">            System.out.print(selector.current() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            selector.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。</p>\n<h3 id=\"内部类与静态内部类（嵌套类）\"><a href=\"#内部类与静态内部类（嵌套类）\" class=\"headerlink\" title=\"内部类与静态内部类（嵌套类）\"></a>内部类与静态内部类（嵌套类）</h3><h4 id=\"创建方法\"><a href=\"#创建方法\" class=\"headerlink\" title=\"创建方法\"></a>创建方法</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部类：DotNew.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DotNew</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        Inner()&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"创建内部类\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        DotNew dn = <span class=\"keyword\">new</span> DotNew();</span><br><span class=\"line\">        DotNew.Inner dni = dn.new Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类：DotNewStatic.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DotNewStatic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        Inner() &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"创建静态内部类\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        DotNewStatic.Inner inner = <span class=\"keyword\">new</span> DotNewStatic.Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><p>Java支持<strong>创建一个继承自某基类的匿名类的对象</strong>，通过new表达式返回的引用被<strong>自动向上转型为对基类的引用</strong>。</p>\n<p>匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。</p>\n<p>注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是<code>final</code>，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Destination.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Destination</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Parcel9.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel9</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destination <span class=\"title\">destination</span><span class=\"params\">(<span class=\"keyword\">final</span> String dest)</span></span>&#123;<span class=\"comment\">// 外部变量dest被引用时需声明为final，否则产生编译时错误</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Destination()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> String label = dest;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> label;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Parcel9 p = <span class=\"keyword\">new</span> Parcel9();</span><br><span class=\"line\">        Destination d = p.destination(<span class=\"string\">\"Tasmania\"</span>);</span><br><span class=\"line\">        System.out.println(d.readLabel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。</p>\n</blockquote>\n<blockquote>\n<p><strong>为什么匿名内部类访问外部变量必须是final的？</strong></p>\n<ol>\n<li><p>为了避免<strong>外部方法修改引用导致内部类得到的引用值不一致</strong>和<strong>内部类修改引用而导致外部方法的参数值在修改前和修改后不一致</strong></p>\n</li>\n<li><p>保证回调函数回调时可访问到变量（<strong>待研究</strong>）</p>\n</li>\n<li><p>反编译查看其实现细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"comment\">// 源代码</span></span><br><span class=\"line\">&gt;    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TryUsingAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useMyInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">final</span> Integer number = <span class=\"number\">123</span>;</span><br><span class=\"line\">&gt;            System.out.println(number);</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;            MyInterface myInterface = <span class=\"keyword\">new</span> MyInterface() &#123;</span><br><span class=\"line\">&gt;                <span class=\"meta\">@Override</span></span><br><span class=\"line\">&gt;                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;                    System.out.println(number);</span><br><span class=\"line\">&gt;                &#125;</span><br><span class=\"line\">&gt;            &#125;;</span><br><span class=\"line\">&gt;            myInterface.doSomething();</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;            System.out.println(number);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;    <span class=\"comment\">// 反编译结果</span></span><br><span class=\"line\">&gt;    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TryUsingAnonymousClass</span>$1</span></span><br><span class=\"line\"><span class=\"class\">&gt;            <span class=\"keyword\">implements</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TryUsingAnonymousClass <span class=\"keyword\">this</span>$<span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer paramInteger;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;        TryUsingAnonymousClass$<span class=\"number\">1</span>(TryUsingAnonymousClass <span class=\"keyword\">this</span>$<span class=\"number\">0</span>, Integer paramInteger) &#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.<span class=\"keyword\">this</span>$<span class=\"number\">0</span> = <span class=\"keyword\">this</span>$<span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.paramInteger = paramInteger;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            System.out.println(<span class=\"keyword\">this</span>.paramInteger);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>   注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时<strong>实际上是做了个”拷贝”</strong>或者说<strong>“赋值”</strong>。若可以更改，则会造成数据不一致。</p>\n</blockquote>\n<h2 id=\"RTTI\"><a href=\"#RTTI\" class=\"headerlink\" title=\"RTTI\"></a>RTTI</h2><p>RTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是<strong>多态的基础</strong>，由<strong>Class类实现</strong>。</p>\n<h3 id=\"Class对象\"><a href=\"#Class对象\" class=\"headerlink\" title=\"Class对象\"></a>Class对象</h3><p>每当编写并且编译一个类时，在与类同名的<code>.class</code>文件中会自动产生一个<code>Class对象</code>。实现此过程的JVM子系统被称作<strong>类加载器</strong>。</p>\n<p>Class对象仅在需要的时候才被加载，也就是所有的类都是<strong>只在对其第一次使用时</strong>，动态加载到JVM中的。所谓第一次使用指的是<strong>对类的非常量静态域的第一次引用。</strong></p>\n<ul>\n<li><p>要注意，<strong>类的构造器</strong>是<strong>隐性非常量静态域</strong>，所以使用new操作符生成对象也是产生这样的Class类引用。</p>\n</li>\n<li><p>与此同时，还可以使用<code>Class.forName(类名)</code>产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常<code>ClassNotFoundException</code>。比如在JDBC连接数据库时常常用到的<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，就是告诉JVM去加载MySQL驱动。</p>\n</li>\n<li><p>当已经拥有某个类型的对象（实例）时，可通过调用<code>getClass()</code>方法来获取该类型的Class引用。</p>\n</li>\n<li><p>另一种方法，使用<strong>类字面变量</strong>。通过使用<code>类名.class</code>可获取此类的Class对象的引用，但是注意，此时<strong>此Class对象还未被初始化</strong>，还需要等到上述的<code>对类的非常量静态域的第一次引用</code>这一操作执行时才被初始化。</p>\n<blockquote>\n<p>使用.class方法获取Class对象引用实际包含三个步骤：</p>\n<ol>\n<li><strong>加载</strong>：类加载器创建Class对象</li>\n<li><strong>链接</strong></li>\n<li><strong>初始化</strong>：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li>\n</ol>\n<p>考虑如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> staticFinal = <span class=\"number\">1</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable2</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticNonFinal = <span class=\"number\">2</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable2\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable3</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticNonFinal = <span class=\"number\">3</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable3\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInitialization</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>);</span><br><span class=\"line\">&gt;     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 创建Initable的Class对象的引用，Class对象未初始化</span></span><br><span class=\"line\">&gt;         Class initable = Initable.class;</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 仍然未初始化，因Initable.staticFinal是常数</span></span><br><span class=\"line\">&gt;         System.out.println(Initable.staticFinal);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 触发了Initable的Class对象的初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable.staticFinal2);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 触发了Initable2的Class对象的初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable2.staticNonFinal);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 创建Initable3的Class对象的引用，同时会初始化此Class对象</span></span><br><span class=\"line\">&gt;         Class initable3 = Class.forName(<span class=\"string\">\"Initable3\"</span>);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 此时已初始化，无需再次初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable3.staticNonFinal);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>另外，当我拥有某个Class对象c的时候，我虽然<strong>不知道它确切类型</strong>，但是可以使用<code>c.newInstance()</code>来正确地获取c代表的类型的实例。<strong>但是此方法要求对应的类</strong>。</p>\n<h3 id=\"泛化的Class对象引用\"><a href=\"#泛化的Class对象引用\" class=\"headerlink\" title=\"泛化的Class对象引用\"></a>泛化的Class对象引用</h3><p>Class对象可以通过<code>Class&lt;Type&gt;</code>的方法产生特定类型的类引用，创建了<strong>使用类型限定后</strong>的Class对象引用<strong>不能再赋值给除本身和子类的其他的Class对象</strong>。</p>\n<blockquote>\n<p>注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如<code>Integer</code>继承自<code>Number</code>，而<code>Integer Class对象</code>却不是<code>Number Class对象</code>的子类。</p>\n</blockquote>\n<p>使用通配符<code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>（实际上是等价的），而且会免除编译器警告，看图：<img src=\"/images/image-20190308105552914.png\" alt=\"image-20190308105552914\"></p>\n<p>一种更好的用法，<code>Class&lt;? extends Type&gt;</code>，这种类型限定比直接<code>Class&lt;Type&gt;</code>好的地方在于他产生的Class对象引用<strong>可赋值给Type本身及子类的Class对象</strong>，这种继承关系<strong>是Type所属的继承关系</strong>而<strong>不是对应的Class对象的继承关系</strong>。</p>\n<h3 id=\"转型语法（不常用）\"><a href=\"#转型语法（不常用）\" class=\"headerlink\" title=\"转型语法（不常用）\"></a>转型语法（不常用）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Building</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">House</span> <span class=\"keyword\">extends</span> <span class=\"title\">Building</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassCasts</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Building b = <span class=\"keyword\">new</span> Building();</span><br><span class=\"line\">        Class&lt;House&gt; houseType = House.class;</span><br><span class=\"line\">        House h = houseType.cast(b);</span><br><span class=\"line\">        h = (House) b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，使用<code>houseType.cast(b)</code>和<code>(House) b</code>效果一样，但是执行的工作却不同，具体内部实现尚未学习到。</p>\n<h3 id=\"动态的类型检测\"><a href=\"#动态的类型检测\" class=\"headerlink\" title=\"动态的类型检测\"></a>动态的类型检测</h3><h4 id=\"obj-instanceof-ClassType\"><a href=\"#obj-instanceof-ClassType\" class=\"headerlink\" title=\"obj instanceof ClassType\"></a>obj instanceof ClassType</h4><p>返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。</p>\n<h4 id=\"ClassType-isInstance\"><a href=\"#ClassType-isInstance\" class=\"headerlink\" title=\"ClassType.isInstance()\"></a>ClassType.isInstance()</h4><p>返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>区别主要是后者与前者动态等价，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicEqual</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Father father = <span class=\"keyword\">new</span> Father();</span><br><span class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">        <span class=\"comment\">// instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称</span></span><br><span class=\"line\">        <span class=\"comment\">// if (son instanceof father.getClass())&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     ...</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (father.getClass().isInstance(son))&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"isInstance is Dynamic\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><code>isInstance()</code>的存在可以替代<code>instanceof</code>，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：</p>\n<ul>\n<li>使用<code>instanceof</code>时可能需要使用<code>switch-case</code>语句；当需要添加一个子类时，需要修改<code>switch-case</code>内部代码。</li>\n<li>而使用<code>isInstance()</code>时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。</li>\n</ul>\n<h3 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h3><h4 id=\"反射与RTTI的区别\"><a href=\"#反射与RTTI的区别\" class=\"headerlink\" title=\"反射与RTTI的区别\"></a>反射与RTTI的区别</h4><ul>\n<li>RTTI：编译器在编译时打开和检查<code>.class</code>文件（获取类的Class类对象信息）</li>\n<li>反射：JVM在运行时打开和检查<code>.class</code>文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取<code>.class</code>文件）</li>\n</ul>\n<h4 id=\"类方法提取器\"><a href=\"#类方法提取器\" class=\"headerlink\" title=\"类方法提取器\"></a>类方法提取器</h4><p>通过Class对象引用：调用<code>getMethods()</code>方法获取该类及其父类的方法列表，调用<code>getConstructors()</code>方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个<strong>非public类的非public方法是无法被获取的</strong>。</p>\n<h4 id=\"接口与类型信息\"><a href=\"#接口与类型信息\" class=\"headerlink\" title=\"接口与类型信息\"></a>接口与类型信息</h4><p>interface关键字的一种重要目标就是允许程序员<strong>隔离构件，进而降低耦合性</strong>。</p>\n<h4 id=\"包权限安全吗？\"><a href=\"#包权限安全吗？\" class=\"headerlink\" title=\"包权限安全吗？\"></a>包权限安全吗？</h4><p>直接看例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HiddenC.java</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"public C.f()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"public C.g()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">u</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"package C.u()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">v</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"protected C.v()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">w</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"private C.w()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HiddenC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title\">makeA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HiddenImplementation.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HiddenImplementation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        A a = HiddenC.makeA();</span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        System.out.println(a.getClass().getName());</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"g\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"u\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"v\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"w\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">callHiddenMethod</span><span class=\"params\">(Object a, String methodName)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取a中的方法</span></span><br><span class=\"line\">        Method g = a.getClass().getDeclaredMethod(methodName);</span><br><span class=\"line\">        <span class=\"comment\">// 修改该方法的权限</span></span><br><span class=\"line\">        g.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 调用该方法</span></span><br><span class=\"line\">        g.invoke(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* output</span></span><br><span class=\"line\"><span class=\"comment\">public C.f()</span></span><br><span class=\"line\"><span class=\"comment\">C</span></span><br><span class=\"line\"><span class=\"comment\">public C.g()</span></span><br><span class=\"line\"><span class=\"comment\">package C.u()</span></span><br><span class=\"line\"><span class=\"comment\">protected C.v()</span></span><br><span class=\"line\"><span class=\"comment\">private C.w()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//:)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用<code>setAccessble(true)</code>后被调用。</li>\n<li>只发布<code>.class</code>文件也是没办法避免此问题，<code>javap -private</code>命令可以反编译<code>.class</code>文件，<code>-private</code>参数约定显示所有的成员</li>\n<li>同样，内部类和匿名内部类也是没办法避免此情况</li>\n</ul>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"指定类型有保证吗？\"><a href=\"#指定类型有保证吗？\" class=\"headerlink\" title=\"指定类型有保证吗？\"></a>指定类型有保证吗？</h3><blockquote>\n<p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>\n</blockquote>\n<p>例如对于<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>，二者的实例调用<code>.getClass()</code>获取的Class对象时相同的，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Erase</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; s = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class=\"line\">        Class&lt;?&gt; i = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class=\"line\">        System.out.println(s == i);</span><br><span class=\"line\">        System.out.println(s.getName());</span><br><span class=\"line\">        System.out.println(s.getTypeParameters());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">java.util.ArrayList</span></span><br><span class=\"line\"><span class=\"comment\">[Ljava.lang.reflect.TypeVariable;@68f7aae2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>但是，如果在一个<code>ArrayList&lt;String&gt;</code>类型的实例中添加<code>Integer</code>会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"This is an apple\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectAdd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; strings = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Class&lt;?&gt; s = strings.getClass();</span><br><span class=\"line\">        Method method = s.getMethod(<span class=\"string\">\"add\"</span>, Object.class);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"number\">1</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"number\">3</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        System.out.println(Arrays.toString(strings.toArray()));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : strings)&#123;</span><br><span class=\"line\">            System.out.println(o.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">[1, 2, 3, This is an apple]</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.Integer</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.String</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.Integer</span></span><br><span class=\"line\"><span class=\"comment\">class Apple</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到上述代码使用反射机制成功的在<code>ArrayList&lt;String&gt;</code>里面添加了<code>Integer</code>，原因在于<code>ArrayList</code>的泛型实现<code>ArrayList&lt;E&gt;</code>使其被擦除为<code>ArrayList&lt;Object&gt;</code>，从而通过反射机制找到其<code>add(E e)</code>方法时，实际上是<code>add(Object o)</code>，而我们代码中的<code>Method method = s.getMethod(&quot;add&quot;, Object.class);</code>恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。</p>\n<h3 id=\"与C-的区别\"><a href=\"#与C-的区别\" class=\"headerlink\" title=\"与C++的区别\"></a>与C++的区别</h3><p><strong>C++:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt; <span class=\"title\">class</span> <span class=\"title\">Manipulator</span> &#123;</span></span><br><span class=\"line\">    T obj;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span> </span>&#123; obj.f(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">manipulate2</span><span class=\"params\">()</span> </span>&#123; obj.noF(); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasF</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"HasF()::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DontHaveF</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">noF</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Don't have f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    HasF hf;</span><br><span class=\"line\">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class=\"line\">    manipulator.manipulate();</span><br><span class=\"line\">    <span class=\"comment\">// manipulator.manipulate2();  无法编译</span></span><br><span class=\"line\">    DontHaveF dhf;</span><br><span class=\"line\">    Manipulator&lt;DontHaveF&gt; manipulator2(dhf);</span><br><span class=\"line\">    <span class=\"comment\">// manipulator2.manipulate();  无法编译</span></span><br><span class=\"line\">    manipulator2.manipulate2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">HasF()::f()</span></span><br><span class=\"line\"><span class=\"comment\">Don't have f()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>模板类<code>Manipulator</code>在编译时期便可以检测到函数<code>f()</code>、<code>noF()</code>是在类型参数<t>中存在的，这是在编译器看到声明<code>Manipulator&lt;HasF&gt; manipulator(hf)</code>和<code>Manipulator&lt;DontHaveF&gt; manipulator2(dhf)</code>所产生的结果。</t></p>\n<p>然而Java中却无法实现这样的操作：</p>\n<p><strong>Java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HasF.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasF</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"HasF.f();\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Manipulation.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T obj;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Manipulator</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        obj = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        obj.f() <span class=\"comment\">// 会报编译错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulation</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        HasF hf = <span class=\"keyword\">new</span> HasF();</span><br><span class=\"line\">        Manipulator&lt;HasF&gt; manipulation = <span class=\"keyword\">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class=\"line\">        manipulation.manipulate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于Java在编译过程中，<code>Manipulator&lt;T&gt;</code>是无法确定其类型参数，只知道他是一个<code>Object实例</code>，因此obj<strong>只能调用Object基类所有的公开方法</strong>。若想实现C++的操作有两种办法(目前我已知的只有这两种)。</p>\n<ul>\n<li><p>为<code>T</code>限定参数类型（给定边界），即声明时指定其所继承的基类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">HasF</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用反射机制调用<code>f()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T obj;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Manipulator</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        obj = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; oc = obj.getClass();</span><br><span class=\"line\">        Method method = oc.getMethod(<span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">        method.invoke(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulation</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        HasF hf = <span class=\"keyword\">new</span> HasF();</span><br><span class=\"line\">        Manipulator&lt;HasF&gt; manipulation = <span class=\"keyword\">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class=\"line\">        manipulation.manipulate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">HasF.f();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h3><blockquote>\n<p>擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。</p>\n</blockquote>\n<p>泛型<strong>不能用于显式地引用运行时类型的操作之中</strong>，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。</p>\n<p>也就是说，需要时刻提醒自己，我只是<strong>看起来好像拥有</strong>有关参数的类型信息而已。实际上，<strong>它只是一个Object！</strong></p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>既然编译器会<code>擦除</code>类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的<code>边界</code>：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。</p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jonathan</span> <span class=\"keyword\">extends</span> <span class=\"title\">Apple</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Orange</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompilerIntelligence</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        Apple a = (Apple) flist.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Orange o = (Orange) flist.get(0); 运行时错误</span></span><br><span class=\"line\">        <span class=\"comment\">// flist.add(new Fruit());  编译错误</span></span><br><span class=\"line\">        <span class=\"comment\">// flist.add(new Apple());  编译错误</span></span><br><span class=\"line\">        System.out.println(flist.contains(a));</span><br><span class=\"line\">        System.out.println(flist.contains(<span class=\"keyword\">new</span> Apple()));</span><br><span class=\"line\">        System.out.println(flist.indexOf(<span class=\"keyword\">new</span> Apple()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">false</span></span><br><span class=\"line\"><span class=\"comment\">-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>对于使用了通配符的<code>List&lt;? extends Fruit&gt; flist</code>来说，其需要用到类型参数的方法例如<code>add()</code>参数也变成了<code>&lt;? extends Fruit&gt;</code>，然而编译器并不能知道这里需要哪一个具体的子类型，于是<strong>编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。</strong></p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>完整的容器分类法：</p>\n<p><img src=\"/images/image-20190312200304819.png\" alt=\"image-20190312200304819\"></p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p><code>HashMap</code>采用了链地址法，也就是<strong>数组+链表</strong>的方式。主干是一个<code>Entry</code>数组，链表是为了解决哈希冲突而存在的。<code>HashMap</code>中的链表越少，性能越好。</p>\n<h4 id=\"Entry数组长度为2的次幂\"><a href=\"#Entry数组长度为2的次幂\" class=\"headerlink\" title=\"Entry数组长度为2的次幂\"></a>Entry数组长度为2的次幂</h4><ul>\n<li>由于在计算<code>key</code>的<code>插入位置</code>时用到了<code>hash &amp; (length-1)</code>，<code>hash</code>是<code>key</code>计算出来的哈希值，想象一下当<code>length</code>不为2的次幂时，<code>length-1</code>的二进制必然有<code>0位</code>，那么意味着该位为<code>0</code>的位置永远不可能被当做<code>插入位置</code>，造成了严重的空间浪费。</li>\n<li>由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即<code>equal()</code>操作多了起来，效率也就慢了。</li>\n</ul>\n<h4 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h4><p><code>HashMap</code>当<code>Entry</code>数组元素超过<code>数组大小*loadFactor</code>时，就会进行数组扩容。<code>loadFactor</code>默认值为0.75。此时<code>Entry</code>数组大小会扩大一倍，保证了2的次幂大小。</p>\n<p>扩容的时候所有的<code>key</code>需要重新计算哈希值。</p>\n<h4 id=\"JDK1-8优化\"><a href=\"#JDK1-8优化\" class=\"headerlink\" title=\"JDK1.8优化\"></a>JDK1.8优化</h4><p>由于1.8之前的<code>HashMap</code>在<code>hash</code>冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。</p>\n<h3 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h3><p><code>HashTable</code>在结构上与<code>HashMap</code>基本相同，下面总结其不同点：</p>\n<ul>\n<li><code>HashMap</code>可有<code>null key</code>，<code>HashTable</code>获取<code>null key</code>会报空指针异常</li>\n<li><code>HashTable</code>有<code>synchronized</code>方法同步，线程安全；<code>HashMap</code>线程不安全</li>\n<li><code>Hash</code>值计算方法不同</li>\n<li><code>HashTable</code>初始大小为<code>11</code>，扩容机制为<code>2*old+1</code>；<code>HashMap</code>初始大小为<code>16</code>，扩容机制为<code>2*old</code></li>\n</ul>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p><code>JDK1.7</code>版本中的<code>ConcurrentHashMap</code>比<code>HashMap</code>多了一层<code>Segment</code>，其中<code>Segment</code>继承于<code>ReentrantLock</code>：<strong>一次<code>put</code>操作会调用<code>scanAndLockForPut()</code>方法自旋获取锁</strong>；<strong>而一次<code>get</code>操作则不需要加锁，<code>value</code>用<code>volatile</code>关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效</strong>。</p>\n<p><code>JDK1.8</code>版本移除了<code>segment</code>，有一个<code>Node</code>数组相当于<code>HashMap</code>中的<code>Entry</code>数组。同时采用了<code>CAS+synchronized关键字</code>进行<code>put</code>操作。<code>put</code>操作步骤如下：</p>\n<ul>\n<li>根据<code>key</code>计算出<code>hashcode</code>；</li>\n<li>判断是否需要进行初始化；</li>\n<li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功；</li>\n<li>判断是否需要进行扩容；</li>\n<li>如果都不满足，则利用 <code>synchronized</code> 锁写入数据；</li>\n<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>\n</ul>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><h3 id=\"Brian-Goetz的线程同步规则\"><a href=\"#Brian-Goetz的线程同步规则\" class=\"headerlink\" title=\"Brian Goetz的线程同步规则\"></a>Brian Goetz的线程同步规则</h3><blockquote>\n<p>如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，<strong>读写线程</strong>都必须用相同的监视器锁同步。</p>\n</blockquote>\n<h3 id=\"Executor\"><a href=\"#Executor\" class=\"headerlink\" title=\"Executor\"></a>Executor</h3><p>Executor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CachedThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> LiftOff());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池的作用是<strong>限制系统中执行线程的数量</strong>，根据系统情况可以<strong>自动或手动</strong>设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。</p>\n<ul>\n<li><code>newSingleThreadExecutor()</code>：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。</li>\n<li><code>newFixedThreadPool()</code>：创建固定大小的线程池。</li>\n<li><code>newCachedThreadPool()</code>：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。</li>\n<li><code>newScheduledThreadPool()</code>：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。</li>\n</ul>\n<h3 id=\"任务的返回值\"><a href=\"#任务的返回值\" class=\"headerlink\" title=\"任务的返回值\"></a>任务的返回值</h3><p>通常实现<code>Runnable</code>接口的类是没有返回值的，要想任务在完成时返回一个值可实现<code>Callable&lt;T&gt;</code>接口，其泛型类型参数表示方法<code>call()</code>的返回值，并且需要使用<code>ExecutorService.submit()</code>方法调用他。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskWithResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"result of TaskWithResult\"</span> + id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            results.add(exec.submit(<span class=\"keyword\">new</span> TaskWithResult(i)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(fs.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">                System.err.println(e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                exec.shutdown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output：</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult0</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult1</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult2</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult3</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult4</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult5</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult6</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult7</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult8</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult9</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p><code>ExecutorService</code>对象的<code>submit()</code>方法会返回一个<code>Future&lt;T&gt;</code>对象，泛型类型参数即是实现<code>Callable&lt;T&gt;</code>的类型参数。<code>get()</code>方法会返回结果，若任务未完成，<code>get()</code>会阻塞。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。</p>\n<p>但是注意优先级高的线程也有几率比优先级底的线程执行的少。</p>\n<p>优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。</p>\n<h3 id=\"Thread-yield-可靠吗？\"><a href=\"#Thread-yield-可靠吗？\" class=\"headerlink\" title=\"Thread.yield()可靠吗？\"></a>Thread.yield()可靠吗？</h3><p><code>Thread.yield()</code>源码中提及了该方法的效果：<strong>当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。</strong>意即此处的<code>让步</code>只是一厢情愿，发出让步的线程同样可以继续执行。</p>\n<h3 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h3><p>后台线程<strong>并不属于程序中不可或缺的部分</strong>。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p>\n<p>执行<code>main()</code>就是一个非后台线程，当<code>main()</code>没有执行结束时，程序就不会终止。</p>\n<p>后台线程创建的线程也将是后台线程。</p>\n<p>同时要注意在后台线程的<code>run()</code>方法中若有<code>finally</code>子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。</p>\n<h3 id=\"Thread还是Runnable\"><a href=\"#Thread还是Runnable\" class=\"headerlink\" title=\"Thread还是Runnable\"></a>Thread还是Runnable</h3><p>创建多线程任务可以继承<code>Thread</code>类重写其<code>run()</code>方法，也可以实现<code>Runnable</code>接口实现其<code>run()</code>方法。</p>\n<p>实际应用中，<code>Runnable</code>还是比较有优势的：</p>\n<ul>\n<li>避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）</li>\n<li>多个线程区处理同一资源，而非独立处理（这句话有问题）</li>\n</ul>\n<p>注意，一开始在理解这里的时候我出现了误解，什么叫<strong>处理同一资源</strong>，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了<strong>(待确认)</strong>，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"-- val: \"</span> + val--);</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>  (val &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"-- val: \"</span> + val--);</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRunnableAndThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> TestRunnable();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> TestThread();</span><br><span class=\"line\">        <span class=\"comment\">// a.只有1个线程处理一个数据</span></span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"comment\">// b.5个不同线程处理不同数据</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"comment\">// c.5个不同线程处理相同数据</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"comment\">// d.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execRun = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execRun.execute(runnable);</span><br><span class=\"line\">        <span class=\"comment\">// e.5个不同线程处理5个不同数据</span></span><br><span class=\"line\">        ExecutorService execRun2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execRun2.execute(<span class=\"keyword\">new</span> TestRunnable());</span><br><span class=\"line\">        <span class=\"comment\">// f.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execThread = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">            execThread.execute(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// g.5个不同线程处理5个不同数据</span></span><br><span class=\"line\">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execThread2.execute(<span class=\"keyword\">new</span> TestThread());</span><br><span class=\"line\">        <span class=\"comment\">// i.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execThread2.execute(<span class=\"keyword\">new</span> Thread(runnable));</span><br><span class=\"line\"></span><br><span class=\"line\">        execRun.shutdown();</span><br><span class=\"line\">        execRun2.shutdown();</span><br><span class=\"line\">        execThread.shutdown();</span><br><span class=\"line\">        execThread2.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中：<strong>c、d、i</strong>实际上是相同的，<strong>b、g</strong>是相同的，而<strong>a</strong>和<strong>f</strong>看起来相同，但是实际作用却差别很大，待研究。</p>\n<p>实际上，<strong>a</strong>是错误的用法，<strong>b</strong>、<strong>c</strong>基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个<strong>线程安全的外部对象</strong>。</p>\n<h3 id=\"共享资源\"><a href=\"#共享资源\" class=\"headerlink\" title=\"共享资源\"></a>共享资源</h3><h4 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h4><p>冲突是多线程问题必须解决的任务，Java使用<code>synchronized</code>关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当<strong>某一个任务第一次给该对象加锁时，计数变为1</strong>，此后<strong>只有这个相同的任务能继续给该对象加锁</strong>，计数会递增；<strong>每当离开一个synchronized方法时，计数递减</strong>，直到计数变为0时，对象被解锁。要注意，<strong>每个访问该临界资源的方法都必须被同步</strong>，否则就不会正确地工作。</p>\n<p>通常<code>synchronized</code>关键字标识方法时，是在<code>this</code>上面同步，也可在方法中使用<code>synchronized(synObject){}</code>域，<strong>以在特定的对象上同步</strong>，因此不同对象上的锁是相互无关的。</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>Lock对象必须被显式地创建、锁定和释放。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MutexEvenGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentEvenValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 显式声明</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// lock()方法创建临界资源</span></span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ++currentEvenValue;</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            ++currentEvenValue;</span><br><span class=\"line\">            <span class=\"comment\">// return语句必须出现在try子句中</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> currentEvenValue;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// unlock()方法完成清理工作</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与<code>synchronize</code>相比，显式的<code>Lock</code>优点在于可以使用<code>finally子句</code>将系统维护在正常的状态，而在使用<code>synchronize</code>关键字时，某些事物失败了就会抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AttemptLocking</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">untimed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> captured = lock.tryLock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"untimed - tryLock(): \"</span> + captured);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"untimed - isHeldByCurrentThread(): \"</span> + lock.isHeldByCurrentThread());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (captured) </span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">timed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"timed - tryLock(2, TimeUnit.SECONDS): \"</span> + captured);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"timed - isHeldByCurrentThread(): \"</span> + lock.isHeldByCurrentThread());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (captured)</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttemptLocking al = <span class=\"keyword\">new</span> AttemptLocking();</span><br><span class=\"line\">        al.untimed();</span><br><span class=\"line\">        al.timed();</span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类创建单独的Thread来获取锁，而未释放</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            &#123;setDaemon(<span class=\"keyword\">true</span>);&#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                al.lock.lock();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"acquired\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"main - isHeldByCurrentThread(): \"</span> + al.lock.isHeldByCurrentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        al.untimed();</span><br><span class=\"line\">        al.timed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">untimed - tryLock(): true</span></span><br><span class=\"line\"><span class=\"comment\">untimed - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">timed - tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class=\"line\"><span class=\"comment\">timed - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">acquired</span></span><br><span class=\"line\"><span class=\"comment\">main - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">untimed - tryLock(): false</span></span><br><span class=\"line\"><span class=\"comment\">untimed - isHeldByCurrentThread(): false</span></span><br><span class=\"line\"><span class=\"comment\">timed - tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class=\"line\"><span class=\"comment\">timed - isHeldByCurrentThread(): false</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>看代码就很容易理解了。</p>\n<h4 id=\"原子性与易变性\"><a href=\"#原子性与易变性\" class=\"headerlink\" title=\"原子性与易变性\"></a>原子性与易变性</h4><p>原子操作<strong>有可能无需同步机制</strong>，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是<strong>不可视的</strong>，因此不同的任务对应用状态有不同的视图。</p>\n<p><strong>volatile关键字</strong>确保了前面提及的可视性，以及当一个域被声明为volatile时，那么<strong>只要对这个域产生了写操作，所有的读操作都可以看到这个修改</strong>。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。</p>\n<p>所以<strong>非volatile域</strong>上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。</p>\n<p>因此多个任务在同时访问某个域时，<strong>要么使用volatile关键字限定，要么经由同步机制访问</strong>，以保证一致性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicityTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">evenIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            i++; i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">            evenIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        AtomicityTest at = <span class=\"keyword\">new</span> AtomicityTest();</span><br><span class=\"line\">        exec.execute(at);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = at.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val%<span class=\"number\">2</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(val);</span><br><span class=\"line\">                System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看上面这个例子，程序找到奇数时便终止，理想状态下，通过<code>evenIncrement()</code>加2，<code>i</code>应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时<code>i</code>也不是<code>volatile</code>的，因此还存在可视性问题（当然，这里仅仅使用<code>volatile</code>限定<code>i</code>是不够的，因为<code>i++</code>操作不是原子性的）。下面使用<code>Lock</code>显式加锁以实现同步：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicityTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">evenIncrement</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            i++; i++; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">            evenIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        AtomicityTest at = <span class=\"keyword\">new</span> AtomicityTest();</span><br><span class=\"line\">        exec.execute(at);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = at.getValue();</span><br><span class=\"line\">            System.out.println(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val%<span class=\"number\">2</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(val);</span><br><span class=\"line\">                System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原子类\"><a href=\"#原子类\" class=\"headerlink\" title=\"原子类\"></a>原子类</h3><p>上面说到<strong>原子操作是较少的</strong>，而<code>JSE5</code>引入了<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。</p>\n<h3 id=\"ReetrantLock\"><a href=\"#ReetrantLock\" class=\"headerlink\" title=\"ReetrantLock\"></a>ReetrantLock</h3><p>ReentrantLock是一个<strong>可重入</strong>的<strong>互斥锁</strong>，又被称为”<strong>独占锁</strong>“。</p>\n<blockquote>\n<p><strong>可重入锁</strong>指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。</p>\n<p><strong>独占锁</strong>指的是同一时间点锁只能被一个线程获取。</p>\n</blockquote>\n<p>同时ReentrantLock也分为<strong>公平锁</strong>和<strong>非公平锁</strong>，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。</p>\n<h3 id=\"ReentrantReedWriteLock\"><a href=\"#ReentrantReedWriteLock\" class=\"headerlink\" title=\"ReentrantReedWriteLock\"></a>ReentrantReedWriteLock</h3><p>顾名思义，ReentrantReadWriteLock维护了<strong>读取锁</strong>和<strong>写入锁</strong>。</p>\n<p>读取锁用于只读操作，是<strong>共享锁</strong>，能被多个线程获取；</p>\n<p>写入锁用于写入操作，是<strong>独占锁</strong>，只能被一个线程获取。</p>\n<h3 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h3><ul>\n<li>新建（new）</li>\n<li>就绪（Runnable）</li>\n<li>阻塞（Blocked）<ul>\n<li>调用<code>sleep(milliseconds)</code>方法使任务休眠</li>\n<li>调用<code>wait()</code>方法挂起</li>\n<li>等待输入输出完成</li>\n<li>获取锁失败</li>\n</ul>\n</li>\n<li>死亡（Dead）</li>\n</ul>\n<h3 id=\"线程协作\"><a href=\"#线程协作\" class=\"headerlink\" title=\"线程协作\"></a>线程协作</h3><h4 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h4><p>与<code>sleep()</code>和<code>yield()</code>不同，调用<code>wait()</code>时<strong>需要释放当前线程获取的锁</strong>，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了<code>notifyAll()</code>方法时，线程被唤醒。</p>\n<p>但是要注意，使用<code>wait()</code>的时候需要用<code>while</code>循环包围：</p>\n<ul>\n<li>为了检查线程是否被意外唤醒</li>\n</ul>\n<h4 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll()\"></a>notifyAll()</h4><p><code>notifyAll()</code>用来唤醒等待<strong>某个锁</strong>的所有<strong>挂起的任务</strong>。<code>等待某个锁</code>指的是某些需要获取共同的锁的线程，<code>notifyAll()</code>可以唤醒这些线程，而不是程序中所有被挂起的线程。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>多个并发进程因争夺系统资源而产生相互等待的现象。</p>\n<p>四个必要条件：</p>\n<ul>\n<li>互斥</li>\n<li>占有且等待</li>\n<li>不可抢占</li>\n<li>循环等待</li>\n</ul>\n<h3 id=\"免锁容器\"><a href=\"#免锁容器\" class=\"headerlink\" title=\"免锁容器\"></a>免锁容器</h3><p>免锁容器的策略是：对容器的修改可以与读取操作<strong>同时发生</strong>，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。</p>\n<p>这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。</p>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><p>每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。</p>\n<h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><p>每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。<code>synchronized</code>关键字的实现就是悲观锁。</p>\n<h4 id=\"CAS-Compare-And-Swap-技术\"><a href=\"#CAS-Compare-And-Swap-技术\" class=\"headerlink\" title=\"CAS(Compare And Swap)技术\"></a>CAS(Compare And Swap)技术</h4><p>CAS是用来实现乐观锁的一种方法，原理见<a href=\"https://www.jianshu.com/p/ae25eb3cfb5d\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>CAS机制使用3个基本操作数：<strong>内存地址<code>V</code></strong>，<strong>旧的预期值<code>A</code></strong>，<strong>要修改的新值<code>B</code></strong>。</p>\n<p>更新一个变量的时候，只有当<code>A</code>和<code>V</code>的实际值相同时，才会将<code>V</code>对应的值修改为<code>B</code>。</p>\n<p>缺点：</p>\n<ul>\n<li>ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化</li>\n<li>循环时间长开销大</li>\n<li>只能保证一个共享变量的原子性</li>\n</ul>\n<p>未完~</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"垃圾回收器—GC\"><a href=\"#垃圾回收器—GC\" class=\"headerlink\" title=\"垃圾回收器—GC\"></a>垃圾回收器—GC</h2><p>众所周知，Java中的GC负责回收<strong>无用对象占用的内存资源</strong>，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于<strong>GC只释放那些经由new分配的内存</strong>，所以GC不知道如何释放该对象的这块”特殊”内存区域。</p>","more":"<p>作为应对，Java允许在类中定义<code>finalize()</code>方法，它使得在GC回收该对象内存之前先调用<code>finalize()</code>方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在<code>finalize()</code>指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。</p>\n<p><strong>关键点：</strong></p>\n<ol>\n<li>对象可能不被垃圾回收</li>\n<li>垃圾回收并不等于”析构”</li>\n<li>垃圾回收只与内存有关</li>\n</ol>\n<h3 id=\"避免使用finalize\"><a href=\"#避免使用finalize\" class=\"headerlink\" title=\"避免使用finalize()\"></a>避免使用finalize()</h3><blockquote>\n<p>“终结函数无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页</p>\n</blockquote>\n<p>在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在<strong>通过某种创建对象以外的方式为对象分配了存储空间</strong>。</p>\n<p>Native Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。</p>\n<p>可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。</p>\n<h3 id=\"终结条件的验证\"><a href=\"#终结条件的验证\" class=\"headerlink\" title=\"终结条件的验证\"></a>终结条件的验证</h3><p>但是finalize()有个有趣的用法——终结条件。看如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Book类，约定其在被回收前必须被签入。</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> checkedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\tBook(<span class=\"keyword\">boolean</span> checkedOut)&#123;</span><br><span class=\"line\">\t\tcheckedOut = checkedOut;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkIn</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tcheckedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 终结条件，对象未被签入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (checkedOut) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"Error: checked out\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个Book对象-novel</span></span><br><span class=\"line\">\t\tBook novel = <span class=\"keyword\">new</span> Book(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将其签入</span></span><br><span class=\"line\">\t\tnovel.checkIn();</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个Book对象，此时该对象未被签入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Book(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 强制执行垃圾回收，此时会先执行finalize</span></span><br><span class=\"line\">\t\tSystem.gc();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 输出：</span></span><br><span class=\"line\"><span class=\"comment\">Error: checked out</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。</p>\n<blockquote>\n<p>注意这里使用的System.gc()强制调用垃圾回收器</p>\n</blockquote>\n<p>若没有finalize()将很难实现这种操作。</p>\n<h3 id=\"GC如何工作\"><a href=\"#GC如何工作\" class=\"headerlink\" title=\"GC如何工作\"></a>GC如何工作</h3><h4 id=\"引用计数（未被使用过）\"><a href=\"#引用计数（未被使用过）\" class=\"headerlink\" title=\"引用计数（未被使用过）\"></a>引用计数（未被使用过）</h4><p>对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。</p>\n<p>缺陷：循环引用不适用，即出现”对象应该被回收，但引用计数不为0”的情况，称作”交互自引用的对象组”。如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器：1</span></span><br><span class=\"line\">        MyObject object1 = <span class=\"keyword\">new</span> MyObject();</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器：1</span></span><br><span class=\"line\">        MyObject object2 = <span class=\"keyword\">new</span> MyObject();</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器：2</span></span><br><span class=\"line\">        object1.object = object2;</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器：2</span></span><br><span class=\"line\">        object2.object = object1;</span><br><span class=\"line\">        <span class=\"comment\">// object1指向的对象引用计数器减少为1</span></span><br><span class=\"line\">        object1 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// object2指向的对象引用计数器减少为1</span></span><br><span class=\"line\">        object2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将<code>object1</code>和<code>object2</code>赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。</p>\n<h4 id=\"停止-复制（stop-and-copy）\"><a href=\"#停止-复制（stop-and-copy）\" class=\"headerlink\" title=\"停止-复制（stop-and-copy）\"></a>停止-复制（stop-and-copy）</h4><p>遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，将堆中<strong>所有存活的对象复制到另一个堆中</strong>，没有被复制的便都是垃圾了。</p>\n<p>这种策略避免了上述”交互自引用的对象组”无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。</p>\n<p><strong>缺陷：效率低</strong></p>\n<ol>\n<li>复制需要在两个堆之间操作，即需要维护多一倍的空间；</li>\n<li>当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。</li>\n</ol>\n<p>针对第2个情况，有另外一种策略，如下。</p>\n<h4 id=\"标记-清扫（mark-and-sweep）\"><a href=\"#标记-清扫（mark-and-sweep）\" class=\"headerlink\" title=\"标记-清扫（mark-and-sweep）\"></a>标记-清扫（mark-and-sweep）</h4><p>同样遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，同时会给该对象进行<strong>标记</strong>，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作”标记-整理”。</p>\n<blockquote>\n<p>注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。</p>\n<p>许多文献中有关于”垃圾回收器是低优先级的后台进程”的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展”停止-复制”或”标记-清扫”工作。</p>\n</blockquote>\n<p>“标记-清扫”方式速度相当慢，但是当垃圾很少时，就很快了。</p>\n<h4 id=\"自适应技术\"><a href=\"#自适应技术\" class=\"headerlink\" title=\"自适应技术\"></a>自适应技术</h4><p>JVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到”标记-清扫”方式；同样，JVM也会跟踪”标记-清扫”方式，若堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是自适应技术。</p>\n<p>这是早期Sun版本的垃圾回收器。</p>\n<h4 id=\"分代垃圾收集（Generational-Garbage-Collection）\"><a href=\"#分代垃圾收集（Generational-Garbage-Collection）\" class=\"headerlink\" title=\"分代垃圾收集（Generational Garbage Collection）\"></a>分代垃圾收集（Generational Garbage Collection）</h4><p>上述无论是”停止-复制”、”标记-清扫”还是”标记-整理”对于日益增长的对象列表，效率会逐渐低下。</p>\n<p><img src=\"/images/image-20190225225057306.png\" alt=\"image-20190225225057306\"></p>\n<p>堆被分为三代：</p>\n<ul>\n<li><p>年轻代(Young Generation)</p>\n<p>内存空间：<strong>eden:S0:S1 = 8:1:1</strong></p>\n<p>S0和S1<strong>没有先后顺序</strong>，任何一个都可能是<strong>From survivor space</strong>和<strong>To survivor space</strong></p>\n</li>\n<li><p>年老代(Old Generation)</p>\n<p>内存空间：年老代:年轻代 ≈ 2:1</p>\n</li>\n<li><p>持久代(Permanent Generation)</p>\n<p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n</li>\n</ul>\n<p>下面说明一下对象在分配内存、老化、回收的过程：</p>\n<ol>\n<li><p>首先，任何新对象创建时内存都会分配在年轻代的<strong>eden space</strong>中，<strong>S0</strong>和<strong>S1</strong>两个<strong>幸存者空间(survivor space)</strong>起初都是空的<img src=\"/images/image-20190225225802212.png\" alt=\"image-20190225225802212\"></p>\n</li>\n<li><p>当eden space满时，会触发第一次<strong>较小的垃圾回收过程(minor garbage collection，minor GC)</strong>\u0001<img src=\"/images/image-20190225230110077.png\" alt=\"image-20190225230110077\"></p>\n<blockquote>\n<p>实际上MinorGC不一定要等到eden space满了才触发</p>\n</blockquote>\n</li>\n<li><p>eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收<img src=\"/images/image-20190225230647640.png\" alt=\"image-20190225230647640\"></p>\n</li>\n<li><p>当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象\u0001<img src=\"/images/image-20190225232204967.png\" alt=\"image-20190225232204967\"></p>\n</li>\n<li><p>再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收<img src=\"/images/image-20190225232407098.png\" alt=\"image-20190225232407098\"></p>\n</li>\n<li><p>当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代<img src=\"/images/image-20190225232630665.png\" alt=\"image-20190225232630665\"></p>\n</li>\n<li><p>以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发<strong>完全的垃圾回收(major gabarge collector, major GC)</strong>，清理并压缩该块内存空间。</p>\n<p>major GC被触发的原因：</p>\n<ol>\n<li><p>年老代（Tenured）被写满</p>\n</li>\n<li><p>持久代（Permanent）被写满</p>\n</li>\n<li><p>System.gc()被显式调用</p>\n</li>\n<li><p>上一次GC之后Heap的各域分配策略动态变化</p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"HotSpot-JVM的垃圾收集器\"><a href=\"#HotSpot-JVM的垃圾收集器\" class=\"headerlink\" title=\"HotSpot JVM的垃圾收集器\"></a>HotSpot JVM的垃圾收集器</h5><p><strong>Serial收集器（复制算法)</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<p><strong>Serial Old收集器(标记-整理算法)</strong>：老年代单线程收集器，Serial收集器的老年代版本。</p>\n<p><strong>ParNew收集器(停止-复制算法)</strong>：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<p><strong>Parallel Scavenge收集器(停止-复制算法)</strong>：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<p><strong>Parallel Old收集器(停止-复制算法)</strong>：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<p><strong>CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)</strong>：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<p>【参考：<a href=\"https://crowhawk.github.io/2017/08/15/jvm_3/\" target=\"_blank\" rel=\"noopener\">深入理解JVM(3)——7种垃圾收集器</a>】</p>\n<h2 id=\"可变参数列表\"><a href=\"#可变参数列表\" class=\"headerlink\" title=\"可变参数列表\"></a>可变参数列表</h2><p>Java中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tInteger a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tInteger b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tInteger c = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tOther.main(a, b);</span><br><span class=\"line\">\t\tOther.main(a, b, c);</span><br><span class=\"line\">        Other.main();</span><br><span class=\"line\">        Other.main(<span class=\"keyword\">new</span> Object[]&#123;a, b&#125;);</span><br><span class=\"line\">\t\tOther.main(<span class=\"keyword\">new</span> Object[]&#123;a, b, c&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Other</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(Object... args)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Object s : args)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(s + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示，当输入不同个数参数时，编译器会自动将其<strong>转换成数组</strong>，当参数本身就是数组时，编译器又<strong>不会进行转换</strong>，直接传递给函数。参数为空时编译器便<strong>直接传递一个空Object数组</strong>。</p>\n<h3 id=\"可变参数列表的重载\"><a href=\"#可变参数列表的重载\" class=\"headerlink\" title=\"可变参数列表的重载\"></a>可变参数列表的重载</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(String... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">\t\tf();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，函数有<code>f(Character... args)</code>和<code>f(String... args)</code>两种重载方式，此时<code>f(&#39;a&#39;, &#39;b&#39;)</code>和<code>f(&quot;a&quot;, &quot;b&quot;)</code>都可正常调用，但是<code>f()</code>会报错，即两种重载都匹配。</p>\n<p>此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">float</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，编译器也会报错，<code>f(&#39;a&#39;, &#39;b&#39;)</code>可匹配两个函数，(可能是)因为<code>char</code>类型可提升至<code>float</code>类型从而匹配第一个重载函数。</p>\n<p>此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">float</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">char</span> i, Character... args)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"second\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tf(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>);</span><br><span class=\"line\">\t\tf(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种用法比较奇怪，因此”你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它”（《Java编程思想》105页）。</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><h3 id=\"内部类对象对外围类对象的访问\"><a href=\"#内部类对象对外围类对象的访问\" class=\"headerlink\" title=\"内部类对象对外围类对象的访问\"></a>内部类对象对外围类对象的访问</h3><p>当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">current</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] items;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> next = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sequence</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123; items = <span class=\"keyword\">new</span> Object[size]; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt; items.length)&#123;</span><br><span class=\"line\">            items[next++] = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SequenceSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> i == items.length; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">current</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> items[i]; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">if</span>(i &lt; items.length) i++; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Selector <span class=\"title\">selector</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SequenceSelector();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Sequence sequence = <span class=\"keyword\">new</span> Sequence(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">            sequence.add(Integer.toString(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Selector selector = sequence.selector();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!selector.end())&#123;</span><br><span class=\"line\">            System.out.print(selector.current() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            selector.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。</p>\n<h3 id=\"内部类与静态内部类（嵌套类）\"><a href=\"#内部类与静态内部类（嵌套类）\" class=\"headerlink\" title=\"内部类与静态内部类（嵌套类）\"></a>内部类与静态内部类（嵌套类）</h3><h4 id=\"创建方法\"><a href=\"#创建方法\" class=\"headerlink\" title=\"创建方法\"></a>创建方法</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部类：DotNew.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DotNew</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        Inner()&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"创建内部类\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        DotNew dn = <span class=\"keyword\">new</span> DotNew();</span><br><span class=\"line\">        DotNew.Inner dni = dn.new Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类：DotNewStatic.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DotNewStatic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        Inner() &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"创建静态内部类\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        DotNewStatic.Inner inner = <span class=\"keyword\">new</span> DotNewStatic.Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><p>Java支持<strong>创建一个继承自某基类的匿名类的对象</strong>，通过new表达式返回的引用被<strong>自动向上转型为对基类的引用</strong>。</p>\n<p>匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。</p>\n<p>注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是<code>final</code>，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Destination.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Destination</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Parcel9.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel9</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destination <span class=\"title\">destination</span><span class=\"params\">(<span class=\"keyword\">final</span> String dest)</span></span>&#123;<span class=\"comment\">// 外部变量dest被引用时需声明为final，否则产生编译时错误</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Destination()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> String label = dest;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> label;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Parcel9 p = <span class=\"keyword\">new</span> Parcel9();</span><br><span class=\"line\">        Destination d = p.destination(<span class=\"string\">\"Tasmania\"</span>);</span><br><span class=\"line\">        System.out.println(d.readLabel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。</p>\n</blockquote>\n<blockquote>\n<p><strong>为什么匿名内部类访问外部变量必须是final的？</strong></p>\n<ol>\n<li><p>为了避免<strong>外部方法修改引用导致内部类得到的引用值不一致</strong>和<strong>内部类修改引用而导致外部方法的参数值在修改前和修改后不一致</strong></p>\n</li>\n<li><p>保证回调函数回调时可访问到变量（<strong>待研究</strong>）</p>\n</li>\n<li><p>反编译查看其实现细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"comment\">// 源代码</span></span><br><span class=\"line\">&gt;    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TryUsingAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useMyInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">final</span> Integer number = <span class=\"number\">123</span>;</span><br><span class=\"line\">&gt;            System.out.println(number);</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;            MyInterface myInterface = <span class=\"keyword\">new</span> MyInterface() &#123;</span><br><span class=\"line\">&gt;                <span class=\"meta\">@Override</span></span><br><span class=\"line\">&gt;                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;                    System.out.println(number);</span><br><span class=\"line\">&gt;                &#125;</span><br><span class=\"line\">&gt;            &#125;;</span><br><span class=\"line\">&gt;            myInterface.doSomething();</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;            System.out.println(number);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;    <span class=\"comment\">// 反编译结果</span></span><br><span class=\"line\">&gt;    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TryUsingAnonymousClass</span>$1</span></span><br><span class=\"line\"><span class=\"class\">&gt;            <span class=\"keyword\">implements</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TryUsingAnonymousClass <span class=\"keyword\">this</span>$<span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer paramInteger;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;        TryUsingAnonymousClass$<span class=\"number\">1</span>(TryUsingAnonymousClass <span class=\"keyword\">this</span>$<span class=\"number\">0</span>, Integer paramInteger) &#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.<span class=\"keyword\">this</span>$<span class=\"number\">0</span> = <span class=\"keyword\">this</span>$<span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.paramInteger = paramInteger;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    </span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            System.out.println(<span class=\"keyword\">this</span>.paramInteger);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>   注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时<strong>实际上是做了个”拷贝”</strong>或者说<strong>“赋值”</strong>。若可以更改，则会造成数据不一致。</p>\n</blockquote>\n<h2 id=\"RTTI\"><a href=\"#RTTI\" class=\"headerlink\" title=\"RTTI\"></a>RTTI</h2><p>RTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是<strong>多态的基础</strong>，由<strong>Class类实现</strong>。</p>\n<h3 id=\"Class对象\"><a href=\"#Class对象\" class=\"headerlink\" title=\"Class对象\"></a>Class对象</h3><p>每当编写并且编译一个类时，在与类同名的<code>.class</code>文件中会自动产生一个<code>Class对象</code>。实现此过程的JVM子系统被称作<strong>类加载器</strong>。</p>\n<p>Class对象仅在需要的时候才被加载，也就是所有的类都是<strong>只在对其第一次使用时</strong>，动态加载到JVM中的。所谓第一次使用指的是<strong>对类的非常量静态域的第一次引用。</strong></p>\n<ul>\n<li><p>要注意，<strong>类的构造器</strong>是<strong>隐性非常量静态域</strong>，所以使用new操作符生成对象也是产生这样的Class类引用。</p>\n</li>\n<li><p>与此同时，还可以使用<code>Class.forName(类名)</code>产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常<code>ClassNotFoundException</code>。比如在JDBC连接数据库时常常用到的<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，就是告诉JVM去加载MySQL驱动。</p>\n</li>\n<li><p>当已经拥有某个类型的对象（实例）时，可通过调用<code>getClass()</code>方法来获取该类型的Class引用。</p>\n</li>\n<li><p>另一种方法，使用<strong>类字面变量</strong>。通过使用<code>类名.class</code>可获取此类的Class对象的引用，但是注意，此时<strong>此Class对象还未被初始化</strong>，还需要等到上述的<code>对类的非常量静态域的第一次引用</code>这一操作执行时才被初始化。</p>\n<blockquote>\n<p>使用.class方法获取Class对象引用实际包含三个步骤：</p>\n<ol>\n<li><strong>加载</strong>：类加载器创建Class对象</li>\n<li><strong>链接</strong></li>\n<li><strong>初始化</strong>：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li>\n</ol>\n<p>考虑如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> staticFinal = <span class=\"number\">1</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable2</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticNonFinal = <span class=\"number\">2</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable2\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Initable3</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticNonFinal = <span class=\"number\">3</span>;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">&gt;         System.out.println(<span class=\"string\">\"Initializing Initable3\"</span>);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInitialization</span> </span>&#123;</span><br><span class=\"line\">&gt;     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>);</span><br><span class=\"line\">&gt;     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 创建Initable的Class对象的引用，Class对象未初始化</span></span><br><span class=\"line\">&gt;         Class initable = Initable.class;</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 仍然未初始化，因Initable.staticFinal是常数</span></span><br><span class=\"line\">&gt;         System.out.println(Initable.staticFinal);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 触发了Initable的Class对象的初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable.staticFinal2);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 触发了Initable2的Class对象的初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable2.staticNonFinal);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 创建Initable3的Class对象的引用，同时会初始化此Class对象</span></span><br><span class=\"line\">&gt;         Class initable3 = Class.forName(<span class=\"string\">\"Initable3\"</span>);</span><br><span class=\"line\">&gt;         <span class=\"comment\">// 此时已初始化，无需再次初始化</span></span><br><span class=\"line\">&gt;         System.out.println(Initable3.staticNonFinal);</span><br><span class=\"line\">&gt;     &#125;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>另外，当我拥有某个Class对象c的时候，我虽然<strong>不知道它确切类型</strong>，但是可以使用<code>c.newInstance()</code>来正确地获取c代表的类型的实例。<strong>但是此方法要求对应的类</strong>。</p>\n<h3 id=\"泛化的Class对象引用\"><a href=\"#泛化的Class对象引用\" class=\"headerlink\" title=\"泛化的Class对象引用\"></a>泛化的Class对象引用</h3><p>Class对象可以通过<code>Class&lt;Type&gt;</code>的方法产生特定类型的类引用，创建了<strong>使用类型限定后</strong>的Class对象引用<strong>不能再赋值给除本身和子类的其他的Class对象</strong>。</p>\n<blockquote>\n<p>注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如<code>Integer</code>继承自<code>Number</code>，而<code>Integer Class对象</code>却不是<code>Number Class对象</code>的子类。</p>\n</blockquote>\n<p>使用通配符<code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>（实际上是等价的），而且会免除编译器警告，看图：<img src=\"/images/image-20190308105552914.png\" alt=\"image-20190308105552914\"></p>\n<p>一种更好的用法，<code>Class&lt;? extends Type&gt;</code>，这种类型限定比直接<code>Class&lt;Type&gt;</code>好的地方在于他产生的Class对象引用<strong>可赋值给Type本身及子类的Class对象</strong>，这种继承关系<strong>是Type所属的继承关系</strong>而<strong>不是对应的Class对象的继承关系</strong>。</p>\n<h3 id=\"转型语法（不常用）\"><a href=\"#转型语法（不常用）\" class=\"headerlink\" title=\"转型语法（不常用）\"></a>转型语法（不常用）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Building</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">House</span> <span class=\"keyword\">extends</span> <span class=\"title\">Building</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassCasts</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Building b = <span class=\"keyword\">new</span> Building();</span><br><span class=\"line\">        Class&lt;House&gt; houseType = House.class;</span><br><span class=\"line\">        House h = houseType.cast(b);</span><br><span class=\"line\">        h = (House) b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，使用<code>houseType.cast(b)</code>和<code>(House) b</code>效果一样，但是执行的工作却不同，具体内部实现尚未学习到。</p>\n<h3 id=\"动态的类型检测\"><a href=\"#动态的类型检测\" class=\"headerlink\" title=\"动态的类型检测\"></a>动态的类型检测</h3><h4 id=\"obj-instanceof-ClassType\"><a href=\"#obj-instanceof-ClassType\" class=\"headerlink\" title=\"obj instanceof ClassType\"></a>obj instanceof ClassType</h4><p>返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。</p>\n<h4 id=\"ClassType-isInstance\"><a href=\"#ClassType-isInstance\" class=\"headerlink\" title=\"ClassType.isInstance()\"></a>ClassType.isInstance()</h4><p>返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>区别主要是后者与前者动态等价，看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicEqual</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Father father = <span class=\"keyword\">new</span> Father();</span><br><span class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">        <span class=\"comment\">// instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称</span></span><br><span class=\"line\">        <span class=\"comment\">// if (son instanceof father.getClass())&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     ...</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (father.getClass().isInstance(son))&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"isInstance is Dynamic\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><code>isInstance()</code>的存在可以替代<code>instanceof</code>，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：</p>\n<ul>\n<li>使用<code>instanceof</code>时可能需要使用<code>switch-case</code>语句；当需要添加一个子类时，需要修改<code>switch-case</code>内部代码。</li>\n<li>而使用<code>isInstance()</code>时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。</li>\n</ul>\n<h3 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h3><h4 id=\"反射与RTTI的区别\"><a href=\"#反射与RTTI的区别\" class=\"headerlink\" title=\"反射与RTTI的区别\"></a>反射与RTTI的区别</h4><ul>\n<li>RTTI：编译器在编译时打开和检查<code>.class</code>文件（获取类的Class类对象信息）</li>\n<li>反射：JVM在运行时打开和检查<code>.class</code>文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取<code>.class</code>文件）</li>\n</ul>\n<h4 id=\"类方法提取器\"><a href=\"#类方法提取器\" class=\"headerlink\" title=\"类方法提取器\"></a>类方法提取器</h4><p>通过Class对象引用：调用<code>getMethods()</code>方法获取该类及其父类的方法列表，调用<code>getConstructors()</code>方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个<strong>非public类的非public方法是无法被获取的</strong>。</p>\n<h4 id=\"接口与类型信息\"><a href=\"#接口与类型信息\" class=\"headerlink\" title=\"接口与类型信息\"></a>接口与类型信息</h4><p>interface关键字的一种重要目标就是允许程序员<strong>隔离构件，进而降低耦合性</strong>。</p>\n<h4 id=\"包权限安全吗？\"><a href=\"#包权限安全吗？\" class=\"headerlink\" title=\"包权限安全吗？\"></a>包权限安全吗？</h4><p>直接看例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HiddenC.java</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"public C.f()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"public C.g()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">u</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"package C.u()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">v</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"protected C.v()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">w</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"private C.w()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HiddenC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title\">makeA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HiddenImplementation.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HiddenImplementation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        A a = HiddenC.makeA();</span><br><span class=\"line\">        a.f();</span><br><span class=\"line\">        System.out.println(a.getClass().getName());</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"g\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"u\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"v\"</span>);</span><br><span class=\"line\">        callHiddenMethod(a, <span class=\"string\">\"w\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">callHiddenMethod</span><span class=\"params\">(Object a, String methodName)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取a中的方法</span></span><br><span class=\"line\">        Method g = a.getClass().getDeclaredMethod(methodName);</span><br><span class=\"line\">        <span class=\"comment\">// 修改该方法的权限</span></span><br><span class=\"line\">        g.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 调用该方法</span></span><br><span class=\"line\">        g.invoke(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* output</span></span><br><span class=\"line\"><span class=\"comment\">public C.f()</span></span><br><span class=\"line\"><span class=\"comment\">C</span></span><br><span class=\"line\"><span class=\"comment\">public C.g()</span></span><br><span class=\"line\"><span class=\"comment\">package C.u()</span></span><br><span class=\"line\"><span class=\"comment\">protected C.v()</span></span><br><span class=\"line\"><span class=\"comment\">private C.w()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//:)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用<code>setAccessble(true)</code>后被调用。</li>\n<li>只发布<code>.class</code>文件也是没办法避免此问题，<code>javap -private</code>命令可以反编译<code>.class</code>文件，<code>-private</code>参数约定显示所有的成员</li>\n<li>同样，内部类和匿名内部类也是没办法避免此情况</li>\n</ul>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"指定类型有保证吗？\"><a href=\"#指定类型有保证吗？\" class=\"headerlink\" title=\"指定类型有保证吗？\"></a>指定类型有保证吗？</h3><blockquote>\n<p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>\n</blockquote>\n<p>例如对于<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>，二者的实例调用<code>.getClass()</code>获取的Class对象时相同的，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Erase</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; s = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class=\"line\">        Class&lt;?&gt; i = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class=\"line\">        System.out.println(s == i);</span><br><span class=\"line\">        System.out.println(s.getName());</span><br><span class=\"line\">        System.out.println(s.getTypeParameters());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">java.util.ArrayList</span></span><br><span class=\"line\"><span class=\"comment\">[Ljava.lang.reflect.TypeVariable;@68f7aae2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>但是，如果在一个<code>ArrayList&lt;String&gt;</code>类型的实例中添加<code>Integer</code>会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"This is an apple\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectAdd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; strings = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Class&lt;?&gt; s = strings.getClass();</span><br><span class=\"line\">        Method method = s.getMethod(<span class=\"string\">\"add\"</span>, Object.class);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"number\">1</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"number\">3</span>);</span><br><span class=\"line\">        method.invoke(strings, <span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        System.out.println(Arrays.toString(strings.toArray()));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : strings)&#123;</span><br><span class=\"line\">            System.out.println(o.getClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">[1, 2, 3, This is an apple]</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.Integer</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.String</span></span><br><span class=\"line\"><span class=\"comment\">class java.lang.Integer</span></span><br><span class=\"line\"><span class=\"comment\">class Apple</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到上述代码使用反射机制成功的在<code>ArrayList&lt;String&gt;</code>里面添加了<code>Integer</code>，原因在于<code>ArrayList</code>的泛型实现<code>ArrayList&lt;E&gt;</code>使其被擦除为<code>ArrayList&lt;Object&gt;</code>，从而通过反射机制找到其<code>add(E e)</code>方法时，实际上是<code>add(Object o)</code>，而我们代码中的<code>Method method = s.getMethod(&quot;add&quot;, Object.class);</code>恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。</p>\n<h3 id=\"与C-的区别\"><a href=\"#与C-的区别\" class=\"headerlink\" title=\"与C++的区别\"></a>与C++的区别</h3><p><strong>C++:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt; <span class=\"title\">class</span> <span class=\"title\">Manipulator</span> &#123;</span></span><br><span class=\"line\">    T obj;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span> </span>&#123; obj.f(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">manipulate2</span><span class=\"params\">()</span> </span>&#123; obj.noF(); &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasF</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"HasF()::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DontHaveF</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">noF</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Don't have f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    HasF hf;</span><br><span class=\"line\">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class=\"line\">    manipulator.manipulate();</span><br><span class=\"line\">    <span class=\"comment\">// manipulator.manipulate2();  无法编译</span></span><br><span class=\"line\">    DontHaveF dhf;</span><br><span class=\"line\">    Manipulator&lt;DontHaveF&gt; manipulator2(dhf);</span><br><span class=\"line\">    <span class=\"comment\">// manipulator2.manipulate();  无法编译</span></span><br><span class=\"line\">    manipulator2.manipulate2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">HasF()::f()</span></span><br><span class=\"line\"><span class=\"comment\">Don't have f()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>模板类<code>Manipulator</code>在编译时期便可以检测到函数<code>f()</code>、<code>noF()</code>是在类型参数<t>中存在的，这是在编译器看到声明<code>Manipulator&lt;HasF&gt; manipulator(hf)</code>和<code>Manipulator&lt;DontHaveF&gt; manipulator2(dhf)</code>所产生的结果。</t></p>\n<p>然而Java中却无法实现这样的操作：</p>\n<p><strong>Java:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HasF.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HasF</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"HasF.f();\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Manipulation.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T obj;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Manipulator</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        obj = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        obj.f() <span class=\"comment\">// 会报编译错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulation</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        HasF hf = <span class=\"keyword\">new</span> HasF();</span><br><span class=\"line\">        Manipulator&lt;HasF&gt; manipulation = <span class=\"keyword\">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class=\"line\">        manipulation.manipulate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于Java在编译过程中，<code>Manipulator&lt;T&gt;</code>是无法确定其类型参数，只知道他是一个<code>Object实例</code>，因此obj<strong>只能调用Object基类所有的公开方法</strong>。若想实现C++的操作有两种办法(目前我已知的只有这两种)。</p>\n<ul>\n<li><p>为<code>T</code>限定参数类型（给定边界），即声明时指定其所继承的基类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">HasF</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用反射机制调用<code>f()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T obj;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Manipulator</span><span class=\"params\">(T x)</span> </span>&#123;</span><br><span class=\"line\">        obj = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">manipulate</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; oc = obj.getClass();</span><br><span class=\"line\">        Method method = oc.getMethod(<span class=\"string\">\"f\"</span>);</span><br><span class=\"line\">        method.invoke(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manipulation</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        HasF hf = <span class=\"keyword\">new</span> HasF();</span><br><span class=\"line\">        Manipulator&lt;HasF&gt; manipulation = <span class=\"keyword\">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class=\"line\">        manipulation.manipulate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">HasF.f();</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h3><blockquote>\n<p>擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。</p>\n</blockquote>\n<p>泛型<strong>不能用于显式地引用运行时类型的操作之中</strong>，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。</p>\n<p>也就是说，需要时刻提醒自己，我只是<strong>看起来好像拥有</strong>有关参数的类型信息而已。实际上，<strong>它只是一个Object！</strong></p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>既然编译器会<code>擦除</code>类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的<code>边界</code>：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。</p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jonathan</span> <span class=\"keyword\">extends</span> <span class=\"title\">Apple</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Orange</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompilerIntelligence</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        Apple a = (Apple) flist.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Orange o = (Orange) flist.get(0); 运行时错误</span></span><br><span class=\"line\">        <span class=\"comment\">// flist.add(new Fruit());  编译错误</span></span><br><span class=\"line\">        <span class=\"comment\">// flist.add(new Apple());  编译错误</span></span><br><span class=\"line\">        System.out.println(flist.contains(a));</span><br><span class=\"line\">        System.out.println(flist.contains(<span class=\"keyword\">new</span> Apple()));</span><br><span class=\"line\">        System.out.println(flist.indexOf(<span class=\"keyword\">new</span> Apple()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">false</span></span><br><span class=\"line\"><span class=\"comment\">-1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>对于使用了通配符的<code>List&lt;? extends Fruit&gt; flist</code>来说，其需要用到类型参数的方法例如<code>add()</code>参数也变成了<code>&lt;? extends Fruit&gt;</code>，然而编译器并不能知道这里需要哪一个具体的子类型，于是<strong>编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。</strong></p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>完整的容器分类法：</p>\n<p><img src=\"/images/image-20190312200304819.png\" alt=\"image-20190312200304819\"></p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p><code>HashMap</code>采用了链地址法，也就是<strong>数组+链表</strong>的方式。主干是一个<code>Entry</code>数组，链表是为了解决哈希冲突而存在的。<code>HashMap</code>中的链表越少，性能越好。</p>\n<h4 id=\"Entry数组长度为2的次幂\"><a href=\"#Entry数组长度为2的次幂\" class=\"headerlink\" title=\"Entry数组长度为2的次幂\"></a>Entry数组长度为2的次幂</h4><ul>\n<li>由于在计算<code>key</code>的<code>插入位置</code>时用到了<code>hash &amp; (length-1)</code>，<code>hash</code>是<code>key</code>计算出来的哈希值，想象一下当<code>length</code>不为2的次幂时，<code>length-1</code>的二进制必然有<code>0位</code>，那么意味着该位为<code>0</code>的位置永远不可能被当做<code>插入位置</code>，造成了严重的空间浪费。</li>\n<li>由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即<code>equal()</code>操作多了起来，效率也就慢了。</li>\n</ul>\n<h4 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h4><p><code>HashMap</code>当<code>Entry</code>数组元素超过<code>数组大小*loadFactor</code>时，就会进行数组扩容。<code>loadFactor</code>默认值为0.75。此时<code>Entry</code>数组大小会扩大一倍，保证了2的次幂大小。</p>\n<p>扩容的时候所有的<code>key</code>需要重新计算哈希值。</p>\n<h4 id=\"JDK1-8优化\"><a href=\"#JDK1-8优化\" class=\"headerlink\" title=\"JDK1.8优化\"></a>JDK1.8优化</h4><p>由于1.8之前的<code>HashMap</code>在<code>hash</code>冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。</p>\n<h3 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h3><p><code>HashTable</code>在结构上与<code>HashMap</code>基本相同，下面总结其不同点：</p>\n<ul>\n<li><code>HashMap</code>可有<code>null key</code>，<code>HashTable</code>获取<code>null key</code>会报空指针异常</li>\n<li><code>HashTable</code>有<code>synchronized</code>方法同步，线程安全；<code>HashMap</code>线程不安全</li>\n<li><code>Hash</code>值计算方法不同</li>\n<li><code>HashTable</code>初始大小为<code>11</code>，扩容机制为<code>2*old+1</code>；<code>HashMap</code>初始大小为<code>16</code>，扩容机制为<code>2*old</code></li>\n</ul>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p><code>JDK1.7</code>版本中的<code>ConcurrentHashMap</code>比<code>HashMap</code>多了一层<code>Segment</code>，其中<code>Segment</code>继承于<code>ReentrantLock</code>：<strong>一次<code>put</code>操作会调用<code>scanAndLockForPut()</code>方法自旋获取锁</strong>；<strong>而一次<code>get</code>操作则不需要加锁，<code>value</code>用<code>volatile</code>关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效</strong>。</p>\n<p><code>JDK1.8</code>版本移除了<code>segment</code>，有一个<code>Node</code>数组相当于<code>HashMap</code>中的<code>Entry</code>数组。同时采用了<code>CAS+synchronized关键字</code>进行<code>put</code>操作。<code>put</code>操作步骤如下：</p>\n<ul>\n<li>根据<code>key</code>计算出<code>hashcode</code>；</li>\n<li>判断是否需要进行初始化；</li>\n<li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功；</li>\n<li>判断是否需要进行扩容；</li>\n<li>如果都不满足，则利用 <code>synchronized</code> 锁写入数据；</li>\n<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>\n</ul>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><h3 id=\"Brian-Goetz的线程同步规则\"><a href=\"#Brian-Goetz的线程同步规则\" class=\"headerlink\" title=\"Brian Goetz的线程同步规则\"></a>Brian Goetz的线程同步规则</h3><blockquote>\n<p>如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，<strong>读写线程</strong>都必须用相同的监视器锁同步。</p>\n</blockquote>\n<h3 id=\"Executor\"><a href=\"#Executor\" class=\"headerlink\" title=\"Executor\"></a>Executor</h3><p>Executor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CachedThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> LiftOff());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池的作用是<strong>限制系统中执行线程的数量</strong>，根据系统情况可以<strong>自动或手动</strong>设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。</p>\n<ul>\n<li><code>newSingleThreadExecutor()</code>：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。</li>\n<li><code>newFixedThreadPool()</code>：创建固定大小的线程池。</li>\n<li><code>newCachedThreadPool()</code>：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。</li>\n<li><code>newScheduledThreadPool()</code>：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。</li>\n</ul>\n<h3 id=\"任务的返回值\"><a href=\"#任务的返回值\" class=\"headerlink\" title=\"任务的返回值\"></a>任务的返回值</h3><p>通常实现<code>Runnable</code>接口的类是没有返回值的，要想任务在完成时返回一个值可实现<code>Callable&lt;T&gt;</code>接口，其泛型类型参数表示方法<code>call()</code>的返回值，并且需要使用<code>ExecutorService.submit()</code>方法调用他。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskWithResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"result of TaskWithResult\"</span> + id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            results.add(exec.submit(<span class=\"keyword\">new</span> TaskWithResult(i)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(fs.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">                System.err.println(e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                exec.shutdown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output：</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult0</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult1</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult2</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult3</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult4</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult5</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult6</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult7</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult8</span></span><br><span class=\"line\"><span class=\"comment\">result of TaskWithResult9</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p><code>ExecutorService</code>对象的<code>submit()</code>方法会返回一个<code>Future&lt;T&gt;</code>对象，泛型类型参数即是实现<code>Callable&lt;T&gt;</code>的类型参数。<code>get()</code>方法会返回结果，若任务未完成，<code>get()</code>会阻塞。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。</p>\n<p>但是注意优先级高的线程也有几率比优先级底的线程执行的少。</p>\n<p>优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。</p>\n<h3 id=\"Thread-yield-可靠吗？\"><a href=\"#Thread-yield-可靠吗？\" class=\"headerlink\" title=\"Thread.yield()可靠吗？\"></a>Thread.yield()可靠吗？</h3><p><code>Thread.yield()</code>源码中提及了该方法的效果：<strong>当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。</strong>意即此处的<code>让步</code>只是一厢情愿，发出让步的线程同样可以继续执行。</p>\n<h3 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h3><p>后台线程<strong>并不属于程序中不可或缺的部分</strong>。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p>\n<p>执行<code>main()</code>就是一个非后台线程，当<code>main()</code>没有执行结束时，程序就不会终止。</p>\n<p>后台线程创建的线程也将是后台线程。</p>\n<p>同时要注意在后台线程的<code>run()</code>方法中若有<code>finally</code>子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。</p>\n<h3 id=\"Thread还是Runnable\"><a href=\"#Thread还是Runnable\" class=\"headerlink\" title=\"Thread还是Runnable\"></a>Thread还是Runnable</h3><p>创建多线程任务可以继承<code>Thread</code>类重写其<code>run()</code>方法，也可以实现<code>Runnable</code>接口实现其<code>run()</code>方法。</p>\n<p>实际应用中，<code>Runnable</code>还是比较有优势的：</p>\n<ul>\n<li>避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）</li>\n<li>多个线程区处理同一资源，而非独立处理（这句话有问题）</li>\n</ul>\n<p>注意，一开始在理解这里的时候我出现了误解，什么叫<strong>处理同一资源</strong>，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了<strong>(待确认)</strong>，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"-- val: \"</span> + val--);</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>  (val &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"-- val: \"</span> + val--);</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRunnableAndThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> TestRunnable();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> TestThread();</span><br><span class=\"line\">        <span class=\"comment\">// a.只有1个线程处理一个数据</span></span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"comment\">// b.5个不同线程处理不同数据</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestThread().start();</span><br><span class=\"line\">        <span class=\"comment\">// c.5个不同线程处理相同数据</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">        <span class=\"comment\">// d.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execRun = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execRun.execute(runnable);</span><br><span class=\"line\">        <span class=\"comment\">// e.5个不同线程处理5个不同数据</span></span><br><span class=\"line\">        ExecutorService execRun2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execRun2.execute(<span class=\"keyword\">new</span> TestRunnable());</span><br><span class=\"line\">        <span class=\"comment\">// f.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execThread = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">            execThread.execute(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// g.5个不同线程处理5个不同数据</span></span><br><span class=\"line\">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execThread2.execute(<span class=\"keyword\">new</span> TestThread());</span><br><span class=\"line\">        <span class=\"comment\">// i.5个不同线程处理相同数据</span></span><br><span class=\"line\">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">            execThread2.execute(<span class=\"keyword\">new</span> Thread(runnable));</span><br><span class=\"line\"></span><br><span class=\"line\">        execRun.shutdown();</span><br><span class=\"line\">        execRun2.shutdown();</span><br><span class=\"line\">        execThread.shutdown();</span><br><span class=\"line\">        execThread2.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中：<strong>c、d、i</strong>实际上是相同的，<strong>b、g</strong>是相同的，而<strong>a</strong>和<strong>f</strong>看起来相同，但是实际作用却差别很大，待研究。</p>\n<p>实际上，<strong>a</strong>是错误的用法，<strong>b</strong>、<strong>c</strong>基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个<strong>线程安全的外部对象</strong>。</p>\n<h3 id=\"共享资源\"><a href=\"#共享资源\" class=\"headerlink\" title=\"共享资源\"></a>共享资源</h3><h4 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h4><p>冲突是多线程问题必须解决的任务，Java使用<code>synchronized</code>关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当<strong>某一个任务第一次给该对象加锁时，计数变为1</strong>，此后<strong>只有这个相同的任务能继续给该对象加锁</strong>，计数会递增；<strong>每当离开一个synchronized方法时，计数递减</strong>，直到计数变为0时，对象被解锁。要注意，<strong>每个访问该临界资源的方法都必须被同步</strong>，否则就不会正确地工作。</p>\n<p>通常<code>synchronized</code>关键字标识方法时，是在<code>this</code>上面同步，也可在方法中使用<code>synchronized(synObject){}</code>域，<strong>以在特定的对象上同步</strong>，因此不同对象上的锁是相互无关的。</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>Lock对象必须被显式地创建、锁定和释放。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MutexEvenGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentEvenValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 显式声明</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// lock()方法创建临界资源</span></span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ++currentEvenValue;</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">            ++currentEvenValue;</span><br><span class=\"line\">            <span class=\"comment\">// return语句必须出现在try子句中</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> currentEvenValue;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// unlock()方法完成清理工作</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与<code>synchronize</code>相比，显式的<code>Lock</code>优点在于可以使用<code>finally子句</code>将系统维护在正常的状态，而在使用<code>synchronize</code>关键字时，某些事物失败了就会抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AttemptLocking</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">untimed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> captured = lock.tryLock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"untimed - tryLock(): \"</span> + captured);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"untimed - isHeldByCurrentThread(): \"</span> + lock.isHeldByCurrentThread());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (captured) </span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">timed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"timed - tryLock(2, TimeUnit.SECONDS): \"</span> + captured);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"timed - isHeldByCurrentThread(): \"</span> + lock.isHeldByCurrentThread());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (captured)</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttemptLocking al = <span class=\"keyword\">new</span> AttemptLocking();</span><br><span class=\"line\">        al.untimed();</span><br><span class=\"line\">        al.timed();</span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类创建单独的Thread来获取锁，而未释放</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            &#123;setDaemon(<span class=\"keyword\">true</span>);&#125;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                al.lock.lock();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"acquired\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"main - isHeldByCurrentThread(): \"</span> + al.lock.isHeldByCurrentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        al.untimed();</span><br><span class=\"line\">        al.timed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">untimed - tryLock(): true</span></span><br><span class=\"line\"><span class=\"comment\">untimed - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">timed - tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class=\"line\"><span class=\"comment\">timed - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">acquired</span></span><br><span class=\"line\"><span class=\"comment\">main - isHeldByCurrentThread(): true</span></span><br><span class=\"line\"><span class=\"comment\">untimed - tryLock(): false</span></span><br><span class=\"line\"><span class=\"comment\">untimed - isHeldByCurrentThread(): false</span></span><br><span class=\"line\"><span class=\"comment\">timed - tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class=\"line\"><span class=\"comment\">timed - isHeldByCurrentThread(): false</span></span><br><span class=\"line\"><span class=\"comment\">*/</span><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>看代码就很容易理解了。</p>\n<h4 id=\"原子性与易变性\"><a href=\"#原子性与易变性\" class=\"headerlink\" title=\"原子性与易变性\"></a>原子性与易变性</h4><p>原子操作<strong>有可能无需同步机制</strong>，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是<strong>不可视的</strong>，因此不同的任务对应用状态有不同的视图。</p>\n<p><strong>volatile关键字</strong>确保了前面提及的可视性，以及当一个域被声明为volatile时，那么<strong>只要对这个域产生了写操作，所有的读操作都可以看到这个修改</strong>。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。</p>\n<p>所以<strong>非volatile域</strong>上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。</p>\n<p>因此多个任务在同时访问某个域时，<strong>要么使用volatile关键字限定，要么经由同步机制访问</strong>，以保证一致性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicityTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">evenIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            i++; i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">            evenIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        AtomicityTest at = <span class=\"keyword\">new</span> AtomicityTest();</span><br><span class=\"line\">        exec.execute(at);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = at.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val%<span class=\"number\">2</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(val);</span><br><span class=\"line\">                System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看上面这个例子，程序找到奇数时便终止，理想状态下，通过<code>evenIncrement()</code>加2，<code>i</code>应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时<code>i</code>也不是<code>volatile</code>的，因此还存在可视性问题（当然，这里仅仅使用<code>volatile</code>限定<code>i</code>是不够的，因为<code>i++</code>操作不是原子性的）。下面使用<code>Lock</code>显式加锁以实现同步：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicityTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">evenIncrement</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            i++; i++; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">            evenIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        AtomicityTest at = <span class=\"keyword\">new</span> AtomicityTest();</span><br><span class=\"line\">        exec.execute(at);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = at.getValue();</span><br><span class=\"line\">            System.out.println(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val%<span class=\"number\">2</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(val);</span><br><span class=\"line\">                System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原子类\"><a href=\"#原子类\" class=\"headerlink\" title=\"原子类\"></a>原子类</h3><p>上面说到<strong>原子操作是较少的</strong>，而<code>JSE5</code>引入了<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。</p>\n<h3 id=\"ReetrantLock\"><a href=\"#ReetrantLock\" class=\"headerlink\" title=\"ReetrantLock\"></a>ReetrantLock</h3><p>ReentrantLock是一个<strong>可重入</strong>的<strong>互斥锁</strong>，又被称为”<strong>独占锁</strong>“。</p>\n<blockquote>\n<p><strong>可重入锁</strong>指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。</p>\n<p><strong>独占锁</strong>指的是同一时间点锁只能被一个线程获取。</p>\n</blockquote>\n<p>同时ReentrantLock也分为<strong>公平锁</strong>和<strong>非公平锁</strong>，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。</p>\n<h3 id=\"ReentrantReedWriteLock\"><a href=\"#ReentrantReedWriteLock\" class=\"headerlink\" title=\"ReentrantReedWriteLock\"></a>ReentrantReedWriteLock</h3><p>顾名思义，ReentrantReadWriteLock维护了<strong>读取锁</strong>和<strong>写入锁</strong>。</p>\n<p>读取锁用于只读操作，是<strong>共享锁</strong>，能被多个线程获取；</p>\n<p>写入锁用于写入操作，是<strong>独占锁</strong>，只能被一个线程获取。</p>\n<h3 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h3><ul>\n<li>新建（new）</li>\n<li>就绪（Runnable）</li>\n<li>阻塞（Blocked）<ul>\n<li>调用<code>sleep(milliseconds)</code>方法使任务休眠</li>\n<li>调用<code>wait()</code>方法挂起</li>\n<li>等待输入输出完成</li>\n<li>获取锁失败</li>\n</ul>\n</li>\n<li>死亡（Dead）</li>\n</ul>\n<h3 id=\"线程协作\"><a href=\"#线程协作\" class=\"headerlink\" title=\"线程协作\"></a>线程协作</h3><h4 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h4><p>与<code>sleep()</code>和<code>yield()</code>不同，调用<code>wait()</code>时<strong>需要释放当前线程获取的锁</strong>，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了<code>notifyAll()</code>方法时，线程被唤醒。</p>\n<p>但是要注意，使用<code>wait()</code>的时候需要用<code>while</code>循环包围：</p>\n<ul>\n<li>为了检查线程是否被意外唤醒</li>\n</ul>\n<h4 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll()\"></a>notifyAll()</h4><p><code>notifyAll()</code>用来唤醒等待<strong>某个锁</strong>的所有<strong>挂起的任务</strong>。<code>等待某个锁</code>指的是某些需要获取共同的锁的线程，<code>notifyAll()</code>可以唤醒这些线程，而不是程序中所有被挂起的线程。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>多个并发进程因争夺系统资源而产生相互等待的现象。</p>\n<p>四个必要条件：</p>\n<ul>\n<li>互斥</li>\n<li>占有且等待</li>\n<li>不可抢占</li>\n<li>循环等待</li>\n</ul>\n<h3 id=\"免锁容器\"><a href=\"#免锁容器\" class=\"headerlink\" title=\"免锁容器\"></a>免锁容器</h3><p>免锁容器的策略是：对容器的修改可以与读取操作<strong>同时发生</strong>，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。</p>\n<p>这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。</p>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><p>每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。</p>\n<h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><p>每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。<code>synchronized</code>关键字的实现就是悲观锁。</p>\n<h4 id=\"CAS-Compare-And-Swap-技术\"><a href=\"#CAS-Compare-And-Swap-技术\" class=\"headerlink\" title=\"CAS(Compare And Swap)技术\"></a>CAS(Compare And Swap)技术</h4><p>CAS是用来实现乐观锁的一种方法，原理见<a href=\"https://www.jianshu.com/p/ae25eb3cfb5d\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>CAS机制使用3个基本操作数：<strong>内存地址<code>V</code></strong>，<strong>旧的预期值<code>A</code></strong>，<strong>要修改的新值<code>B</code></strong>。</p>\n<p>更新一个变量的时候，只有当<code>A</code>和<code>V</code>的实际值相同时，才会将<code>V</code>对应的值修改为<code>B</code>。</p>\n<p>缺点：</p>\n<ul>\n<li>ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化</li>\n<li>循环时间长开销大</li>\n<li>只能保证一个共享变量的原子性</li>\n</ul>\n<p>未完~</p>"},{"title":"Hadoop与HDFS","date":"2020-11-02T15:33:40.000Z","_content":"\n> **组员：**<br/>2031570 谈瑞<br/>2031568 薛锦伟\n\n分布式计算期末项目简单记录，水一水~\n\n<!-- more -->\n\n## 一 系统架构\n\n### 1 Hadoop基本介绍\n\nHadoop是一个高可靠的(reliable)，规模可扩展的(scalable)，分布式(distributed computing)的开源软件框架。它使我们能用一种简单的编程模型来处理存储于集群上的大数据集。\n\nHadoop是Apache基金会的一个开源项目，是一个提供了分布式存储和分布式计算功能的基础架构平台。可以应用于企业中的数据存储，日志分析，商业智能，数据挖掘等。其为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop 还提供了分布式文件系统HDFS，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。\n\n由于Hadoop的架构与本次项目需求较吻合，因此我们直接使用Hadoop的HDFS和MapReduce框架来进行此次项目所需要的分布式系统的实现。\n\n### 2 集群架构图\n\n![image-20181228192856958](/images/image-20181228192856958-5996536.png)\n\n### 3 集群机器\n\n| 主机名  | 内存 |       IP        |       软件        |                           运行进程                           |\n| :-----: |  :-----: | :-------------: | :---------------: | :----------------------------------------------------------: |\n|  node0  |  512MB  | 192.168.137.200 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node1  |  512MB  | 192.168.137.201 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node2  |  512MB  | 192.168.137.202 |     ZooKeeper     |                        QuorumPeerMain                        |\n| master  |  2GB  | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 |  2GB  | 192.168.137.10  |    Hadoop,Hive    | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1  |  1GB  | 192.168.137.101 |      Hadoop       |               JournalNode,DataNode,NodeManager               |\n| slave2  |  1GB  | 192.168.137.102 |      Hadoop       |                     DataNode,NodeManager                     |\n| slave3  |  1GB  | 192.168.137.103 |      Hadoop       |                     DataNode,NodeManager                     |\n|  host   |  8GB  |  192.168.137.1  |    应用服务器     |                                                              |\n\n### 4 集群搭建\n\n#### 4.1 简介\n\n集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。\n\n#### 4.2 虚拟机创建\n\n此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。\n\n首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的`Host-Only`连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。\n\n在主机网络设置中共享网络：\n\n![image-20181228201105314](/images/image-20181228201105314-5999065.png)\n\n在VirtualBox中执行以下操作设置主机连接方式：\n\n![image-20181228200129326](/images/image-20181228200129326-5998489.png)\n\n在虚拟机终端执行以下操作：\n\n```sh\n# 修改虚拟机的IP、子网掩码\nvim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n# 修改为以下内容\nTYPE=Ethernet\nIPADDR=192.168.137.100\nNETMASK=255.255.255.0\n# 保存退出\n# 修改网关地址\nvim /etc/sysconfig/network\n# 修改为以下内容\nNETWORKING=yes\nGATEWAY=192.168.137.1\n# 保存退出\n# 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP\nhostnamectl set-hostname master\n# 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全\nsystemctl stop firewalld\nsystemctl disable firewalld\n# 重启网络服务\nsystemctl restart network\n# 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功\nping 192.168.137.1\n# 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105\nping 61.135.169.105\n# 修改hosts文件，添加局域网中其他主机的主机名与ip的映射\nvim /etc/hosts\n# 修改为以下内容\n192.168.137.100 master\n192.168.137.10 master1\n192.168.137.101 slave1\n192.168.137.102 slave2\n192.168.137.103 slave3\n192.168.137.200 node0\n192.168.137.201 node1\n192.168.137.202 node2\n0.0.0.0 localhost\n# 保存退出\n```\n\n至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：\n\n```sh\n# 首先添加Hadoop和Hive相关环境变量\nvim /etc/profile\n# 添加下列内容\nexport HADOOP_MAPRED_HOME=/usr/local/hadoop\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\nexport HIVE_HOME=/usr/local/hive\nexport PATH=$HIVE_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH\n# 保存退出，并使环境变量生效\nsource /etc/profile\n```\n\nHadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。\n\n#### 4.3 虚拟机复制\n\n上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。\n\n##### 4.3.1 网络配置\n\n对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：\n\n- 修改IP\n\n  ```sh\n  vim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的IP将`IPADDR`项修改为对应的IP\n\n- 修改主机名\n\n  ```sh\n  hostnamectl set-hostname XXX\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名\n\n- 重启网络服务\n\n  ```sh\n  systemctl restart network\n  ```\n  \n- ping各个节点测试是否成功\n\n  ```sh\n  ping master\n  ping master1\n  ping slave1\n  ping slave2\n  ping slave3\n  ping node0\n  ping node1\n  ping node2\n  ping 192.168.137.1\n  ping 61.135.169.105\n  ```\n\n##### 4.3.2 Hadoop配置\n\n1. 修改core-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/core-site.xml\n```\n\n- 作用：Hadoop集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n          <property>\n                  <name>fs.defaultFS</name>\n                  <value>hdfs://ns</value>\n          </property>\n          <property>\n                  <name>hadoop.tmp.dir</name>\n                  <value>/var/hadoop</value>\n          </property> \n          <property>\n                  <name>dfs.permissions.enabled</name>\n                  <value>true</value>\n          </property> \n          <!-- 指定zookeeper地址 -->\n          <property>\n                  <name>ha.zookeeper.quorum</name>\n                  <value>node0:2181,node1:2182,node2:2181</value>\n          </property>\n      \t<!-- 允许访问此hdfs的主机和群组，此处设置为任意 -->\n          <property>\n                  <name>hadoop.proxyuser.root.hosts</name>\n                  <value>*</value>\n          </property>\n          <property>\n                  <name>hadoop.proxyuser.root.groups</name>\n                  <value>*</value>\n          </property>\n  </configuration>\n  ```\n\n2. 修改hdfs-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n```\n\n-  作用：hdfs集群配置文件\n\n-  需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      \t<!-- 指定dfs文件存储位置 -->\n          <property>\n                  <name>dfs.data.dir</name>\n                  <value>/var/hadoop-data</value>\n          </property>\n      \t<!-- 指定文件备份份数 -->\n          <property>\n                  <name>dfs.replication</name>\n                  <value>2</value>\n          </property>\n      \t<!-- 指定机器运行情况检查时间间隔 -->\n          <property>\n                  <name>dfs.namenode.heartbead.recheck-interval</name>\n                  <value>3000000ms</value>\n          </property>\n          <!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 -->\n          <property>\n                  <name>dfs.nameservices</name>\n                  <value>ns</value>\n          </property>\n          <!-- NS下面的NameNode -->\n          <property>\n                  <name>dfs.ha.namenodes.ns</name>\n                  <value>nn1,nn2</value>\n          </property>\n          <!-- nn1的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn1</name>\n                  <value>master:9000</value>\n          </property>\n          <!-- nn1的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn1</name>\n                  <value>master:50070</value>\n          </property>\n          <!-- nn2的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn2</name>\n                  <value>master1:9000</value>\n          </property>\n          <!-- nn2的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn2</name>\n                  <value>master1:50070</value>\n          </property>\n          <!-- 指定NameNode的元数据在JournalNode上的存放位置 -->\n          <property>\n                  <name>dfs.namenode.shared.edits.dir</name>\n                  <value>qjournal://master:8485;master1:8485;slave1:8485/ns</value>\n          </property>\n          <!-- 指定JournalNode在本地磁盘存放数据的位置 -->\n          <property>\n                  <name>dfs.journalnode.edits.dir</name>\n                  <value>/usr/local/hadoop/journaldata</value>\n          </property>\n      \t<!-- 开启机器故障自动切换主从机器 -->\n          <property>\n                  <name>dfs.ha.automatic-failover.enabled</name>\n                  <value>true</value>\n          </property>\n      \t<!-- 指定failover切换的方法(java类的名称) -->\n          <property>\n                  <name>dfs.client.failover.proxy.provider.ns</name>\n              <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n          </property>\n      \t<!-- 指定failover切换的方法，这里使用ssh通信方式交换 -->\n          <property>\n                  <name>dfs.ha.fencing.methods</name>\n                  <value>\n                  sshfence\n                  shell(/bin/true)\n                  </value>\n          </property>\n      \t<!-- ssh切换方法需要指定私钥文件位置 -->\n          <property>\n                  <name>dfs.ha.fencing.ssh.private-key-files</name>\n                  <value>/root/.ssh/id_rsa</value>\n          </property>\n  </configuration>\n  ```\n\n-  注意\n\n   -  假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   -  当使用jdbc访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n3. 修改slaves文件\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/slaves\n```\n\n- 作用：为各个master指定为其工作的slave\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```txt\n  slave1\n  slave2\n  slave3\n  ```\n\n4. 修改yarn-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/yarn-site.xml\n```\n\n- 作用：yarn集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      <!-- 启用yarn集群的高可用机制 -->\n      <property>\n          <name>yarn.resourcemanager.ha.enabled</name>\n          <value>true</value>\n      </property>\n      <!-- 指定ResourceManager集群id，可为任意字串 -->\n      <property>\n          <name>yarn.resourcemanager.cluster-id</name>\n          <value>yrc</value>\n      </property>\n      <!-- 指定两台ResourceManager的名称 -->\n      <property>\n          <name>yarn.resourcemanager.ha.rm-ids</name>\n          <value>rm1,rm2</value>\n      </property>\n      <!-- 指定两台ResourceManager的主机名 -->\n      <property>\n          <name>yarn.resourcemanager.hostname.rm1</name>\n          <value>master</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.hostname.rm2</name>\n          <value>master1</value>\n      </property>\n      <!-- 指定两台ResourceManager的web端口，正常情况为8088 -->\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm1</name>\n          <value>master:8088</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm2</name>\n          <value>master1:8088</value>\n      </property>\n      <!-- 指定管理集群的Zookeeper集群的地址及对应端口 -->\n      <property>\n          <name>yarn.resourcemanager.zk-address</name>\n          <value>node0:2181,node1:2181,node2:2181</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.aux-services</name>\n          <value>mapreduce_shuffle</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.auxservices.mapreduce.shuffle.class</name>\n          <value>org.apache.hadoop.mapred.ShuffleHandler</value>\n      </property>\n      <!-- 指定jar包路径 -->\n      <property>\n          <name>yarn.application.classpath</name>\n          <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n      </property>\n  </configuration>\n  ```\n\n5. 修改mapred-site.xml\n\n- 作用：指定MapReduce操作的基本属性\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```xml\n  <configuration>\n  <property>\n      <name>mapreduce.framework.name</name>\n      <value>yarn</value>\n  </property>\n  <property>\n      <name>mapreduce.application.classpath</name>\n      <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n  </property>\n  </configuration>\n  ```\n\n- 注意：\n\n  - MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce\n  - 此项若是不配，一些job只会在本机跑，而不会分发给其他机器\n\n6. 修改hive-site.xml\n\n```sh\nvim $HIVE_HOME/conf/hive-site.xml\n```\n\n- 作用：hive的基本配置\n\n- 需要修改的机器：master、master1\n\n- 内容：\n\n  - 修改`hive.server2.webui.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.webui.host</name>\n          <value>${hostname}</value>\n          <description>The host address the HiveServer2 WebUI will listen on</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.bind.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.thrift.bind.host</name>\n          <value>${hostname}</value>\n          <description>Bind host on which to run the HiveServer2 Thrift service.</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.zookeeper.namespace`\n\n      ```xml\n      <property>\n          <name>hive.server2.zookeeper.namespace</name>\n          <value>hiveserver2</value>\n          <description>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.</description>\n      </property>\n      ```\n\n      注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。\n\n  - 修改`javax.jdo.option.ConnectionURL`、`javax.jdo.option.ConnectionPassword`和`javax.jdo.option.ConnectionDriverName`\n\n      ```xml\n      <property>\n          <name>javax.jdo.option.ConnectionURL</name>\n              <value>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</value>\n          <description>\n            JDBC connect string for a JDBC metastore.\n            To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.\n            For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.\n          </description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionPassword</name>\n              <value>root</value>\n          <description>password to use against metastore database</description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionDriverName</name>\n              <value>com.mysql.jdbc.Driver</value>\n          <description>Driver class name for a JDBC metastore</description>\n      </property>\n      ```\n\n      这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(~~此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据~~)。\n\n      另外，mysql的连接jar包需要下载并复制到hive的lib目录下。\n\n至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。\n\n##### 4.3.3 Zookeeper配置\n\n对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：\n\n```sh\nvim /usr/local/zookeeper/conf/zoo.cfg\n# 添加一下内容\nserver.1=192.168.137.200:2888:3888\nserver.2=192.168.137.201:2888:3888\nserver.3=192.168.137.202:2888:3888\n# 保存并关闭\n```\n\n##### 4.3.4 ssh免密登录配置\n\n- 作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的\n\n- 需要修改的机器：所有机器\n\n- 内容：\n\n  ```sh\n  # 进入用户目录下的`.ssh`目录\n  cd\n  cd .ssh/\n  # 创建公钥私钥对\n  ssh-keygen -t rsa\n  # 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍\n  ssh-copy-id ${hostname}\n  ```\n\n至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。\n\n#### 4.4 集群启动\n\n##### 4.4.1 初始化数据库\n\n在master机器上执行以下操作以初始化数据库：\n\n```sh\ncd $HIVE_HOME\nschematool -initSchema -dbType mysql\n```\n\n此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。\n\n##### 4.4.2 启动集群\n\n在master机器上执行以下操作以启动集群：\n\n```sh\nstart-all.sh\n```\n\n## 二 HDFS文件系统\n\n### 1 简介\n\n#### 1.1 HDFS简介\n\nHDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。\n\n#### 1.2 NameNode与DataNode\n\nHDFS由四部分组成，HDFS Client、NameNode、DataNode和Secondary NameNode。整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。\n\n![image-20210105151742421](/images/image-20210105151742421.png)\n\nNamenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：Namespcae image和Edit log。但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。NameNode 的文件结构包含 edits、fsimage、seen_txid、VERSION 以及 in_use.lock。其中， edits 为编辑日志（edit log）， 当客户端执行写操作时， NameNode 会先在编辑日志中写入记录，并在内存中保存一个文件系统的元数据。这一描述 符会在编辑日志改动后更新。fsimage 为文件系统镜像，是文件系统元数据的持久检查点，包含以序列化 格式存储的文件系统目录和文件 inodes，每个 inodes 表征一个文件或目录的元数 据信息以及文件的副本数、修改和访问时间等信息。seen_txid 文件代表的是 NameNode 中 edits_*文件的尾数，当 NameNode 重 启后，会按照 seen_txid 所定义的数字，循序从头运行 edits_0000001~至 seen_txid。VERSION 文件是 java 的属性文件，保存了 HDFS 的版本号。in_use.lock 的作用是防止一台机器同时启动多个 NameNode 进程，导致目录 数据不一致。\n\n在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： <br/>1）备份持久化元数据 \n将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。<br/>2）Secondary Namenode \nSecondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。SecondaryNameNode 的文件结构主要包括 edits、fsimage、VERSION 以及 in_use.lock。其中edits、fsimage、VERSION的内容均与NameNode相同，in_use.lock 的作用是防止一台机器同时启动多个 SecondaryNameNode 进程导致目录数据不 一致。\n\n而DataNode则会负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。DataNode 的文件结构主要包含 BP-前缀文件、blk前缀文件、VERSION 和 in_use.lock。 其中 BP-random integer-NameNode IP address-creation time 的 BP 代表 BlockPool，即 NameNode 的 VERSION 集群中唯一的 blockpoolID；finalized/rbw 目录用于存储 HDFS BLOCK 的数据， blk_前缀文件是 HDFS 中的文件块本身， 存储的是原始文件内容；VERSION 及 in_use.lock 的含义与上述类似。\n\n我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。\n\n### 2 分块机制\n\n#### 2.1 分块机制简介\n\n物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。\n\n#### 2.2 块分配流程\n\n通常当一个客户端`a`机器发起请求分配块请求，NN接收到请求后，执行如下块分配流程：<br/>1）  如果a不是一个DataNode，则在集群范围内随机选择一个节点作为目标节点，否则执行下面的2,3步骤；<br/>2） 判断a机器是否符合存储数据块的目标节点，如果符合，第一个块副本分配完毕；<br/>3）如果a机器不符合作为目标节点，则在于与a机器同机架范围内寻找，如果找到目标节点，第一个块副本分配完毕；<br/>4）如果在同一个机架内未找到符合要求的目标节点，则在集群内随机查找，找到则第一个块副本分配完毕，否则未找到符合条件的块，块分配失败；<br/>5）如果已经成功分配第一个块副本，则与a不同机架的远程机架内寻找目标节点，如果符合，第二个块副本分配完毕；<br/>6）如果在远程机架内未找到符合要求的目标节点，在与a相同的本机架寻找，如果找到则第二个块副本分配完毕；否则未找到符合条件的块，第二份块分配失败；<br/>7）如果前2个块副本分配成功，则准备分配第三个副本的目标节点，首先会判断前两份是否在同一个机架，如果是，则在远程机架寻找目标节点，找到则第三份副本分配完毕；如果前两份在不同机架，则在与a相同机架内寻找，如果找到则第三份副本分配完毕，否则在集群范围寻找，找到则第三份分配完毕，否则第三份分配失败<br/>8）如果块副本大于三分，则在集群范围内随机寻找节点\n\n当在一个范围内找到一个节点后，还需要经过如上的条件判断，才能确定一个DataNode进程是否可以作为目标节点：<br/>1） 如果没有节点机器被选择，则该节点可以作为备选节点，否则需要判断下一个DataNode是否符合要求；（这样就防止同一个块副本存储到同一台机器）<br/>2） 然后判断节点是否退役，存储空间是否足够，负载是否大于2倍平均负载，本机架选择的节点是否超过限制，如果均满足，则该datanode符合要求，否则需要判断下一个DataNode是否符合要求\n\n### 3 备份策略\n\n#### 3.1 备份策略简介\n\n对于HDFS而言，由Namenode负责这个集群的数据备份和分配，在分配过程中，主要考虑下面两个因素：\n\n- 数据安全：在某个节点发生故障时，不会丢失数据备份；\n- 网络传输开销：在备份数据同步过程中，尽量减少网络传输中的带宽开销；\n\n这两个因素看起来是有些相互矛盾的：想要保证数据安全，那么就尽量把数据备份到多台节点上，但是就需要向多个节点传输数据；想要减少网络传输开销，那么就尽可能把数据备份到一个节点内部或者一个机架内部，因为系统内部的数据传输速度会远大于网络传输的速度。\n\n#### 3.2 数据块部署\n\n对于巨大的集群来说，把所有的节点都部署在一个平行的拓扑结构里是不太现实的。比较实际且通用的做法是，把所有的节点分布到多个Rack(服务器机架)上。每个Rack上的节点共享一个交换机，Rack之间可以使用一个或者多个核心交换机进行互联。在大多数情况下，同一Rack中的节点间通信的带宽肯定会高于不同Rack间节点的通信带宽。HDFS默认两个节点之间的网络带宽与他们的物理距离成正比。从一个节点到其父节点的距离被认为是常数1。这样，两个节点之间的距离可以通过将其到各级祖先节点的距离相加计算出来。两个节点之间的距离越短，就意味着他们之间传输数据的带宽越大。\nHDFS允许管理员通过配置脚本，返回一个节点的rack标识符，作为节点地址。NameNode位于整个结构的最中央，负责解析每一个DataNode的rack位置。当DataNode注册到NameNode时，NameNode会运行这些配置脚本，确定节点属于哪个rack。如果没有进行脚本配置，NameNode则会认为所有的节点都属于一个默认的Rack。\n\n数据块备份的部署对于HDFS数据的可靠性和读写性能都有至关重要的影响。良好的数据块部署策略能够有效地改进数据的可靠性，可用性，甚至提高网络带宽的利用率。目前的HDFS系统提供了可配置的数据块部署策略接口，以此来让用户和研究人员能够对不同的部署策略进行测验，从而达到对系统应用进行优化的目的。\n\n缺省的HDFS数据块部署策略企图在降低数据写入代价，最大化数据可靠性，可用性，以及整合读数据带宽等几个方面做出权衡。当一个新的数据块被创建，HDFS会把第一个数据开备份放到写入程序所在的位置。第二个和第三个数据块备份会被部署到不同rack的其他两个不同的节点。剩余的数据块备份则被放到随机的节点上，但是限制每个节点不会部署多于一个相同的数据块，每个rack不会部署都与两个相同的数据块（如果条件满足的话）。之所以要把第二个和第三个数据块备份放到不同的rack上，是为了考虑到一个集群上的文件所应当具有的分布性。如果头两个数据块备份放到相同的rack上，那么对于任何文件来说，其2/3的文件块会被存放在同一rack上。\n\n在所有目标节点都被选择后，这些节点会被有组织地按照其亲近程度，以流水线的方式被传输到第一个备份上。数据会被以这个顺序推送到节点。在读取的时候，NameNode首先会检查客户端所对应的主机是否位于集群当中。如果是，那么数据块的位置会被返回到客户端，并以按照距离远近排序。然后数据块就会按照顺序从DataNode中进行读取。\n这一策略会降低rack之间以及节点之间的写入时间，普遍提高写入效率。因为rack故障的几率远低于节点故障的几率，所以该策略不会影响到数据的有效性和可用性。在大多数使用3数据块备份的情况下，该策略能够降低网络带宽的消耗，因为一个数据块只需要部署到两个不同的rack上，而不是3个。\n\n#### 3.3 备份策略\n\nNameNode会尽力保证们每个数据块都有所需的备份数量。当Block Report从DataNode提交上来的时候，NameNode会侦测到数据块的备份数量是少于所需还是超过所需。当超过时，NameNode会选择删除一个数据备份。NameNode倾向于不减少rack的数量，并在DataNode中选择一个剩余磁盘空间最小的节点进行备份移除。这样做的主要目的是平衡利用DataNode的存储空间，并其不降低到数据块的可用性。\n\n当一个数据块处于低于其备份需求数的状态时，该数据块就会被放入到备份优先队列中。仅拥有一个数据备份的数据块处于最高优先级，其数据备份数高于其备份因子2/3的数据块则处于最低优先级。有一个后台进程专门负责定期对备份优先队列进行扫面，以确定将备份部署到何处。数据块备份遵循与数据块部署相似的策略。如果数据块当前只有一个备份，那么HDFS会把一个新的备份放到不同rack上。如果数据块当前有两个备份，并且连个备份都存在与相同的rack上，第三个备份就会被放到不同的rack上。否则，第三个备份就被放到同一rack的不同节点上。这么做的目的也是为了降低创建备份的代价。\n\nNameNode也会确保不把所有的数据块备份都部署到同一个rack上。如果NameNode侦测到某数据块的所有备份都在一个rack上，那么它就会把这个数据块当做是mis-replicated(误备份),然后它就会用上面所提到的策略，在其他的rack上把这个数据块再备份一次。在NameNode收到异地rack备份成功后，该数据块就成为了“备份数量高于所需备份数”状态。此时NameNode会根据策略把本地的一个备份删除，因为策略规定不能减少rack的数量。\n\n### 4 文件一致性\n\n#### 4.1 一致性简介\n\n从**客户端**来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。\n\n从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是**强一致性**。如果能容忍后续的部分或者全部访问不到，则是**弱一致性**。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性\n\n从**服务端**角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：\n\n- N — 数据复制的份数 \n- W — 更新数据时需要保证写完成的节点数 \n- R — 读取数据的时候需要读取的节点数 \n\n如果W+R>N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。\n\n如果W+R<=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。\n\n对于分布式系统，为了保证高可用性，一般设置N>=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。\n\n- 如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。 \n- 如果N=R,W=1，只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。这种情况下，如果W<(N+1)/2，并且写入的节点不重叠的话，则会存在写冲突  \n\n#### 4.2 一致性模型\n\nHDFS牺牲了一些POSIX的需求来补偿性能，所以有些操作可能会和传统的文件系统不同。当创建一个文件时，它在文件系统的命名空间中是可见的，代码如下:\n\n```java\nPath p = new Path(\"p\");\nfs.create(p);\nassertThat(fs.exists(p),is(true));\n```\n\n但是对这个文件的任何写操作不保证是可见的，即使在数据流已经刷新的情况下，文件的长度很长时间也会显示为0 ：\n\n```java\nPath p = new Path(\"p\");\nOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();\nassertThat(fs.getFileStatus(p),getLen(),is(0L));\n```\n\n一旦一个数据块写人成功，那么大家提出的新请求就可以看到这个块，而对当前写入的块，大家是看不见的。HDFS提供了使所有缓存和DataNode之间的数据强制同步的方法，这个方法是FSDataOutputStream中的sync()函数。当sync()函数返回成功时，HDFS就可以保证此时写入的文件数据是一致的并且对于所有新的用户都是可见的。即使HDFS客户端之间发生冲突，也会导致数据丢失，代码如下:\n\n```java\nPath p = new Path(\"p\");\nFSDataOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();\nout.sync();\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n这个操作类似于UNIX系统中的fsync系统调用，为一个文件描述符提交缓存数据，利用Java API写入本地数据，这样就可以保证看到刷新流并且同步之后的数据，代码如下:\n\n```java\nFileOutputStream out = new FileOutStream(localFile);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();       //  flush to operatig system\nout.getFD().sync();    //  sync to disk\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n在HDFS中关闭一个文件也隐式地执行了sync()函数，代码如下:\n\n```java\nPath p = new Path(\"p\");\nOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.close();\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n文件系统的一致性与设计应用程序的方法有关。如果不调用sync()，那么需要做好因客户端或者系统发生故障而丢失部分数据做好准备。对大多数应用程序来说，这是不可接受的，所以需要在合适的地方调用sync()，比如在写入一定量的数据之后。尽管sync()被设计用来最大限度地减少HDFS的负担，但是它仍然有不可忽视的开销，所以需要在数据健壮性和吞吐最之间做好权衡，其中一个较好的参考平衡点就是:通过测试应用程序来选择不同sync()频率间的最佳平衡点。\n\n### 5 文件读写\n\n#### 5.1 写策略\n\n应用程序通过创建新文件以及向新文件写数据的方式，给HDFS系统添加数据。文件关闭以后，被写入的数据就无法再修改或者删除，只有以“追加”方式重新打开文件后，才能再次为文件添加数据。HDFS采用单线程写，多线程读的模式。\n\nHDFS客户端需要首先获得对文件操作的授权，然后才能对文件进行写操作。在此期间，其他的客户端都不能对该文件进行写操作。被授权的客户端通过向NameNode发送心跳信号来定期更新授权的状态。当文件关闭时，授权会被回收。文件授权期限分为软限制期和硬限制期两个等级。当处于软限制期内时，写文件的客户端独占对文件的访问权。当软限制过期后，如果客户端无法关闭文件，或没有释放对文件的授权，其他客户端即可以预定获取授权。当硬限制期过期后（一小时左右），如果此时客户端还没有更新（释放）授权，HDFS会认为原客户端已经退出，并自动终止文件的写行为，收回文件控制授权。文件的写控制授权并不会阻止其他客户端对文件进行读操作。因此一个文件可以有多个并行的客户端对其进行读取。\n\nHDFS文件由多个文件块组成。当需要创建一个新文件块时，NameNode会生成唯一的块ID，分配块空间，以及决定将块和块的备份副本存储到哪些DataNode节点上。DataNode节点会形成一个管道，管道中DataNode节点的顺序能够确保从客户端到上一DataNode节点的总体网络距离最小。文件的则以有序包（sequence of packets）的形式被推送到管道。应用程序客户端创建第一个缓冲区，并向其中写入字节。第一个缓冲区被填满后（一般是64 KB大小），数据会被推送到管道。后续的包随时可以推送，并不需要等前一个包发送成功并发回通知（这被称为“未答复发送”——译者注）。不过，这种未答复发送包的数目会根据客户端所限定的“未答复包窗口”(outstanding packets windows)的大小进行限制。\n\n在数据写入HDFS文件后，只要文件写操作没有关闭，HDFS就不保证数据在此期间对新增的客户端读操作可见。如果客户端用户程序需要确保对写入数据的可见性，可以显示地执行hflush操作。这样，当前的包就会被立即推送到管道，并且hflush操作会一直等到所有管道中的DataNode返回成功接收到数据的通知后才会停止。如此就可以保证所有在执行hflush之前所写入的数据对试图读取的客户端用户均可见。\n\n在一个集群的数千个节点里，节点失效（往往是因为存储故障造成的）每天都有可能发生。DataNode中所包含的文件块备份可能会因为内存、磁盘或者网络的错误而造成损坏。为了避免这种错误的形成，HDFS会为其文件的每个数据块生成并存储一份Checksum（总和检查）。Checksum主要供HDFS客户端在读取文件时检查客户端，DataNode以及网络等几个方面可能造成的数据块损坏。当客户端开始建立HDFS文件时，会检查文件的每个数据块的checksum序列，并将其与数据一起发送给DataNode。 DataNode则将checksum存放在文件的元数据文件里，与数据块的具体数据分开存放。当HDFS读取文件时，文件的每个块数据和checksum均被发送到客户端。客户端会即时计算出接受的块数据的checksum, 并将其与接受到的checksum进行匹配。如果不匹配，客户端会通知NameNode，表明接受到的数据块已经损坏，并尝试从其他的DataNode节点获取所需的数据块。\n\n当客户端打开一个文件进行读取时，会从NameNode中获得一个文件数据块列表，列表中包含了每一个所需的数据块的具体位置。这些位置会按照与客户端的距离进行排序。当具体进行数据块读取时，客户端总是尝试首先从最近的位置获取数据。如果尝试失败，客户端会根据排序的顺寻，从下一个位置获取数据。下列情况可能会造成数据读取失败：DataNode不可用，节点不再包含所需数据块，或者数据块备份损坏，以及checksum验证失败。\nHDFS允许客户端从正在进行写操作的文件中读取数据。当进行这样的操作时，目前正在被写入的数据块对于NameNode来说是未知的。在这样的情况下，客户端会从所有数据块备份中挑选一个数据块，以这个数据块的最后长度作为开始读取数据之前的数据长度。HDFS I/O的设计是专门针对批处理系统进行优化的，比如MapReduce系统，这类系统对顺序读写的吞吐量都有很高的要求。针对于那些需要实时数据流以及随机读写级别的应用来说，系统的读/写响应时间还有待于优化，目前正在做这方面的努力。\n\n#### 5.2 读策略\n\n读相对于写，简单一些，详细步骤如下：\n\n1. client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。\n2. 就近挑选一台datanode服务器，请求建立输入流 。\n3. DataNode向输入流中中写数据，以packet为单位来校验。\n4. 关闭输入流\n\n## 三 MapReduce计算\n\n### 1 简介\n\nMapReduce是Google提出的一个软件架构，也是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念\"Map（映射）\"和\"Reduce（归约）\"，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。\n\n### 2 工作原理\n\n#### 2.1 Map\n\n程序根据输入格式将输入文件划分为多个部分，每个部分均用作映射。任务输入，每个map任务都有一个内存缓冲区，输入数据在映射阶段进行处理，中间结果被写入存储缓冲区，并由写入数据的一方确定。当数据达到内存缓冲区阈值（默认值为0.8）时，会启动线程将内存中溢出的数据写入磁盘，并继续缓冲而不影响映射的中间结果。在溢出写入过程中，MapReduce框架对键进行排序。如果中间结果相对较大，则会形成多个溢出文件。最后缓冲区中的数据也被写入磁盘，从而形成一个溢出文件（至少一个溢出文件）。如果有多个溢出文件，则所有文件最后都会合并为一个文件。\n\n#### 2.2 Reduce\n\n当所有的映射任务完成后，每个映射任务会形成一个最终文件，并且该文件按区划分。reduce 任务启动之前，一个映射任务完成后，就会启动线程来拉取映射结果数据到相应的规约任务，不断地合并数据，为规约的数据输入做准备，当所有的射任务完成完成后，数据也拉取合并完毕后，规约任务启动，最终将输出结果存入HDFS 上。\n\n### 3 MapReduce运行流程\n\n#### 3.1 分析 MapReduce 执行过程\n\nMapReduce运行的时候，输入输出都是HDFS中的文件，首先，Mapper中运行的任务会去读取HDFS中的数据文件，通过调用map中的方法来处理数据，然后将处理结果输出给Reducer任务，Reducer将接收到的结果作为自己的输入数据，并且也调用自己的方法，将最后的结果输出到HDFS中。过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/ZyxlBMGXXPu08Qws.png!original)\n\n#### 3.2 Mapper 任务执行过程详解\n\n每个Mapper 任务是一个java 进程，它会读取HDFS 中的文件，解析成很多的键值对，经过我们覆盖的map 方法处理后，转换为很多的键值对再输出。整个Mapper 任务的处理过程又可以分为以下几个阶段：\n\n1. 第一阶段是把输入文件按照一定的标准分片(InputSplit)，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的。如果数据块(Block)的大小是默认值64MB，输入文件有两个，一个是32MB，一个是72MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由一个Mapper 进程处理。这里的三个输入片，会有三个Mapper 进程处理。\n2. 第二阶段是对输入片中的记录按照一定的规则解析成键值对。有个默认规则是把每一行文本内容解析成键值对。“键”是每一行的起始位置(单位是字节)，“值” 是本行的文本内容。\n3. 第三阶段是调用Mapper 类中的map 方法。第二阶段中解析出来的每一个键值对，调用一次map 方法。如果有1000 个键值对，就会调用1000 次map方法。每一次调用map 方法会输出零个或者多个键值对。\n4. 第四阶段是按照一定的规则对第三阶段输出的键值对进行分区。比较是基于键进行的。比如我们的键表示省份(如北京、上海、山东等)，那么就可以按照不同省份进行分区，同一个省份的键值对划分到一个区中。默认是只有一个区。分区的数量就是Reducer 任务运行的数量。默认只有一个Reducer 任务。\n5. 第五阶段是对每个分区中的键值对进行排序。首先，按照键进行排序，对于键相同的键值对，按照值进行排序。比如三个键值对<2,2>、<1,3>、<2,1>，键和值分别是整数。那么排序后的结果是<1,3>、<2,1>、<2,2>。如果有\n6. 第六阶段，那么进入第六阶段；如果没有，直接输出到本地的linux 文件中。第六阶段是对数据进行归约处理，也就是reduce 处理。键相等的键值对会调用一次reduce 方法。经过这一阶段，数据量会减少。归约后的数据输出到本地的linux文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。\n\n上述过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2kbg02YRqSS3ZofE.png!original)\n\n#### 3.3 Reduce任务执行过程详解\n\n每个Reducer 任务是一个java 进程。Reducer 任务接收Mapper 任务的输出，归约处理后写入到HDFS 中，可以分为如下几个阶段。\n\n1. 第一阶段是Reducer 任务会主动从Mapper 任务复制其输出的键值对。Mapper 任务可能会有很多，因此Reducer 会复制多个Mapper 的输出。\n2. 第二阶段是把复制到Reducer 本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。\n3. 第三阶段是对排序后的键值对调用reduce 方法。键相等的键值对调用一次reduce 方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS 文件中。\n\n在整个MapReduce 程序的开发过程中，我们最大的工作量是覆盖map 函数和覆盖reduce 函数。上述过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2YC2iJF2OJvYbs1R.png!original)\n\n#### 3.4 键值对的编号\n\n在对Mapper 任务、Reducer 任务的分析过程中，会看到很多阶段都出现了键值对，这里对键值对进行编号，方便理解键值对的变化情况，对于Mapper 任务输入的键值对，定义为key1 和value1。在map 方法中处理后，输出的键值对，定义为key2 和value2。reduce 方法接收key2 和value2，处理后，输出key3 和value3。具体如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dXULEPSCEIT3QZW0.png!original)\n\n### 4 MapReduce实现\n\nMapReduce 在执行的时候，先执行Map 函数，再执行Reduce 函数，达到分布式并行运算效果。其中Map 函数与Reduce 函数需要用户自行设计，而这两个任务也定义了任务本身。\n\n#### 4.1 统计平均通话次数\n\n需要用到的数据为：主叫号码。仅需统计每个主叫号码在数据文件中出现的次数，用该数除以天数，即可得到平均值。与WordCount 类似，提取出第二列数据即可进行。具体代码如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/f7g9O8xBBwHpkdZB.png!original)\n\n结果如下图所示，其中每一行有两个数据，第一列为主叫号码，第二列为平均每日通话次数：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/NM80fSViYPVEfD3Q.png!original)\n\n#### 4.2 统计不同通话类型下各运营商占比\n\n需要用到的数据为：通话类型，主叫号码运营商，被叫号码运营商。与第一个需求不同，本需求的key 值由两个数共同组成，需要定义一个新的类用来包含通话类型和运行商。定义如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/aCFEDYqbUtuMMWFm.png!original)\n\n其中需要注意，由于key 中数据的个数不唯一，需要对内部的数据优先级进行规定，所以要重写compareTo 函数，对key 进行排序。主函数中需要注意Map 阶段的输出类型和Reduce 阶段的输入输出类型，代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/khmfgplaXcfeVygE.png!original)\n\n结果如下图，其中1代表电信，2 代表移动，3 代表联通：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dw7Q7n01PquYb8xX.png!original)\n\n![img](https://uploader.shimo.im/f/pTZXRD60QSU3j9Un.png!original)\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/3rK4jBFXZs3Ig47t.png!original)\n\n#### 4.3 统计用户在各个时间段通话时长所占比例\n\n所需用到的数据有：主叫电话号码，通话开始时间，通话结束时间。最后输出的形式是一长串的数组，因此同样需要设计一个新的类用于封装。与上一需求不同的是，该类用于value 的输入和输出。代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/rlXjbmDdWKPLQS5R.png!original)\n\n为了完成统计任务，还需要自己求出每个时间段的时间，才能统计占比。这需要设计统计时间段内持续时间的算法，代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/iwXvfrzHPmTxAVJ9.png!original)\n\n主函数与上一需求类似，区别在于Reduce 阶段的结果输出为浮点型数据，需要再同最开始一样重新定义一个浮点结果类，才能输出。\n\n结果如下图所示，每一行有9 个数据，第一列为主叫号码，第二到第八列为对应时间段中通话时长占一天的比例：\n\n![img](https://uploader.shimo.im/f/tSgwVy0seIoRbjlJ.png!original)","source":"_posts/分布式计算期末项目文档.md","raw":"---\ntitle: Hadoop与HDFS\ndate: 2020-11-02 23:33:40\ntags:\n    - Hadoop\n    - HDFS\ncategories:\n    - 分布式与云计算\n---\n\n> **组员：**<br/>2031570 谈瑞<br/>2031568 薛锦伟\n\n分布式计算期末项目简单记录，水一水~\n\n<!-- more -->\n\n## 一 系统架构\n\n### 1 Hadoop基本介绍\n\nHadoop是一个高可靠的(reliable)，规模可扩展的(scalable)，分布式(distributed computing)的开源软件框架。它使我们能用一种简单的编程模型来处理存储于集群上的大数据集。\n\nHadoop是Apache基金会的一个开源项目，是一个提供了分布式存储和分布式计算功能的基础架构平台。可以应用于企业中的数据存储，日志分析，商业智能，数据挖掘等。其为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop 还提供了分布式文件系统HDFS，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。\n\n由于Hadoop的架构与本次项目需求较吻合，因此我们直接使用Hadoop的HDFS和MapReduce框架来进行此次项目所需要的分布式系统的实现。\n\n### 2 集群架构图\n\n![image-20181228192856958](/images/image-20181228192856958-5996536.png)\n\n### 3 集群机器\n\n| 主机名  | 内存 |       IP        |       软件        |                           运行进程                           |\n| :-----: |  :-----: | :-------------: | :---------------: | :----------------------------------------------------------: |\n|  node0  |  512MB  | 192.168.137.200 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node1  |  512MB  | 192.168.137.201 |     ZooKeeper     |                        QuorumPeerMain                        |\n|  node2  |  512MB  | 192.168.137.202 |     ZooKeeper     |                        QuorumPeerMain                        |\n| master  |  2GB  | 192.168.137.100 | Hadoop,Hive,MySql | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2,MySql |\n| master1 |  2GB  | 192.168.137.10  |    Hadoop,Hive    | JournalNode,NameNode,ResourceManager,<br/>DFSZKFailoverController,HiveServer2 |\n| slave1  |  1GB  | 192.168.137.101 |      Hadoop       |               JournalNode,DataNode,NodeManager               |\n| slave2  |  1GB  | 192.168.137.102 |      Hadoop       |                     DataNode,NodeManager                     |\n| slave3  |  1GB  | 192.168.137.103 |      Hadoop       |                     DataNode,NodeManager                     |\n|  host   |  8GB  |  192.168.137.1  |    应用服务器     |                                                              |\n\n### 4 集群搭建\n\n#### 4.1 简介\n\n集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。\n\n#### 4.2 虚拟机创建\n\n此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。\n\n首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的`Host-Only`连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。\n\n在主机网络设置中共享网络：\n\n![image-20181228201105314](/images/image-20181228201105314-5999065.png)\n\n在VirtualBox中执行以下操作设置主机连接方式：\n\n![image-20181228200129326](/images/image-20181228200129326-5998489.png)\n\n在虚拟机终端执行以下操作：\n\n```sh\n# 修改虚拟机的IP、子网掩码\nvim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n# 修改为以下内容\nTYPE=Ethernet\nIPADDR=192.168.137.100\nNETMASK=255.255.255.0\n# 保存退出\n# 修改网关地址\nvim /etc/sysconfig/network\n# 修改为以下内容\nNETWORKING=yes\nGATEWAY=192.168.137.1\n# 保存退出\n# 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP\nhostnamectl set-hostname master\n# 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全\nsystemctl stop firewalld\nsystemctl disable firewalld\n# 重启网络服务\nsystemctl restart network\n# 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功\nping 192.168.137.1\n# 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105\nping 61.135.169.105\n# 修改hosts文件，添加局域网中其他主机的主机名与ip的映射\nvim /etc/hosts\n# 修改为以下内容\n192.168.137.100 master\n192.168.137.10 master1\n192.168.137.101 slave1\n192.168.137.102 slave2\n192.168.137.103 slave3\n192.168.137.200 node0\n192.168.137.201 node1\n192.168.137.202 node2\n0.0.0.0 localhost\n# 保存退出\n```\n\n至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：\n\n```sh\n# 首先添加Hadoop和Hive相关环境变量\nvim /etc/profile\n# 添加下列内容\nexport HADOOP_MAPRED_HOME=/usr/local/hadoop\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\nexport HIVE_HOME=/usr/local/hive\nexport PATH=$HIVE_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH\n# 保存退出，并使环境变量生效\nsource /etc/profile\n```\n\nHadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。\n\n#### 4.3 虚拟机复制\n\n上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。\n\n##### 4.3.1 网络配置\n\n对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：\n\n- 修改IP\n\n  ```sh\n  vim /etc/sysconfig/network-scripts/ifcfg-enp0s3\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的IP将`IPADDR`项修改为对应的IP\n\n- 修改主机名\n\n  ```sh\n  hostnamectl set-hostname XXX\n  ```\n\n  针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名\n\n- 重启网络服务\n\n  ```sh\n  systemctl restart network\n  ```\n  \n- ping各个节点测试是否成功\n\n  ```sh\n  ping master\n  ping master1\n  ping slave1\n  ping slave2\n  ping slave3\n  ping node0\n  ping node1\n  ping node2\n  ping 192.168.137.1\n  ping 61.135.169.105\n  ```\n\n##### 4.3.2 Hadoop配置\n\n1. 修改core-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/core-site.xml\n```\n\n- 作用：Hadoop集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n          <property>\n                  <name>fs.defaultFS</name>\n                  <value>hdfs://ns</value>\n          </property>\n          <property>\n                  <name>hadoop.tmp.dir</name>\n                  <value>/var/hadoop</value>\n          </property> \n          <property>\n                  <name>dfs.permissions.enabled</name>\n                  <value>true</value>\n          </property> \n          <!-- 指定zookeeper地址 -->\n          <property>\n                  <name>ha.zookeeper.quorum</name>\n                  <value>node0:2181,node1:2182,node2:2181</value>\n          </property>\n      \t<!-- 允许访问此hdfs的主机和群组，此处设置为任意 -->\n          <property>\n                  <name>hadoop.proxyuser.root.hosts</name>\n                  <value>*</value>\n          </property>\n          <property>\n                  <name>hadoop.proxyuser.root.groups</name>\n                  <value>*</value>\n          </property>\n  </configuration>\n  ```\n\n2. 修改hdfs-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n```\n\n-  作用：hdfs集群配置文件\n\n-  需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      \t<!-- 指定dfs文件存储位置 -->\n          <property>\n                  <name>dfs.data.dir</name>\n                  <value>/var/hadoop-data</value>\n          </property>\n      \t<!-- 指定文件备份份数 -->\n          <property>\n                  <name>dfs.replication</name>\n                  <value>2</value>\n          </property>\n      \t<!-- 指定机器运行情况检查时间间隔 -->\n          <property>\n                  <name>dfs.namenode.heartbead.recheck-interval</name>\n                  <value>3000000ms</value>\n          </property>\n          <!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 -->\n          <property>\n                  <name>dfs.nameservices</name>\n                  <value>ns</value>\n          </property>\n          <!-- NS下面的NameNode -->\n          <property>\n                  <name>dfs.ha.namenodes.ns</name>\n                  <value>nn1,nn2</value>\n          </property>\n          <!-- nn1的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn1</name>\n                  <value>master:9000</value>\n          </property>\n          <!-- nn1的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn1</name>\n                  <value>master:50070</value>\n          </property>\n          <!-- nn2的RPC通信地址 -->\n          <property>\n                  <name>dfs.namenode.rpc-address.ns.nn2</name>\n                  <value>master1:9000</value>\n          </property>\n          <!-- nn2的http通信地址 -->\n          <property>\n                  <name>dfs.namenode.http-address.ns.nn2</name>\n                  <value>master1:50070</value>\n          </property>\n          <!-- 指定NameNode的元数据在JournalNode上的存放位置 -->\n          <property>\n                  <name>dfs.namenode.shared.edits.dir</name>\n                  <value>qjournal://master:8485;master1:8485;slave1:8485/ns</value>\n          </property>\n          <!-- 指定JournalNode在本地磁盘存放数据的位置 -->\n          <property>\n                  <name>dfs.journalnode.edits.dir</name>\n                  <value>/usr/local/hadoop/journaldata</value>\n          </property>\n      \t<!-- 开启机器故障自动切换主从机器 -->\n          <property>\n                  <name>dfs.ha.automatic-failover.enabled</name>\n                  <value>true</value>\n          </property>\n      \t<!-- 指定failover切换的方法(java类的名称) -->\n          <property>\n                  <name>dfs.client.failover.proxy.provider.ns</name>\n              <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n          </property>\n      \t<!-- 指定failover切换的方法，这里使用ssh通信方式交换 -->\n          <property>\n                  <name>dfs.ha.fencing.methods</name>\n                  <value>\n                  sshfence\n                  shell(/bin/true)\n                  </value>\n          </property>\n      \t<!-- ssh切换方法需要指定私钥文件位置 -->\n          <property>\n                  <name>dfs.ha.fencing.ssh.private-key-files</name>\n                  <value>/root/.ssh/id_rsa</value>\n          </property>\n  </configuration>\n  ```\n\n-  注意\n\n   -  假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的`dfs.namenode.heartbead.recheck-interval`时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。\n   -  当使用jdbc访问hdfs时，不会使用`hdfs-site.xml`中的`dfs.replication`，而会默认使用3，可在java的`configuration`中配置为指定值\n\n3. 修改slaves文件\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/slaves\n```\n\n- 作用：为各个master指定为其工作的slave\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```txt\n  slave1\n  slave2\n  slave3\n  ```\n\n4. 修改yarn-site.xml\n\n```sh\nvim $HADOOP_HOME/etc/hadoop/yarn-site.xml\n```\n\n- 作用：yarn集群的核心配置文件\n\n- 需要修改的机器：master、master1、slave1、slave2、slave3\n\n- 内容：\n\n  ```xml\n  <configuration>\n      <!-- 启用yarn集群的高可用机制 -->\n      <property>\n          <name>yarn.resourcemanager.ha.enabled</name>\n          <value>true</value>\n      </property>\n      <!-- 指定ResourceManager集群id，可为任意字串 -->\n      <property>\n          <name>yarn.resourcemanager.cluster-id</name>\n          <value>yrc</value>\n      </property>\n      <!-- 指定两台ResourceManager的名称 -->\n      <property>\n          <name>yarn.resourcemanager.ha.rm-ids</name>\n          <value>rm1,rm2</value>\n      </property>\n      <!-- 指定两台ResourceManager的主机名 -->\n      <property>\n          <name>yarn.resourcemanager.hostname.rm1</name>\n          <value>master</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.hostname.rm2</name>\n          <value>master1</value>\n      </property>\n      <!-- 指定两台ResourceManager的web端口，正常情况为8088 -->\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm1</name>\n          <value>master:8088</value>\n      </property>\n      <property>\n          <name>yarn.resourcemanager.webapp.address.rm2</name>\n          <value>master1:8088</value>\n      </property>\n      <!-- 指定管理集群的Zookeeper集群的地址及对应端口 -->\n      <property>\n          <name>yarn.resourcemanager.zk-address</name>\n          <value>node0:2181,node1:2181,node2:2181</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.aux-services</name>\n          <value>mapreduce_shuffle</value>\n      </property>\n      <property>\n          <name>yarn.nodemanager.auxservices.mapreduce.shuffle.class</name>\n          <value>org.apache.hadoop.mapred.ShuffleHandler</value>\n      </property>\n      <!-- 指定jar包路径 -->\n      <property>\n          <name>yarn.application.classpath</name>\n          <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n      </property>\n  </configuration>\n  ```\n\n5. 修改mapred-site.xml\n\n- 作用：指定MapReduce操作的基本属性\n\n- 需要修改的机器：master、master1\n\n- 内容\n\n  ```xml\n  <configuration>\n  <property>\n      <name>mapreduce.framework.name</name>\n      <value>yarn</value>\n  </property>\n  <property>\n      <name>mapreduce.application.classpath</name>\n      <value>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar</value>\n  </property>\n  </configuration>\n  ```\n\n- 注意：\n\n  - MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce\n  - 此项若是不配，一些job只会在本机跑，而不会分发给其他机器\n\n6. 修改hive-site.xml\n\n```sh\nvim $HIVE_HOME/conf/hive-site.xml\n```\n\n- 作用：hive的基本配置\n\n- 需要修改的机器：master、master1\n\n- 内容：\n\n  - 修改`hive.server2.webui.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.webui.host</name>\n          <value>${hostname}</value>\n          <description>The host address the HiveServer2 WebUI will listen on</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.bind.host`\n\n      ```xml\n      <property>\n          <name>hive.server2.thrift.bind.host</name>\n          <value>${hostname}</value>\n          <description>Bind host on which to run the HiveServer2 Thrift service.</description>\n      </property>\n      ```\n\n      其中`${hostname}`需要改成对应的主机名称(master与master1)，或者都改为`0.0.0.0`\n\n  - 修改`hive.server2.zookeeper.namespace`\n\n      ```xml\n      <property>\n          <name>hive.server2.zookeeper.namespace</name>\n          <value>hiveserver2</value>\n          <description>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.</description>\n      </property>\n      ```\n\n      注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。\n\n  - 修改`javax.jdo.option.ConnectionURL`、`javax.jdo.option.ConnectionPassword`和`javax.jdo.option.ConnectionDriverName`\n\n      ```xml\n      <property>\n          <name>javax.jdo.option.ConnectionURL</name>\n              <value>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</value>\n          <description>\n            JDBC connect string for a JDBC metastore.\n            To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.\n            For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.\n          </description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionPassword</name>\n              <value>root</value>\n          <description>password to use against metastore database</description>\n      </property>\n      <property>\n          <name>javax.jdo.option.ConnectionDriverName</name>\n              <value>com.mysql.jdbc.Driver</value>\n          <description>Driver class name for a JDBC metastore</description>\n      </property>\n      ```\n\n      这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(~~此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据~~)。\n\n      另外，mysql的连接jar包需要下载并复制到hive的lib目录下。\n\n至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。\n\n##### 4.3.3 Zookeeper配置\n\n对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：\n\n```sh\nvim /usr/local/zookeeper/conf/zoo.cfg\n# 添加一下内容\nserver.1=192.168.137.200:2888:3888\nserver.2=192.168.137.201:2888:3888\nserver.3=192.168.137.202:2888:3888\n# 保存并关闭\n```\n\n##### 4.3.4 ssh免密登录配置\n\n- 作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的\n\n- 需要修改的机器：所有机器\n\n- 内容：\n\n  ```sh\n  # 进入用户目录下的`.ssh`目录\n  cd\n  cd .ssh/\n  # 创建公钥私钥对\n  ssh-keygen -t rsa\n  # 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍\n  ssh-copy-id ${hostname}\n  ```\n\n至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。\n\n#### 4.4 集群启动\n\n##### 4.4.1 初始化数据库\n\n在master机器上执行以下操作以初始化数据库：\n\n```sh\ncd $HIVE_HOME\nschematool -initSchema -dbType mysql\n```\n\n此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。\n\n##### 4.4.2 启动集群\n\n在master机器上执行以下操作以启动集群：\n\n```sh\nstart-all.sh\n```\n\n## 二 HDFS文件系统\n\n### 1 简介\n\n#### 1.1 HDFS简介\n\nHDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。\n\n#### 1.2 NameNode与DataNode\n\nHDFS由四部分组成，HDFS Client、NameNode、DataNode和Secondary NameNode。整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。\n\n![image-20210105151742421](/images/image-20210105151742421.png)\n\nNamenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：Namespcae image和Edit log。但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。NameNode 的文件结构包含 edits、fsimage、seen_txid、VERSION 以及 in_use.lock。其中， edits 为编辑日志（edit log）， 当客户端执行写操作时， NameNode 会先在编辑日志中写入记录，并在内存中保存一个文件系统的元数据。这一描述 符会在编辑日志改动后更新。fsimage 为文件系统镜像，是文件系统元数据的持久检查点，包含以序列化 格式存储的文件系统目录和文件 inodes，每个 inodes 表征一个文件或目录的元数 据信息以及文件的副本数、修改和访问时间等信息。seen_txid 文件代表的是 NameNode 中 edits_*文件的尾数，当 NameNode 重 启后，会按照 seen_txid 所定义的数字，循序从头运行 edits_0000001~至 seen_txid。VERSION 文件是 java 的属性文件，保存了 HDFS 的版本号。in_use.lock 的作用是防止一台机器同时启动多个 NameNode 进程，导致目录 数据不一致。\n\n在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： <br/>1）备份持久化元数据 \n将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。<br/>2）Secondary Namenode \nSecondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。SecondaryNameNode 的文件结构主要包括 edits、fsimage、VERSION 以及 in_use.lock。其中edits、fsimage、VERSION的内容均与NameNode相同，in_use.lock 的作用是防止一台机器同时启动多个 SecondaryNameNode 进程导致目录数据不 一致。\n\n而DataNode则会负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。DataNode 的文件结构主要包含 BP-前缀文件、blk前缀文件、VERSION 和 in_use.lock。 其中 BP-random integer-NameNode IP address-creation time 的 BP 代表 BlockPool，即 NameNode 的 VERSION 集群中唯一的 blockpoolID；finalized/rbw 目录用于存储 HDFS BLOCK 的数据， blk_前缀文件是 HDFS 中的文件块本身， 存储的是原始文件内容；VERSION 及 in_use.lock 的含义与上述类似。\n\n我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。\n\n### 2 分块机制\n\n#### 2.1 分块机制简介\n\n物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。\n\n#### 2.2 块分配流程\n\n通常当一个客户端`a`机器发起请求分配块请求，NN接收到请求后，执行如下块分配流程：<br/>1）  如果a不是一个DataNode，则在集群范围内随机选择一个节点作为目标节点，否则执行下面的2,3步骤；<br/>2） 判断a机器是否符合存储数据块的目标节点，如果符合，第一个块副本分配完毕；<br/>3）如果a机器不符合作为目标节点，则在于与a机器同机架范围内寻找，如果找到目标节点，第一个块副本分配完毕；<br/>4）如果在同一个机架内未找到符合要求的目标节点，则在集群内随机查找，找到则第一个块副本分配完毕，否则未找到符合条件的块，块分配失败；<br/>5）如果已经成功分配第一个块副本，则与a不同机架的远程机架内寻找目标节点，如果符合，第二个块副本分配完毕；<br/>6）如果在远程机架内未找到符合要求的目标节点，在与a相同的本机架寻找，如果找到则第二个块副本分配完毕；否则未找到符合条件的块，第二份块分配失败；<br/>7）如果前2个块副本分配成功，则准备分配第三个副本的目标节点，首先会判断前两份是否在同一个机架，如果是，则在远程机架寻找目标节点，找到则第三份副本分配完毕；如果前两份在不同机架，则在与a相同机架内寻找，如果找到则第三份副本分配完毕，否则在集群范围寻找，找到则第三份分配完毕，否则第三份分配失败<br/>8）如果块副本大于三分，则在集群范围内随机寻找节点\n\n当在一个范围内找到一个节点后，还需要经过如上的条件判断，才能确定一个DataNode进程是否可以作为目标节点：<br/>1） 如果没有节点机器被选择，则该节点可以作为备选节点，否则需要判断下一个DataNode是否符合要求；（这样就防止同一个块副本存储到同一台机器）<br/>2） 然后判断节点是否退役，存储空间是否足够，负载是否大于2倍平均负载，本机架选择的节点是否超过限制，如果均满足，则该datanode符合要求，否则需要判断下一个DataNode是否符合要求\n\n### 3 备份策略\n\n#### 3.1 备份策略简介\n\n对于HDFS而言，由Namenode负责这个集群的数据备份和分配，在分配过程中，主要考虑下面两个因素：\n\n- 数据安全：在某个节点发生故障时，不会丢失数据备份；\n- 网络传输开销：在备份数据同步过程中，尽量减少网络传输中的带宽开销；\n\n这两个因素看起来是有些相互矛盾的：想要保证数据安全，那么就尽量把数据备份到多台节点上，但是就需要向多个节点传输数据；想要减少网络传输开销，那么就尽可能把数据备份到一个节点内部或者一个机架内部，因为系统内部的数据传输速度会远大于网络传输的速度。\n\n#### 3.2 数据块部署\n\n对于巨大的集群来说，把所有的节点都部署在一个平行的拓扑结构里是不太现实的。比较实际且通用的做法是，把所有的节点分布到多个Rack(服务器机架)上。每个Rack上的节点共享一个交换机，Rack之间可以使用一个或者多个核心交换机进行互联。在大多数情况下，同一Rack中的节点间通信的带宽肯定会高于不同Rack间节点的通信带宽。HDFS默认两个节点之间的网络带宽与他们的物理距离成正比。从一个节点到其父节点的距离被认为是常数1。这样，两个节点之间的距离可以通过将其到各级祖先节点的距离相加计算出来。两个节点之间的距离越短，就意味着他们之间传输数据的带宽越大。\nHDFS允许管理员通过配置脚本，返回一个节点的rack标识符，作为节点地址。NameNode位于整个结构的最中央，负责解析每一个DataNode的rack位置。当DataNode注册到NameNode时，NameNode会运行这些配置脚本，确定节点属于哪个rack。如果没有进行脚本配置，NameNode则会认为所有的节点都属于一个默认的Rack。\n\n数据块备份的部署对于HDFS数据的可靠性和读写性能都有至关重要的影响。良好的数据块部署策略能够有效地改进数据的可靠性，可用性，甚至提高网络带宽的利用率。目前的HDFS系统提供了可配置的数据块部署策略接口，以此来让用户和研究人员能够对不同的部署策略进行测验，从而达到对系统应用进行优化的目的。\n\n缺省的HDFS数据块部署策略企图在降低数据写入代价，最大化数据可靠性，可用性，以及整合读数据带宽等几个方面做出权衡。当一个新的数据块被创建，HDFS会把第一个数据开备份放到写入程序所在的位置。第二个和第三个数据块备份会被部署到不同rack的其他两个不同的节点。剩余的数据块备份则被放到随机的节点上，但是限制每个节点不会部署多于一个相同的数据块，每个rack不会部署都与两个相同的数据块（如果条件满足的话）。之所以要把第二个和第三个数据块备份放到不同的rack上，是为了考虑到一个集群上的文件所应当具有的分布性。如果头两个数据块备份放到相同的rack上，那么对于任何文件来说，其2/3的文件块会被存放在同一rack上。\n\n在所有目标节点都被选择后，这些节点会被有组织地按照其亲近程度，以流水线的方式被传输到第一个备份上。数据会被以这个顺序推送到节点。在读取的时候，NameNode首先会检查客户端所对应的主机是否位于集群当中。如果是，那么数据块的位置会被返回到客户端，并以按照距离远近排序。然后数据块就会按照顺序从DataNode中进行读取。\n这一策略会降低rack之间以及节点之间的写入时间，普遍提高写入效率。因为rack故障的几率远低于节点故障的几率，所以该策略不会影响到数据的有效性和可用性。在大多数使用3数据块备份的情况下，该策略能够降低网络带宽的消耗，因为一个数据块只需要部署到两个不同的rack上，而不是3个。\n\n#### 3.3 备份策略\n\nNameNode会尽力保证们每个数据块都有所需的备份数量。当Block Report从DataNode提交上来的时候，NameNode会侦测到数据块的备份数量是少于所需还是超过所需。当超过时，NameNode会选择删除一个数据备份。NameNode倾向于不减少rack的数量，并在DataNode中选择一个剩余磁盘空间最小的节点进行备份移除。这样做的主要目的是平衡利用DataNode的存储空间，并其不降低到数据块的可用性。\n\n当一个数据块处于低于其备份需求数的状态时，该数据块就会被放入到备份优先队列中。仅拥有一个数据备份的数据块处于最高优先级，其数据备份数高于其备份因子2/3的数据块则处于最低优先级。有一个后台进程专门负责定期对备份优先队列进行扫面，以确定将备份部署到何处。数据块备份遵循与数据块部署相似的策略。如果数据块当前只有一个备份，那么HDFS会把一个新的备份放到不同rack上。如果数据块当前有两个备份，并且连个备份都存在与相同的rack上，第三个备份就会被放到不同的rack上。否则，第三个备份就被放到同一rack的不同节点上。这么做的目的也是为了降低创建备份的代价。\n\nNameNode也会确保不把所有的数据块备份都部署到同一个rack上。如果NameNode侦测到某数据块的所有备份都在一个rack上，那么它就会把这个数据块当做是mis-replicated(误备份),然后它就会用上面所提到的策略，在其他的rack上把这个数据块再备份一次。在NameNode收到异地rack备份成功后，该数据块就成为了“备份数量高于所需备份数”状态。此时NameNode会根据策略把本地的一个备份删除，因为策略规定不能减少rack的数量。\n\n### 4 文件一致性\n\n#### 4.1 一致性简介\n\n从**客户端**来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。\n\n从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是**强一致性**。如果能容忍后续的部分或者全部访问不到，则是**弱一致性**。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性\n\n从**服务端**角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：\n\n- N — 数据复制的份数 \n- W — 更新数据时需要保证写完成的节点数 \n- R — 读取数据的时候需要读取的节点数 \n\n如果W+R>N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。\n\n如果W+R<=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。\n\n对于分布式系统，为了保证高可用性，一般设置N>=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。\n\n- 如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。 \n- 如果N=R,W=1，只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。这种情况下，如果W<(N+1)/2，并且写入的节点不重叠的话，则会存在写冲突  \n\n#### 4.2 一致性模型\n\nHDFS牺牲了一些POSIX的需求来补偿性能，所以有些操作可能会和传统的文件系统不同。当创建一个文件时，它在文件系统的命名空间中是可见的，代码如下:\n\n```java\nPath p = new Path(\"p\");\nfs.create(p);\nassertThat(fs.exists(p),is(true));\n```\n\n但是对这个文件的任何写操作不保证是可见的，即使在数据流已经刷新的情况下，文件的长度很长时间也会显示为0 ：\n\n```java\nPath p = new Path(\"p\");\nOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();\nassertThat(fs.getFileStatus(p),getLen(),is(0L));\n```\n\n一旦一个数据块写人成功，那么大家提出的新请求就可以看到这个块，而对当前写入的块，大家是看不见的。HDFS提供了使所有缓存和DataNode之间的数据强制同步的方法，这个方法是FSDataOutputStream中的sync()函数。当sync()函数返回成功时，HDFS就可以保证此时写入的文件数据是一致的并且对于所有新的用户都是可见的。即使HDFS客户端之间发生冲突，也会导致数据丢失，代码如下:\n\n```java\nPath p = new Path(\"p\");\nFSDataOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();\nout.sync();\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n这个操作类似于UNIX系统中的fsync系统调用，为一个文件描述符提交缓存数据，利用Java API写入本地数据，这样就可以保证看到刷新流并且同步之后的数据，代码如下:\n\n```java\nFileOutputStream out = new FileOutStream(localFile);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.flush();       //  flush to operatig system\nout.getFD().sync();    //  sync to disk\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n在HDFS中关闭一个文件也隐式地执行了sync()函数，代码如下:\n\n```java\nPath p = new Path(\"p\");\nOutputStream out = fs.create(p);\nout.write(\"content\".getBytes(\"UTF-8\"));\nout.close();\nassertThat(fs.getFileStatus(p),getLen(),is(((long) \"content\" .length()));\n```\n\n文件系统的一致性与设计应用程序的方法有关。如果不调用sync()，那么需要做好因客户端或者系统发生故障而丢失部分数据做好准备。对大多数应用程序来说，这是不可接受的，所以需要在合适的地方调用sync()，比如在写入一定量的数据之后。尽管sync()被设计用来最大限度地减少HDFS的负担，但是它仍然有不可忽视的开销，所以需要在数据健壮性和吞吐最之间做好权衡，其中一个较好的参考平衡点就是:通过测试应用程序来选择不同sync()频率间的最佳平衡点。\n\n### 5 文件读写\n\n#### 5.1 写策略\n\n应用程序通过创建新文件以及向新文件写数据的方式，给HDFS系统添加数据。文件关闭以后，被写入的数据就无法再修改或者删除，只有以“追加”方式重新打开文件后，才能再次为文件添加数据。HDFS采用单线程写，多线程读的模式。\n\nHDFS客户端需要首先获得对文件操作的授权，然后才能对文件进行写操作。在此期间，其他的客户端都不能对该文件进行写操作。被授权的客户端通过向NameNode发送心跳信号来定期更新授权的状态。当文件关闭时，授权会被回收。文件授权期限分为软限制期和硬限制期两个等级。当处于软限制期内时，写文件的客户端独占对文件的访问权。当软限制过期后，如果客户端无法关闭文件，或没有释放对文件的授权，其他客户端即可以预定获取授权。当硬限制期过期后（一小时左右），如果此时客户端还没有更新（释放）授权，HDFS会认为原客户端已经退出，并自动终止文件的写行为，收回文件控制授权。文件的写控制授权并不会阻止其他客户端对文件进行读操作。因此一个文件可以有多个并行的客户端对其进行读取。\n\nHDFS文件由多个文件块组成。当需要创建一个新文件块时，NameNode会生成唯一的块ID，分配块空间，以及决定将块和块的备份副本存储到哪些DataNode节点上。DataNode节点会形成一个管道，管道中DataNode节点的顺序能够确保从客户端到上一DataNode节点的总体网络距离最小。文件的则以有序包（sequence of packets）的形式被推送到管道。应用程序客户端创建第一个缓冲区，并向其中写入字节。第一个缓冲区被填满后（一般是64 KB大小），数据会被推送到管道。后续的包随时可以推送，并不需要等前一个包发送成功并发回通知（这被称为“未答复发送”——译者注）。不过，这种未答复发送包的数目会根据客户端所限定的“未答复包窗口”(outstanding packets windows)的大小进行限制。\n\n在数据写入HDFS文件后，只要文件写操作没有关闭，HDFS就不保证数据在此期间对新增的客户端读操作可见。如果客户端用户程序需要确保对写入数据的可见性，可以显示地执行hflush操作。这样，当前的包就会被立即推送到管道，并且hflush操作会一直等到所有管道中的DataNode返回成功接收到数据的通知后才会停止。如此就可以保证所有在执行hflush之前所写入的数据对试图读取的客户端用户均可见。\n\n在一个集群的数千个节点里，节点失效（往往是因为存储故障造成的）每天都有可能发生。DataNode中所包含的文件块备份可能会因为内存、磁盘或者网络的错误而造成损坏。为了避免这种错误的形成，HDFS会为其文件的每个数据块生成并存储一份Checksum（总和检查）。Checksum主要供HDFS客户端在读取文件时检查客户端，DataNode以及网络等几个方面可能造成的数据块损坏。当客户端开始建立HDFS文件时，会检查文件的每个数据块的checksum序列，并将其与数据一起发送给DataNode。 DataNode则将checksum存放在文件的元数据文件里，与数据块的具体数据分开存放。当HDFS读取文件时，文件的每个块数据和checksum均被发送到客户端。客户端会即时计算出接受的块数据的checksum, 并将其与接受到的checksum进行匹配。如果不匹配，客户端会通知NameNode，表明接受到的数据块已经损坏，并尝试从其他的DataNode节点获取所需的数据块。\n\n当客户端打开一个文件进行读取时，会从NameNode中获得一个文件数据块列表，列表中包含了每一个所需的数据块的具体位置。这些位置会按照与客户端的距离进行排序。当具体进行数据块读取时，客户端总是尝试首先从最近的位置获取数据。如果尝试失败，客户端会根据排序的顺寻，从下一个位置获取数据。下列情况可能会造成数据读取失败：DataNode不可用，节点不再包含所需数据块，或者数据块备份损坏，以及checksum验证失败。\nHDFS允许客户端从正在进行写操作的文件中读取数据。当进行这样的操作时，目前正在被写入的数据块对于NameNode来说是未知的。在这样的情况下，客户端会从所有数据块备份中挑选一个数据块，以这个数据块的最后长度作为开始读取数据之前的数据长度。HDFS I/O的设计是专门针对批处理系统进行优化的，比如MapReduce系统，这类系统对顺序读写的吞吐量都有很高的要求。针对于那些需要实时数据流以及随机读写级别的应用来说，系统的读/写响应时间还有待于优化，目前正在做这方面的努力。\n\n#### 5.2 读策略\n\n读相对于写，简单一些，详细步骤如下：\n\n1. client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。\n2. 就近挑选一台datanode服务器，请求建立输入流 。\n3. DataNode向输入流中中写数据，以packet为单位来校验。\n4. 关闭输入流\n\n## 三 MapReduce计算\n\n### 1 简介\n\nMapReduce是Google提出的一个软件架构，也是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念\"Map（映射）\"和\"Reduce（归约）\"，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。\n\n### 2 工作原理\n\n#### 2.1 Map\n\n程序根据输入格式将输入文件划分为多个部分，每个部分均用作映射。任务输入，每个map任务都有一个内存缓冲区，输入数据在映射阶段进行处理，中间结果被写入存储缓冲区，并由写入数据的一方确定。当数据达到内存缓冲区阈值（默认值为0.8）时，会启动线程将内存中溢出的数据写入磁盘，并继续缓冲而不影响映射的中间结果。在溢出写入过程中，MapReduce框架对键进行排序。如果中间结果相对较大，则会形成多个溢出文件。最后缓冲区中的数据也被写入磁盘，从而形成一个溢出文件（至少一个溢出文件）。如果有多个溢出文件，则所有文件最后都会合并为一个文件。\n\n#### 2.2 Reduce\n\n当所有的映射任务完成后，每个映射任务会形成一个最终文件，并且该文件按区划分。reduce 任务启动之前，一个映射任务完成后，就会启动线程来拉取映射结果数据到相应的规约任务，不断地合并数据，为规约的数据输入做准备，当所有的射任务完成完成后，数据也拉取合并完毕后，规约任务启动，最终将输出结果存入HDFS 上。\n\n### 3 MapReduce运行流程\n\n#### 3.1 分析 MapReduce 执行过程\n\nMapReduce运行的时候，输入输出都是HDFS中的文件，首先，Mapper中运行的任务会去读取HDFS中的数据文件，通过调用map中的方法来处理数据，然后将处理结果输出给Reducer任务，Reducer将接收到的结果作为自己的输入数据，并且也调用自己的方法，将最后的结果输出到HDFS中。过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/ZyxlBMGXXPu08Qws.png!original)\n\n#### 3.2 Mapper 任务执行过程详解\n\n每个Mapper 任务是一个java 进程，它会读取HDFS 中的文件，解析成很多的键值对，经过我们覆盖的map 方法处理后，转换为很多的键值对再输出。整个Mapper 任务的处理过程又可以分为以下几个阶段：\n\n1. 第一阶段是把输入文件按照一定的标准分片(InputSplit)，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的。如果数据块(Block)的大小是默认值64MB，输入文件有两个，一个是32MB，一个是72MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由一个Mapper 进程处理。这里的三个输入片，会有三个Mapper 进程处理。\n2. 第二阶段是对输入片中的记录按照一定的规则解析成键值对。有个默认规则是把每一行文本内容解析成键值对。“键”是每一行的起始位置(单位是字节)，“值” 是本行的文本内容。\n3. 第三阶段是调用Mapper 类中的map 方法。第二阶段中解析出来的每一个键值对，调用一次map 方法。如果有1000 个键值对，就会调用1000 次map方法。每一次调用map 方法会输出零个或者多个键值对。\n4. 第四阶段是按照一定的规则对第三阶段输出的键值对进行分区。比较是基于键进行的。比如我们的键表示省份(如北京、上海、山东等)，那么就可以按照不同省份进行分区，同一个省份的键值对划分到一个区中。默认是只有一个区。分区的数量就是Reducer 任务运行的数量。默认只有一个Reducer 任务。\n5. 第五阶段是对每个分区中的键值对进行排序。首先，按照键进行排序，对于键相同的键值对，按照值进行排序。比如三个键值对<2,2>、<1,3>、<2,1>，键和值分别是整数。那么排序后的结果是<1,3>、<2,1>、<2,2>。如果有\n6. 第六阶段，那么进入第六阶段；如果没有，直接输出到本地的linux 文件中。第六阶段是对数据进行归约处理，也就是reduce 处理。键相等的键值对会调用一次reduce 方法。经过这一阶段，数据量会减少。归约后的数据输出到本地的linux文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。\n\n上述过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2kbg02YRqSS3ZofE.png!original)\n\n#### 3.3 Reduce任务执行过程详解\n\n每个Reducer 任务是一个java 进程。Reducer 任务接收Mapper 任务的输出，归约处理后写入到HDFS 中，可以分为如下几个阶段。\n\n1. 第一阶段是Reducer 任务会主动从Mapper 任务复制其输出的键值对。Mapper 任务可能会有很多，因此Reducer 会复制多个Mapper 的输出。\n2. 第二阶段是把复制到Reducer 本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。\n3. 第三阶段是对排序后的键值对调用reduce 方法。键相等的键值对调用一次reduce 方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS 文件中。\n\n在整个MapReduce 程序的开发过程中，我们最大的工作量是覆盖map 函数和覆盖reduce 函数。上述过程如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2YC2iJF2OJvYbs1R.png!original)\n\n#### 3.4 键值对的编号\n\n在对Mapper 任务、Reducer 任务的分析过程中，会看到很多阶段都出现了键值对，这里对键值对进行编号，方便理解键值对的变化情况，对于Mapper 任务输入的键值对，定义为key1 和value1。在map 方法中处理后，输出的键值对，定义为key2 和value2。reduce 方法接收key2 和value2，处理后，输出key3 和value3。具体如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dXULEPSCEIT3QZW0.png!original)\n\n### 4 MapReduce实现\n\nMapReduce 在执行的时候，先执行Map 函数，再执行Reduce 函数，达到分布式并行运算效果。其中Map 函数与Reduce 函数需要用户自行设计，而这两个任务也定义了任务本身。\n\n#### 4.1 统计平均通话次数\n\n需要用到的数据为：主叫号码。仅需统计每个主叫号码在数据文件中出现的次数，用该数除以天数，即可得到平均值。与WordCount 类似，提取出第二列数据即可进行。具体代码如下图所示：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/f7g9O8xBBwHpkdZB.png!original)\n\n结果如下图所示，其中每一行有两个数据，第一列为主叫号码，第二列为平均每日通话次数：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/NM80fSViYPVEfD3Q.png!original)\n\n#### 4.2 统计不同通话类型下各运营商占比\n\n需要用到的数据为：通话类型，主叫号码运营商，被叫号码运营商。与第一个需求不同，本需求的key 值由两个数共同组成，需要定义一个新的类用来包含通话类型和运行商。定义如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/aCFEDYqbUtuMMWFm.png!original)\n\n其中需要注意，由于key 中数据的个数不唯一，需要对内部的数据优先级进行规定，所以要重写compareTo 函数，对key 进行排序。主函数中需要注意Map 阶段的输出类型和Reduce 阶段的输入输出类型，代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/khmfgplaXcfeVygE.png!original)\n\n结果如下图，其中1代表电信，2 代表移动，3 代表联通：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dw7Q7n01PquYb8xX.png!original)\n\n![img](https://uploader.shimo.im/f/pTZXRD60QSU3j9Un.png!original)\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/3rK4jBFXZs3Ig47t.png!original)\n\n#### 4.3 统计用户在各个时间段通话时长所占比例\n\n所需用到的数据有：主叫电话号码，通话开始时间，通话结束时间。最后输出的形式是一长串的数组，因此同样需要设计一个新的类用于封装。与上一需求不同的是，该类用于value 的输入和输出。代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/rlXjbmDdWKPLQS5R.png!original)\n\n为了完成统计任务，还需要自己求出每个时间段的时间，才能统计占比。这需要设计统计时间段内持续时间的算法，代码如下：\n\n![img](/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/iwXvfrzHPmTxAVJ9.png!original)\n\n主函数与上一需求类似，区别在于Reduce 阶段的结果输出为浮点型数据，需要再同最开始一样重新定义一个浮点结果类，才能输出。\n\n结果如下图所示，每一行有9 个数据，第一列为主叫号码，第二到第八列为对应时间段中通话时长占一天的比例：\n\n![img](https://uploader.shimo.im/f/tSgwVy0seIoRbjlJ.png!original)","slug":"分布式计算期末项目文档","published":1,"updated":"2021-05-16T11:00:42.355Z","_id":"ckor1kofc0000mixoexv8yhsh","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><strong>组员：</strong><br>2031570 谈瑞<br>2031568 薛锦伟</p>\n</blockquote>\n<p>分布式计算期末项目简单记录，水一水~</p>\n<a id=\"more\"></a>\n<h2 id=\"一-系统架构\"><a href=\"#一-系统架构\" class=\"headerlink\" title=\"一 系统架构\"></a>一 系统架构</h2><h3 id=\"1-Hadoop基本介绍\"><a href=\"#1-Hadoop基本介绍\" class=\"headerlink\" title=\"1 Hadoop基本介绍\"></a>1 Hadoop基本介绍</h3><p>Hadoop是一个高可靠的(reliable)，规模可扩展的(scalable)，分布式(distributed computing)的开源软件框架。它使我们能用一种简单的编程模型来处理存储于集群上的大数据集。</p>\n<p>Hadoop是Apache基金会的一个开源项目，是一个提供了分布式存储和分布式计算功能的基础架构平台。可以应用于企业中的数据存储，日志分析，商业智能，数据挖掘等。其为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop 还提供了分布式文件系统HDFS，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。</p>\n<p>由于Hadoop的架构与本次项目需求较吻合，因此我们直接使用Hadoop的HDFS和MapReduce框架来进行此次项目所需要的分布式系统的实现。</p>\n<h3 id=\"2-集群架构图\"><a href=\"#2-集群架构图\" class=\"headerlink\" title=\"2 集群架构图\"></a>2 集群架构图</h3><p><img src=\"/images/image-20181228192856958-5996536.png\" alt=\"image-20181228192856958\"></p>\n<h3 id=\"3-集群机器\"><a href=\"#3-集群机器\" class=\"headerlink\" title=\"3 集群机器\"></a>3 集群机器</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">8GB</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-集群搭建\"><a href=\"#4-集群搭建\" class=\"headerlink\" title=\"4 集群搭建\"></a>4 集群搭建</h3><h4 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1 简介\"></a>4.1 简介</h4><p>集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。</p>\n<h4 id=\"4-2-虚拟机创建\"><a href=\"#4-2-虚拟机创建\" class=\"headerlink\" title=\"4.2 虚拟机创建\"></a>4.2 虚拟机创建</h4><p>此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。</p>\n<p>首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的<code>Host-Only</code>连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。</p>\n<p>在主机网络设置中共享网络：</p>\n<p><img src=\"/images/image-20181228201105314-5999065.png\" alt=\"image-20181228201105314\"></p>\n<p>在VirtualBox中执行以下操作设置主机连接方式：</p>\n<p><img src=\"/images/image-20181228200129326-5998489.png\" alt=\"image-20181228200129326\"></p>\n<p>在虚拟机终端执行以下操作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改虚拟机的IP、子网掩码</span></span><br><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">IPADDR=192.168.137.100</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改网关地址</span></span><br><span class=\"line\">vim /etc/sysconfig/network</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">GATEWAY=192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP</span></span><br><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname master</span><br><span class=\"line\"><span class=\"comment\"># 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"><span class=\"comment\"># 重启网络服务</span></span><br><span class=\"line\">systemctl restart network</span><br><span class=\"line\"><span class=\"comment\"># 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功</span></span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105</span></span><br><span class=\"line\">ping 61.135.169.105</span><br><span class=\"line\"><span class=\"comment\"># 修改hosts文件，添加局域网中其他主机的主机名与ip的映射</span></span><br><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">192.168.137.100 master</span><br><span class=\"line\">192.168.137.10 master1</span><br><span class=\"line\">192.168.137.101 slave1</span><br><span class=\"line\">192.168.137.102 slave2</span><br><span class=\"line\">192.168.137.103 slave3</span><br><span class=\"line\">192.168.137.200 node0</span><br><span class=\"line\">192.168.137.201 node1</span><br><span class=\"line\">192.168.137.202 node2</span><br><span class=\"line\">0.0.0.0 localhost</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br></pre></td></tr></table></figure>\n<p>至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先添加Hadoop和Hive相关环境变量</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 添加下列内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_MAPRED_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HIVE_HOME=/usr/<span class=\"built_in\">local</span>/hive</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HIVE_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 保存退出，并使环境变量生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<p>Hadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。</p>\n<h4 id=\"4-3-虚拟机复制\"><a href=\"#4-3-虚拟机复制\" class=\"headerlink\" title=\"4.3 虚拟机复制\"></a>4.3 虚拟机复制</h4><p>上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。</p>\n<h5 id=\"4-3-1-网络配置\"><a href=\"#4-3-1-网络配置\" class=\"headerlink\" title=\"4.3.1 网络配置\"></a>4.3.1 网络配置</h5><p>对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：</p>\n<ul>\n<li><p>修改IP</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的IP将<code>IPADDR</code>项修改为对应的IP</p>\n</li>\n<li><p>修改主机名</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname XXX</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名</p>\n</li>\n<li><p>重启网络服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ping各个节点测试是否成功</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping master</span><br><span class=\"line\">ping master1</span><br><span class=\"line\">ping slave1</span><br><span class=\"line\">ping slave2</span><br><span class=\"line\">ping slave3</span><br><span class=\"line\">ping node0</span><br><span class=\"line\">ping node1</span><br><span class=\"line\">ping node2</span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\">ping 61.135.169.105</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"4-3-2-Hadoop配置\"><a href=\"#4-3-2-Hadoop配置\" class=\"headerlink\" title=\"4.3.2 Hadoop配置\"></a>4.3.2 Hadoop配置</h5><ol>\n<li>修改core-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：Hadoop集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.permissions.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>ha.zookeeper.quorum<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2182,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 允许访问此hdfs的主机和群组，此处设置为任意 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>修改hdfs-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hdfs集群配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定dfs文件存储位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop-data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定文件备份份数 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定机器运行情况检查时间间隔 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.heartbead.recheck-interval<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>3000000ms<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.nameservices<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- NS下面的NameNode --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.namenodes.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>nn1,nn2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>qjournal://master:8485;master1:8485;slave1:8485/ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.journalnode.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/journaldata<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 开启机器故障自动切换主从机器 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法(java类的名称) --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法，这里使用ssh通信方式交换 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.methods<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                sshfence</span><br><span class=\"line\">                shell(/bin/true)</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- ssh切换方法需要指定私钥文件位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/root/.ssh/id_rsa<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<ul>\n<li>假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用jdbc访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>修改slaves文件</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/slaves</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：为各个master指定为其工作的slave</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">slave1</span><br><span class=\"line\">slave2</span><br><span class=\"line\">slave3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>修改yarn-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：yarn集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用yarn集群的高可用机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定ResourceManager集群id，可为任意字串 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yrc<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>rm1,rm2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的主机名 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的web端口，正常情况为8088 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定管理集群的Zookeeper集群的地址及对应端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2181,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定jar包路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li>修改mapred-site.xml</li>\n</ol>\n<ul>\n<li><p>作用：指定MapReduce操作的基本属性</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce</li>\n<li>此项若是不配，一些job只会在本机跑，而不会分发给其他机器</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>修改hive-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HIVE_HOME</span>/conf/hive-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hive的基本配置</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容：</p>\n<ul>\n<li><p>修改<code>hive.server2.webui.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.webui.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The host address the HiveServer2 WebUI will listen on<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.bind.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.thrift.bind.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Bind host on which to run the HiveServer2 Thrift service.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.zookeeper.namespace</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.zookeeper.namespace<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hiveserver2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。</p>\n</li>\n<li><p>修改<code>javax.jdo.option.ConnectionURL</code>、<code>javax.jdo.option.ConnectionPassword</code>和<code>javax.jdo.option.ConnectionDriverName</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">      JDBC connect string for a JDBC metastore.</span><br><span class=\"line\">      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class=\"line\">      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>password to use against metastore database<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Driver class name for a JDBC metastore<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(<del>此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据</del>)。</p>\n<p>  另外，mysql的连接jar包需要下载并复制到hive的lib目录下。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。</p>\n<h5 id=\"4-3-3-Zookeeper配置\"><a href=\"#4-3-3-Zookeeper配置\" class=\"headerlink\" title=\"4.3.3 Zookeeper配置\"></a>4.3.3 Zookeeper配置</h5><p>对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"built_in\">local</span>/zookeeper/conf/zoo.cfg</span><br><span class=\"line\"><span class=\"comment\"># 添加一下内容</span></span><br><span class=\"line\">server.1=192.168.137.200:2888:3888</span><br><span class=\"line\">server.2=192.168.137.201:2888:3888</span><br><span class=\"line\">server.3=192.168.137.202:2888:3888</span><br><span class=\"line\"><span class=\"comment\"># 保存并关闭</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"4-3-4-ssh免密登录配置\"><a href=\"#4-3-4-ssh免密登录配置\" class=\"headerlink\" title=\"4.3.4 ssh免密登录配置\"></a>4.3.4 ssh免密登录配置</h5><ul>\n<li><p>作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的</p>\n</li>\n<li><p>需要修改的机器：所有机器</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入用户目录下的`.ssh`目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> .ssh/</span><br><span class=\"line\"><span class=\"comment\"># 创建公钥私钥对</span></span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\"># 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍</span></span><br><span class=\"line\">ssh-copy-id <span class=\"variable\">$&#123;hostname&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。</p>\n<h4 id=\"4-4-集群启动\"><a href=\"#4-4-集群启动\" class=\"headerlink\" title=\"4.4 集群启动\"></a>4.4 集群启动</h4><h5 id=\"4-4-1-初始化数据库\"><a href=\"#4-4-1-初始化数据库\" class=\"headerlink\" title=\"4.4.1 初始化数据库\"></a>4.4.1 初始化数据库</h5><p>在master机器上执行以下操作以初始化数据库：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HIVE_HOME</span></span><br><span class=\"line\">schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure>\n<p>此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。</p>\n<h5 id=\"4-4-2-启动集群\"><a href=\"#4-4-2-启动集群\" class=\"headerlink\" title=\"4.4.2 启动集群\"></a>4.4.2 启动集群</h5><p>在master机器上执行以下操作以启动集群：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">start-all.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-HDFS文件系统\"><a href=\"#二-HDFS文件系统\" class=\"headerlink\" title=\"二 HDFS文件系统\"></a>二 HDFS文件系统</h2><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><h4 id=\"1-1-HDFS简介\"><a href=\"#1-1-HDFS简介\" class=\"headerlink\" title=\"1.1 HDFS简介\"></a>1.1 HDFS简介</h4><p>HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p>\n<h4 id=\"1-2-NameNode与DataNode\"><a href=\"#1-2-NameNode与DataNode\" class=\"headerlink\" title=\"1.2 NameNode与DataNode\"></a>1.2 NameNode与DataNode</h4><p>HDFS由四部分组成，HDFS Client、NameNode、DataNode和Secondary NameNode。整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p>\n<p><img src=\"/images/image-20210105151742421.png\" alt=\"image-20210105151742421\"></p>\n<p>Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：Namespcae image和Edit log。但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。NameNode 的文件结构包含 edits、fsimage、seen_txid、VERSION 以及 in_use.lock。其中， edits 为编辑日志（edit log）， 当客户端执行写操作时， NameNode 会先在编辑日志中写入记录，并在内存中保存一个文件系统的元数据。这一描述 符会在编辑日志改动后更新。fsimage 为文件系统镜像，是文件系统元数据的持久检查点，包含以序列化 格式存储的文件系统目录和文件 inodes，每个 inodes 表征一个文件或目录的元数 据信息以及文件的副本数、修改和访问时间等信息。seen_txid 文件代表的是 NameNode 中 edits_*文件的尾数，当 NameNode 重 启后，会按照 seen_txid 所定义的数字，循序从头运行 edits_0000001~至 seen_txid。VERSION 文件是 java 的属性文件，保存了 HDFS 的版本号。in_use.lock 的作用是防止一台机器同时启动多个 NameNode 进程，导致目录 数据不一致。</p>\n<p>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： <br>1）备份持久化元数据<br>将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。<br>2）Secondary Namenode<br>Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。SecondaryNameNode 的文件结构主要包括 edits、fsimage、VERSION 以及 in_use.lock。其中edits、fsimage、VERSION的内容均与NameNode相同，in_use.lock 的作用是防止一台机器同时启动多个 SecondaryNameNode 进程导致目录数据不 一致。</p>\n<p>而DataNode则会负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。DataNode 的文件结构主要包含 BP-前缀文件、blk前缀文件、VERSION 和 in_use.lock。 其中 BP-random integer-NameNode IP address-creation time 的 BP 代表 BlockPool，即 NameNode 的 VERSION 集群中唯一的 blockpoolID；finalized/rbw 目录用于存储 HDFS BLOCK 的数据， blk_前缀文件是 HDFS 中的文件块本身， 存储的是原始文件内容；VERSION 及 in_use.lock 的含义与上述类似。</p>\n<p>我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。</p>\n<h3 id=\"2-分块机制\"><a href=\"#2-分块机制\" class=\"headerlink\" title=\"2 分块机制\"></a>2 分块机制</h3><h4 id=\"2-1-分块机制简介\"><a href=\"#2-1-分块机制简介\" class=\"headerlink\" title=\"2.1 分块机制简介\"></a>2.1 分块机制简介</h4><p>物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。</p>\n<h4 id=\"2-2-块分配流程\"><a href=\"#2-2-块分配流程\" class=\"headerlink\" title=\"2.2 块分配流程\"></a>2.2 块分配流程</h4><p>通常当一个客户端<code>a</code>机器发起请求分配块请求，NN接收到请求后，执行如下块分配流程：<br>1）  如果a不是一个DataNode，则在集群范围内随机选择一个节点作为目标节点，否则执行下面的2,3步骤；<br>2） 判断a机器是否符合存储数据块的目标节点，如果符合，第一个块副本分配完毕；<br>3）如果a机器不符合作为目标节点，则在于与a机器同机架范围内寻找，如果找到目标节点，第一个块副本分配完毕；<br>4）如果在同一个机架内未找到符合要求的目标节点，则在集群内随机查找，找到则第一个块副本分配完毕，否则未找到符合条件的块，块分配失败；<br>5）如果已经成功分配第一个块副本，则与a不同机架的远程机架内寻找目标节点，如果符合，第二个块副本分配完毕；<br>6）如果在远程机架内未找到符合要求的目标节点，在与a相同的本机架寻找，如果找到则第二个块副本分配完毕；否则未找到符合条件的块，第二份块分配失败；<br>7）如果前2个块副本分配成功，则准备分配第三个副本的目标节点，首先会判断前两份是否在同一个机架，如果是，则在远程机架寻找目标节点，找到则第三份副本分配完毕；如果前两份在不同机架，则在与a相同机架内寻找，如果找到则第三份副本分配完毕，否则在集群范围寻找，找到则第三份分配完毕，否则第三份分配失败<br>8）如果块副本大于三分，则在集群范围内随机寻找节点</p>\n<p>当在一个范围内找到一个节点后，还需要经过如上的条件判断，才能确定一个DataNode进程是否可以作为目标节点：<br>1） 如果没有节点机器被选择，则该节点可以作为备选节点，否则需要判断下一个DataNode是否符合要求；（这样就防止同一个块副本存储到同一台机器）<br>2） 然后判断节点是否退役，存储空间是否足够，负载是否大于2倍平均负载，本机架选择的节点是否超过限制，如果均满足，则该datanode符合要求，否则需要判断下一个DataNode是否符合要求</p>\n<h3 id=\"3-备份策略\"><a href=\"#3-备份策略\" class=\"headerlink\" title=\"3 备份策略\"></a>3 备份策略</h3><h4 id=\"3-1-备份策略简介\"><a href=\"#3-1-备份策略简介\" class=\"headerlink\" title=\"3.1 备份策略简介\"></a>3.1 备份策略简介</h4><p>对于HDFS而言，由Namenode负责这个集群的数据备份和分配，在分配过程中，主要考虑下面两个因素：</p>\n<ul>\n<li>数据安全：在某个节点发生故障时，不会丢失数据备份；</li>\n<li>网络传输开销：在备份数据同步过程中，尽量减少网络传输中的带宽开销；</li>\n</ul>\n<p>这两个因素看起来是有些相互矛盾的：想要保证数据安全，那么就尽量把数据备份到多台节点上，但是就需要向多个节点传输数据；想要减少网络传输开销，那么就尽可能把数据备份到一个节点内部或者一个机架内部，因为系统内部的数据传输速度会远大于网络传输的速度。</p>\n<h4 id=\"3-2-数据块部署\"><a href=\"#3-2-数据块部署\" class=\"headerlink\" title=\"3.2 数据块部署\"></a>3.2 数据块部署</h4><p>对于巨大的集群来说，把所有的节点都部署在一个平行的拓扑结构里是不太现实的。比较实际且通用的做法是，把所有的节点分布到多个Rack(服务器机架)上。每个Rack上的节点共享一个交换机，Rack之间可以使用一个或者多个核心交换机进行互联。在大多数情况下，同一Rack中的节点间通信的带宽肯定会高于不同Rack间节点的通信带宽。HDFS默认两个节点之间的网络带宽与他们的物理距离成正比。从一个节点到其父节点的距离被认为是常数1。这样，两个节点之间的距离可以通过将其到各级祖先节点的距离相加计算出来。两个节点之间的距离越短，就意味着他们之间传输数据的带宽越大。<br>HDFS允许管理员通过配置脚本，返回一个节点的rack标识符，作为节点地址。NameNode位于整个结构的最中央，负责解析每一个DataNode的rack位置。当DataNode注册到NameNode时，NameNode会运行这些配置脚本，确定节点属于哪个rack。如果没有进行脚本配置，NameNode则会认为所有的节点都属于一个默认的Rack。</p>\n<p>数据块备份的部署对于HDFS数据的可靠性和读写性能都有至关重要的影响。良好的数据块部署策略能够有效地改进数据的可靠性，可用性，甚至提高网络带宽的利用率。目前的HDFS系统提供了可配置的数据块部署策略接口，以此来让用户和研究人员能够对不同的部署策略进行测验，从而达到对系统应用进行优化的目的。</p>\n<p>缺省的HDFS数据块部署策略企图在降低数据写入代价，最大化数据可靠性，可用性，以及整合读数据带宽等几个方面做出权衡。当一个新的数据块被创建，HDFS会把第一个数据开备份放到写入程序所在的位置。第二个和第三个数据块备份会被部署到不同rack的其他两个不同的节点。剩余的数据块备份则被放到随机的节点上，但是限制每个节点不会部署多于一个相同的数据块，每个rack不会部署都与两个相同的数据块（如果条件满足的话）。之所以要把第二个和第三个数据块备份放到不同的rack上，是为了考虑到一个集群上的文件所应当具有的分布性。如果头两个数据块备份放到相同的rack上，那么对于任何文件来说，其2/3的文件块会被存放在同一rack上。</p>\n<p>在所有目标节点都被选择后，这些节点会被有组织地按照其亲近程度，以流水线的方式被传输到第一个备份上。数据会被以这个顺序推送到节点。在读取的时候，NameNode首先会检查客户端所对应的主机是否位于集群当中。如果是，那么数据块的位置会被返回到客户端，并以按照距离远近排序。然后数据块就会按照顺序从DataNode中进行读取。<br>这一策略会降低rack之间以及节点之间的写入时间，普遍提高写入效率。因为rack故障的几率远低于节点故障的几率，所以该策略不会影响到数据的有效性和可用性。在大多数使用3数据块备份的情况下，该策略能够降低网络带宽的消耗，因为一个数据块只需要部署到两个不同的rack上，而不是3个。</p>\n<h4 id=\"3-3-备份策略\"><a href=\"#3-3-备份策略\" class=\"headerlink\" title=\"3.3 备份策略\"></a>3.3 备份策略</h4><p>NameNode会尽力保证们每个数据块都有所需的备份数量。当Block Report从DataNode提交上来的时候，NameNode会侦测到数据块的备份数量是少于所需还是超过所需。当超过时，NameNode会选择删除一个数据备份。NameNode倾向于不减少rack的数量，并在DataNode中选择一个剩余磁盘空间最小的节点进行备份移除。这样做的主要目的是平衡利用DataNode的存储空间，并其不降低到数据块的可用性。</p>\n<p>当一个数据块处于低于其备份需求数的状态时，该数据块就会被放入到备份优先队列中。仅拥有一个数据备份的数据块处于最高优先级，其数据备份数高于其备份因子2/3的数据块则处于最低优先级。有一个后台进程专门负责定期对备份优先队列进行扫面，以确定将备份部署到何处。数据块备份遵循与数据块部署相似的策略。如果数据块当前只有一个备份，那么HDFS会把一个新的备份放到不同rack上。如果数据块当前有两个备份，并且连个备份都存在与相同的rack上，第三个备份就会被放到不同的rack上。否则，第三个备份就被放到同一rack的不同节点上。这么做的目的也是为了降低创建备份的代价。</p>\n<p>NameNode也会确保不把所有的数据块备份都部署到同一个rack上。如果NameNode侦测到某数据块的所有备份都在一个rack上，那么它就会把这个数据块当做是mis-replicated(误备份),然后它就会用上面所提到的策略，在其他的rack上把这个数据块再备份一次。在NameNode收到异地rack备份成功后，该数据块就成为了“备份数量高于所需备份数”状态。此时NameNode会根据策略把本地的一个备份删除，因为策略规定不能减少rack的数量。</p>\n<h3 id=\"4-文件一致性\"><a href=\"#4-文件一致性\" class=\"headerlink\" title=\"4 文件一致性\"></a>4 文件一致性</h3><h4 id=\"4-1-一致性简介\"><a href=\"#4-1-一致性简介\" class=\"headerlink\" title=\"4.1 一致性简介\"></a>4.1 一致性简介</h4><p>从<strong>客户端</strong>来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p>\n<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性</p>\n<p>从<strong>服务端</strong>角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：</p>\n<ul>\n<li>N — 数据复制的份数 </li>\n<li>W — 更新数据时需要保证写完成的节点数 </li>\n<li>R — 读取数据的时候需要读取的节点数 </li>\n</ul>\n<p>如果W+R&gt;N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。</p>\n<p>如果W+R&lt;=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。</p>\n<p>对于分布式系统，为了保证高可用性，一般设置N&gt;=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。</p>\n<ul>\n<li>如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。 </li>\n<li>如果N=R,W=1，只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。这种情况下，如果W&lt;(N+1)/2，并且写入的节点不重叠的话，则会存在写冲突  </li>\n</ul>\n<h4 id=\"4-2-一致性模型\"><a href=\"#4-2-一致性模型\" class=\"headerlink\" title=\"4.2 一致性模型\"></a>4.2 一致性模型</h4><p>HDFS牺牲了一些POSIX的需求来补偿性能，所以有些操作可能会和传统的文件系统不同。当创建一个文件时，它在文件系统的命名空间中是可见的，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">fs.create(p);</span><br><span class=\"line\">assertThat(fs.exists(p),is(<span class=\"keyword\">true</span>));</span><br></pre></td></tr></table></figure>\n<p>但是对这个文件的任何写操作不保证是可见的，即使在数据流已经刷新的情况下，文件的长度很长时间也会显示为0 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">OutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(<span class=\"number\">0L</span>));</span><br></pre></td></tr></table></figure>\n<p>一旦一个数据块写人成功，那么大家提出的新请求就可以看到这个块，而对当前写入的块，大家是看不见的。HDFS提供了使所有缓存和DataNode之间的数据强制同步的方法，这个方法是FSDataOutputStream中的sync()函数。当sync()函数返回成功时，HDFS就可以保证此时写入的文件数据是一致的并且对于所有新的用户都是可见的。即使HDFS客户端之间发生冲突，也会导致数据丢失，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">FSDataOutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">out.sync();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>这个操作类似于UNIX系统中的fsync系统调用，为一个文件描述符提交缓存数据，利用Java API写入本地数据，这样就可以保证看到刷新流并且同步之后的数据，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">FileOutputStream out = <span class=\"keyword\">new</span> FileOutStream(localFile);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();       <span class=\"comment\">//  flush to operatig system</span></span><br><span class=\"line\">out.getFD().sync();    <span class=\"comment\">//  sync to disk</span></span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>在HDFS中关闭一个文件也隐式地执行了sync()函数，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">OutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.close();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>文件系统的一致性与设计应用程序的方法有关。如果不调用sync()，那么需要做好因客户端或者系统发生故障而丢失部分数据做好准备。对大多数应用程序来说，这是不可接受的，所以需要在合适的地方调用sync()，比如在写入一定量的数据之后。尽管sync()被设计用来最大限度地减少HDFS的负担，但是它仍然有不可忽视的开销，所以需要在数据健壮性和吞吐最之间做好权衡，其中一个较好的参考平衡点就是:通过测试应用程序来选择不同sync()频率间的最佳平衡点。</p>\n<h3 id=\"5-文件读写\"><a href=\"#5-文件读写\" class=\"headerlink\" title=\"5 文件读写\"></a>5 文件读写</h3><h4 id=\"5-1-写策略\"><a href=\"#5-1-写策略\" class=\"headerlink\" title=\"5.1 写策略\"></a>5.1 写策略</h4><p>应用程序通过创建新文件以及向新文件写数据的方式，给HDFS系统添加数据。文件关闭以后，被写入的数据就无法再修改或者删除，只有以“追加”方式重新打开文件后，才能再次为文件添加数据。HDFS采用单线程写，多线程读的模式。</p>\n<p>HDFS客户端需要首先获得对文件操作的授权，然后才能对文件进行写操作。在此期间，其他的客户端都不能对该文件进行写操作。被授权的客户端通过向NameNode发送心跳信号来定期更新授权的状态。当文件关闭时，授权会被回收。文件授权期限分为软限制期和硬限制期两个等级。当处于软限制期内时，写文件的客户端独占对文件的访问权。当软限制过期后，如果客户端无法关闭文件，或没有释放对文件的授权，其他客户端即可以预定获取授权。当硬限制期过期后（一小时左右），如果此时客户端还没有更新（释放）授权，HDFS会认为原客户端已经退出，并自动终止文件的写行为，收回文件控制授权。文件的写控制授权并不会阻止其他客户端对文件进行读操作。因此一个文件可以有多个并行的客户端对其进行读取。</p>\n<p>HDFS文件由多个文件块组成。当需要创建一个新文件块时，NameNode会生成唯一的块ID，分配块空间，以及决定将块和块的备份副本存储到哪些DataNode节点上。DataNode节点会形成一个管道，管道中DataNode节点的顺序能够确保从客户端到上一DataNode节点的总体网络距离最小。文件的则以有序包（sequence of packets）的形式被推送到管道。应用程序客户端创建第一个缓冲区，并向其中写入字节。第一个缓冲区被填满后（一般是64 KB大小），数据会被推送到管道。后续的包随时可以推送，并不需要等前一个包发送成功并发回通知（这被称为“未答复发送”——译者注）。不过，这种未答复发送包的数目会根据客户端所限定的“未答复包窗口”(outstanding packets windows)的大小进行限制。</p>\n<p>在数据写入HDFS文件后，只要文件写操作没有关闭，HDFS就不保证数据在此期间对新增的客户端读操作可见。如果客户端用户程序需要确保对写入数据的可见性，可以显示地执行hflush操作。这样，当前的包就会被立即推送到管道，并且hflush操作会一直等到所有管道中的DataNode返回成功接收到数据的通知后才会停止。如此就可以保证所有在执行hflush之前所写入的数据对试图读取的客户端用户均可见。</p>\n<p>在一个集群的数千个节点里，节点失效（往往是因为存储故障造成的）每天都有可能发生。DataNode中所包含的文件块备份可能会因为内存、磁盘或者网络的错误而造成损坏。为了避免这种错误的形成，HDFS会为其文件的每个数据块生成并存储一份Checksum（总和检查）。Checksum主要供HDFS客户端在读取文件时检查客户端，DataNode以及网络等几个方面可能造成的数据块损坏。当客户端开始建立HDFS文件时，会检查文件的每个数据块的checksum序列，并将其与数据一起发送给DataNode。 DataNode则将checksum存放在文件的元数据文件里，与数据块的具体数据分开存放。当HDFS读取文件时，文件的每个块数据和checksum均被发送到客户端。客户端会即时计算出接受的块数据的checksum, 并将其与接受到的checksum进行匹配。如果不匹配，客户端会通知NameNode，表明接受到的数据块已经损坏，并尝试从其他的DataNode节点获取所需的数据块。</p>\n<p>当客户端打开一个文件进行读取时，会从NameNode中获得一个文件数据块列表，列表中包含了每一个所需的数据块的具体位置。这些位置会按照与客户端的距离进行排序。当具体进行数据块读取时，客户端总是尝试首先从最近的位置获取数据。如果尝试失败，客户端会根据排序的顺寻，从下一个位置获取数据。下列情况可能会造成数据读取失败：DataNode不可用，节点不再包含所需数据块，或者数据块备份损坏，以及checksum验证失败。<br>HDFS允许客户端从正在进行写操作的文件中读取数据。当进行这样的操作时，目前正在被写入的数据块对于NameNode来说是未知的。在这样的情况下，客户端会从所有数据块备份中挑选一个数据块，以这个数据块的最后长度作为开始读取数据之前的数据长度。HDFS I/O的设计是专门针对批处理系统进行优化的，比如MapReduce系统，这类系统对顺序读写的吞吐量都有很高的要求。针对于那些需要实时数据流以及随机读写级别的应用来说，系统的读/写响应时间还有待于优化，目前正在做这方面的努力。</p>\n<h4 id=\"5-2-读策略\"><a href=\"#5-2-读策略\" class=\"headerlink\" title=\"5.2 读策略\"></a>5.2 读策略</h4><p>读相对于写，简单一些，详细步骤如下：</p>\n<ol>\n<li>client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。</li>\n<li>就近挑选一台datanode服务器，请求建立输入流 。</li>\n<li>DataNode向输入流中中写数据，以packet为单位来校验。</li>\n<li>关闭输入流</li>\n</ol>\n<h2 id=\"三-MapReduce计算\"><a href=\"#三-MapReduce计算\" class=\"headerlink\" title=\"三 MapReduce计算\"></a>三 MapReduce计算</h2><h3 id=\"1-简介-1\"><a href=\"#1-简介-1\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p>MapReduce是Google提出的一个软件架构，也是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（归约）”，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>\n<h3 id=\"2-工作原理\"><a href=\"#2-工作原理\" class=\"headerlink\" title=\"2 工作原理\"></a>2 工作原理</h3><h4 id=\"2-1-Map\"><a href=\"#2-1-Map\" class=\"headerlink\" title=\"2.1 Map\"></a>2.1 Map</h4><p>程序根据输入格式将输入文件划分为多个部分，每个部分均用作映射。任务输入，每个map任务都有一个内存缓冲区，输入数据在映射阶段进行处理，中间结果被写入存储缓冲区，并由写入数据的一方确定。当数据达到内存缓冲区阈值（默认值为0.8）时，会启动线程将内存中溢出的数据写入磁盘，并继续缓冲而不影响映射的中间结果。在溢出写入过程中，MapReduce框架对键进行排序。如果中间结果相对较大，则会形成多个溢出文件。最后缓冲区中的数据也被写入磁盘，从而形成一个溢出文件（至少一个溢出文件）。如果有多个溢出文件，则所有文件最后都会合并为一个文件。</p>\n<h4 id=\"2-2-Reduce\"><a href=\"#2-2-Reduce\" class=\"headerlink\" title=\"2.2 Reduce\"></a>2.2 Reduce</h4><p>当所有的映射任务完成后，每个映射任务会形成一个最终文件，并且该文件按区划分。reduce 任务启动之前，一个映射任务完成后，就会启动线程来拉取映射结果数据到相应的规约任务，不断地合并数据，为规约的数据输入做准备，当所有的射任务完成完成后，数据也拉取合并完毕后，规约任务启动，最终将输出结果存入HDFS 上。</p>\n<h3 id=\"3-MapReduce运行流程\"><a href=\"#3-MapReduce运行流程\" class=\"headerlink\" title=\"3 MapReduce运行流程\"></a>3 MapReduce运行流程</h3><h4 id=\"3-1-分析-MapReduce-执行过程\"><a href=\"#3-1-分析-MapReduce-执行过程\" class=\"headerlink\" title=\"3.1 分析 MapReduce 执行过程\"></a>3.1 分析 MapReduce 执行过程</h4><p>MapReduce运行的时候，输入输出都是HDFS中的文件，首先，Mapper中运行的任务会去读取HDFS中的数据文件，通过调用map中的方法来处理数据，然后将处理结果输出给Reducer任务，Reducer将接收到的结果作为自己的输入数据，并且也调用自己的方法，将最后的结果输出到HDFS中。过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/ZyxlBMGXXPu08Qws.png!original\" alt=\"img\"></p>\n<h4 id=\"3-2-Mapper-任务执行过程详解\"><a href=\"#3-2-Mapper-任务执行过程详解\" class=\"headerlink\" title=\"3.2 Mapper 任务执行过程详解\"></a>3.2 Mapper 任务执行过程详解</h4><p>每个Mapper 任务是一个java 进程，它会读取HDFS 中的文件，解析成很多的键值对，经过我们覆盖的map 方法处理后，转换为很多的键值对再输出。整个Mapper 任务的处理过程又可以分为以下几个阶段：</p>\n<ol>\n<li>第一阶段是把输入文件按照一定的标准分片(InputSplit)，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的。如果数据块(Block)的大小是默认值64MB，输入文件有两个，一个是32MB，一个是72MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由一个Mapper 进程处理。这里的三个输入片，会有三个Mapper 进程处理。</li>\n<li>第二阶段是对输入片中的记录按照一定的规则解析成键值对。有个默认规则是把每一行文本内容解析成键值对。“键”是每一行的起始位置(单位是字节)，“值” 是本行的文本内容。</li>\n<li>第三阶段是调用Mapper 类中的map 方法。第二阶段中解析出来的每一个键值对，调用一次map 方法。如果有1000 个键值对，就会调用1000 次map方法。每一次调用map 方法会输出零个或者多个键值对。</li>\n<li>第四阶段是按照一定的规则对第三阶段输出的键值对进行分区。比较是基于键进行的。比如我们的键表示省份(如北京、上海、山东等)，那么就可以按照不同省份进行分区，同一个省份的键值对划分到一个区中。默认是只有一个区。分区的数量就是Reducer 任务运行的数量。默认只有一个Reducer 任务。</li>\n<li>第五阶段是对每个分区中的键值对进行排序。首先，按照键进行排序，对于键相同的键值对，按照值进行排序。比如三个键值对&lt;2,2&gt;、&lt;1,3&gt;、&lt;2,1&gt;，键和值分别是整数。那么排序后的结果是&lt;1,3&gt;、&lt;2,1&gt;、&lt;2,2&gt;。如果有</li>\n<li>第六阶段，那么进入第六阶段；如果没有，直接输出到本地的linux 文件中。第六阶段是对数据进行归约处理，也就是reduce 处理。键相等的键值对会调用一次reduce 方法。经过这一阶段，数据量会减少。归约后的数据输出到本地的linux文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。</li>\n</ol>\n<p>上述过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2kbg02YRqSS3ZofE.png!original\" alt=\"img\"></p>\n<h4 id=\"3-3-Reduce任务执行过程详解\"><a href=\"#3-3-Reduce任务执行过程详解\" class=\"headerlink\" title=\"3.3 Reduce任务执行过程详解\"></a>3.3 Reduce任务执行过程详解</h4><p>每个Reducer 任务是一个java 进程。Reducer 任务接收Mapper 任务的输出，归约处理后写入到HDFS 中，可以分为如下几个阶段。</p>\n<ol>\n<li>第一阶段是Reducer 任务会主动从Mapper 任务复制其输出的键值对。Mapper 任务可能会有很多，因此Reducer 会复制多个Mapper 的输出。</li>\n<li>第二阶段是把复制到Reducer 本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。</li>\n<li>第三阶段是对排序后的键值对调用reduce 方法。键相等的键值对调用一次reduce 方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS 文件中。</li>\n</ol>\n<p>在整个MapReduce 程序的开发过程中，我们最大的工作量是覆盖map 函数和覆盖reduce 函数。上述过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2YC2iJF2OJvYbs1R.png!original\" alt=\"img\"></p>\n<h4 id=\"3-4-键值对的编号\"><a href=\"#3-4-键值对的编号\" class=\"headerlink\" title=\"3.4 键值对的编号\"></a>3.4 键值对的编号</h4><p>在对Mapper 任务、Reducer 任务的分析过程中，会看到很多阶段都出现了键值对，这里对键值对进行编号，方便理解键值对的变化情况，对于Mapper 任务输入的键值对，定义为key1 和value1。在map 方法中处理后，输出的键值对，定义为key2 和value2。reduce 方法接收key2 和value2，处理后，输出key3 和value3。具体如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dXULEPSCEIT3QZW0.png!original\" alt=\"img\"></p>\n<h3 id=\"4-MapReduce实现\"><a href=\"#4-MapReduce实现\" class=\"headerlink\" title=\"4 MapReduce实现\"></a>4 MapReduce实现</h3><p>MapReduce 在执行的时候，先执行Map 函数，再执行Reduce 函数，达到分布式并行运算效果。其中Map 函数与Reduce 函数需要用户自行设计，而这两个任务也定义了任务本身。</p>\n<h4 id=\"4-1-统计平均通话次数\"><a href=\"#4-1-统计平均通话次数\" class=\"headerlink\" title=\"4.1 统计平均通话次数\"></a>4.1 统计平均通话次数</h4><p>需要用到的数据为：主叫号码。仅需统计每个主叫号码在数据文件中出现的次数，用该数除以天数，即可得到平均值。与WordCount 类似，提取出第二列数据即可进行。具体代码如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/f7g9O8xBBwHpkdZB.png!original\" alt=\"img\"></p>\n<p>结果如下图所示，其中每一行有两个数据，第一列为主叫号码，第二列为平均每日通话次数：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/NM80fSViYPVEfD3Q.png!original\" alt=\"img\"></p>\n<h4 id=\"4-2-统计不同通话类型下各运营商占比\"><a href=\"#4-2-统计不同通话类型下各运营商占比\" class=\"headerlink\" title=\"4.2 统计不同通话类型下各运营商占比\"></a>4.2 统计不同通话类型下各运营商占比</h4><p>需要用到的数据为：通话类型，主叫号码运营商，被叫号码运营商。与第一个需求不同，本需求的key 值由两个数共同组成，需要定义一个新的类用来包含通话类型和运行商。定义如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/aCFEDYqbUtuMMWFm.png!original\" alt=\"img\"></p>\n<p>其中需要注意，由于key 中数据的个数不唯一，需要对内部的数据优先级进行规定，所以要重写compareTo 函数，对key 进行排序。主函数中需要注意Map 阶段的输出类型和Reduce 阶段的输入输出类型，代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/khmfgplaXcfeVygE.png!original\" alt=\"img\"></p>\n<p>结果如下图，其中1代表电信，2 代表移动，3 代表联通：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dw7Q7n01PquYb8xX.png!original\" alt=\"img\"></p>\n<p><img src=\"https://uploader.shimo.im/f/pTZXRD60QSU3j9Un.png!original\" alt=\"img\"></p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/3rK4jBFXZs3Ig47t.png!original\" alt=\"img\"></p>\n<h4 id=\"4-3-统计用户在各个时间段通话时长所占比例\"><a href=\"#4-3-统计用户在各个时间段通话时长所占比例\" class=\"headerlink\" title=\"4.3 统计用户在各个时间段通话时长所占比例\"></a>4.3 统计用户在各个时间段通话时长所占比例</h4><p>所需用到的数据有：主叫电话号码，通话开始时间，通话结束时间。最后输出的形式是一长串的数组，因此同样需要设计一个新的类用于封装。与上一需求不同的是，该类用于value 的输入和输出。代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/rlXjbmDdWKPLQS5R.png!original\" alt=\"img\"></p>\n<p>为了完成统计任务，还需要自己求出每个时间段的时间，才能统计占比。这需要设计统计时间段内持续时间的算法，代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/iwXvfrzHPmTxAVJ9.png!original\" alt=\"img\"></p>\n<p>主函数与上一需求类似，区别在于Reduce 阶段的结果输出为浮点型数据，需要再同最开始一样重新定义一个浮点结果类，才能输出。</p>\n<p>结果如下图所示，每一行有9 个数据，第一列为主叫号码，第二到第八列为对应时间段中通话时长占一天的比例：</p>\n<p><img src=\"https://uploader.shimo.im/f/tSgwVy0seIoRbjlJ.png!original\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>组员：</strong><br>2031570 谈瑞<br>2031568 薛锦伟</p>\n</blockquote>\n<p>分布式计算期末项目简单记录，水一水~</p>","more":"<h2 id=\"一-系统架构\"><a href=\"#一-系统架构\" class=\"headerlink\" title=\"一 系统架构\"></a>一 系统架构</h2><h3 id=\"1-Hadoop基本介绍\"><a href=\"#1-Hadoop基本介绍\" class=\"headerlink\" title=\"1 Hadoop基本介绍\"></a>1 Hadoop基本介绍</h3><p>Hadoop是一个高可靠的(reliable)，规模可扩展的(scalable)，分布式(distributed computing)的开源软件框架。它使我们能用一种简单的编程模型来处理存储于集群上的大数据集。</p>\n<p>Hadoop是Apache基金会的一个开源项目，是一个提供了分布式存储和分布式计算功能的基础架构平台。可以应用于企业中的数据存储，日志分析，商业智能，数据挖掘等。其为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop 还提供了分布式文件系统HDFS，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。</p>\n<p>由于Hadoop的架构与本次项目需求较吻合，因此我们直接使用Hadoop的HDFS和MapReduce框架来进行此次项目所需要的分布式系统的实现。</p>\n<h3 id=\"2-集群架构图\"><a href=\"#2-集群架构图\" class=\"headerlink\" title=\"2 集群架构图\"></a>2 集群架构图</h3><p><img src=\"/images/image-20181228192856958-5996536.png\" alt=\"image-20181228192856958\"></p>\n<h3 id=\"3-集群机器\"><a href=\"#3-集群机器\" class=\"headerlink\" title=\"3 集群机器\"></a>3 集群机器</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">主机名</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">软件</th>\n<th style=\"text-align:center\">运行进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">node0</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.200</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node1</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.201</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">node2</td>\n<td style=\"text-align:center\">512MB</td>\n<td style=\"text-align:center\">192.168.137.202</td>\n<td style=\"text-align:center\">ZooKeeper</td>\n<td style=\"text-align:center\">QuorumPeerMain</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.100</td>\n<td style=\"text-align:center\">Hadoop,Hive,MySql</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">master1</td>\n<td style=\"text-align:center\">2GB</td>\n<td style=\"text-align:center\">192.168.137.10</td>\n<td style=\"text-align:center\">Hadoop,Hive</td>\n<td style=\"text-align:center\">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave1</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.101</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">JournalNode,DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave2</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.102</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">slave3</td>\n<td style=\"text-align:center\">1GB</td>\n<td style=\"text-align:center\">192.168.137.103</td>\n<td style=\"text-align:center\">Hadoop</td>\n<td style=\"text-align:center\">DataNode,NodeManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">host</td>\n<td style=\"text-align:center\">8GB</td>\n<td style=\"text-align:center\">192.168.137.1</td>\n<td style=\"text-align:center\">应用服务器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-集群搭建\"><a href=\"#4-集群搭建\" class=\"headerlink\" title=\"4 集群搭建\"></a>4 集群搭建</h3><h4 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1 简介\"></a>4.1 简介</h4><p>集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。</p>\n<h4 id=\"4-2-虚拟机创建\"><a href=\"#4-2-虚拟机创建\" class=\"headerlink\" title=\"4.2 虚拟机创建\"></a>4.2 虚拟机创建</h4><p>此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。</p>\n<p>首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的<code>Host-Only</code>连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。</p>\n<p>在主机网络设置中共享网络：</p>\n<p><img src=\"/images/image-20181228201105314-5999065.png\" alt=\"image-20181228201105314\"></p>\n<p>在VirtualBox中执行以下操作设置主机连接方式：</p>\n<p><img src=\"/images/image-20181228200129326-5998489.png\" alt=\"image-20181228200129326\"></p>\n<p>在虚拟机终端执行以下操作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改虚拟机的IP、子网掩码</span></span><br><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">IPADDR=192.168.137.100</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改网关地址</span></span><br><span class=\"line\">vim /etc/sysconfig/network</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">GATEWAY=192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br><span class=\"line\"><span class=\"comment\"># 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP</span></span><br><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname master</span><br><span class=\"line\"><span class=\"comment\"># 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"><span class=\"comment\"># 重启网络服务</span></span><br><span class=\"line\">systemctl restart network</span><br><span class=\"line\"><span class=\"comment\"># 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功</span></span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\"><span class=\"comment\"># 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105</span></span><br><span class=\"line\">ping 61.135.169.105</span><br><span class=\"line\"><span class=\"comment\"># 修改hosts文件，添加局域网中其他主机的主机名与ip的映射</span></span><br><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"><span class=\"comment\"># 修改为以下内容</span></span><br><span class=\"line\">192.168.137.100 master</span><br><span class=\"line\">192.168.137.10 master1</span><br><span class=\"line\">192.168.137.101 slave1</span><br><span class=\"line\">192.168.137.102 slave2</span><br><span class=\"line\">192.168.137.103 slave3</span><br><span class=\"line\">192.168.137.200 node0</span><br><span class=\"line\">192.168.137.201 node1</span><br><span class=\"line\">192.168.137.202 node2</span><br><span class=\"line\">0.0.0.0 localhost</span><br><span class=\"line\"><span class=\"comment\"># 保存退出</span></span><br></pre></td></tr></table></figure>\n<p>至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先添加Hadoop和Hive相关环境变量</span></span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"><span class=\"comment\"># 添加下列内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_MAPRED_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=<span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop</span><br><span class=\"line\"><span class=\"built_in\">export</span> HIVE_HOME=/usr/<span class=\"built_in\">local</span>/hive</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$HIVE_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 保存退出，并使环境变量生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<p>Hadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。</p>\n<h4 id=\"4-3-虚拟机复制\"><a href=\"#4-3-虚拟机复制\" class=\"headerlink\" title=\"4.3 虚拟机复制\"></a>4.3 虚拟机复制</h4><p>上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。</p>\n<h5 id=\"4-3-1-网络配置\"><a href=\"#4-3-1-网络配置\" class=\"headerlink\" title=\"4.3.1 网络配置\"></a>4.3.1 网络配置</h5><p>对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：</p>\n<ul>\n<li><p>修改IP</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的IP将<code>IPADDR</code>项修改为对应的IP</p>\n</li>\n<li><p>修改主机名</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl <span class=\"built_in\">set</span>-hostname XXX</span><br></pre></td></tr></table></figure>\n<p>针对<a href=\"#a1\">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名</p>\n</li>\n<li><p>重启网络服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ping各个节点测试是否成功</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping master</span><br><span class=\"line\">ping master1</span><br><span class=\"line\">ping slave1</span><br><span class=\"line\">ping slave2</span><br><span class=\"line\">ping slave3</span><br><span class=\"line\">ping node0</span><br><span class=\"line\">ping node1</span><br><span class=\"line\">ping node2</span><br><span class=\"line\">ping 192.168.137.1</span><br><span class=\"line\">ping 61.135.169.105</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"4-3-2-Hadoop配置\"><a href=\"#4-3-2-Hadoop配置\" class=\"headerlink\" title=\"4.3.2 Hadoop配置\"></a>4.3.2 Hadoop配置</h5><ol>\n<li>修改core-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：Hadoop集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.permissions.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>ha.zookeeper.quorum<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2182,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 允许访问此hdfs的主机和群组，此处设置为任意 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>修改hdfs-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hdfs集群配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定dfs文件存储位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/hadoop-data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定文件备份份数 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定机器运行情况检查时间间隔 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.heartbead.recheck-interval<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>3000000ms<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.nameservices<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- NS下面的NameNode --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.namenodes.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>nn1,nn2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:50070<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>qjournal://master:8485;master1:8485;slave1:8485/ns<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.journalnode.edits.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/journaldata<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 开启机器故障自动切换主从机器 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法(java类的名称) --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 指定failover切换的方法，这里使用ssh通信方式交换 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.methods<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                sshfence</span><br><span class=\"line\">                shell(/bin/true)</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- ssh切换方法需要指定私钥文件位置 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/root/.ssh/id_rsa<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<ul>\n<li>假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li>\n<li>当使用jdbc访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>修改slaves文件</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/slaves</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：为各个master指定为其工作的slave</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">slave1</span><br><span class=\"line\">slave2</span><br><span class=\"line\">slave3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>修改yarn-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HADOOP_HOME</span>/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：yarn集群的核心配置文件</p>\n</li>\n<li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用yarn集群的高可用机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定ResourceManager集群id，可为任意字串 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yrc<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>rm1,rm2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的主机名 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定两台ResourceManager的web端口，正常情况为8088 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master1:8088<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定管理集群的Zookeeper集群的地址及对应端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>node0:2181,node1:2181,node2:2181<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定jar包路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li>修改mapred-site.xml</li>\n</ol>\n<ul>\n<li><p>作用：指定MapReduce操作的基本属性</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.application.classpath<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce</li>\n<li>此项若是不配，一些job只会在本机跑，而不会分发给其他机器</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>修改hive-site.xml</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim <span class=\"variable\">$HIVE_HOME</span>/conf/hive-site.xml</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>作用：hive的基本配置</p>\n</li>\n<li><p>需要修改的机器：master、master1</p>\n</li>\n<li><p>内容：</p>\n<ul>\n<li><p>修改<code>hive.server2.webui.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.webui.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The host address the HiveServer2 WebUI will listen on<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.bind.host</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.thrift.bind.host<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>$&#123;hostname&#125;<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Bind host on which to run the HiveServer2 Thrift service.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p>\n</li>\n<li><p>修改<code>hive.server2.zookeeper.namespace</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hive.server2.zookeeper.namespace<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hiveserver2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。</p>\n</li>\n<li><p>修改<code>javax.jdo.option.ConnectionURL</code>、<code>javax.jdo.option.ConnectionPassword</code>和<code>javax.jdo.option.ConnectionDriverName</code></p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">      JDBC connect string for a JDBC metastore.</span><br><span class=\"line\">      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class=\"line\">      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>password to use against metastore database<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Driver class name for a JDBC metastore<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(<del>此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据</del>)。</p>\n<p>  另外，mysql的连接jar包需要下载并复制到hive的lib目录下。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。</p>\n<h5 id=\"4-3-3-Zookeeper配置\"><a href=\"#4-3-3-Zookeeper配置\" class=\"headerlink\" title=\"4.3.3 Zookeeper配置\"></a>4.3.3 Zookeeper配置</h5><p>对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /usr/<span class=\"built_in\">local</span>/zookeeper/conf/zoo.cfg</span><br><span class=\"line\"><span class=\"comment\"># 添加一下内容</span></span><br><span class=\"line\">server.1=192.168.137.200:2888:3888</span><br><span class=\"line\">server.2=192.168.137.201:2888:3888</span><br><span class=\"line\">server.3=192.168.137.202:2888:3888</span><br><span class=\"line\"><span class=\"comment\"># 保存并关闭</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"4-3-4-ssh免密登录配置\"><a href=\"#4-3-4-ssh免密登录配置\" class=\"headerlink\" title=\"4.3.4 ssh免密登录配置\"></a>4.3.4 ssh免密登录配置</h5><ul>\n<li><p>作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的</p>\n</li>\n<li><p>需要修改的机器：所有机器</p>\n</li>\n<li><p>内容：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入用户目录下的`.ssh`目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> .ssh/</span><br><span class=\"line\"><span class=\"comment\"># 创建公钥私钥对</span></span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\"># 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍</span></span><br><span class=\"line\">ssh-copy-id <span class=\"variable\">$&#123;hostname&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。</p>\n<h4 id=\"4-4-集群启动\"><a href=\"#4-4-集群启动\" class=\"headerlink\" title=\"4.4 集群启动\"></a>4.4 集群启动</h4><h5 id=\"4-4-1-初始化数据库\"><a href=\"#4-4-1-初始化数据库\" class=\"headerlink\" title=\"4.4.1 初始化数据库\"></a>4.4.1 初始化数据库</h5><p>在master机器上执行以下操作以初始化数据库：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HIVE_HOME</span></span><br><span class=\"line\">schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure>\n<p>此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。</p>\n<h5 id=\"4-4-2-启动集群\"><a href=\"#4-4-2-启动集群\" class=\"headerlink\" title=\"4.4.2 启动集群\"></a>4.4.2 启动集群</h5><p>在master机器上执行以下操作以启动集群：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">start-all.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-HDFS文件系统\"><a href=\"#二-HDFS文件系统\" class=\"headerlink\" title=\"二 HDFS文件系统\"></a>二 HDFS文件系统</h2><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><h4 id=\"1-1-HDFS简介\"><a href=\"#1-1-HDFS简介\" class=\"headerlink\" title=\"1.1 HDFS简介\"></a>1.1 HDFS简介</h4><p>HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p>\n<h4 id=\"1-2-NameNode与DataNode\"><a href=\"#1-2-NameNode与DataNode\" class=\"headerlink\" title=\"1.2 NameNode与DataNode\"></a>1.2 NameNode与DataNode</h4><p>HDFS由四部分组成，HDFS Client、NameNode、DataNode和Secondary NameNode。整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p>\n<p><img src=\"/images/image-20210105151742421.png\" alt=\"image-20210105151742421\"></p>\n<p>Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：Namespcae image和Edit log。但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。NameNode 的文件结构包含 edits、fsimage、seen_txid、VERSION 以及 in_use.lock。其中， edits 为编辑日志（edit log）， 当客户端执行写操作时， NameNode 会先在编辑日志中写入记录，并在内存中保存一个文件系统的元数据。这一描述 符会在编辑日志改动后更新。fsimage 为文件系统镜像，是文件系统元数据的持久检查点，包含以序列化 格式存储的文件系统目录和文件 inodes，每个 inodes 表征一个文件或目录的元数 据信息以及文件的副本数、修改和访问时间等信息。seen_txid 文件代表的是 NameNode 中 edits_*文件的尾数，当 NameNode 重 启后，会按照 seen_txid 所定义的数字，循序从头运行 edits_0000001~至 seen_txid。VERSION 文件是 java 的属性文件，保存了 HDFS 的版本号。in_use.lock 的作用是防止一台机器同时启动多个 NameNode 进程，导致目录 数据不一致。</p>\n<p>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： <br>1）备份持久化元数据<br>将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。<br>2）Secondary Namenode<br>Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。SecondaryNameNode 的文件结构主要包括 edits、fsimage、VERSION 以及 in_use.lock。其中edits、fsimage、VERSION的内容均与NameNode相同，in_use.lock 的作用是防止一台机器同时启动多个 SecondaryNameNode 进程导致目录数据不 一致。</p>\n<p>而DataNode则会负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。DataNode 的文件结构主要包含 BP-前缀文件、blk前缀文件、VERSION 和 in_use.lock。 其中 BP-random integer-NameNode IP address-creation time 的 BP 代表 BlockPool，即 NameNode 的 VERSION 集群中唯一的 blockpoolID；finalized/rbw 目录用于存储 HDFS BLOCK 的数据， blk_前缀文件是 HDFS 中的文件块本身， 存储的是原始文件内容；VERSION 及 in_use.lock 的含义与上述类似。</p>\n<p>我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。</p>\n<h3 id=\"2-分块机制\"><a href=\"#2-分块机制\" class=\"headerlink\" title=\"2 分块机制\"></a>2 分块机制</h3><h4 id=\"2-1-分块机制简介\"><a href=\"#2-1-分块机制简介\" class=\"headerlink\" title=\"2.1 分块机制简介\"></a>2.1 分块机制简介</h4><p>物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。</p>\n<h4 id=\"2-2-块分配流程\"><a href=\"#2-2-块分配流程\" class=\"headerlink\" title=\"2.2 块分配流程\"></a>2.2 块分配流程</h4><p>通常当一个客户端<code>a</code>机器发起请求分配块请求，NN接收到请求后，执行如下块分配流程：<br>1）  如果a不是一个DataNode，则在集群范围内随机选择一个节点作为目标节点，否则执行下面的2,3步骤；<br>2） 判断a机器是否符合存储数据块的目标节点，如果符合，第一个块副本分配完毕；<br>3）如果a机器不符合作为目标节点，则在于与a机器同机架范围内寻找，如果找到目标节点，第一个块副本分配完毕；<br>4）如果在同一个机架内未找到符合要求的目标节点，则在集群内随机查找，找到则第一个块副本分配完毕，否则未找到符合条件的块，块分配失败；<br>5）如果已经成功分配第一个块副本，则与a不同机架的远程机架内寻找目标节点，如果符合，第二个块副本分配完毕；<br>6）如果在远程机架内未找到符合要求的目标节点，在与a相同的本机架寻找，如果找到则第二个块副本分配完毕；否则未找到符合条件的块，第二份块分配失败；<br>7）如果前2个块副本分配成功，则准备分配第三个副本的目标节点，首先会判断前两份是否在同一个机架，如果是，则在远程机架寻找目标节点，找到则第三份副本分配完毕；如果前两份在不同机架，则在与a相同机架内寻找，如果找到则第三份副本分配完毕，否则在集群范围寻找，找到则第三份分配完毕，否则第三份分配失败<br>8）如果块副本大于三分，则在集群范围内随机寻找节点</p>\n<p>当在一个范围内找到一个节点后，还需要经过如上的条件判断，才能确定一个DataNode进程是否可以作为目标节点：<br>1） 如果没有节点机器被选择，则该节点可以作为备选节点，否则需要判断下一个DataNode是否符合要求；（这样就防止同一个块副本存储到同一台机器）<br>2） 然后判断节点是否退役，存储空间是否足够，负载是否大于2倍平均负载，本机架选择的节点是否超过限制，如果均满足，则该datanode符合要求，否则需要判断下一个DataNode是否符合要求</p>\n<h3 id=\"3-备份策略\"><a href=\"#3-备份策略\" class=\"headerlink\" title=\"3 备份策略\"></a>3 备份策略</h3><h4 id=\"3-1-备份策略简介\"><a href=\"#3-1-备份策略简介\" class=\"headerlink\" title=\"3.1 备份策略简介\"></a>3.1 备份策略简介</h4><p>对于HDFS而言，由Namenode负责这个集群的数据备份和分配，在分配过程中，主要考虑下面两个因素：</p>\n<ul>\n<li>数据安全：在某个节点发生故障时，不会丢失数据备份；</li>\n<li>网络传输开销：在备份数据同步过程中，尽量减少网络传输中的带宽开销；</li>\n</ul>\n<p>这两个因素看起来是有些相互矛盾的：想要保证数据安全，那么就尽量把数据备份到多台节点上，但是就需要向多个节点传输数据；想要减少网络传输开销，那么就尽可能把数据备份到一个节点内部或者一个机架内部，因为系统内部的数据传输速度会远大于网络传输的速度。</p>\n<h4 id=\"3-2-数据块部署\"><a href=\"#3-2-数据块部署\" class=\"headerlink\" title=\"3.2 数据块部署\"></a>3.2 数据块部署</h4><p>对于巨大的集群来说，把所有的节点都部署在一个平行的拓扑结构里是不太现实的。比较实际且通用的做法是，把所有的节点分布到多个Rack(服务器机架)上。每个Rack上的节点共享一个交换机，Rack之间可以使用一个或者多个核心交换机进行互联。在大多数情况下，同一Rack中的节点间通信的带宽肯定会高于不同Rack间节点的通信带宽。HDFS默认两个节点之间的网络带宽与他们的物理距离成正比。从一个节点到其父节点的距离被认为是常数1。这样，两个节点之间的距离可以通过将其到各级祖先节点的距离相加计算出来。两个节点之间的距离越短，就意味着他们之间传输数据的带宽越大。<br>HDFS允许管理员通过配置脚本，返回一个节点的rack标识符，作为节点地址。NameNode位于整个结构的最中央，负责解析每一个DataNode的rack位置。当DataNode注册到NameNode时，NameNode会运行这些配置脚本，确定节点属于哪个rack。如果没有进行脚本配置，NameNode则会认为所有的节点都属于一个默认的Rack。</p>\n<p>数据块备份的部署对于HDFS数据的可靠性和读写性能都有至关重要的影响。良好的数据块部署策略能够有效地改进数据的可靠性，可用性，甚至提高网络带宽的利用率。目前的HDFS系统提供了可配置的数据块部署策略接口，以此来让用户和研究人员能够对不同的部署策略进行测验，从而达到对系统应用进行优化的目的。</p>\n<p>缺省的HDFS数据块部署策略企图在降低数据写入代价，最大化数据可靠性，可用性，以及整合读数据带宽等几个方面做出权衡。当一个新的数据块被创建，HDFS会把第一个数据开备份放到写入程序所在的位置。第二个和第三个数据块备份会被部署到不同rack的其他两个不同的节点。剩余的数据块备份则被放到随机的节点上，但是限制每个节点不会部署多于一个相同的数据块，每个rack不会部署都与两个相同的数据块（如果条件满足的话）。之所以要把第二个和第三个数据块备份放到不同的rack上，是为了考虑到一个集群上的文件所应当具有的分布性。如果头两个数据块备份放到相同的rack上，那么对于任何文件来说，其2/3的文件块会被存放在同一rack上。</p>\n<p>在所有目标节点都被选择后，这些节点会被有组织地按照其亲近程度，以流水线的方式被传输到第一个备份上。数据会被以这个顺序推送到节点。在读取的时候，NameNode首先会检查客户端所对应的主机是否位于集群当中。如果是，那么数据块的位置会被返回到客户端，并以按照距离远近排序。然后数据块就会按照顺序从DataNode中进行读取。<br>这一策略会降低rack之间以及节点之间的写入时间，普遍提高写入效率。因为rack故障的几率远低于节点故障的几率，所以该策略不会影响到数据的有效性和可用性。在大多数使用3数据块备份的情况下，该策略能够降低网络带宽的消耗，因为一个数据块只需要部署到两个不同的rack上，而不是3个。</p>\n<h4 id=\"3-3-备份策略\"><a href=\"#3-3-备份策略\" class=\"headerlink\" title=\"3.3 备份策略\"></a>3.3 备份策略</h4><p>NameNode会尽力保证们每个数据块都有所需的备份数量。当Block Report从DataNode提交上来的时候，NameNode会侦测到数据块的备份数量是少于所需还是超过所需。当超过时，NameNode会选择删除一个数据备份。NameNode倾向于不减少rack的数量，并在DataNode中选择一个剩余磁盘空间最小的节点进行备份移除。这样做的主要目的是平衡利用DataNode的存储空间，并其不降低到数据块的可用性。</p>\n<p>当一个数据块处于低于其备份需求数的状态时，该数据块就会被放入到备份优先队列中。仅拥有一个数据备份的数据块处于最高优先级，其数据备份数高于其备份因子2/3的数据块则处于最低优先级。有一个后台进程专门负责定期对备份优先队列进行扫面，以确定将备份部署到何处。数据块备份遵循与数据块部署相似的策略。如果数据块当前只有一个备份，那么HDFS会把一个新的备份放到不同rack上。如果数据块当前有两个备份，并且连个备份都存在与相同的rack上，第三个备份就会被放到不同的rack上。否则，第三个备份就被放到同一rack的不同节点上。这么做的目的也是为了降低创建备份的代价。</p>\n<p>NameNode也会确保不把所有的数据块备份都部署到同一个rack上。如果NameNode侦测到某数据块的所有备份都在一个rack上，那么它就会把这个数据块当做是mis-replicated(误备份),然后它就会用上面所提到的策略，在其他的rack上把这个数据块再备份一次。在NameNode收到异地rack备份成功后，该数据块就成为了“备份数量高于所需备份数”状态。此时NameNode会根据策略把本地的一个备份删除，因为策略规定不能减少rack的数量。</p>\n<h3 id=\"4-文件一致性\"><a href=\"#4-文件一致性\" class=\"headerlink\" title=\"4 文件一致性\"></a>4 文件一致性</h3><h4 id=\"4-1-一致性简介\"><a href=\"#4-1-一致性简介\" class=\"headerlink\" title=\"4.1 一致性简介\"></a>4.1 一致性简介</h4><p>从<strong>客户端</strong>来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p>\n<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性</p>\n<p>从<strong>服务端</strong>角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：</p>\n<ul>\n<li>N — 数据复制的份数 </li>\n<li>W — 更新数据时需要保证写完成的节点数 </li>\n<li>R — 读取数据的时候需要读取的节点数 </li>\n</ul>\n<p>如果W+R&gt;N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。</p>\n<p>如果W+R&lt;=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。</p>\n<p>对于分布式系统，为了保证高可用性，一般设置N&gt;=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。</p>\n<ul>\n<li>如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。 </li>\n<li>如果N=R,W=1，只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。这种情况下，如果W&lt;(N+1)/2，并且写入的节点不重叠的话，则会存在写冲突  </li>\n</ul>\n<h4 id=\"4-2-一致性模型\"><a href=\"#4-2-一致性模型\" class=\"headerlink\" title=\"4.2 一致性模型\"></a>4.2 一致性模型</h4><p>HDFS牺牲了一些POSIX的需求来补偿性能，所以有些操作可能会和传统的文件系统不同。当创建一个文件时，它在文件系统的命名空间中是可见的，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">fs.create(p);</span><br><span class=\"line\">assertThat(fs.exists(p),is(<span class=\"keyword\">true</span>));</span><br></pre></td></tr></table></figure>\n<p>但是对这个文件的任何写操作不保证是可见的，即使在数据流已经刷新的情况下，文件的长度很长时间也会显示为0 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">OutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(<span class=\"number\">0L</span>));</span><br></pre></td></tr></table></figure>\n<p>一旦一个数据块写人成功，那么大家提出的新请求就可以看到这个块，而对当前写入的块，大家是看不见的。HDFS提供了使所有缓存和DataNode之间的数据强制同步的方法，这个方法是FSDataOutputStream中的sync()函数。当sync()函数返回成功时，HDFS就可以保证此时写入的文件数据是一致的并且对于所有新的用户都是可见的。即使HDFS客户端之间发生冲突，也会导致数据丢失，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">FSDataOutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">out.sync();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>这个操作类似于UNIX系统中的fsync系统调用，为一个文件描述符提交缓存数据，利用Java API写入本地数据，这样就可以保证看到刷新流并且同步之后的数据，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">FileOutputStream out = <span class=\"keyword\">new</span> FileOutStream(localFile);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.flush();       <span class=\"comment\">//  flush to operatig system</span></span><br><span class=\"line\">out.getFD().sync();    <span class=\"comment\">//  sync to disk</span></span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>在HDFS中关闭一个文件也隐式地执行了sync()函数，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path p = <span class=\"keyword\">new</span> Path(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">OutputStream out = fs.create(p);</span><br><span class=\"line\">out.write(<span class=\"string\">\"content\"</span>.getBytes(<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">out.close();</span><br><span class=\"line\">assertThat(fs.getFileStatus(p),getLen(),is(((<span class=\"keyword\">long</span>) <span class=\"string\">\"content\"</span> .length()));</span><br></pre></td></tr></table></figure>\n<p>文件系统的一致性与设计应用程序的方法有关。如果不调用sync()，那么需要做好因客户端或者系统发生故障而丢失部分数据做好准备。对大多数应用程序来说，这是不可接受的，所以需要在合适的地方调用sync()，比如在写入一定量的数据之后。尽管sync()被设计用来最大限度地减少HDFS的负担，但是它仍然有不可忽视的开销，所以需要在数据健壮性和吞吐最之间做好权衡，其中一个较好的参考平衡点就是:通过测试应用程序来选择不同sync()频率间的最佳平衡点。</p>\n<h3 id=\"5-文件读写\"><a href=\"#5-文件读写\" class=\"headerlink\" title=\"5 文件读写\"></a>5 文件读写</h3><h4 id=\"5-1-写策略\"><a href=\"#5-1-写策略\" class=\"headerlink\" title=\"5.1 写策略\"></a>5.1 写策略</h4><p>应用程序通过创建新文件以及向新文件写数据的方式，给HDFS系统添加数据。文件关闭以后，被写入的数据就无法再修改或者删除，只有以“追加”方式重新打开文件后，才能再次为文件添加数据。HDFS采用单线程写，多线程读的模式。</p>\n<p>HDFS客户端需要首先获得对文件操作的授权，然后才能对文件进行写操作。在此期间，其他的客户端都不能对该文件进行写操作。被授权的客户端通过向NameNode发送心跳信号来定期更新授权的状态。当文件关闭时，授权会被回收。文件授权期限分为软限制期和硬限制期两个等级。当处于软限制期内时，写文件的客户端独占对文件的访问权。当软限制过期后，如果客户端无法关闭文件，或没有释放对文件的授权，其他客户端即可以预定获取授权。当硬限制期过期后（一小时左右），如果此时客户端还没有更新（释放）授权，HDFS会认为原客户端已经退出，并自动终止文件的写行为，收回文件控制授权。文件的写控制授权并不会阻止其他客户端对文件进行读操作。因此一个文件可以有多个并行的客户端对其进行读取。</p>\n<p>HDFS文件由多个文件块组成。当需要创建一个新文件块时，NameNode会生成唯一的块ID，分配块空间，以及决定将块和块的备份副本存储到哪些DataNode节点上。DataNode节点会形成一个管道，管道中DataNode节点的顺序能够确保从客户端到上一DataNode节点的总体网络距离最小。文件的则以有序包（sequence of packets）的形式被推送到管道。应用程序客户端创建第一个缓冲区，并向其中写入字节。第一个缓冲区被填满后（一般是64 KB大小），数据会被推送到管道。后续的包随时可以推送，并不需要等前一个包发送成功并发回通知（这被称为“未答复发送”——译者注）。不过，这种未答复发送包的数目会根据客户端所限定的“未答复包窗口”(outstanding packets windows)的大小进行限制。</p>\n<p>在数据写入HDFS文件后，只要文件写操作没有关闭，HDFS就不保证数据在此期间对新增的客户端读操作可见。如果客户端用户程序需要确保对写入数据的可见性，可以显示地执行hflush操作。这样，当前的包就会被立即推送到管道，并且hflush操作会一直等到所有管道中的DataNode返回成功接收到数据的通知后才会停止。如此就可以保证所有在执行hflush之前所写入的数据对试图读取的客户端用户均可见。</p>\n<p>在一个集群的数千个节点里，节点失效（往往是因为存储故障造成的）每天都有可能发生。DataNode中所包含的文件块备份可能会因为内存、磁盘或者网络的错误而造成损坏。为了避免这种错误的形成，HDFS会为其文件的每个数据块生成并存储一份Checksum（总和检查）。Checksum主要供HDFS客户端在读取文件时检查客户端，DataNode以及网络等几个方面可能造成的数据块损坏。当客户端开始建立HDFS文件时，会检查文件的每个数据块的checksum序列，并将其与数据一起发送给DataNode。 DataNode则将checksum存放在文件的元数据文件里，与数据块的具体数据分开存放。当HDFS读取文件时，文件的每个块数据和checksum均被发送到客户端。客户端会即时计算出接受的块数据的checksum, 并将其与接受到的checksum进行匹配。如果不匹配，客户端会通知NameNode，表明接受到的数据块已经损坏，并尝试从其他的DataNode节点获取所需的数据块。</p>\n<p>当客户端打开一个文件进行读取时，会从NameNode中获得一个文件数据块列表，列表中包含了每一个所需的数据块的具体位置。这些位置会按照与客户端的距离进行排序。当具体进行数据块读取时，客户端总是尝试首先从最近的位置获取数据。如果尝试失败，客户端会根据排序的顺寻，从下一个位置获取数据。下列情况可能会造成数据读取失败：DataNode不可用，节点不再包含所需数据块，或者数据块备份损坏，以及checksum验证失败。<br>HDFS允许客户端从正在进行写操作的文件中读取数据。当进行这样的操作时，目前正在被写入的数据块对于NameNode来说是未知的。在这样的情况下，客户端会从所有数据块备份中挑选一个数据块，以这个数据块的最后长度作为开始读取数据之前的数据长度。HDFS I/O的设计是专门针对批处理系统进行优化的，比如MapReduce系统，这类系统对顺序读写的吞吐量都有很高的要求。针对于那些需要实时数据流以及随机读写级别的应用来说，系统的读/写响应时间还有待于优化，目前正在做这方面的努力。</p>\n<h4 id=\"5-2-读策略\"><a href=\"#5-2-读策略\" class=\"headerlink\" title=\"5.2 读策略\"></a>5.2 读策略</h4><p>读相对于写，简单一些，详细步骤如下：</p>\n<ol>\n<li>client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。</li>\n<li>就近挑选一台datanode服务器，请求建立输入流 。</li>\n<li>DataNode向输入流中中写数据，以packet为单位来校验。</li>\n<li>关闭输入流</li>\n</ol>\n<h2 id=\"三-MapReduce计算\"><a href=\"#三-MapReduce计算\" class=\"headerlink\" title=\"三 MapReduce计算\"></a>三 MapReduce计算</h2><h3 id=\"1-简介-1\"><a href=\"#1-简介-1\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p>MapReduce是Google提出的一个软件架构，也是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（归约）”，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>\n<h3 id=\"2-工作原理\"><a href=\"#2-工作原理\" class=\"headerlink\" title=\"2 工作原理\"></a>2 工作原理</h3><h4 id=\"2-1-Map\"><a href=\"#2-1-Map\" class=\"headerlink\" title=\"2.1 Map\"></a>2.1 Map</h4><p>程序根据输入格式将输入文件划分为多个部分，每个部分均用作映射。任务输入，每个map任务都有一个内存缓冲区，输入数据在映射阶段进行处理，中间结果被写入存储缓冲区，并由写入数据的一方确定。当数据达到内存缓冲区阈值（默认值为0.8）时，会启动线程将内存中溢出的数据写入磁盘，并继续缓冲而不影响映射的中间结果。在溢出写入过程中，MapReduce框架对键进行排序。如果中间结果相对较大，则会形成多个溢出文件。最后缓冲区中的数据也被写入磁盘，从而形成一个溢出文件（至少一个溢出文件）。如果有多个溢出文件，则所有文件最后都会合并为一个文件。</p>\n<h4 id=\"2-2-Reduce\"><a href=\"#2-2-Reduce\" class=\"headerlink\" title=\"2.2 Reduce\"></a>2.2 Reduce</h4><p>当所有的映射任务完成后，每个映射任务会形成一个最终文件，并且该文件按区划分。reduce 任务启动之前，一个映射任务完成后，就会启动线程来拉取映射结果数据到相应的规约任务，不断地合并数据，为规约的数据输入做准备，当所有的射任务完成完成后，数据也拉取合并完毕后，规约任务启动，最终将输出结果存入HDFS 上。</p>\n<h3 id=\"3-MapReduce运行流程\"><a href=\"#3-MapReduce运行流程\" class=\"headerlink\" title=\"3 MapReduce运行流程\"></a>3 MapReduce运行流程</h3><h4 id=\"3-1-分析-MapReduce-执行过程\"><a href=\"#3-1-分析-MapReduce-执行过程\" class=\"headerlink\" title=\"3.1 分析 MapReduce 执行过程\"></a>3.1 分析 MapReduce 执行过程</h4><p>MapReduce运行的时候，输入输出都是HDFS中的文件，首先，Mapper中运行的任务会去读取HDFS中的数据文件，通过调用map中的方法来处理数据，然后将处理结果输出给Reducer任务，Reducer将接收到的结果作为自己的输入数据，并且也调用自己的方法，将最后的结果输出到HDFS中。过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/ZyxlBMGXXPu08Qws.png!original\" alt=\"img\"></p>\n<h4 id=\"3-2-Mapper-任务执行过程详解\"><a href=\"#3-2-Mapper-任务执行过程详解\" class=\"headerlink\" title=\"3.2 Mapper 任务执行过程详解\"></a>3.2 Mapper 任务执行过程详解</h4><p>每个Mapper 任务是一个java 进程，它会读取HDFS 中的文件，解析成很多的键值对，经过我们覆盖的map 方法处理后，转换为很多的键值对再输出。整个Mapper 任务的处理过程又可以分为以下几个阶段：</p>\n<ol>\n<li>第一阶段是把输入文件按照一定的标准分片(InputSplit)，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的。如果数据块(Block)的大小是默认值64MB，输入文件有两个，一个是32MB，一个是72MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由一个Mapper 进程处理。这里的三个输入片，会有三个Mapper 进程处理。</li>\n<li>第二阶段是对输入片中的记录按照一定的规则解析成键值对。有个默认规则是把每一行文本内容解析成键值对。“键”是每一行的起始位置(单位是字节)，“值” 是本行的文本内容。</li>\n<li>第三阶段是调用Mapper 类中的map 方法。第二阶段中解析出来的每一个键值对，调用一次map 方法。如果有1000 个键值对，就会调用1000 次map方法。每一次调用map 方法会输出零个或者多个键值对。</li>\n<li>第四阶段是按照一定的规则对第三阶段输出的键值对进行分区。比较是基于键进行的。比如我们的键表示省份(如北京、上海、山东等)，那么就可以按照不同省份进行分区，同一个省份的键值对划分到一个区中。默认是只有一个区。分区的数量就是Reducer 任务运行的数量。默认只有一个Reducer 任务。</li>\n<li>第五阶段是对每个分区中的键值对进行排序。首先，按照键进行排序，对于键相同的键值对，按照值进行排序。比如三个键值对&lt;2,2&gt;、&lt;1,3&gt;、&lt;2,1&gt;，键和值分别是整数。那么排序后的结果是&lt;1,3&gt;、&lt;2,1&gt;、&lt;2,2&gt;。如果有</li>\n<li>第六阶段，那么进入第六阶段；如果没有，直接输出到本地的linux 文件中。第六阶段是对数据进行归约处理，也就是reduce 处理。键相等的键值对会调用一次reduce 方法。经过这一阶段，数据量会减少。归约后的数据输出到本地的linux文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。</li>\n</ol>\n<p>上述过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2kbg02YRqSS3ZofE.png!original\" alt=\"img\"></p>\n<h4 id=\"3-3-Reduce任务执行过程详解\"><a href=\"#3-3-Reduce任务执行过程详解\" class=\"headerlink\" title=\"3.3 Reduce任务执行过程详解\"></a>3.3 Reduce任务执行过程详解</h4><p>每个Reducer 任务是一个java 进程。Reducer 任务接收Mapper 任务的输出，归约处理后写入到HDFS 中，可以分为如下几个阶段。</p>\n<ol>\n<li>第一阶段是Reducer 任务会主动从Mapper 任务复制其输出的键值对。Mapper 任务可能会有很多，因此Reducer 会复制多个Mapper 的输出。</li>\n<li>第二阶段是把复制到Reducer 本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。</li>\n<li>第三阶段是对排序后的键值对调用reduce 方法。键相等的键值对调用一次reduce 方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS 文件中。</li>\n</ol>\n<p>在整个MapReduce 程序的开发过程中，我们最大的工作量是覆盖map 函数和覆盖reduce 函数。上述过程如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/2YC2iJF2OJvYbs1R.png!original\" alt=\"img\"></p>\n<h4 id=\"3-4-键值对的编号\"><a href=\"#3-4-键值对的编号\" class=\"headerlink\" title=\"3.4 键值对的编号\"></a>3.4 键值对的编号</h4><p>在对Mapper 任务、Reducer 任务的分析过程中，会看到很多阶段都出现了键值对，这里对键值对进行编号，方便理解键值对的变化情况，对于Mapper 任务输入的键值对，定义为key1 和value1。在map 方法中处理后，输出的键值对，定义为key2 和value2。reduce 方法接收key2 和value2，处理后，输出key3 和value3。具体如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dXULEPSCEIT3QZW0.png!original\" alt=\"img\"></p>\n<h3 id=\"4-MapReduce实现\"><a href=\"#4-MapReduce实现\" class=\"headerlink\" title=\"4 MapReduce实现\"></a>4 MapReduce实现</h3><p>MapReduce 在执行的时候，先执行Map 函数，再执行Reduce 函数，达到分布式并行运算效果。其中Map 函数与Reduce 函数需要用户自行设计，而这两个任务也定义了任务本身。</p>\n<h4 id=\"4-1-统计平均通话次数\"><a href=\"#4-1-统计平均通话次数\" class=\"headerlink\" title=\"4.1 统计平均通话次数\"></a>4.1 统计平均通话次数</h4><p>需要用到的数据为：主叫号码。仅需统计每个主叫号码在数据文件中出现的次数，用该数除以天数，即可得到平均值。与WordCount 类似，提取出第二列数据即可进行。具体代码如下图所示：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/f7g9O8xBBwHpkdZB.png!original\" alt=\"img\"></p>\n<p>结果如下图所示，其中每一行有两个数据，第一列为主叫号码，第二列为平均每日通话次数：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/NM80fSViYPVEfD3Q.png!original\" alt=\"img\"></p>\n<h4 id=\"4-2-统计不同通话类型下各运营商占比\"><a href=\"#4-2-统计不同通话类型下各运营商占比\" class=\"headerlink\" title=\"4.2 统计不同通话类型下各运营商占比\"></a>4.2 统计不同通话类型下各运营商占比</h4><p>需要用到的数据为：通话类型，主叫号码运营商，被叫号码运营商。与第一个需求不同，本需求的key 值由两个数共同组成，需要定义一个新的类用来包含通话类型和运行商。定义如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/aCFEDYqbUtuMMWFm.png!original\" alt=\"img\"></p>\n<p>其中需要注意，由于key 中数据的个数不唯一，需要对内部的数据优先级进行规定，所以要重写compareTo 函数，对key 进行排序。主函数中需要注意Map 阶段的输出类型和Reduce 阶段的输入输出类型，代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/khmfgplaXcfeVygE.png!original\" alt=\"img\"></p>\n<p>结果如下图，其中1代表电信，2 代表移动，3 代表联通：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/dw7Q7n01PquYb8xX.png!original\" alt=\"img\"></p>\n<p><img src=\"https://uploader.shimo.im/f/pTZXRD60QSU3j9Un.png!original\" alt=\"img\"></p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/3rK4jBFXZs3Ig47t.png!original\" alt=\"img\"></p>\n<h4 id=\"4-3-统计用户在各个时间段通话时长所占比例\"><a href=\"#4-3-统计用户在各个时间段通话时长所占比例\" class=\"headerlink\" title=\"4.3 统计用户在各个时间段通话时长所占比例\"></a>4.3 统计用户在各个时间段通话时长所占比例</h4><p>所需用到的数据有：主叫电话号码，通话开始时间，通话结束时间。最后输出的形式是一长串的数组，因此同样需要设计一个新的类用于封装。与上一需求不同的是，该类用于value 的输入和输出。代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/rlXjbmDdWKPLQS5R.png!original\" alt=\"img\"></p>\n<p>为了完成统计任务，还需要自己求出每个时间段的时间，才能统计占比。这需要设计统计时间段内持续时间的算法，代码如下：</p>\n<p><img src=\"/Users/tanrui/Documents/GitHub/Hexo/guitoubing.top/guitoubing.top/source/_posts/assets/iwXvfrzHPmTxAVJ9.png!original\" alt=\"img\"></p>\n<p>主函数与上一需求类似，区别在于Reduce 阶段的结果输出为浮点型数据，需要再同最开始一样重新定义一个浮点结果类，才能输出。</p>\n<p>结果如下图所示，每一行有9 个数据，第一列为主叫号码，第二到第八列为对应时间段中通话时长占一天的比例：</p>\n<p><img src=\"https://uploader.shimo.im/f/tSgwVy0seIoRbjlJ.png!original\" alt=\"img\"></p>"},{"title":"我们梦中见","date":"2018-06-26T04:29:17.000Z","_content":"\n> “Yeah It’s on. ”\n\n## 26/06/2018\n\n当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。\n\n## 14/10/2017\n\n（是不是个技博自己心里没点B数？\n\n<!-- more -->\n\n应该说[天明学长](http://donggu.me/)在技术方面给予了很大的支持，为她打call！\n\n说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？\n\n买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。\n\n### 接下来是干货了（扯淡\n\n然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到[天明学长](http://donggu.me/)了，在她网站中得知有了个[Hexo](https://hexo.io/)的框架，仿佛看到了未来。至于[Hexo](https://hexo.io/)怎么用，[官方文档](https://hexo.io/zh-cn/docs/index.html)里面都很详尽了，这里讲几点用的时候踩过的坑，以备。\n\n#### _config.YML配置，比较重要的几个地方\n\n##### 路径URL\n\n```\nurl: http://guitoubing.top/\nroot: /\n```\n\n- url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错\n- 在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。\n\n##### [Disqus插件](https://disqus.com/)\n\n```\ndisqus_username: guitoubing\n```\n\n因为多说已经关闭服务了，只能用[Disqus](https://disqus.com/)，而[Disqus](https://disqus.com/)又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题[hexo-theme-huxblog](https://github.com/kaijun/hexo-theme-huxblog/)已经集成了[Disqus](https://disqus.com/)的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 \n\n##### Analytics\n\n```\n# Analytics settings\n# Baidu Analytics\nba_track_id: bcfce8e737b***********04c164dc96\n# Google Analytics\nga_track_id: 'UA-10*******-1'            # Format: UA-xxxxxx-xx\nga_domain: guitoubing.top\n```\n\n#### deploy\n\n```\ndeploy:\n  type: ftpsync\n  host: guitoubing.top\n  user: webmaster@HK******\n  pass: tanrui106\n  remote: /WEB/\n  port: 21\n```\n\n[deploy](https://hexo.io/zh-cn/docs/deployment.html)就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。\n\n#### _config.YML配置完成了就可以开始创作咯\n\n```\nhexo new \"blog\" \nhexo g\nhexo s\n```\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)都有详细使用方法，不赘述。\n\n### 有几句MMP当讲\n\n```\n古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？\n```\n\n从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）\n\n\n\n","source":"_posts/我们梦中见.md","raw":"---\ntitle: 我们梦中见\ndate: 2018-06-26 12:29:17\ntags: \ncategories: \n   - 心记\n---\n\n> “Yeah It’s on. ”\n\n## 26/06/2018\n\n当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。\n\n## 14/10/2017\n\n（是不是个技博自己心里没点B数？\n\n<!-- more -->\n\n应该说[天明学长](http://donggu.me/)在技术方面给予了很大的支持，为她打call！\n\n说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？\n\n买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。\n\n### 接下来是干货了（扯淡\n\n然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到[天明学长](http://donggu.me/)了，在她网站中得知有了个[Hexo](https://hexo.io/)的框架，仿佛看到了未来。至于[Hexo](https://hexo.io/)怎么用，[官方文档](https://hexo.io/zh-cn/docs/index.html)里面都很详尽了，这里讲几点用的时候踩过的坑，以备。\n\n#### _config.YML配置，比较重要的几个地方\n\n##### 路径URL\n\n```\nurl: http://guitoubing.top/\nroot: /\n```\n\n- url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错\n- 在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。\n\n##### [Disqus插件](https://disqus.com/)\n\n```\ndisqus_username: guitoubing\n```\n\n因为多说已经关闭服务了，只能用[Disqus](https://disqus.com/)，而[Disqus](https://disqus.com/)又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题[hexo-theme-huxblog](https://github.com/kaijun/hexo-theme-huxblog/)已经集成了[Disqus](https://disqus.com/)的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 \n\n##### Analytics\n\n```\n# Analytics settings\n# Baidu Analytics\nba_track_id: bcfce8e737b***********04c164dc96\n# Google Analytics\nga_track_id: 'UA-10*******-1'            # Format: UA-xxxxxx-xx\nga_domain: guitoubing.top\n```\n\n#### deploy\n\n```\ndeploy:\n  type: ftpsync\n  host: guitoubing.top\n  user: webmaster@HK******\n  pass: tanrui106\n  remote: /WEB/\n  port: 21\n```\n\n[deploy](https://hexo.io/zh-cn/docs/deployment.html)就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。\n\n#### _config.YML配置完成了就可以开始创作咯\n\n```\nhexo new \"blog\" \nhexo g\nhexo s\n```\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)都有详细使用方法，不赘述。\n\n### 有几句MMP当讲\n\n```\n古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？\n```\n\n从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）\n\n\n\n","slug":"我们梦中见","published":1,"updated":"2021-05-16T11:03:25.055Z","_id":"ckor1sg2h000051xocvmj9wjr","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"26-06-2018\"><a href=\"#26-06-2018\" class=\"headerlink\" title=\"26/06/2018\"></a>26/06/2018</h2><p>当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。</p>\n<h2 id=\"14-10-2017\"><a href=\"#14-10-2017\" class=\"headerlink\" title=\"14/10/2017\"></a>14/10/2017</h2><p>（是不是个技博自己心里没点B数？</p>\n<a id=\"more\"></a>\n<p>应该说<a href=\"http://donggu.me/\" target=\"_blank\" rel=\"noopener\">天明学长</a>在技术方面给予了很大的支持，为她打call！</p>\n<p>说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？</p>\n<p>买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。</p>\n<h3 id=\"接下来是干货了（扯淡\"><a href=\"#接下来是干货了（扯淡\" class=\"headerlink\" title=\"接下来是干货了（扯淡\"></a>接下来是干货了（扯淡</h3><p>然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到<a href=\"http://donggu.me/\" target=\"_blank\" rel=\"noopener\">天明学长</a>了，在她网站中得知有了个<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>的框架，仿佛看到了未来。至于<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>怎么用，<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>里面都很详尽了，这里讲几点用的时候踩过的坑，以备。</p>\n<h4 id=\"config-YML配置，比较重要的几个地方\"><a href=\"#config-YML配置，比较重要的几个地方\" class=\"headerlink\" title=\"_config.YML配置，比较重要的几个地方\"></a>_config.YML配置，比较重要的几个地方</h4><h5 id=\"路径URL\"><a href=\"#路径URL\" class=\"headerlink\" title=\"路径URL\"></a>路径URL</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: http://guitoubing.top/</span><br><span class=\"line\">root: /</span><br></pre></td></tr></table></figure>\n<ul>\n<li>url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错</li>\n<li>在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。</li>\n</ul>\n<h5 id=\"Disqus插件\"><a href=\"#Disqus插件\" class=\"headerlink\" title=\"Disqus插件\"></a><a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus插件</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disqus_username: guitoubing</span><br></pre></td></tr></table></figure>\n<p>因为多说已经关闭服务了，只能用<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>，而<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题<a href=\"https://github.com/kaijun/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">hexo-theme-huxblog</a>已经集成了<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 </p>\n<h5 id=\"Analytics\"><a href=\"#Analytics\" class=\"headerlink\" title=\"Analytics\"></a>Analytics</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Analytics settings</span><br><span class=\"line\"># Baidu Analytics</span><br><span class=\"line\">ba_track_id: bcfce8e737b***********04c164dc96</span><br><span class=\"line\"># Google Analytics</span><br><span class=\"line\">ga_track_id: &apos;UA-10*******-1&apos;            # Format: UA-xxxxxx-xx</span><br><span class=\"line\">ga_domain: guitoubing.top</span><br></pre></td></tr></table></figure>\n<h4 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: ftpsync</span><br><span class=\"line\">  host: guitoubing.top</span><br><span class=\"line\">  user: webmaster@HK******</span><br><span class=\"line\">  pass: tanrui106</span><br><span class=\"line\">  remote: /WEB/</span><br><span class=\"line\">  port: 21</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">deploy</a>就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。</p>\n<h4 id=\"config-YML配置完成了就可以开始创作咯\"><a href=\"#config-YML配置完成了就可以开始创作咯\" class=\"headerlink\" title=\"_config.YML配置完成了就可以开始创作咯\"></a>_config.YML配置完成了就可以开始创作咯</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new &quot;blog&quot; </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>都有详细使用方法，不赘述。</p>\n<h3 id=\"有几句MMP当讲\"><a href=\"#有几句MMP当讲\" class=\"headerlink\" title=\"有几句MMP当讲\"></a>有几句MMP当讲</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？</span><br></pre></td></tr></table></figure>\n<p>从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"26-06-2018\"><a href=\"#26-06-2018\" class=\"headerlink\" title=\"26/06/2018\"></a>26/06/2018</h2><p>当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。</p>\n<h2 id=\"14-10-2017\"><a href=\"#14-10-2017\" class=\"headerlink\" title=\"14/10/2017\"></a>14/10/2017</h2><p>（是不是个技博自己心里没点B数？</p>","more":"<p>应该说<a href=\"http://donggu.me/\" target=\"_blank\" rel=\"noopener\">天明学长</a>在技术方面给予了很大的支持，为她打call！</p>\n<p>说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？</p>\n<p>买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。</p>\n<h3 id=\"接下来是干货了（扯淡\"><a href=\"#接下来是干货了（扯淡\" class=\"headerlink\" title=\"接下来是干货了（扯淡\"></a>接下来是干货了（扯淡</h3><p>然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到<a href=\"http://donggu.me/\" target=\"_blank\" rel=\"noopener\">天明学长</a>了，在她网站中得知有了个<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>的框架，仿佛看到了未来。至于<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>怎么用，<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>里面都很详尽了，这里讲几点用的时候踩过的坑，以备。</p>\n<h4 id=\"config-YML配置，比较重要的几个地方\"><a href=\"#config-YML配置，比较重要的几个地方\" class=\"headerlink\" title=\"_config.YML配置，比较重要的几个地方\"></a>_config.YML配置，比较重要的几个地方</h4><h5 id=\"路径URL\"><a href=\"#路径URL\" class=\"headerlink\" title=\"路径URL\"></a>路径URL</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: http://guitoubing.top/</span><br><span class=\"line\">root: /</span><br></pre></td></tr></table></figure>\n<ul>\n<li>url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错</li>\n<li>在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。</li>\n</ul>\n<h5 id=\"Disqus插件\"><a href=\"#Disqus插件\" class=\"headerlink\" title=\"Disqus插件\"></a><a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus插件</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disqus_username: guitoubing</span><br></pre></td></tr></table></figure>\n<p>因为多说已经关闭服务了，只能用<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>，而<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题<a href=\"https://github.com/kaijun/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">hexo-theme-huxblog</a>已经集成了<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 </p>\n<h5 id=\"Analytics\"><a href=\"#Analytics\" class=\"headerlink\" title=\"Analytics\"></a>Analytics</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Analytics settings</span><br><span class=\"line\"># Baidu Analytics</span><br><span class=\"line\">ba_track_id: bcfce8e737b***********04c164dc96</span><br><span class=\"line\"># Google Analytics</span><br><span class=\"line\">ga_track_id: &apos;UA-10*******-1&apos;            # Format: UA-xxxxxx-xx</span><br><span class=\"line\">ga_domain: guitoubing.top</span><br></pre></td></tr></table></figure>\n<h4 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: ftpsync</span><br><span class=\"line\">  host: guitoubing.top</span><br><span class=\"line\">  user: webmaster@HK******</span><br><span class=\"line\">  pass: tanrui106</span><br><span class=\"line\">  remote: /WEB/</span><br><span class=\"line\">  port: 21</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">deploy</a>就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。</p>\n<h4 id=\"config-YML配置完成了就可以开始创作咯\"><a href=\"#config-YML配置完成了就可以开始创作咯\" class=\"headerlink\" title=\"_config.YML配置完成了就可以开始创作咯\"></a>_config.YML配置完成了就可以开始创作咯</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new &quot;blog&quot; </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>都有详细使用方法，不赘述。</p>\n<h3 id=\"有几句MMP当讲\"><a href=\"#有几句MMP当讲\" class=\"headerlink\" title=\"有几句MMP当讲\"></a>有几句MMP当讲</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？</span><br></pre></td></tr></table></figure>\n<p>从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfukja97000eszxo9f0lygyj","category_id":"ckfukja96000bszxohywikf3k","_id":"ckfukja9k000lszxorldlttca"},{"post_id":"ckfukja8t0003szxopnv39i7f","category_id":"ckfukja96000bszxohywikf3k","_id":"ckfukja9m000pszxop7fvzvoh"},{"post_id":"ckfukja920007szxofpjwt0x7","category_id":"ckfukja96000bszxohywikf3k","_id":"ckfukja9n000sszxol6yq4xip"},{"post_id":"ckfukja940009szxob08e6w4m","category_id":"ckfukja9k000mszxoqsti1xwa","_id":"ckfukja9q000zszxo95v4fr6d"},{"post_id":"ckfukja95000aszxo7xv6d5vq","category_id":"ckfukja96000bszxohywikf3k","_id":"ckfukja9w0014szxo7s9emdj0"},{"post_id":"ckfukja9e000jszxo6jsbjbfb","category_id":"ckfukja9k000mszxoqsti1xwa","_id":"ckfukjaa2001iszxoducm7yfy"},{"post_id":"ckfukjaa0001cszxoaavqnip6","category_id":"ckfukja9k000mszxoqsti1xwa","_id":"ckfukjaa3001lszxobwircuij"},{"post_id":"ckfukja9j000kszxok1vvgery","category_id":"ckfukja9k000mszxoqsti1xwa","_id":"ckfukjaa4001nszxokc3pc5v7"},{"post_id":"ckfukjaa1001fszxoisla5phb","category_id":"ckfukja9k000mszxoqsti1xwa","_id":"ckfukjaa4001rszxoagdqegu2"},{"post_id":"ckfukja9l000oszxo8fj9bmj7","category_id":"ckfukjaa2001hszxo6y3x3gxd","_id":"ckfukjaa5001tszxow9y82z0a"},{"post_id":"ckfukja9m000rszxo5fz1hf7g","category_id":"ckfukjaa4001oszxom8x6v3nm","_id":"ckfukjaa6001zszxofkcsngc3"},{"post_id":"ckfukja9o000wszxolq7tgs33","category_id":"ckfukjaa4001oszxom8x6v3nm","_id":"ckfukjaa90023szxofdpqjfzl"},{"post_id":"ckfukja9p000xszxo3gt7tpv1","category_id":"ckfukjaa4001oszxom8x6v3nm","_id":"ckfukjaaa0026szxoppyejx6f"},{"post_id":"ckfukja9w0017szxoqfcc2l9h","category_id":"ckfukjaa4001oszxom8x6v3nm","_id":"ckfukjaad002dszxovc6sxt7f"},{"post_id":"ckfukja9y0019szxo4pb96nxk","category_id":"ckor1sg7j000351xondtp676x","_id":"ckor1sg7t000751xoii5hf3r8"},{"post_id":"ckor1kofc0000mixoexv8yhsh","category_id":"ckor1sg7s000551xonz6dr3zu","_id":"ckor1sg7v000951xotfvjkjy9"},{"post_id":"ckor1sg2h000051xocvmj9wjr","category_id":"ckor1xrzn000z51xokh8j3vxh","_id":"ckor1xrzq001251xokn4ke1eo"},{"post_id":"ckfukja9q0010szxodvtxpx3y","category_id":"ckor1sg7s000551xonz6dr3zu","_id":"ckor1y6jq001351xoablyzrv3"},{"post_id":"ckfukja9b000fszxoyswtcdf2","category_id":"ckor1sg7s000551xonz6dr3zu","_id":"ckor2amfw0005uoxosv2gpeeo"},{"post_id":"ckfukja9u0013szxonm4xi6cu","category_id":"ckfukjaa4001oszxom8x6v3nm","_id":"ckor2hti70000fixokwphnxhp"}],"PostTag":[{"post_id":"ckfukja8t0003szxopnv39i7f","tag_id":"ckfukja96000cszxokomw2a24","_id":"ckfukja9m000qszxok0gbjko7"},{"post_id":"ckfukja920007szxofpjwt0x7","tag_id":"ckfukja9o000vszxocdwqyzfb","_id":"ckfukja9w0016szxo01i7vxxx"},{"post_id":"ckfukja940009szxob08e6w4m","tag_id":"ckfukja9r0011szxou7bwwmjy","_id":"ckfukjaa2001gszxob4q52bmr"},{"post_id":"ckfukja95000aszxo7xv6d5vq","tag_id":"ckfukja9l000nszxo20sz4t63","_id":"ckfukjaa5001sszxo1s805nn2"},{"post_id":"ckfukja9j000kszxok1vvgery","tag_id":"ckfukjaa90024szxovkftr6le","_id":"ckfukjaac002bszxomjsgp2wj"},{"post_id":"ckfukja9l000oszxo8fj9bmj7","tag_id":"ckfukjaab0027szxoza5gl70i","_id":"ckfukjaad002fszxoaxqb3ojo"},{"post_id":"ckfukja9l000oszxo8fj9bmj7","tag_id":"ckfukjaac002cszxo39sku5zl","_id":"ckfukjaae002hszxobwk4ln6g"},{"post_id":"ckfukja9m000rszxo5fz1hf7g","tag_id":"ckfukjaad002eszxosys7bxyd","_id":"ckfukjaaf002kszxoiajllyb8"},{"post_id":"ckfukja9m000rszxo5fz1hf7g","tag_id":"ckfukjaae002iszxomwwox476","_id":"ckfukjaaf002lszxoom73btdl"},{"post_id":"ckfukja9o000wszxolq7tgs33","tag_id":"ckfukjaae002jszxoqtof22v5","_id":"ckfukjaag002oszxovj83onup"},{"post_id":"ckfukja9o000wszxolq7tgs33","tag_id":"ckfukjaaf002mszxowxtwl253","_id":"ckfukjaah002pszxojkz9z2xv"},{"post_id":"ckfukja9p000xszxo3gt7tpv1","tag_id":"ckfukjaae002jszxoqtof22v5","_id":"ckfukjaam002sszxo1dlqympt"},{"post_id":"ckfukja9p000xszxo3gt7tpv1","tag_id":"ckfukjaaf002mszxowxtwl253","_id":"ckfukjaam002tszxozk5sivni"},{"post_id":"ckfukja9q0010szxodvtxpx3y","tag_id":"ckfukjaa4001qszxoyyp26xa7","_id":"ckfukjaao002wszxoarih39zj"},{"post_id":"ckfukja9q0010szxodvtxpx3y","tag_id":"ckfukjaam002uszxome5lijwl","_id":"ckfukjaao002xszxooy0bnf4u"},{"post_id":"ckfukja9u0013szxonm4xi6cu","tag_id":"ckfukjaae002iszxomwwox476","_id":"ckfukjaaq0030szxok843xi89"},{"post_id":"ckfukja9u0013szxonm4xi6cu","tag_id":"ckfukjaap002yszxoyi9njp45","_id":"ckfukjaaq0031szxoezho1lp3"},{"post_id":"ckfukja9y0019szxo4pb96nxk","tag_id":"ckfukjaaq0033szxodvlq9onm","_id":"ckfukjaas0039szxoadal0ymy"},{"post_id":"ckfukja9y0019szxo4pb96nxk","tag_id":"ckfukjaar0036szxoq0cactbp","_id":"ckfukjaas003aszxoxwaj9d8w"},{"post_id":"ckfukja9y0019szxo4pb96nxk","tag_id":"ckfukjaar0037szxo5q9ykty6","_id":"ckfukjaas003bszxohueet4f0"},{"post_id":"ckfukja9y0019szxo4pb96nxk","tag_id":"ckfukjaar0038szxo9hc66bbx","_id":"ckfukjaas003cszxokef23742"},{"post_id":"ckor1kofc0000mixoexv8yhsh","tag_id":"ckfukjaa4001qszxoyyp26xa7","_id":"ckor1sg7s000651xos3toolz5"},{"post_id":"ckor1kofc0000mixoexv8yhsh","tag_id":"ckor1sg7q000451xosudyue8n","_id":"ckor1sg7u000851xoro7ino18"},{"post_id":"ckfukjaa1001fszxoisla5phb","tag_id":"ckor1trw1000a51xow0tw5mby","_id":"ckor1trw3000d51xox77j7j5i"},{"post_id":"ckfukjaa1001fszxoisla5phb","tag_id":"ckor1trw2000b51xo5lxyeoxt","_id":"ckor1trw4000e51xo8hiq4la7"},{"post_id":"ckfukjaa1001fszxoisla5phb","tag_id":"ckor1trw3000c51xogxy8ea3w","_id":"ckor1trw4000f51xo317h6t2i"},{"post_id":"ckfukjaa0001cszxoaavqnip6","tag_id":"ckor1trw1000a51xow0tw5mby","_id":"ckor1ux4p000i51xomyb2j857"},{"post_id":"ckfukjaa0001cszxoaavqnip6","tag_id":"ckor1ux4o000g51xos5i20it6","_id":"ckor1ux4p000j51xog19b4alm"},{"post_id":"ckfukjaa0001cszxoaavqnip6","tag_id":"ckor1ux4p000h51xotpjmpy7l","_id":"ckor1ux4u000k51xoze3p8rwd"},{"post_id":"ckfukja9w0017szxoqfcc2l9h","tag_id":"ckor1vxyd000p51xo4pb9j1zu","_id":"ckor1vxye000t51xo0vf1gsgp"},{"post_id":"ckfukja9w0017szxoqfcc2l9h","tag_id":"ckor1vxye000q51xo1og8xdb6","_id":"ckor1vxye000u51xoq0otnm1z"},{"post_id":"ckfukja9w0017szxoqfcc2l9h","tag_id":"ckor1vxye000r51xo13onpt4z","_id":"ckor1vxye000v51xozel6um4z"},{"post_id":"ckfukja9w0017szxoqfcc2l9h","tag_id":"ckor1vxye000s51xomkciag90","_id":"ckor1vxye000w51xoql5qpq4v"},{"post_id":"ckfukja8t0003szxopnv39i7f","tag_id":"ckor2a2zf0000uoxom6m3u1iv","_id":"ckor2a2zh0001uoxor1f4ywc5"},{"post_id":"ckfukja8t0003szxopnv39i7f","tag_id":"ckor1vxye000q51xo1og8xdb6","_id":"ckor2a2zh0002uoxobx750k8v"},{"post_id":"ckfukja95000aszxo7xv6d5vq","tag_id":"ckor2ad9k0003uoxo1a8jzrmq","_id":"ckor2ad9k0004uoxovhd6lcui"},{"post_id":"ckfukja9b000fszxoyswtcdf2","tag_id":"ckor2apox0006uoxom8pxtvlu","_id":"ckor2apoy0007uoxolcg6tb00"},{"post_id":"ckfukja9e000jszxo6jsbjbfb","tag_id":"ckor2b3ji0008uoxodxwxzj1c","_id":"ckor2b3ji0009uoxoepxzs6g0"},{"post_id":"ckfukja97000eszxo9f0lygyj","tag_id":"ckor2bnyz000auoxog4vealr7","_id":"ckor2bnyz000cuoxod70sjqqy"},{"post_id":"ckfukja97000eszxo9f0lygyj","tag_id":"ckor2bnyz000buoxogzxsu72y","_id":"ckor2bnyz000duoxocn5gxq3b"},{"post_id":"ckfukja9l000oszxo8fj9bmj7","tag_id":"ckor2d1rv000fuoxor3tq84lv","_id":"ckor2d1ry000guoxo4ow7b9yj"}],"Tag":[{"name":"Hexo","_id":"ckfukja8z0005szxos9s6m5ms"},{"name":".Net","_id":"ckfukja96000cszxokomw2a24"},{"name":"数据库","_id":"ckfukja9d000iszxozkacmppp"},{"name":".NET","_id":"ckfukja9l000nszxo20sz4t63"},{"name":"C#","_id":"ckfukja9o000vszxocdwqyzfb"},{"name":"JavaFX","_id":"ckfukja9r0011szxou7bwwmjy"},{"name":"Java","_id":"ckfukja9x0018szxo9dyyedlp"},{"name":"Hadoop","_id":"ckfukjaa4001qszxoyyp26xa7"},{"name":"Spring","_id":"ckfukjaa90024szxovkftr6le"},{"name":"TensorFlow","_id":"ckfukjaab0027szxoza5gl70i"},{"name":"图像分割","_id":"ckfukjaac002cszxo39sku5zl"},{"name":"Docker","_id":"ckfukjaad002eszxosys7bxyd"},{"name":"Oracle","_id":"ckfukjaae002iszxomwwox476"},{"name":"TimesTen","_id":"ckfukjaae002jszxoqtof22v5"},{"name":"内存数据库","_id":"ckfukjaaf002mszxowxtwl253"},{"name":"云计算","_id":"ckfukjaam002uszxome5lijwl"},{"name":"Timesten","_id":"ckfukjaap002yszxoyi9njp45"},{"name":"大三上笔记","_id":"ckfukjaap002zszxoqdib7xoe"},{"name":"数据仓库","_id":"ckfukjaaq0032szxoaf8m6kle"},{"name":"Win10","_id":"ckfukjaaq0033szxodvlq9onm"},{"name":"Linux","_id":"ckfukjaar0036szxoq0cactbp"},{"name":"双系统","_id":"ckfukjaar0037szxo5q9ykty6"},{"name":"引导修复","_id":"ckfukjaar0038szxo9hc66bbx"},{"name":"分布式","_id":"ckor1n41x0001mixovulawmbf"},{"name":"HDFS","_id":"ckor1sg7q000451xosudyue8n"},{"name":"垃圾回收","_id":"ckor1trw1000a51xow0tw5mby"},{"name":"泛型编程","_id":"ckor1trw2000b51xo5lxyeoxt"},{"name":"容器","_id":"ckor1trw3000c51xogxy8ea3w"},{"name":"可达性分析","_id":"ckor1ux4o000g51xos5i20it6"},{"name":"HotSpot","_id":"ckor1ux4p000h51xotpjmpy7l"},{"name":"课程笔记","_id":"ckor1vau4000l51xobpitpgcl"},{"name":"Neo4j","_id":"ckor1vxyd000p51xo4pb9j1zu"},{"name":"MySQL","_id":"ckor1vxye000q51xo1og8xdb6"},{"name":"Influx","_id":"ckor1vxye000r51xo13onpt4z"},{"name":"Hive","_id":"ckor1vxye000s51xomkciag90"},{"name":"笔记","_id":"ckor1xrzo001051xoe7phbgvh"},{"name":"EFCore","_id":"ckor2a2zf0000uoxom6m3u1iv"},{"name":"ADO.NET","_id":"ckor2ad9k0003uoxo1a8jzrmq"},{"name":"Hadoop配置记录","_id":"ckor2apox0006uoxom8pxtvlu"},{"name":"ClassLoader","_id":"ckor2b3ji0008uoxodxwxzj1c"},{"name":".NET Framework","_id":"ckor2bnyz000auoxog4vealr7"},{"name":"EntityFramework","_id":"ckor2bnyz000buoxogzxsu72y"},{"name":"遥感影像","_id":"ckor2d1rv000fuoxor3tq84lv"}]}}