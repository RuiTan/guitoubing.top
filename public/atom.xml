<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archer</title>
  
  <subtitle>我们梦中见</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.guitoubing.top/"/>
  <updated>2019-10-20T09:12:25.574Z</updated>
  <id>http://blog.guitoubing.top/</id>
  
  <author>
    <name>Rui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java - Spring学习笔记</title>
    <link href="http://blog.guitoubing.top/2019/10/19/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.guitoubing.top/2019/10/19/Spring学习笔记/</id>
    <published>2019-10-19T11:12:29.000Z</published>
    <updated>2019-10-20T09:12:25.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理解DIP、IOC、DI及IOC容器</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;理解DIP、IOC、DI及IOC容器&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://blog.guitoubing.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.guitoubing.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://blog.guitoubing.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>C# - 实现读写锁</title>
    <link href="http://blog.guitoubing.top/2019/05/03/C-ReadWriteLock/"/>
    <id>http://blog.guitoubing.top/2019/05/03/C-ReadWriteLock/</id>
    <published>2019-05-02T16:33:11.000Z</published>
    <updated>2019-10-20T08:53:23.213Z</updated>
    
    <content type="html"><![CDATA[<p>使用C#实现的<code>可重入</code>、<code>非公平</code>的<code>读写锁</code>，主要目的实现<strong>并发读写</strong>以及<strong>读写同步</strong>问题。为了<strong>减少读等待时间</strong>以及<strong>防止出现写饥饿现象</strong>，本锁使用了<strong>非同步锁</strong>的实现，允许<strong>读优先（提高效率）</strong>的同时<strong>使用一个阈值限定读者的最大数量（防止写饥饿）</strong>；重入机制允许某个线程可以获取锁多次（如多次函数调用导致的锁重入），每次获取都需要有对应的释放，否则会出错。</p><p>本锁的目的是实现对读写线程队列的调度，而不是对线程获取锁的顺序进行调度。要注意读写线程进入队列的顺序是系统调度的（意即创建多个线程并Start时，其进入线程的时机是系统决定的，可能最后创建的线程最先执行），这里实现的是<strong>对进入队列后的线程进行阻塞、唤醒等操作</strong>。</p><p>本锁使用了<code>C#</code>中的<code>lock原语</code>，目的是为了实现一些<strong>队列操作的原子性</strong>。</p><p>实现本锁时作者参考了<code>Java</code>中<code>AQS</code>和<code>ReentrantReadWriteLock</code>的一些实现细节，予以理解仿效，设计了这个简单的读写锁，实现逻辑上可能仍有很多缺陷或矛盾，望各位看官批评指正！</p><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node节点是实现本读写锁的关键所在，读写线程队列也是基于Node节点实现的。Node内部持有了一个线程，同时有很多指向其他Node的引用。Node类实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Node</span><br><span class="line">    &#123;</span><br><span class="line">        // 读节点</span><br><span class="line">        public static readonly Node SHARED = new Node();</span><br><span class="line">        // 写节点</span><br><span class="line">        public static readonly Node EXCLUSIVE = null;</span><br><span class="line">        // 读链长度阈值</span><br><span class="line">        public static int Threshold = 3;</span><br><span class="line"></span><br><span class="line">        // 节点状态</span><br><span class="line">        public static readonly int CANCELLED = 1;</span><br><span class="line">        public static readonly int RUNNING = -1;</span><br><span class="line">        public static readonly int WAITING = -2;</span><br><span class="line">        public static readonly int SIGNAL = -3;</span><br><span class="line">    </span><br><span class="line">        public int waitStatus;</span><br><span class="line">        // 前驱节点</span><br><span class="line">        public Node prev;</span><br><span class="line">        // 后继节点</span><br><span class="line">        public Node next;</span><br><span class="line">        // 持有线程</span><br><span class="line">        public Thread thread;</span><br><span class="line"></span><br><span class="line">        //以下参数仅对读节点适用</span><br><span class="line">        // 读链头</span><br><span class="line">        public Node readerHead;</span><br><span class="line">        // 后继读节点</span><br><span class="line">        public Node nextReader;</span><br><span class="line">        // 读链长度</span><br><span class="line">        public int readerCount = 1;</span><br><span class="line"></span><br><span class="line">        // 节点类型</span><br><span class="line">        public Node mode;</span><br><span class="line">        // 是否是共享节点</span><br><span class="line">        public bool isShared()</span><br><span class="line">        &#123;</span><br><span class="line">            return mode == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建共享或独占节点</span><br><span class="line">        public Node(Thread thread, Node mode)</span><br><span class="line">        &#123;</span><br><span class="line">            this.mode = mode;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    // 获取状态</span><br><span class="line">        public static string GetStatus(int status)</span><br><span class="line">        &#123;</span><br><span class="line">            switch (status)</span><br><span class="line">            &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    return &quot;CANCELLED&quot;;</span><br><span class="line">                case -1:</span><br><span class="line">                    return &quot;RUNNING&quot;;</span><br><span class="line">                case -2:</span><br><span class="line">                    return &quot;WAITING&quot;;</span><br><span class="line">                case -3:</span><br><span class="line">                    return &quot;SIGNAL&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;DEFAULT&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>各属性及方法的涵义如上述代码注释所示，而由Node组成的等待队列结构（双向链表）如下图所示（可能出现的一种情况）：</p><p><img src="http://getme.guitoubing.top/队列示意图.png" alt="队列示意图.png"></p><p>对于写节点来说，锁是独占的，一次仅能有一个写线程在执行；而对于读节点来说，锁是共享的，在同一读链上的所有节点都可同时进行读。</p><h2 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h2><h3 id="头节点-head"><a href="#头节点-head" class="headerlink" title="头节点 head"></a>头节点 head</h3><p>头节点是个傀儡节点，<code>private volatile Node head</code>，其无实际涵义，只是为了作为队列头而存在；其使用了惰性初始化的方法，仅在第一个节点入队列时初始化。</p><blockquote><p><code>volatile</code>关键字在是为了实现变量的内存可见性，使用该关键字修饰的变量的修改会直接反映到内存中而不是缓存中。</p></blockquote><h3 id="尾节点-tail"><a href="#尾节点-tail" class="headerlink" title="尾节点 tail"></a>尾节点 tail</h3><p>尾节点是队列的最后一个节点，<code>private volatile Node tail</code>，引入尾节点是为了防止在新节点入列时遍历队列，提高了效率。</p><h3 id="重入量-reentrants"><a href="#重入量-reentrants" class="headerlink" title="重入量 reentrants"></a>重入量 reentrants</h3><p>对于写锁（独占锁）来说，当一个写线程获取锁时，<code>reentrants</code>为<code>1</code>，后续每当锁重入一次，<code>reentrants</code>增加<code>1</code>；释放锁时，每释放一次<code>reentrants</code>减少1，直到<code>reentrants</code>为<code>0</code>时该线程释放当前锁，唤醒后续线程；</p><p>对于读锁（共享锁）来说，由于读链中可能会有不超过<code>Node.Threshold</code>个数的读节点，且每个读节点都可能会产生重入，这里会将<code>reentrants</code>初始化为读链长度，在<code>Node.RUNNING`</code>时读链每增加一个读节点会增加一个reentrants<code>，读链中的每个节点多一次重入也会导致</code>reentrants<code>增加</code>1`。</p><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><h3 id="获取-WriteLock"><a href="#获取-WriteLock" class="headerlink" title="获取 WriteLock()"></a>获取 WriteLock()</h3><p>先看获取写锁的流程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取写锁</span><br><span class="line"> */</span><br><span class="line">public void WriteLock()</span><br><span class="line">&#123;</span><br><span class="line">    // 当前节点</span><br><span class="line">    Node currentNode = null;</span><br><span class="line">    // 这里使用了惰性初始化，如果头节点为空，则初始化头节点</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        if (head == null)</span><br><span class="line">            head = new Node();</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果尾节点为空，说明当前队列为空，此时线程直接入队列设置为RUNNING状态</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        if (tail == null)</span><br><span class="line">        &#123;</span><br><span class="line">            EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果当前线程就是持有线程，说明锁在重入，reentrants加1</span><br><span class="line">        if (owner == Thread.CurrentThread)</span><br><span class="line">        &#123;</span><br><span class="line">            reentrants += 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则，当前线程需要进入等待队列进行等待</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 获取尾节点</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 由于可能出现其他线程的介入，需要再次检测为节点是否为空</span><br><span class="line">            if (t == null)</span><br><span class="line">            &#123;</span><br><span class="line">                EnqWhenTailNull(Node.EXCLUSIVE);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则直接入队列等待</span><br><span class="line">            else</span><br><span class="line">                currentNode = Enq(Node.EXCLUSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测当前节点是否可以被唤醒</span><br><span class="line">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class="line">    // 此时线程已被唤醒，设置重入量及状态等</span><br><span class="line">    reentrants = 1;</span><br><span class="line">    currentNode.waitStatus = Node.RUNNING;</span><br><span class="line">    owner = Thread.CurrentThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程如下：</p><ol><li>先判断队列是否已初始化，若未初始化，先初始化head节点</li><li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li><li>判断当前线程是否为持有锁的线程，若是说明线程在重入当前锁，直接<code>reentrants</code>加<code>1</code>，成功获取锁，返回；否则进入下一步</li><li>获取尾节点，由于第2步结束时可能有其他线程的介入，因此需再次判断<code>tail==null</code>，若是直接进入队列，成功获取锁，返回；否则以当前线程创建节点并入队列，同时阻塞</li><li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，并成功获取独占锁</li></ol><h3 id="释放-WriteUnlock"><a href="#释放-WriteUnlock" class="headerlink" title="释放 WriteUnlock()"></a>释放 WriteUnlock()</h3><p>释放写锁的逻辑很简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 释放写锁</span><br><span class="line"> */</span><br><span class="line">public void WriteUnlock()</span><br><span class="line">&#123;</span><br><span class="line">    // 加锁是为了同步修改队列信息</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前锁持有者重入量直接-1</span><br><span class="line">        reentrants -= 1;</span><br><span class="line">        // 获取队列头（除了head之外的头）</span><br><span class="line">        Node node = GetHolderNode();</span><br><span class="line">        // 如果后续节点为空，则释放完成，队列已空；若后续节点不为空，则可能需要唤醒后续节点</span><br><span class="line">        if (node != null)</span><br><span class="line">        &#123;</span><br><span class="line">            // 若当前锁的重入量为0，说明锁已经完全释放，则需要唤醒后继有效节点（否则可能只是释放了一个锁内部的锁）</span><br><span class="line">            if (reentrants == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 当前节点置为无效</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">                // 唤醒后继有效节点</span><br><span class="line">                AwakeNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑如下：</p><ol><li>锁<code>reentrants</code>减<code>1</code></li><li>获取当前锁持有的节点</li><li>判断上述获取的节点是否为空，若为空说明队列已空，已无等待节点，直接返回；否则检查<code>reentrants</code>是否已减至<code>0</code></li><li>若是则当前节点线程已完成，置为<code>Node.CANCELLED</code>状态，并唤醒后继有效节点</li></ol><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><h3 id="获取-ReadLock"><a href="#获取-ReadLock" class="headerlink" title="获取 ReadLock()"></a>获取 ReadLock()</h3><p>相比于写锁的获取，读锁的获取要复杂一点，因为涉及到读的共享以及阈值的控制：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取读锁</span><br><span class="line"> */</span><br><span class="line">public void ReadLock()</span><br><span class="line">&#123;</span><br><span class="line">    Node reader = null;</span><br><span class="line">    // 这里基本的初始化方式和读锁相似，不赘述</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        if (head == null)</span><br><span class="line">            head = new Node();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread current = Thread.CurrentThread;</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        if (tail == null)</span><br><span class="line">        &#123;</span><br><span class="line">            EnqWhenTailNull(Node.SHARED);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node currentNode = null;</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        // 读可重入</span><br><span class="line">        if (ReaderCanReentranted())</span><br><span class="line">        &#123;</span><br><span class="line">            reentrants += 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取当前持有锁节点</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            EnqWhenTailNull(Node.SHARED);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 队列中有写者的情况</span><br><span class="line">            if (HasWriter())</span><br><span class="line">            &#123;</span><br><span class="line">                // 创建当前持有当前线程的读节点</span><br><span class="line">                reader = new Node(current, Node.SHARED);</span><br><span class="line">                // 获取第一个读节点（可能为null）</span><br><span class="line">                while (node != null &amp;&amp; (!node.isShared() || node.waitStatus == Node.CANCELLED))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (node.isShared())</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (!CheckReadChainCancelled(node))</span><br><span class="line">                            break;</span><br><span class="line">                        else</span><br><span class="line">                            node = node.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                // 未找到读节点，说明队列中只有写节点，此时直接添加到队列尾</span><br><span class="line">                if (node == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentNode = Enq(Node.SHARED);</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则说明找到了有效的读节点，此时此读节点为队列中第一个读节点，只需要判断此读节点链长是否达到了阈值，</span><br><span class="line">                //  若未超过阈值，直接添加到读链中，并判断当前读链头是否正在读，则可以直接读，否则需要循环检测；</span><br><span class="line">                //  若超过了阈值：</span><br><span class="line">                //      若队尾为写节点，则添加到队列尾，并循环等待；</span><br><span class="line">                //      若队尾为读节点，判断是否到达阈值：</span><br><span class="line">                //          若是则添加到队列尾，并循环等待；</span><br><span class="line">                //          否则添加到读链中。</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    // 未超过阈值</span><br><span class="line">                    if (node.readerCount &lt; Node.Threshold)</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 添加到读链中</span><br><span class="line">                        currentNode = AddReader(node, reader);</span><br><span class="line">                        // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class="line">                        if (node.waitStatus == Node.RUNNING)</span><br><span class="line">                        &#123;</span><br><span class="line">                            reader.waitStatus = Node.RUNNING;</span><br><span class="line">                            reentrants += 1;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 超过了阈值</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 判断队尾节点类型</span><br><span class="line">                        Node t = tail;</span><br><span class="line">                        // 队尾为“写节点”或“达到阈值的读节点”</span><br><span class="line">                        if (!t.isShared() || (t.isShared() &amp;&amp; t.readerCount &gt;= Node.Threshold))</span><br><span class="line">                            currentNode = Enq(Node.SHARED);</span><br><span class="line">                        // 队尾为“未达到阈值的读节点”</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            // 添加到队尾节点所在的读链中</span><br><span class="line">                            currentNode = AddReader(t, reader);</span><br><span class="line">                            // 链头正在读，此节点也直接读，且reentrants+1</span><br><span class="line">                            if (t.waitStatus == Node.RUNNING)</span><br><span class="line">                            &#123;</span><br><span class="line">                                reader.waitStatus = Node.RUNNING;</span><br><span class="line">                                reentrants += 1;</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 队列中无写者，说明队列中要么为空，要么全为读者，直接加到队尾或者队尾所在的读链</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                // 队列为空，直接入队</span><br><span class="line">                if (tail == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    EnqWhenTailNull(Node.SHARED);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                // 队尾节点读链长度未达到阈值</span><br><span class="line">                if (tail.readerCount &lt; Node.Threshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    reader = new Node(current, Node.SHARED);</span><br><span class="line">                    // 添加到链尾</span><br><span class="line">                    currentNode = AddReader(tail, reader);</span><br><span class="line">                    // 是否需要循环等待</span><br><span class="line">                    if (tail.waitStatus == Node.RUNNING)</span><br><span class="line">                    &#123;</span><br><span class="line">                        reader.waitStatus = Node.RUNNING;</span><br><span class="line">                        reentrants += 1;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 队尾节点读链达到了阈值，直接加入队尾，并等待唤醒</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    currentNode = Enq(Node.SHARED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (currentNode.waitStatus != Node.SIGNAL) &#123; &#125;</span><br><span class="line">    currentNode.waitStatus = Node.RUNNING;</span><br><span class="line">    reentrants = currentNode.readerHead.readerCount;</span><br><span class="line">    owner = currentNode.readerHead == null ? null : currentNode.readerHead.thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑如下：</p><ol><li>先判断队列是否已初始化，若未初始化，先初始化head节点</li><li>判断队列是否为空（即判断<code>tail==null</code>），若是直接进入队列，成功获取锁，返回；否则进入下一步</li><li>判断当前线程是否可重入锁（读线程的可重入判断与写不同，会在后面对<code>ReaderCanReentranted()</code>方法解释时介绍到），若是<code>reentrants</code>加<code>1</code>，返回；否则进入下一步</li><li>获取当前持有锁节点，若为空说明队列为空，直接进入队列，成功获取锁，返回；否则进入下一步</li><li>判断队列中是否有写者，若是跳至第6步，否则跳至第7步</li><li>队列中有写者，为防止出现写饥饿的情况，此读节点可能在写者前或后：<ol><li>若队列中无读节点，即只有写节点，直接添加至队列尾，并阻塞</li><li>若找到了队列中的第一个有效读节点，判断其读链是否达到阈值</li><li>若未超过阈值，则直接添加到读链中，是否阻塞由读链头的状态决定</li><li>若超过了阈值，则有两种情况：<ul><li>队尾为<strong>写节点</strong>或者队尾为<strong>读节点且读链长度达到阈值</strong>，此时节点添加至队列尾，并阻塞</li><li>队尾为<strong>读节点且读链长度未达到阈值</strong>，将节点加入队尾的读链中，与队尾节点状态一致</li></ul></li></ol></li><li>队列中无写者，说明队列中要么为空，要么全为读者，则根据队尾节点读链长度来决定是直接加到队尾还是加到队尾所在的读链</li><li>循环检测当前节点是否可以被唤醒，若可则解除阻塞状态，设置节点状态等信息，设置<code>reentrants</code>为读链长度，并成功获取共享锁</li></ol><h3 id="释放-ReadUnlock"><a href="#释放-ReadUnlock" class="headerlink" title="释放 ReadUnlock()"></a>释放 ReadUnlock()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 释放读锁</span><br><span class="line"> */</span><br><span class="line">public void ReadUnlock()</span><br><span class="line">&#123;</span><br><span class="line">    lock (this)</span><br><span class="line">    &#123;</span><br><span class="line">        // 读重入量-1</span><br><span class="line">        reentrants -= 1;</span><br><span class="line">        // 获取到锁持有节点</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        while (node != null)</span><br><span class="line">        &#123;</span><br><span class="line">            if (CheckReadChainCancelled(node))</span><br><span class="line">            &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">                head.next = node;</span><br><span class="line">                if (node != null)</span><br><span class="line">                    node.prev = head;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取到有效读节点了</span><br><span class="line">        if (node != null)</span><br><span class="line">        &#123;</span><br><span class="line">            // 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class="line">            node = GetCurrentNodeByReader(node);</span><br><span class="line">            // 当前节点置为取消</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">            // 重入量为0，需要判断读链是否已全部读完成，若是则需要唤醒后续线程</span><br><span class="line">            if (reentrants == 0)</span><br><span class="line">                AwakeNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放读锁的逻辑与释放写锁逻辑基本类似，无需多提。</p><h2 id="其余辅助方法"><a href="#其余辅助方法" class="headerlink" title="其余辅助方法"></a>其余辅助方法</h2><h3 id="Enq-Node-mode"><a href="#Enq-Node-mode" class="headerlink" title="Enq(Node mode)"></a>Enq(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，并入队列并阻塞，同时返回此节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读写节点入队列操作，入队列后需等待</span><br><span class="line"> */</span><br><span class="line">private Node Enq(Node mode)</span><br><span class="line">&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    // 以当前线程创建独占节点</span><br><span class="line">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class="line">    // 连接尾节点与当前节点</span><br><span class="line">    t.next = node;</span><br><span class="line">    node.prev = t;</span><br><span class="line">    // 重置尾节点为当前节点</span><br><span class="line">    tail = node;</span><br><span class="line">    // 设置节点等待状态为WAITING</span><br><span class="line">    node.waitStatus = Node.WAITING;</span><br><span class="line">    // 若为读节点，需要设置读链头</span><br><span class="line">    if (node.isShared())</span><br><span class="line">        node.readerHead = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnqWhenTailNull-Node-mode"><a href="#EnqWhenTailNull-Node-mode" class="headerlink" title="EnqWhenTailNull(Node mode)"></a>EnqWhenTailNull(Node mode)</h3><p>以当前线程为基础，指定类型创建节点，在队列为空时，此节点直接入队列且当前线程继续执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读写节点入队列操作，此时队列尾为空，入队列之后继续运行，无需等待</span><br><span class="line"> */</span><br><span class="line">private void EnqWhenTailNull(Node mode)</span><br><span class="line">&#123;</span><br><span class="line">    // 以当前线程创建独占节点</span><br><span class="line">    Node node = new Node(Thread.CurrentThread, mode);</span><br><span class="line">    // 设置等待类型为RUNNING</span><br><span class="line">    node.waitStatus = Node.RUNNING;</span><br><span class="line">    // 当前节点加入队列，尾节点为当前节点</span><br><span class="line">    tail = node;</span><br><span class="line">    // 设置锁的持有者为当前线程</span><br><span class="line">    owner = Thread.CurrentThread;</span><br><span class="line">    // 重入量初始为1</span><br><span class="line">    reentrants = 1;</span><br><span class="line">    // 连接头节点与此节点</span><br><span class="line">    head.next = node;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    // 若为读节点，需要设置读链头</span><br><span class="line">    if (node.isShared())</span><br><span class="line">        node.readerHead = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AwakeNext"><a href="#AwakeNext" class="headerlink" title="AwakeNext()"></a>AwakeNext()</h3><p>当某个节点置为<code>Node.CANCELLED</code>状态时，会唤醒其后一个有效节点，主要是将节点状态修改为<code>Node.SIGNAL</code>状态，以被各自节点监测到。</p><p>对于写节点来说，由于是独占的，只需要修改该节点；对于读节点来说，由于是共享的，需要遍历该节点所在的读链并修改每个节点的状态，才能达到唤醒整条读链的目的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 唤醒后一个节点</span><br><span class="line"> */</span><br><span class="line">private void AwakeNext()</span><br><span class="line">&#123;</span><br><span class="line">    // 获取持有当前锁的节点，此时锁刚好被上个节点释放，获取的节点应处于Node.WAITING状态</span><br><span class="line">    Node node = GetHolderNode();</span><br><span class="line">    // 当前节点为空，说明队列中无有效节点，直接返回即可</span><br><span class="line">    if (node == null)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = null;</span><br><span class="line">        owner = null;</span><br><span class="line">        reentrants = 0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则需要唤醒此有效节点</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // 连接到头节点</span><br><span class="line">        node.prev = head;</span><br><span class="line">        // 对于写节点，readerCount为1，即为reentrants初始值1</span><br><span class="line">        // 对于读节点，readerCount即为reentrants的初始值</span><br><span class="line">        reentrants = node.readerCount;</span><br><span class="line">        // 对于读节点来说，需唤醒读链中的所有节点；对于写节点来说，无读链，只会唤醒当前节点</span><br><span class="line">        while (node != null)</span><br><span class="line">        &#123;</span><br><span class="line">            // 等待类型设置为SIGNAL，会被捕捉从而唤醒相关线程</span><br><span class="line">            node.waitStatus = Node.SIGNAL;</span><br><span class="line">            // 若为读节点，可获取下一个读者；否则获取了null</span><br><span class="line">            node = node.nextReader;</span><br><span class="line">            // 下一个读者不为空，则也将其前驱节点设置为头节点</span><br><span class="line">            if (node != null)</span><br><span class="line">                node.prev = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetHolderNode"><a href="#GetHolderNode" class="headerlink" title="GetHolderNode()"></a>GetHolderNode()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> *   删除无效节点（可能由于主动中断或者其他因素导致的线程失效），获取第一个有效节点或空节点，</span><br><span class="line"> * 或者称作获取锁持有节点</span><br><span class="line"> */</span><br><span class="line">private Node GetHolderNode()</span><br><span class="line">&#123;</span><br><span class="line">    Node node = head.next;</span><br><span class="line">    // 此循环的判断条件可能出现歧义，因存在读链头为取消状态时，读链中仍然有读节点读未完成，但是此函数只在释放写锁(WriteUnlock)和唤醒后续节点(AwakeNext)中使用到，当AwakeNext被触发时，读链头的状态便可以代表整个读链的状态了。</span><br><span class="line">    while (node != null &amp;&amp; node.waitStatus == Node.CANCELLED)</span><br><span class="line">        node = node.next;</span><br><span class="line">    // 连接头节点和持有节点，无效节点全部交由垃圾收集器回收</span><br><span class="line">    head.next = node;</span><br><span class="line">    if (node != null)</span><br><span class="line">        node.prev = head;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HasWriter"><a href="#HasWriter" class="headerlink" title="HasWriter()"></a>HasWriter()</h3><p>在读节点获取锁时，有一步是需要判断队列中是否存在写者，即用到此函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回当前队列中是否存在写者，用在读者入队列时的决策</span><br><span class="line"> */</span><br><span class="line">private bool HasWriter()</span><br><span class="line">&#123;</span><br><span class="line">    bool exclusive = false;</span><br><span class="line">    Node excluNode = head.next;</span><br><span class="line">    while (excluNode != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!excluNode.isShared())</span><br><span class="line">        &#123;</span><br><span class="line">            exclusive = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        excluNode = excluNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return exclusive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetCurrentNodeByReader-Node-node"><a href="#GetCurrentNodeByReader-Node-node" class="headerlink" title="GetCurrentNodeByReader(Node node)"></a>GetCurrentNodeByReader(Node node)</h3><p>在释放读锁时，我们无法直接获取到当前节点，只能通过线程名称来确定当前线程的持有者在<code>node</code>所在的读链中的位置，返回获取到的节点，以在释放锁时修改状态。</p><p>而由于是通过线程名称来判断线程是否相等，可能会因线程重名导致异常，待改进。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过一个读节点（通常是链头）获取其读链中持有当前运行线程的节点</span><br><span class="line"> */</span><br><span class="line">private Node GetCurrentNodeByReader(Node node)</span><br><span class="line">&#123;</span><br><span class="line">    Node nextReader = node.readerHead;</span><br><span class="line">    // 以线程名称为依据，这里可能出现多个线程同名的情况，待改进</span><br><span class="line">    while (nextReader != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nextReader.thread.Name.Equals(Thread.CurrentThread.Name))</span><br><span class="line">            return nextReader;</span><br><span class="line">        else</span><br><span class="line">            nextReader = nextReader.nextReader;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CheckReadChainCancelled-Node-node"><a href="#CheckReadChainCancelled-Node-node" class="headerlink" title="CheckReadChainCancelled(Node node)"></a>CheckReadChainCancelled(Node node)</h3><p>对于写节点来说，只要节点状态为<code>Node.CANCELLED</code>，说明写已经完成；而对于读节点，需要遍历读链中所有节点的状态才能确定读是否完成，此方法便是如此。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过一个读节点判断其所在读链是否已全部读完成</span><br><span class="line"> */</span><br><span class="line">private bool CheckReadChainCancelled(Node node)</span><br><span class="line">&#123;</span><br><span class="line">    Node nextReader = node.readerHead;</span><br><span class="line">    while (nextReader != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nextReader.waitStatus != Node.CANCELLED)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            nextReader = nextReader.nextReader;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AddReader-Node-readerHead-Node-node"><a href="#AddReader-Node-readerHead-Node-node" class="headerlink" title="AddReader(Node readerHead, Node node)"></a>AddReader(Node readerHead, Node node)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加读者到指定读链头所在的读链中</span><br><span class="line"> */</span><br><span class="line">private Node AddReader(Node readerHead, Node node)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取到读链尾</span><br><span class="line">    Node reader = readerHead;</span><br><span class="line">    while (reader.nextReader != null)</span><br><span class="line">    &#123;</span><br><span class="line">        reader = reader.nextReader;</span><br><span class="line">    &#125;</span><br><span class="line">    // 读链头的前驱节点也是读链中任何节点的前驱节点</span><br><span class="line">    node.prev = reader.prev;</span><br><span class="line">    // 连接到读链尾</span><br><span class="line">    reader.nextReader = node;</span><br><span class="line">    node.readerHead = readerHead;</span><br><span class="line">    node.waitStatus = readerHead.waitStatus;</span><br><span class="line">    // 读链头记录的读链长度+1</span><br><span class="line">    readerHead.readerCount++;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReaderCanReentranted"><a href="#ReaderCanReentranted" class="headerlink" title="ReaderCanReentranted()"></a>ReaderCanReentranted()</h3><p>对于来说写者，只需判断当前线程是否为持有锁线程即可判断是否可以重入；而对于读者来说，只要当前线程与正在读的读链中的任意一个线程相等即可重入。</p><p>同样线程同名的情况也不可避免。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断读者是否可以重入，判断依据为当前线程是否被正在执行读的读链中的某一个节点持有</span><br><span class="line"> */</span><br><span class="line">private bool ReaderCanReentranted()</span><br><span class="line">&#123;</span><br><span class="line">    Node node = head.next;</span><br><span class="line">    if (node == null || !node.isShared())</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node reader = node;</span><br><span class="line">        while (reader != null)</span><br><span class="line">        &#123;</span><br><span class="line">            if (reader.thread == Thread.CurrentThread)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            reader = reader.nextReader;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString()"></a>ToString()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 覆盖ToString方法，格式化输出当前队列情况</span><br><span class="line"> */</span><br><span class="line">public override string ToString()</span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    if (head != null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (owner != null)</span><br><span class="line">            sb.Append(&quot;Head(持有线程：&quot; + owner.Name + &quot;，重入量：&quot; + reentrants + &quot;)\n&quot;);</span><br><span class="line">        else</span><br><span class="line">            sb.Append(&quot;Head(持有线程：未持有线程，重入量：&quot; + reentrants + &quot;)\n&quot;);</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        while (node != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Node reader = node;</span><br><span class="line">            if (node.isShared())</span><br><span class="line">            &#123;</span><br><span class="line">                while (reader != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：读，状态：&#123;1&#125;】&quot;, reader.thread.Name, Node.GetStatus(reader.waitStatus));</span><br><span class="line">                    reader = reader.nextReader;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.AppendLine();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sb.AppendFormat(&quot;-&gt;【线程名称：&#123;0&#125;，类型：写，状态：&#123;1&#125;】&quot;, node.thread.Name, Node.GetStatus(node.waitStatus));</span><br><span class="line">                sb.AppendLine();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace ReadWriteLock</span><br><span class="line">&#123;</span><br><span class="line">    class MainClass</span><br><span class="line">    &#123;</span><br><span class="line">      public static void Add(ReadWriteLock readWriteLock)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100000000; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                readWriteLock.WriteLock();</span><br><span class="line">                N++;</span><br><span class="line">                readWriteLock.WriteUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void TestReentrantWriter(ReadWriteLock readWriteLock)</span><br><span class="line">        &#123;</span><br><span class="line">            readWriteLock.WriteLock();</span><br><span class="line">            readWriteLock.WriteLock();</span><br><span class="line">            readWriteLock.WriteLock();</span><br><span class="line">            readWriteLock.WriteLock();</span><br><span class="line">            Thread.Sleep(1000);</span><br><span class="line">            readWriteLock.WriteUnlock();</span><br><span class="line">            readWriteLock.WriteUnlock();</span><br><span class="line">            readWriteLock.WriteUnlock();</span><br><span class="line">            readWriteLock.WriteUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        public static void TestWriter(ReadWriteLock readWriteLock)</span><br><span class="line">        &#123;</span><br><span class="line">            readWriteLock.WriteLock();</span><br><span class="line">            Thread.Sleep(500);</span><br><span class="line">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class="line">            readWriteLock.WriteUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        public static void TestReader(ReadWriteLock readWriteLock)</span><br><span class="line">        &#123;</span><br><span class="line">            readWriteLock.ReadLock();</span><br><span class="line">            Thread.Sleep(500);</span><br><span class="line">            //Console.WriteLine(Thread.CurrentThread.Name + &quot;执行完毕&quot;);</span><br><span class="line">            readWriteLock.ReadUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            ReadWriteLock readWriteLock = new ReadWriteLock();</span><br><span class="line">            for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">                CreateThread(false, i, readWriteLock);</span><br><span class="line">            for (int i = 1; i &lt;= 20; i++)</span><br><span class="line">                CreateThread(true, i, readWriteLock);</span><br><span class="line">            for (int i = 0; i &lt; 100; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(500);</span><br><span class="line">                readWriteLock.PrintQueue();</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">        static void CreateThread(bool share, int i, ReadWriteLock readWriteLock)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread thread;</span><br><span class="line">            if (share) </span><br><span class="line">            &#123;</span><br><span class="line">                thread = new Thread(() =&gt; TestReader(readWriteLock));</span><br><span class="line">                thread.Name = &quot;Reader-&quot; + i;            </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                thread = i == 5 ? new Thread(() =&gt; TestReentrantWriter(readWriteLock)) : new Thread(() =&gt; TestWriter(readWriteLock));</span><br><span class="line">                thread.Name = &quot;Writer-&quot; + i;</span><br><span class="line">            &#125;</span><br><span class="line">            thread.Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是两个线程同时增加1亿次的时间：约30s，比Monitor大概慢了5倍。</p><p>其次，测试创建了10个写线程、20个读线程，假定每个线程持续时间为500毫秒，每隔500毫秒输出等待队列的情况如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Head(持有线程：Writer-2，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-2，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-8，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-8，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-8，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-10，类型：读，状态：WAITING】-&gt;【线程名称：Reader-6，类型：读，状态：WAITING】-&gt;【线程名称：Reader-4，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-10，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-10，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-6，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-4，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-6，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-6，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-6，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-7，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-7，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-7，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-3，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-3，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-5，重入量：4)</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-5，重入量：4)</span><br><span class="line">-&gt;【线程名称：Writer-5，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：WAITING】-&gt;【线程名称：Reader-5，类型：读，状态：WAITING】-&gt;【线程名称：Reader-7，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-3，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-3，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-5，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-7，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-8，重入量：1)</span><br><span class="line">-&gt;【线程名称：Reader-8，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-8，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：SIGNAL】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-9，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-9，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-9，重入量：1)</span><br><span class="line">-&gt;【线程名称：Reader-9，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-4，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-4，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Writer-1，重入量：1)</span><br><span class="line">-&gt;【线程名称：Writer-1，类型：写，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：WAITING】-&gt;【线程名称：Reader-2，类型：读，状态：WAITING】-&gt;【线程名称：Reader-1，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-11，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-11，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-2，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-1，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：WAITING】-&gt;【线程名称：Reader-13，类型：读，状态：WAITING】-&gt;【线程名称：Reader-14，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-12，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-12，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-13，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-14，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：WAITING】-&gt;【线程名称：Reader-16，类型：读，状态：WAITING】-&gt;【线程名称：Reader-17，类型：读，状态：WAITING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-15，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-15，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-16，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-17，类型：读，状态：RUNNING】</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：WAITING】-&gt;【线程名称：Reader-19，类型：读，状态：WAITING】-&gt;【线程名称：Reader-20，类型：读，状态：WAITING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：Reader-18，重入量：3)</span><br><span class="line">-&gt;【线程名称：Reader-18，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-19，类型：读，状态：RUNNING】-&gt;【线程名称：Reader-20，类型：读，状态：RUNNING】</span><br><span class="line"></span><br><span class="line">Head(持有线程：未持有线程，重入量：0)</span><br><span class="line"></span><br><span class="line">Head(持有线程：未持有线程，重入量：0)</span><br></pre></td></tr></table></figure><p>如上述结果，每一行代表一个节点（读节点有不超过读链阈值的节点个数），Head开头说明打印了一次线程队列中的执行和等待情况。结果说明该读写锁可支持：</p><ol><li>多个线程的并发读访问</li><li>多个线程的写访问</li><li>避免了写饥饿</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用C#实现的&lt;code&gt;可重入&lt;/code&gt;、&lt;code&gt;非公平&lt;/code&gt;的&lt;code&gt;读写锁&lt;/code&gt;，主要目的实现&lt;strong&gt;并发读写&lt;/strong&gt;以及&lt;strong&gt;读写同步&lt;/strong&gt;问题。为了&lt;strong&gt;减少读等待时间&lt;/strong&gt;
      
    
    </summary>
    
      <category term="C#" scheme="http://blog.guitoubing.top/categories/C/"/>
    
    
      <category term=".NET" scheme="http://blog.guitoubing.top/tags/NET/"/>
    
      <category term="C#" scheme="http://blog.guitoubing.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C# - .NETFramework及EntityFramework</title>
    <link href="http://blog.guitoubing.top/2019/04/18/NET-Framework%E5%8F%8AEntityFramework/"/>
    <id>http://blog.guitoubing.top/2019/04/18/NET-Framework及EntityFramework/</id>
    <published>2019-04-18T03:07:39.000Z</published>
    <updated>2019-10-20T09:08:41.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>EntityFramework</code>是一种对象关系映射器<code>ORM</code>，它使<code>.NET</code>开发人员能够使用<code>.NET</code>对象处理数据库。它消除了开发人员通常需要编写的大多数数据访问代码的需要。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>本次实验我使用最新的<code>Microsoft Visual Studio Community 2019</code>版本进行实验，环境配置过程中也是历经坎坷，在此记录如下。</p><h3 id="VS2019连接MySQL"><a href="#VS2019连接MySQL" class="headerlink" title="VS2019连接MySQL"></a>VS2019连接MySQL</h3><p>使用VS2019连接MySQL时需要两个必备的程序：</p><ul><li><p><a href="https://cdn.mysql.com//Downloads/MySQL-for-VisualStudio/mysql-for-visualstudio-1.2.8.msi" target="_blank" rel="noopener">mysql-for-visualstudio-1.2.8.msi</a>：<code>MySQL for Visual Studio</code>是<code>MySQL</code>提供给<code>Microsoft Visual Studio</code>的驱动，用来实现对MySQL对象和数据的访问。</p></li><li><p><a href="https://cdn.mysql.com//Downloads/Connector-Net/mysql-connector-net-6.10.8.msi" target="_blank" rel="noopener">mysql-connector-net-6.10.8.msi</a>：<code>MySQL Connector / NET</code>能够开发需要与<code>MySQL</code>进行安全，高性能数据连接的.NET应用程序。它实现了所需的<code>ADO.NET</code>接口，并集成到<code>ADO.NET</code>感知工具中。</p></li></ul><p>下载并安装完成之后，启动<code>VS2019</code>，选择<code>工具</code>-&gt;<code>连接到数据库</code>：</p><p><img src="/images/1555337368613.png" alt="1555337368613"></p><p>选择<code>MySQL Database</code>数据源：</p><p><img src="/images/1555337410546.png" alt="1555337410546"></p><p>填入我在<code>ADO.NET实验</code>中创建的数据库参数如下：</p><p><img src="/images/1555337487973.png" alt="1555337487973"></p><p>至此，关于<code>VS2019</code>连接<code>MySQL</code>的配置已经完成。</p><h3 id="关于创建的项目类型"><a href="#关于创建的项目类型" class="headerlink" title="关于创建的项目类型"></a>关于创建的项目类型</h3><p>在<code>.NET</code>家族中有<code>.NET Core</code>和<code>.NET Framework</code>两大平台，他们的区别如下：</p><p><strong>.NET Framework</strong>：支持<code>Windows</code>和<code>Web</code>应用程序。今天，您可以使用<code>Windows</code>窗体，<code>WPF</code>和<code>UWP</code>在<code>.NET Framework</code>中构建<code>Windows</code>应用程序。<code>ASP.NET MVC</code>用于在<code>.NET Framework</code>中构建<code>Web应用程序</code>。</p><p><strong>.NET Core</strong>：是一种新的开源和跨平台框架，用于为包括<code>Windows</code>，<code>Mac</code>和<code>Linux</code>在内的所有操作系统构建应用程序。<code>.NET Core</code>仅支持<code>UWP</code>和<code>ASP.NET Core</code>。<code>UWP</code>用于构建<code>Windows 10</code>目标<code>Windows</code>和移动应用程序。<code>ASP.NET Core</code>用于构建基于浏览器的<code>Web应用程序</code>。 </p><p>而在<code>VS2019</code>中也有两大类项目类型：</p><ul><li><p>.NET Core应用</p><p><img src="/images/1555335982957.png" alt="1555335982957"></p></li><li><p>.NET Framework应用</p><p><img src="/images/1555336042119.png" alt="1555336042119"></p></li></ul><p>而我们本次实验一定要选择<code>.NET Framework</code>应用，否则无法通过<code>EntityFramework</code>创建实体数据模型。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>这里我选择的是<code>控制台应用(.NET Framework)</code>：</p><p><img src="/images/1555336181441.png" alt="1555336181441"></p><p>注意最后一项<code>框架</code>最好选择<code>4.6.0</code>以上的框架，这里我选择最新版本<code>4.7.2</code>。</p><h3 id="NuGet添加程序包"><a href="#NuGet添加程序包" class="headerlink" title="NuGet添加程序包"></a>NuGet添加程序包</h3><p><img src="/images/1555336839432.png" alt="1555336839432"></p><p>使用NuGet添加程序包时最要紧的就是程序包的版本问题。</p><p><strong>注意！！！：</strong>在前面安装MySQL Connector / NET时，选择的版本是6.10.8，因此我们这里的MySql.Data和MySql.Data.Entity两个程序包的版本也需要一致为<code>v6.10.8</code>，否则会出现各式各样的错误，我遇到的错误有以下两个：</p><ol><li><p><img src="/images/1555337786084.png" alt="1555337786084"></p></li><li><p>在1问题解决后，点击下一步会闪退。</p></li></ol><p>至此环境配置已完成，下面针对EntityFramework三种模型来说明。</p><h2 id="DB-First（来自数据库的EF设计器）"><a href="#DB-First（来自数据库的EF设计器）" class="headerlink" title="DB First（来自数据库的EF设计器）"></a>DB First（来自数据库的EF设计器）</h2><p>右键项目解决方案，选择<code>添加</code>-&gt;<code>新建项</code>：</p><p><img src="/images/1555338066598.png" alt="1555338066598"></p><p>选择<code>ADO.NET实体数据模型</code>，单击<code>下一步</code>：</p><p><img src="/images/1555338108853.png" alt="1555338108853"></p><p>选择<code>来自数据库的EF设计器</code>，单击<code>下一步</code>：</p><p><img src="/images/1555338141910.png" alt="1555338141910"></p><p>点击<code>是，在连接字符串中包含敏感数据</code>，单击<code>下一步</code>：</p><p><img src="/images/1555338199372.png" alt="1555338199372"></p><p>在<code>表</code>选项前打勾，单击完成：</p><p><img src="/images/1555338281068.png" alt="1555338281068"></p><p>完成后会发现，项目解决方案中出现了<code>Model1.edmx</code>文件，里面有两种主要的类<code>DBContext</code>和<code>DBSet</code>：</p><p><img src="/images/1555338670472.png" alt="1555338670472"></p><h3 id="DbSet"><a href="#DbSet" class="headerlink" title="DbSet"></a>DbSet</h3><p><code>DbSet</code>对应于数据库中的表，意即每个实体表对应一个<code>DbSet</code>实体类，相当于数据的集合，可通过此类间接对数据库表进行<code>ACID操作</code>再通过<code>DbContext</code>关联到数据库。具体操作再介绍完<code>DbContext</code>后一齐举例。</p><h3 id="DbContext"><a href="#DbContext" class="headerlink" title="DbContext"></a>DbContext</h3><p> <code>DbContext</code>类是实体框架的重要组成部分。它是您的域或实体类与数据库之间的桥梁。</p><p><img src="/images/1555338761379.png" alt="1555338761379"></p><p><code>DbContext</code>是负责与数据交互作为对象的主要类。<code>DbContext</code>负责以下活动：</p><ol><li><code>EntitySet</code>： <code>DbContext</code>包含映射到数据库表的所有实体的实体集（<code>DbSet &lt;TEntity&gt;</code>）。</li><li>查询（Querying）： <code>DbContext</code>将<code>LINQ-to-Entities</code>查询转换为<code>SQL查询</code>并将其发送到数据库。</li><li>更改跟踪（Change Tracking）：跟踪实体在从数据库查询后发生的更改。</li><li>持久数据（Persisting Data）：它还根据实体的状态对数据库执行插入，更新和删除操作。</li><li>缓存（Caching）： DbContext默认进行一级缓存。它存储在上下文类生命周期中已经被检索的实体。</li><li>管理关系（Manage Relationship）： <code>DbContext</code>还使用<code>DB-First</code>或<code>Model-First</code>方法使用<code>CSDL</code>，<code>MSL</code>和<code>SSDL</code>或者使用<code>Code-First</code>方法使用流利的<code>API</code>来管理关系。</li><li>对象实现（Object Materialization）： <code>DbContext</code>将原始表数据转换为实体对象。</li></ol><p>下面是使用<code>DBContext</code>的示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace EF</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            assignment4Entities entities = new assignment4Entities();</span><br><span class="line"></span><br><span class="line">            // 增</span><br><span class="line">            student student = new student</span><br><span class="line">            &#123;</span><br><span class="line">                Id = 4,</span><br><span class="line">                Name = &quot;Tanrui&quot;,</span><br><span class="line">                Age = 23</span><br><span class="line">            &#125;;</span><br><span class="line">            entities.student.Add(student);</span><br><span class="line">            student = new student</span><br><span class="line">            &#123;</span><br><span class="line">                Id = 5,</span><br><span class="line">                Name = &quot;TanRui&quot;,</span><br><span class="line">                Age = 23</span><br><span class="line">            &#125;;</span><br><span class="line">            entities.student.Add(student);</span><br><span class="line">            entities.SaveChanges();</span><br><span class="line"></span><br><span class="line">            // 删</span><br><span class="line">            foreach (var stu in entities.student.Where(stu =&gt; stu.Name == &quot;Tanrui1&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                entities.student.Remove(stu);</span><br><span class="line">            &#125;</span><br><span class="line">            entities.SaveChanges();</span><br><span class="line"></span><br><span class="line">            // 改</span><br><span class="line">            foreach ( var stu in entities.student.Where(stu =&gt; stu.Name == &quot;TanRui&quot;) )</span><br><span class="line">            &#123;</span><br><span class="line">                stu.Age = 25;</span><br><span class="line">            &#125;</span><br><span class="line">            entities.SaveChanges();</span><br><span class="line"></span><br><span class="line">            // 查（使用Linq）</span><br><span class="line">            var query = from s in entities.student</span><br><span class="line">                        select new</span><br><span class="line">                        &#123;</span><br><span class="line">                            Name = s.Name,</span><br><span class="line">                            Age = s.Age</span><br><span class="line">                        &#125;;</span><br><span class="line">            foreach(var item in query)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过数据库查看数据变化情况如期望一样。</p><h2 id="Code-First（空Code-First模型）"><a href="#Code-First（空Code-First模型）" class="headerlink" title="Code First（空Code First模型）"></a>Code First（空Code First模型）</h2><p>创建步骤和<code>DB First</code>类似，区别如下：</p><p>在选择<code>实体数据模型内容</code>时选择<code>空Code First模型</code>，直接点击完成即可：</p><p><img src="/images/1555348366529.png" alt="1555348366529"></p><p>点击完成后我们发现解决方案中出现了<code>Model1.cs</code>文件，同时查看<code>App.Config</code>文件发现多了下面内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"Model1"</span> <span class="attr">connectionString</span>=<span class="string">"data source=(LocalDb)\MSSQLLocalDB;initial catalog=EF.Model1;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework"</span> <span class="attr">providerName</span>=<span class="string">"System.Data.SqlClient"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>VS2019</code>默认使用<code>SQLserver数据库文件</code>格式存储<code>Code First</code>生成的数据模型，而此处我们要使用的是<code>MySQL数据库</code>，因此需要更改<code>connectionStrings</code>参数如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"Model1"</span> <span class="attr">providerName</span>=<span class="string">"MySql.Data.MySqlClient"</span> <span class="attr">connectionString</span>=<span class="string">"server=localhost;userid=tanrui;password=tanrui;database=assignment4;persistsecurityinfo=True"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件修改好之后，我们还需要修改<code>Model1.cs</code>文件，先看自动生成的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EF</span><br><span class="line">&#123;</span><br><span class="line">    using System;</span><br><span class="line">    using System.Data.Entity;</span><br><span class="line">    using System.Linq;</span><br><span class="line">    [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</span><br><span class="line">    public class Model1 : DbContext</span><br><span class="line">    &#123;</span><br><span class="line">        //您的上下文已配置为从您的应用程序的配置文件(App.config 或 Web.config)</span><br><span class="line">        //使用“Model1”连接字符串。默认情况下，此连接字符串针对您的 LocalDb 实例上的</span><br><span class="line">        //“EF.Model1”数据库。</span><br><span class="line">        // </span><br><span class="line">        //如果您想要针对其他数据库和/或数据库提供程序，请在应用程序配置文件中修改“Model1”</span><br><span class="line">        //连接字符串。</span><br><span class="line">        public Model1()</span><br><span class="line">            : base(&quot;name=Model1&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //为您要在模型中包含的每种实体类型都添加 DbSet。有关配置和使用 Code First  模型</span><br><span class="line">        //的详细信息，请参阅 http://go.microsoft.com/fwlink/?LinkId=390109。</span><br><span class="line"></span><br><span class="line">        public virtual DbSet&lt;MyEntity&gt; MyEntities &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class MyEntity</span><br><span class="line">    &#123;</span><br><span class="line">        public int Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>为我们自动生成的<code>Model1.cs</code>中已经给出了最基本的<code>Code First范例</code>，这里为了简便起见，我们没有新建<code>MyEntity.cs文件</code>，而是直接在<code>Model1.cs</code>中声明此<code>Model类</code>，并在<code>Model1类</code>中定义对应的<code>DbSet对象</code>。</p><p>注意，上述代码中第6行的 <code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>内容需要手动添加，自动生成时不会自动添加。</p><p>至此我们假设已经创建了一个简单的逻辑表，现在需要将其同步到数据库中：</p><p><img src="/images/1555348996560.png" alt="1555348996560"></p><p>如图，打开<code>程序包管理器控制台</code>，输入如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为项目启用迁移</span><br><span class="line">PM&gt; Enable-Migrations</span><br><span class="line"># 为当前设计器代码模型生成一次快照，在搭建迁移基架时会使用最近一次的快照，意即更改代码后，需要重新执行此命令</span><br><span class="line">PM&gt; Add-Migration AddMyEntity</span><br><span class="line"># 将更改迁移到数据库</span><br><span class="line">PM&gt; Update-Database -Verbose</span><br></pre></td></tr></table></figure><p>可能出现的错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未为提供程序“MySql.Data.MySqlClient”找到任何 MigrationSqlGenerator。请在目标迁移配置类中使用 SetSqlGenerator 方法以注册其他 SQL 生成器。</span><br></pre></td></tr></table></figure><p>原因：在Model1类定义前未手动添加<code>[DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]</code>。</p><p>当上述迁移成功完成后，就可以测试数据库是否真正生效了，测试代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace EF</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Model1 model = new Model1();</span><br><span class="line">            MyEntity entity = new MyEntity</span><br><span class="line">            &#123;</span><br><span class="line">                Id = 1,</span><br><span class="line">                Name = &quot;Tanrui&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            model.MyEntities.Add(entity);</span><br><span class="line">            model.SaveChanges();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行完之后查看数据库：</p><p><img src="/images/1555349943322.png" alt="1555349943322"></p><p>可以看到，<code>myentities表</code>已成功添加到数据库中，一行数据也成功插入到表中了。</p><blockquote><p>Tips: 注意到Code First还有个来自数据库的Code First，它实际上是根据现有的表生成对应的代码设计器，用户需要修改表结构时可通过修改设计器，而后更新迁移再更新到数据库中，个人感觉这和DB First没什么区别，而且不如DB First来的灵活。</p><p><img src="/images/1555350134801.png" alt="1555350134801"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;EntityFramework&lt;/code&gt;是一种对象关系映射器&lt;code&gt;ORM&lt;/code&gt;，它使&lt;code&gt;.NET&lt;/c
      
    
    </summary>
    
      <category term="C#" scheme="http://blog.guitoubing.top/categories/C/"/>
    
    
      <category term=".NET" scheme="http://blog.guitoubing.top/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>C# - ADO.NET配置说明</title>
    <link href="http://blog.guitoubing.top/2019/04/18/Framework/"/>
    <id>http://blog.guitoubing.top/2019/04/18/Framework/</id>
    <published>2019-04-18T03:04:15.000Z</published>
    <updated>2019-10-20T08:53:44.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ADO.NET</code>提供对数据库如<code>MySQL</code>和<code>XML</code>这样的数据源以及通过<code>OLE DB</code>和<code>ODBC</code>公开的数据源的一致访问。共享数据的使用方应用程序可以使用<code>ADO.NET</code>连接到这些数据源，并可以检索、处理和更新其中包含的数据。</p><h2 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS A:\&gt; cd .\MySQL\mysql-5.7.25-winx64\bin\</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装MySQL服务</span></span><br><span class="line">PS A:\MySQL\mysql-5.7.25-winx64\bin&gt; .\mysqld install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化MySQL数据库，创建无root密码的root用户</span></span><br><span class="line">PS A:\MySQL\mysql-5.7.25-winx64\bin&gt; mysqld --initialize-insecure</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动MySQL服务</span></span><br><span class="line">PS A:\MySQL\mysql-5.7.25-winx64\bin&gt; net start mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户，设置密码并赋予权限</span></span><br><span class="line">PS A:\MySQL\mysql-5.7.25-winx64\bin&gt; mysql -uroot</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户并设置密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create user <span class="string">'tanrui'</span>@<span class="string">'localhost'</span> identified by <span class="string">'tanrui'</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> grant all privileges on *.* to <span class="string">'tanrui'</span>@<span class="string">'localhost'</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">Bye</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以新用户登录数据库</span></span><br><span class="line">PS A:\MySQL\mysql-5.7.25-winx64\bin&gt; mysql -utanrui -ptanrui</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 7</span><br><span class="line">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database Assignment4;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| assignment4        |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="使用DataGrip连接数据库"><a href="#使用DataGrip连接数据库" class="headerlink" title="使用DataGrip连接数据库"></a>使用DataGrip连接数据库</h3><p>设置连接参数如下，点击<code>OK</code>完成连接：</p><p><img src="/images/1555227842703.png" alt="1555227842703"></p><p>右键<code>assignment4</code>数据库点击<code>New</code>-&gt;<code>Table</code>创建<code>Student</code>和<code>Score</code>新表：</p><p><img src="/images/1555227964411.png" alt="1555227964411"></p><p><img src="/images/1555228253075.png" alt="1555228253075"></p><p><img src="/images/1555228331186.png" alt="1555228331186"></p><h2 id="Visual-Studio-Nuget包管理"><a href="#Visual-Studio-Nuget包管理" class="headerlink" title="Visual Studio Nuget包管理"></a>Visual Studio Nuget包管理</h2><p>本次实验需要用到<code>MySQL</code>一些操作，因此需要在<code>Visual Studio</code>中添加相应的包，如下：</p><p><img src="/images/image-20190414160931753.png" alt="image-20190414160931753"></p><p>打开<code>Nuget包管理器</code>，下载<code>Mysql.Data</code>和<code>System.Data.DataSetExtensions</code>两个包，前者提供<code>MySQL</code>连接驱动，后者主要是提供<code>C#</code>中对于数据库表操作的一些语法支持。</p><p><img src="/images/image-20190414161020200.png" alt="image-20190414161020200"></p><h2 id="ADONET基础编程"><a href="#ADONET基础编程" class="headerlink" title="ADONET基础编程"></a>ADONET基础编程</h2><h3 id="一个小示例"><a href="#一个小示例" class="headerlink" title="一个小示例"></a>一个小示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Data;</span><br><span class="line">using MySql.Data.MySqlClient;</span><br><span class="line"></span><br><span class="line">namespace ADONET</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Hello World!&quot;);</span><br><span class="line">            //ADO.NET 几个关键对象</span><br><span class="line">            //(1) Connection对象 用于连接数据库</span><br><span class="line">            //(2) Command对象 对数据源执行命令</span><br><span class="line">            //(3) DataReader对象 用户从数据源读取数据</span><br><span class="line">            //(4) DataAdapter对象 从数据源读取数据并且填充数据集对象 </span><br><span class="line">            //(5) DataSet对象 相当于内存数据库</span><br><span class="line">            //(6) DataTable对象 相当于内存数据库中的表格</span><br><span class="line">            string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4&quot;;</span><br><span class="line">            MySqlConnection conn = new MySqlConnection(connString);</span><br><span class="line">            conn.Open();</span><br><span class="line"></span><br><span class="line">            MySqlCommand cmd = new MySqlCommand();</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line">            //ExecuteNonQuery的简单使用</span><br><span class="line">                        cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                        cmd.CommandText = &quot;insert into Student values (2,&apos;zhangsan2&apos;,19)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                        cmd.CommandText = &quot;insert into Student values (3,&apos;zhangsan3&apos;,22)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                        cmd.CommandText = &quot;insert into Score values (1,80,85)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                        cmd.CommandText = &quot;insert into Score values (2,90,95)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                        cmd.CommandText = &quot;insert into Score values (3,86,75)&quot;;</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">                       </span><br><span class="line">            //参数化查询的使用，是目前唯一可以预防SQL Injection的方法</span><br><span class="line">            cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class="line">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class="line">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;,</span><br><span class="line">            &quot;newstudent&quot;));</span><br><span class="line">                        cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class="line">                        cmd.ExecuteNonQuery();</span><br><span class="line">            //ExecuteReader的简单使用</span><br><span class="line">            cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class="line">            object nRows = cmd.ExecuteScalar();</span><br><span class="line">            Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br><span class="line"></span><br><span class="line">cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class="line">            MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class="line">            while(dr.Read())</span><br><span class="line">            &#123;</span><br><span class="line">                 Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class="line">dr.GetValue(0), dr[&quot;Name&quot;], dr.GetValue( dr.GetOrdinal(&quot;Age&quot;) ));</span><br><span class="line">            &#125;</span><br><span class="line">            dr.Close();</span><br><span class="line">            //使用MySqlDataAdapter填充DataSet</span><br><span class="line">            DataSet ds = new DataSet();</span><br><span class="line">            MySqlDataAdapter adapter = new MySqlDataAdapter(cmd);</span><br><span class="line">            cmd.CommandText = &quot;select * from Student&quot;;</span><br><span class="line">            adapter.Fill(ds, &quot;Student&quot;);</span><br><span class="line">            cmd.CommandText = &quot;select * from Score&quot;;</span><br><span class="line">            adapter.Fill(ds, &quot;Score&quot;);</span><br><span class="line">            DataTable Student = ds.Tables[&quot;Student&quot;];</span><br><span class="line">            DataTable Score = ds.Tables[&quot;Score&quot;];</span><br><span class="line">            //LINQ与DataTable的结合</span><br><span class="line">            var qry = from s in Student.AsEnumerable()</span><br><span class="line">                      join c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class="line">                      where c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class="line">                      select new</span><br><span class="line">                      &#123;</span><br><span class="line">                          Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class="line">                          English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class="line">                          Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class="line">                      &#125;;</span><br><span class="line">            foreach (var item in qry)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            //可以使用using模式进行资源的释放</span><br><span class="line">            conn.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line">Hello World!</span><br><span class="line">nRows: 4</span><br><span class="line">One Row: 1,zhangsan1,20</span><br><span class="line">One Row: 2,zhangsan2,19</span><br><span class="line">One Row: 3,zhangsan3,22</span><br><span class="line">One Row: 100,newstudent,18</span><br><span class="line">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class="line">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class="line">*/~</span><br></pre></td></tr></table></figure><p>上述例子将ADONET中几个主要对象综合到了一起，下面逐一介绍各个对象的功能及用法。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><code>Connection对象</code>用于和数据库交互，若要操作数据库必须与其连接。创建连接时需要指定<code>数据库服务器</code>、<code>数据库名</code>、<code>用户名</code>、<code>密码</code>以及<code>其他所需参数</code>。例如本例中的<code>connString</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string connString = &quot;server = 127.0.0.1; user id = tanrui; password = tanrui; persistsecurityinfo = True; database = assignment4&quot;;</span><br></pre></td></tr></table></figure><p>每一种数据源都有特定的<code>Connection类</code>，例如本例中的<code>MySqlConnection</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySqlConnection conn = new MySqlConnection(connString);</span><br></pre></td></tr></table></figure><p>与<code>Java</code>不同，<code>C#</code>中创建的<code>Connection对象</code>是使用正常的构造函数创建一个连接，而<code>Java</code>中使用的是<strong>单例模式</strong>创建数据库连接。</p><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p><code>Command对象</code>针对<code>Connection对象</code>指定的数据源执行SQL语句和存储过程及函数。这个对象是架构在<code>Connection对象</code>上的，也就是说<code>Command对象</code>通过<code>Connection对象</code>操作数据源。</p><p>同样，对于每一种数据源都有特定的<code>Command类</code>，例如本例中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySqlCommand cmd = new MySqlCommand();</span><br><span class="line">cmd.Connection = conn;</span><br></pre></td></tr></table></figure><p>在创建了<code>MySqlCommand对象</code>后还需为其指定对应的<code>Connection对象</code>。</p><h4 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h4><p><code>ExecuteNonQuery()</code>方法主要用于<code>Command对象</code>的<code>增删改</code>操作。</p><p><code>Command对象</code>的基本使用方法如例中所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.CommandText = &quot;insert into Student values (1,&apos;zhangsan1&apos;,20)&quot;;</span><br><span class="line">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure><p>先指定其<code>CommandText</code>即SQL语句，而后调用<code>ExecuteNonQuery()</code>方法完成query。</p><p>上述SQL操作方法很容易被非法分子通过字符串拼接等方式进行<code>SQL注入攻击</code>，我们可以使用<code>Parameters</code>修饰SQL语句，以防止<code>SQL注入攻击</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.CommandText = @&quot;INSERT INTO Student (Id,Name,Age) VALUES (@Id,@Name,@Age)&quot;;</span><br><span class="line">cmd.Parameters.Add(new MySqlParameter(&quot;@Id&quot;, 100));</span><br><span class="line">cmd.Parameters.Add(new MySqlParameter(&quot;@Name&quot;, &quot;newstudent&quot;));</span><br><span class="line">cmd.Parameters.Add(new MySqlParameter(&quot;@Age&quot;, 18));</span><br><span class="line">cmd.ExecuteNonQuery();</span><br></pre></td></tr></table></figure><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>查询由于返回的结果的复杂性，一般有<code>ExecuteScalar()</code>和<code>ExecuteReader()</code>两种方法。</p><p><code>ExecuteScalar()</code>主要用于<strong>SQL查询语句只返回一个数据</strong>，例如<code>Count操作</code>、<code>Max操作</code>等的返回值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.CommandText = &quot;select Count(*) from Student&quot;;</span><br><span class="line">object nRows = cmd.ExecuteScalar();</span><br><span class="line">Console.WriteLine(&quot;nRows: &#123;0&#125;&quot;, nRows);</span><br></pre></td></tr></table></figure><p><code>ExecuteReader()</code>返回一个<code>DataReader对象</code>，即结果集，下面会重点讨论该对象。</p><h3 id="DataReader"><a href="#DataReader" class="headerlink" title="DataReader"></a>DataReader</h3><p><code>DataReader对象</code>是对数据源的查询结果的<strong>基于流的、仅向前的只读检索</strong>，它不会更新数据。</p><p>它是基于<code>Command对象</code>的，意即只能通过调用<code>特定Command对象</code>的<code>ExecuteReader()</code>方法以获取<code>DataReader对象</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySqlDataReader dr = cmd.ExecuteReader();</span><br><span class="line">while(dr.Read())</span><br><span class="line">&#123;</span><br><span class="line">         Console.WriteLine(&quot;One Row: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;,</span><br><span class="line">         dr.GetValue(0),</span><br><span class="line">         dr[&quot;Name&quot;],</span><br><span class="line">         dr.GetValue(dr.GetOrdinal(&quot;Age&quot;) </span><br><span class="line">         ));</span><br><span class="line">&#125;</span><br><span class="line">dr.Close();</span><br></pre></td></tr></table></figure><p>同样，特定的数据源也是有特定类型的<code>DataReader类</code>，其都是通过继承<code>DbDataReader类</code>实现的。</p><p>由于<code>Read()</code>方法返回是否有下一行的布尔值，因此很适合使用<code>while循环</code>遍历结果。</p><p>从代码中易知，<code>DataReader对象</code>的<code>Read()</code>方法是通过循环从数据源中每次获取一行数据，类似于plsql中的游标，他除了读取效率很高之外，牺牲了很多其他特性，例如对结果的排序、更改等。</p><h3 id="DataSet和DataAdapter"><a href="#DataSet和DataAdapter" class="headerlink" title="DataSet和DataAdapter"></a>DataSet和DataAdapter</h3><p><code>DataSet类</code>包含数据的数据表集合。它用于在<strong>不与数据源交互</strong>的情况下获取数据，这就是为什么它也被称为<code>断开数据访问方法</code>。这是一个<strong>内存数据存储</strong>，可以<strong>同时容纳多个表</strong>。可以使用<code>DataRelation</code>对象来关联这些表。 <code>DataSet</code>也可以用来读写<code>XML文档</code>中的数据。</p><p><code>DataAdapter</code>是<code>ADO.NET</code>数据提供程序的一部分。<code>DataAdapter</code>提供<strong>数据集和数据源之间的通信</strong>。我们可以将<code>DataAdapter</code>与<code>DataSet</code>对象结合使用。注意<code>DataAdapter类</code>也是<strong>各个数据源有各自的实现方法</strong>。</p><p><code>DataAdapter</code>通过映射<code>Fill()</code>方法提供此组合，该方法更改<code>DataSet</code>中的数据以匹配数据源中的数据。也就是说，这两个对象组合起来以实现<code>数据访问</code>和<code>数据操作</code>功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataSet ds = new DataSet();</span><br><span class="line">SqlDataAdapter adapter = new SqlDataAdapter(cmd); cmd.CommandText = &quot;select * from Student&quot;; adapter.Fill(ds, &quot;Student&quot;);</span><br><span class="line">cmd.CommandText = &quot;select * from Score&quot;; adapter.Fill(ds, &quot;Score&quot;);</span><br><span class="line">DataTable Student = ds.Tables[&quot;Student&quot;]; DataTable Score = ds.Tables[&quot;Score&quot;];</span><br></pre></td></tr></table></figure><p>通过代码，我们可以看到<code>DataSet</code>是<strong>独立于数据源的数据集</strong>，即<strong>对于任何数据源，都提供一致的关系编程模型</strong>。</p><p>相比于<code>DataReader</code>，<code>DataSet</code><strong>一次性将所有数据放入内存中</strong>，同时还提供了很多额外的数据集操作方法，因此<strong>速度很快且很方便</strong>，但是<strong>对内存资源会有很大的消耗</strong>。</p><h3 id="DataTable"><a href="#DataTable" class="headerlink" title="DataTable"></a>DataTable</h3><p><code>DataTable</code>类将关系数据表示为表格形式。<code>ADO.NET</code>提供了一个<code>DataTable</code>类来独立创建和使用数据表。一般与<code>DataSet</code>一起使用。 </p><p>在创建<code>DataTable</code>之前，<strong>必须包含<code>System.Data</code>名称空间</strong>。同时由于本例中使用了<code>AsEnumerable()</code>方法，因此还<strong>必须使用<code>Nuget</code>添加<code>System.Data.DataSetExtensions</code>包</strong>，<strong>否则会报错</strong>。</p><p>我们可以使用LINQ语法对DataTable进行查询，实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var qry = from s in Student.AsEnumerable()</span><br><span class="line">join c in Score.AsEnumerable() on s.Field&lt;int&gt;(&quot;Id&quot;) equals c.Field&lt;int&gt;(&quot;StudentId&quot;)</span><br><span class="line">where c.Field&lt;int&gt;(&quot;English&quot;) &gt; 80</span><br><span class="line">          select new</span><br><span class="line">          &#123;</span><br><span class="line">                Name = s.Field&lt;string&gt;(&quot;Name&quot;),</span><br><span class="line">                English = c.Field&lt;int&gt;(&quot;English&quot;),</span><br><span class="line">                Maths = c.Field&lt;int&gt;(&quot;Maths&quot;)</span><br><span class="line">          &#125;;</span><br><span class="line">foreach (var item in qry)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line">&#123; Name = zhangsan2, English = 90, Maths = 95 &#125;</span><br><span class="line">&#123; Name = zhangsan3, English = 86, Maths = 75 &#125;</span><br><span class="line">**//~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ADO.NET&lt;/code&gt;提供对数据库如&lt;code&gt;MySQL&lt;/code&gt;和&lt;code&gt;XML&lt;/code&gt;这样的数据源以及
      
    
    </summary>
    
      <category term="C#" scheme="http://blog.guitoubing.top/categories/C/"/>
    
    
      <category term=".NET" scheme="http://blog.guitoubing.top/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>Java - 深入垃圾回收</title>
    <link href="http://blog.guitoubing.top/2019/04/11/%E6%B7%B1%E5%85%A5GC/"/>
    <id>http://blog.guitoubing.top/2019/04/11/深入GC/</id>
    <published>2019-04-11T02:36:03.000Z</published>
    <updated>2019-10-20T08:55:53.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>算法的基本思路是通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称作<code>引用链</code>。</p><p><img src="/images/可达性分析算法.png" alt="image-20190408154950595"></p><p>可作为GC Roots的对象包括下面几种：</p><ul><li><strong>虚拟机栈</strong>(栈帧中的<strong>本地变量表</strong>)中引用的对象</li><li>方法区中<strong>类静态属性</strong>引用的对象</li><li>方法去中<strong>常量</strong>引用的对象</li><li>本地方法栈中<code>JNI</code>引用的对象</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>程序代码中普遍存在的，类似于<code>Object obj = new Object();</code>这类的引用，<strong>只要强引用还存在，GC永远不会回收掉被引用的对象</strong>。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还<strong>有用但并非必需</strong>的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。可用SoftReference类来实现。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>比软引用强度低，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。可用WeakReference类来实现。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>最弱的引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><h2 id="再谈finalize"><a href="#再谈finalize" class="headerlink" title="再谈finalize()"></a>再谈finalize()</h2><p>即使在上述可达性分析算法中不可达的对象，<strong>也并非是非死不可的</strong>。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li>如果对象在进行可达性分析后没有与<code>GC Roots</code>相连接的引用链</li><li>进行筛选，条件是对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法以及被调用过，则虚拟机认定<code>没有必要执行</code>，此时才宣判对象已死</li></ol><h3 id="再生"><a href="#再生" class="headerlink" title="再生"></a>再生</h3><p>当有必要执行<code>finalize()</code>方法时，则对象就会有拯救自己的机会，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为finalize方法优先级很低，所以暂停0.5s以等待它</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码与上面完全相同，但是此次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Output:</span></span><br><span class="line"><span class="comment">finalize method executed!</span></span><br><span class="line"><span class="comment">yes, i am still alive.</span></span><br><span class="line"><span class="comment">no, i am dead!</span></span><br><span class="line"><span class="comment">**/</span>.</span><br></pre></td></tr></table></figure><p>从上述代码及其结果可看到，<code>SAVE_HOOK</code>对象的<code>finalize()</code>方法确实被GC触发过，其本身也在垃圾收集之前成功逃脱了。但是注意，由于一个对象的finalize()只会被执行一遍，因此上述代码中第二次将逃脱失败，无法完成自救。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><blockquote><p>关于GC的几种主流实现方法（简单记忆）：</p><ul><li>保守式GC(Conservative GC)：指JVM不记录内存上的某个数据应该被解读为引用类型还是其他类型。</li><li>半保守式GC(Conservative with respect to the roots)：让对象带有足够的元数据</li><li>准确式GC(Exact GC)：提供特定数据结构保存对象引用</li></ul></blockquote><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>枚举根节点这一过程是<strong>必须要停顿所有Java执行线程</strong>，即<code>Stop The World</code>。因为要保证这段时间的引用不变性。</p><p><code>Java</code>中使用<code>OopMap</code>来存储对象引用，以实现<code>准确性GC</code>，同时也避免了垃圾回收时需要遍历栈的每个位置。</p><h3 id="安全点-Safepoint"><a href="#安全点-Safepoint" class="headerlink" title="安全点 Safepoint"></a>安全点 Safepoint</h3><p><code>Hotspot</code>虚拟机<strong>只在到达<code>Safepoint</code>位置暂停</strong>，以进行GC。</p><p>程序中<strong>指令序列复用</strong>的指令，例如方法调用、循环跳转、异常跳转等情况，才会产生<code>Safepoint</code>。</p><p>在多线程中，有两种中断方案可供选择：</p><ul><li><strong>抢先式中断</strong>：GC发生时，将所有线程中断，而后让不在安全点上的线程恢复，直到跑到安全点。</li><li><strong>主动式中断</strong>：设置一个标志，各个线程主动轮询这个标志，发现中断标志为真时就自己中断挂起。</li></ul><h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域 Safe Region"></a>安全区域 Safe Region</h3><p>安全区域是为了解决<strong>程序<code>不执行</code>的时候，程序无法进入安全点的情况</strong>，例如线程处于<code>Sleep</code>或者<code>Blocked</code>状态时。</p><p>安全区域指的是一段代码片段之中，引用关系不会发生变化，因此在这个区域的任何地方开始GC都是安全的。</p><p>当线程执行到安全区域的代码中时：</p><ul><li>首先标识自己已经进入安全区域，此时JVM发起GC时就<strong>无需</strong>询问处于安全区域状态的线程了，直接回收</li><li>在线程要离开安全区域时，需要<strong>检查JVM是否已经完成了根节点枚举</strong>，如果完成了则线程继续执行，否则<strong>必须要等待直到收到可以安全离开安全区域的信号为止</strong>。</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><code>Serial收集器</code>是一个<strong>单线程的收集器</strong>，它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，同时它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><code>Serial收集器</code>的<strong>多线程</strong>版本。</p><p>目前只有<code>Serial</code>和<code>ParNew</code>能够与<code>CMS收集器</code>配合工作。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>此收集器的侧重点放在<code>吞吐量</code>上，吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即<code>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</code>。</p><p>注意，<strong>吞吐量与垃圾收集速度无太大关系</strong>。</p><p>同时采用此类收集器的虚拟机可根据系统运行状况手机性能监控信息，<strong>动态调整参数</strong>以提供最合适的停顿时间或最大的吞吐量。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><code>Serial收集器</code>的老年代版本，两大用途：</p><ol><li>与<code>Parallel Scavenge收集器</code>搭配使用</li><li>作为<code>CMS收集器</code>的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用。</li></ol><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><code>Parallel Scavenge收集器</code>的老年代版本。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。</p><h4 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h4><p>CMS收集器收集过程分为4个步骤：</p><ul><li><strong>初始标记：</strong>需要<code>Stop The World</code>，标记GC Roots能直接关联到的对象，速度很快。</li><li><strong>并发标记：</strong>不需要<code>Stop The World</code>，进行<code>GC Roots Tracing</code>。</li><li><strong>重新标记：</strong>需要<code>Stop The World</code>，标记因用户程序继续运作而导致变动的那一部分对象的标记记录。</li><li><strong>并发清除：</strong>不需要<code>Stop The World</code>，进行清除。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对CPU资源很敏感，当CPU资源紧张时，用户程序速度下降很明显。</li><li>无法处理浮动垃圾，即在标记之后出现的垃圾，只能留到下一次GC时再清理掉。同时使用CMS时，由于需要预留空间给用户线程，因此不能等到老年代几乎全部被填满了再进行收集。此时当CMS预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，这是就使用后备收集器<code>Serial Old</code>。</li><li>标记-清除算法会产生空间碎片。</li></ul><h3 id="G1收集器-Garbage-First"><a href="#G1收集器-Garbage-First" class="headerlink" title="G1收集器(Garbage First)"></a>G1收集器(Garbage First)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>G1收集器中新生代和老年代不再是物理隔离的，它<strong>将整个Java堆划分为多个大小相等的独立区域(<code>Region</code>)</strong>。</p><p>由于<code>Region</code>之间可能存在相互引用的关系，所以<strong>使用<code>Remembered Set</code>来记录从<code>其他Region</code>引用<code>当前Region</code>的引用信息</strong>，<strong><code>Remembered Set</code>是一种抽象概念，<code>Card Table</code>是其一种实现方式</strong>。</p><p>实际上，G1相关算法是个很复杂的过程，见<a href="https://hllvm-group.iteye.com/group/topic/44381#post-272188" target="_blank" rel="noopener">R大的帖子</a>，需要进一步研究。</p><h4 id="收集过程-1"><a href="#收集过程-1" class="headerlink" title="收集过程"></a>收集过程</h4><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次MinorGC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象指的是<strong>需要大量连续内存空间的Java对象</strong>，例如很长的字符串以及数组。更糟糕的是产生一群<strong>朝生夕灭</strong>的<strong>短命大对象</strong>。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个<code>对象年龄计数器</code>，当年龄增长到阈值时，就可以晋升到老年代。阈值默认为15，也可通过<code>MaxTenuringThredhold</code>参数设置。</p><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>当<code>Survivor</code>空间中<strong>相同年龄所有对象大小总和</strong>大于<code>Survivor</code>空间的一半，年龄大于等于该年龄的对象就直接进入老年代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可达性分析算法&quot;&gt;&lt;a href=&quot;#可达性分析算法&quot; class=&quot;headerlink&quot; title=&quot;可达性分析算法&quot;&gt;&lt;/a&gt;可达性分析算法&lt;/h2&gt;&lt;p&gt;算法的基本思路是通过一系列称为&lt;code&gt;GC Roots&lt;/code&gt;的对象作为起始点，从这些节点
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.guitoubing.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.guitoubing.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Java类与类加载器</title>
    <link href="http://blog.guitoubing.top/2019/03/27/Java%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://blog.guitoubing.top/2019/03/27/Java类与类加载器/</id>
    <published>2019-03-27T15:54:46.000Z</published>
    <updated>2019-10-20T08:53:59.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p><img src="/images/类加载机制.png" alt="image-20190327204927833"></p><p>其中<code>解析</code>可能会发生在<code>初始化</code>之后，<code>使用</code>可能不会被使用。</p><p>上述流程指的是<strong>开始时间</strong>的顺序，<strong>比如说<code>加载</code>未结束可能<code>验证</code>就会开始</strong>。</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>虚拟机严格规定了5种情况<strong>必须立即</strong>对类进行<strong>初始化</strong>(不是上述流程中的初始化，指的是初始化类对象)：</p><ol><li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这4条字节码指令时，如果类没有进行初始化则需要先触发其初始化。</p></li><li><p>对类进行反射调用；</p></li><li>当初始化一个类时，若父类还没有被初始化需要先触发其父类的初始化；</li><li>当虚拟机启动时，包含<code>main()</code>方法的那个类需要被初始化；</li><li>当使用动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且句柄对应的类没有被初始化。</li></ol><p><strong>不会触发</strong>类的初始化的<strong>可能操作</strong>：</p><ul><li><strong>通过子类调用父类的静态字段</strong>，不会导致<strong>子类</strong>初始化</li><li><strong>通过数组定义来引用类</strong>，不会触发该类的初始化</li><li><strong>引用类的静态常量域或字段</strong>，不会导致该类的初始化</li></ul><p>注意，接口也是会有初始化的过程，与类唯一不同的是上述<code>第3点</code>：接口在初始化时，<strong>并不要求其父接口全部都完成了初始化</strong>(原因应该是接口<code>&lt;clinit&gt;()</code>方法不需要调用父类的<code>&lt;clinit&gt;()</code>方法)，只有<strong>在真正使用到父接口的时候</strong>(如引用接口中定义的常量时)才会初始化。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载阶段的3件事情：</p><ol><li>通过一个类的<strong>全限定名</strong>来获取<strong>定义此类的二进制字节流</strong></li><li>将这个<strong>字节流所代表的静态存储结构</strong>转化为<strong>方法区</strong>的<strong>运行时数据结构</strong></li><li>在内存中<strong>生成一个代表这个类的<code>Class对象</code></strong>，作为方法区这个类的各种数据的访问入口</li></ol><p>第1件事情中的<code>二进制字节流</code>不一定是本地文件，可能是从<strong>ZIP获取</strong>、<strong>从网络获取(Applet)</strong>、<strong>动态代理</strong>、<strong>JSP生成</strong>、<strong>数据库读取</strong>等。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证主要是为了虚拟机对自身保护的一项重要工作，大致会完成以下4个阶段的检验动作：</p><ol><li>文件格式验证：检测字节流是否符合Class文件格式规范</li><li>元数据验证：语义分析，保证信息符合Java语言规范的要求，主要是<strong>数据类型</strong></li><li>字节码验证：最复杂的一部分，主要是对<strong>类的方法体</strong>进行校验(控制流、跳转等)</li><li>符号引用验证：发生在<code>解析</code>阶段，主要是对<strong>符号引用进行匹配性校验</strong>(能否找到、是否可达等)</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是为类变量(静态变量)分配初始值的过程。</p><p>注意两点：</p><ol><li>初始值<strong>通常情况</strong>下是<strong>数据类型的零值</strong>，比如语句<code>public static int value = 123;</code>会在准备阶段给<code>value</code>初始化为<code>int</code>的零值即<code>0</code>，而<code>123</code>会在<strong>后续的初始化阶段被赋值</strong>给<code>value</code>；</li><li><strong>特殊情况</strong>下，常量类型会在<strong>准备阶段被赋值</strong>，比如语句<code>public static final int value = 123;</code></li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>是指<strong>以一组符号来描述所引用的目标</strong>，符号引用在使用时能无歧义地定位到目标。</p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>是指<strong>可以直接指向目标的指针</strong>、<strong>相对偏移量</strong>或<strong>一个句柄</strong>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>正式开始执行类中定义的Java代码(或者说是字节码)。记得准备阶段有为变量赋予初始值，这里就会为其赋予程序中制定的初始值。</p><p>初始化主要的过程是执行<code>&lt;clinit&gt;()</code>方法。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和<strong>类本身</strong>一同确立其在JVM中的唯一性。</p><p>在使用<code>instanceof</code>关键字、Class对象的<code>equal()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>方法时，都需要判定上述两方面是否相等。<strong>自定义的类加载器</strong>和<strong>系统自带的类加载器</strong>加载的<strong>同一个类生成的对象使用相等方法验证是得不到相等结果的</strong>。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器划分：</p><ul><li>启动类加载器：负责将<code>&lt;JAVA_HOME&gt;\lib</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序无法直接引用。</li><li>扩展类加载器：负责将<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下的能被虚拟机识别的类库加载到虚拟机内存中，程序可直接使用。</li><li>应用程序类加载器：负责加载用户类路径(ClassPath)上的类库，程序可直接使用。</li></ul><p>双亲委派模型如下图所示：</p><p><img src="/images/双亲委派模型.png" alt="image-20190327234320380"></p><p>其中每一层与其父层关系一般<strong>不是继承(Inheritance)</strong>而是<strong>组合(Composition)</strong>来复用父加载器的代码。</p><p><strong>工作过程：</strong>如果一个类加载器收到了类加载的请求，它<strong>首先不会尝试加载这个类</strong>，而是<strong>把这个请求委派给父类加载器去加载</strong>，<strong>每个层次都是这样</strong>，直到请求被传递到<strong>顶层的启动类加载器</strong>中；而<strong>只有父加载器反馈自己无法完成此请求时，子加载器才回去尝试加载</strong>。</p><p>双亲委托模型在<code>ClassLoader</code>类中的<code>loadClass()</code>方法中实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h2&gt;&lt;p&gt;类加载机制个人认为是JVM中比较重要的一部分，因此在JVM系统学习之前就先学习了类加载机制的相关细节，以记之。&lt;/p
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.guitoubing.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.guitoubing.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java - 深入学习Java</title>
    <link href="http://blog.guitoubing.top/2019/03/06/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>http://blog.guitoubing.top/2019/03/06/深入学习Java（更新中）/</id>
    <published>2019-03-06T13:01:30.000Z</published>
    <updated>2019-10-20T08:56:04.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收器—GC"><a href="#垃圾回收器—GC" class="headerlink" title="垃圾回收器—GC"></a>垃圾回收器—GC</h2><p>众所周知，Java中的GC负责回收<strong>无用对象占用的内存资源</strong>，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于<strong>GC只释放那些经由new分配的内存</strong>，所以GC不知道如何释放该对象的这块”特殊”内存区域。</p><p>作为应对，Java允许在类中定义<code>finalize()</code>方法，它使得在GC回收该对象内存之前先调用<code>finalize()</code>方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在<code>finalize()</code>指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。</p><p><strong>关键点：</strong></p><ol><li>对象可能不被垃圾回收</li><li>垃圾回收并不等于”析构”</li><li>垃圾回收只与内存有关</li></ol><h3 id="避免使用finalize"><a href="#避免使用finalize" class="headerlink" title="避免使用finalize()"></a>避免使用finalize()</h3><blockquote><p>“终结函数无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页</p></blockquote><p>在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在<strong>通过某种创建对象以外的方式为对象分配了存储空间</strong>。</p><p>Native Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。</p><p>可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。</p><h3 id="终结条件的验证"><a href="#终结条件的验证" class="headerlink" title="终结条件的验证"></a>终结条件的验证</h3><p>但是finalize()有个有趣的用法——终结条件。看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="comment">// Book类，约定其在被回收前必须被签入。</span></span><br><span class="line"><span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line">Book(<span class="keyword">boolean</span> checkedOut)&#123;</span><br><span class="line">checkedOut = checkedOut;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">checkedOut = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 终结条件，对象未被签入</span></span><br><span class="line"><span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">System.out.println(<span class="string">"Error: checked out"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Book对象-novel</span></span><br><span class="line">Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 将其签入</span></span><br><span class="line">novel.checkIn();</span><br><span class="line">        <span class="comment">// 创建一个Book对象，此时该对象未被签入</span></span><br><span class="line"><span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 强制执行垃圾回收，此时会先执行finalize</span></span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。</p><blockquote><p>注意这里使用的System.gc()强制调用垃圾回收器</p></blockquote><p>若没有finalize()将很难实现这种操作。</p><h3 id="GC如何工作"><a href="#GC如何工作" class="headerlink" title="GC如何工作"></a>GC如何工作</h3><h4 id="引用计数（未被使用过）"><a href="#引用计数（未被使用过）" class="headerlink" title="引用计数（未被使用过）"></a>引用计数（未被使用过）</h4><p>对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。</p><p>缺陷：循环引用不适用，即出现”对象应该被回收，但引用计数不为0”的情况，称作”交互自引用的对象组”。如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器：1</span></span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器：1</span></span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器：2</span></span><br><span class="line">        object1.object = object2;</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器：2</span></span><br><span class="line">        object2.object = object1;</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器减少为1</span></span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器减少为1</span></span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将<code>object1</code>和<code>object2</code>赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。</p><h4 id="停止-复制（stop-and-copy）"><a href="#停止-复制（stop-and-copy）" class="headerlink" title="停止-复制（stop-and-copy）"></a>停止-复制（stop-and-copy）</h4><p>遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，将堆中<strong>所有存活的对象复制到另一个堆中</strong>，没有被复制的便都是垃圾了。</p><p>这种策略避免了上述”交互自引用的对象组”无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。</p><p><strong>缺陷：效率低</strong></p><ol><li>复制需要在两个堆之间操作，即需要维护多一倍的空间；</li><li>当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。</li></ol><p>针对第2个情况，有另外一种策略，如下。</p><h4 id="标记-清扫（mark-and-sweep）"><a href="#标记-清扫（mark-and-sweep）" class="headerlink" title="标记-清扫（mark-and-sweep）"></a>标记-清扫（mark-and-sweep）</h4><p>同样遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，同时会给该对象进行<strong>标记</strong>，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作”标记-整理”。</p><blockquote><p>注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。</p><p>许多文献中有关于”垃圾回收器是低优先级的后台进程”的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展”停止-复制”或”标记-清扫”工作。</p></blockquote><p>“标记-清扫”方式速度相当慢，但是当垃圾很少时，就很快了。</p><h4 id="自适应技术"><a href="#自适应技术" class="headerlink" title="自适应技术"></a>自适应技术</h4><p>JVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到”标记-清扫”方式；同样，JVM也会跟踪”标记-清扫”方式，若堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是自适应技术。</p><p>这是早期Sun版本的垃圾回收器。</p><h4 id="分代垃圾收集（Generational-Garbage-Collection）"><a href="#分代垃圾收集（Generational-Garbage-Collection）" class="headerlink" title="分代垃圾收集（Generational Garbage Collection）"></a>分代垃圾收集（Generational Garbage Collection）</h4><p>上述无论是”停止-复制”、”标记-清扫”还是”标记-整理”对于日益增长的对象列表，效率会逐渐低下。</p><p><img src="/images/image-20190225225057306.png" alt="image-20190225225057306"></p><p>堆被分为三代：</p><ul><li><p>年轻代(Young Generation)</p><p>内存空间：<strong>eden:S0:S1 = 8:1:1</strong></p><p>S0和S1<strong>没有先后顺序</strong>，任何一个都可能是<strong>From survivor space</strong>和<strong>To survivor space</strong></p></li><li><p>年老代(Old Generation)</p><p>内存空间：年老代:年轻代 ≈ 2:1</p></li><li><p>持久代(Permanent Generation)</p><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p></li></ul><p>下面说明一下对象在分配内存、老化、回收的过程：</p><ol><li><p>首先，任何新对象创建时内存都会分配在年轻代的<strong>eden space</strong>中，<strong>S0</strong>和<strong>S1</strong>两个<strong>幸存者空间(survivor space)</strong>起初都是空的<img src="/images/image-20190225225802212.png" alt="image-20190225225802212"></p></li><li><p>当eden space满时，会触发第一次<strong>较小的垃圾回收过程(minor garbage collection，minor GC)</strong><img src="/images/image-20190225230110077.png" alt="image-20190225230110077"></p><blockquote><p>实际上MinorGC不一定要等到eden space满了才触发</p></blockquote></li><li><p>eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收<img src="/images/image-20190225230647640.png" alt="image-20190225230647640"></p></li><li><p>当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象<img src="/images/image-20190225232204967.png" alt="image-20190225232204967"></p></li><li><p>再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收<img src="/images/image-20190225232407098.png" alt="image-20190225232407098"></p></li><li><p>当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代<img src="/images/image-20190225232630665.png" alt="image-20190225232630665"></p></li><li><p>以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发<strong>完全的垃圾回收(major gabarge collector, major GC)</strong>，清理并压缩该块内存空间。</p><p>major GC被触发的原因：</p><ol><li><p>年老代（Tenured）被写满</p></li><li><p>持久代（Permanent）被写满</p></li><li><p>System.gc()被显式调用</p></li><li><p>上一次GC之后Heap的各域分配策略动态变化</p></li></ol></li></ol><h5 id="HotSpot-JVM的垃圾收集器"><a href="#HotSpot-JVM的垃圾收集器" class="headerlink" title="HotSpot JVM的垃圾收集器"></a>HotSpot JVM的垃圾收集器</h5><p><strong>Serial收集器（复制算法)</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p><p><strong>Serial Old收集器(标记-整理算法)</strong>：老年代单线程收集器，Serial收集器的老年代版本。</p><p><strong>ParNew收集器(停止-复制算法)</strong>：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><p><strong>Parallel Scavenge收集器(停止-复制算法)</strong>：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p><p><strong>Parallel Old收集器(停止-复制算法)</strong>：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p><p><strong>CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)</strong>：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p><p>【参考：<a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解JVM(3)——7种垃圾收集器</a>】</p><h2 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h2><p>Java中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">Integer c = <span class="number">3</span>;</span><br><span class="line">Other.main(a, b);</span><br><span class="line">Other.main(a, b, c);</span><br><span class="line">        Other.main();</span><br><span class="line">        Other.main(<span class="keyword">new</span> Object[]&#123;a, b&#125;);</span><br><span class="line">Other.main(<span class="keyword">new</span> Object[]&#123;a, b, c&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Object s : args)&#123;</span><br><span class="line">System.out.println(s + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，当输入不同个数参数时，编译器会自动将其<strong>转换成数组</strong>，当参数本身就是数组时，编译器又<strong>不会进行转换</strong>，直接传递给函数。参数为空时编译器便<strong>直接传递一个空Object数组</strong>。</p><h3 id="可变参数列表的重载"><a href="#可变参数列表的重载" class="headerlink" title="可变参数列表的重载"></a>可变参数列表的重载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"first"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"second"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">f(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，函数有<code>f(Character... args)</code>和<code>f(String... args)</code>两种重载方式，此时<code>f(&#39;a&#39;, &#39;b&#39;)</code>和<code>f(&quot;a&quot;, &quot;b&quot;)</code>都可正常调用，但是<code>f()</code>会报错，即两种重载都匹配。</p><p>此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"first"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"second"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">f(<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，编译器也会报错，<code>f(&#39;a&#39;, &#39;b&#39;)</code>可匹配两个函数，(可能是)因为<code>char</code>类型可提升至<code>float</code>类型从而匹配第一个重载函数。</p><p>此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"first"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> i, Character... args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"second"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">f(<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法比较奇怪，因此”你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它”（《Java编程思想》105页）。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类对象对外围类对象的访问"><a href="#内部类对象对外围类对象的访问" class="headerlink" title="内部类对象对外围类对象的访问"></a>内部类对象对外围类对象的访问</h3><p>当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; items = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; items.length)&#123;</span><br><span class="line">            items[next++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span>(!selector.end())&#123;</span><br><span class="line">            System.out.print(selector.current() + <span class="string">" "</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。</p><h3 id="内部类与静态内部类（嵌套类）"><a href="#内部类与静态内部类（嵌套类）" class="headerlink" title="内部类与静态内部类（嵌套类）"></a>内部类与静态内部类（嵌套类）</h3><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类：DotNew.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner dni = dn.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类：DotNewStatic.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNewStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner() &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建静态内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNewStatic.Inner inner = <span class="keyword">new</span> DotNewStatic.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>Java支持<strong>创建一个继承自某基类的匿名类的对象</strong>，通过new表达式返回的引用被<strong>自动向上转型为对基类的引用</strong>。</p><p>匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。</p><p>注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是<code>final</code>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Destination.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parcel9.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span></span>&#123;<span class="comment">// 外部变量dest被引用时需声明为final，否则产生编译时错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</span><br><span class="line">        Destination d = p.destination(<span class="string">"Tasmania"</span>);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。</p></blockquote><blockquote><p><strong>为什么匿名内部类访问外部变量必须是final的？</strong></p><ol><li><p>为了避免<strong>外部方法修改引用导致内部类得到的引用值不一致</strong>和<strong>内部类修改引用而导致外部方法的参数值在修改前和修改后不一致</strong></p></li><li><p>保证回调函数回调时可访问到变量（<strong>待研究</strong>）</p></li><li><p>反编译查看其实现细节：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;    <span class="comment">// 源代码</span></span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useMyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">final</span> Integer number = <span class="number">123</span>;</span><br><span class="line">&gt;            System.out.println(number);</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            MyInterface myInterface = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;                    System.out.println(number);</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;;</span><br><span class="line">&gt;            myInterface.doSomething();</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            System.out.println(number);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="comment">// 反编译结果</span></span><br><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span>$1</span></span><br><span class="line"><span class="class">&gt;            <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">final</span> TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">final</span> Integer paramInteger;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        TryUsingAnonymousClass$<span class="number">1</span>(TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>, Integer paramInteger) &#123;</span><br><span class="line">&gt;            <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt;            <span class="keyword">this</span>.paramInteger = paramInteger;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(<span class="keyword">this</span>.paramInteger);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时<strong>实际上是做了个”拷贝”</strong>或者说<strong>“赋值”</strong>。若可以更改，则会造成数据不一致。</p></blockquote><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是<strong>多态的基础</strong>，由<strong>Class类实现</strong>。</p><h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>每当编写并且编译一个类时，在与类同名的<code>.class</code>文件中会自动产生一个<code>Class对象</code>。实现此过程的JVM子系统被称作<strong>类加载器</strong>。</p><p>Class对象仅在需要的时候才被加载，也就是所有的类都是<strong>只在对其第一次使用时</strong>，动态加载到JVM中的。所谓第一次使用指的是<strong>对类的非常量静态域的第一次引用。</strong></p><ul><li><p>要注意，<strong>类的构造器</strong>是<strong>隐性非常量静态域</strong>，所以使用new操作符生成对象也是产生这样的Class类引用。</p></li><li><p>与此同时，还可以使用<code>Class.forName(类名)</code>产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常<code>ClassNotFoundException</code>。比如在JDBC连接数据库时常常用到的<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，就是告诉JVM去加载MySQL驱动。</p></li><li><p>当已经拥有某个类型的对象（实例）时，可通过调用<code>getClass()</code>方法来获取该类型的Class引用。</p></li><li><p>另一种方法，使用<strong>类字面变量</strong>。通过使用<code>类名.class</code>可获取此类的Class对象的引用，但是注意，此时<strong>此Class对象还未被初始化</strong>，还需要等到上述的<code>对类的非常量静态域的第一次引用</code>这一操作执行时才被初始化。</p><blockquote><p>使用.class方法获取Class对象引用实际包含三个步骤：</p><ol><li><strong>加载</strong>：类加载器创建Class对象</li><li><strong>链接</strong></li><li><strong>初始化</strong>：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li></ol><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> java.util.Random;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">3</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 创建Initable的Class对象的引用，Class对象未初始化</span></span><br><span class="line">&gt;         Class initable = Initable.class;</span><br><span class="line">&gt;         <span class="comment">// 仍然未初始化，因Initable.staticFinal是常数</span></span><br><span class="line">&gt;         System.out.println(Initable.staticFinal);</span><br><span class="line">&gt;         <span class="comment">// 触发了Initable的Class对象的初始化</span></span><br><span class="line">&gt;         System.out.println(Initable.staticFinal2);</span><br><span class="line">&gt;         <span class="comment">// 触发了Initable2的Class对象的初始化</span></span><br><span class="line">&gt;         System.out.println(Initable2.staticNonFinal);</span><br><span class="line">&gt;         <span class="comment">// 创建Initable3的Class对象的引用，同时会初始化此Class对象</span></span><br><span class="line">&gt;         Class initable3 = Class.forName(<span class="string">"Initable3"</span>);</span><br><span class="line">&gt;         <span class="comment">// 此时已初始化，无需再次初始化</span></span><br><span class="line">&gt;         System.out.println(Initable3.staticNonFinal);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>另外，当我拥有某个Class对象c的时候，我虽然<strong>不知道它确切类型</strong>，但是可以使用<code>c.newInstance()</code>来正确地获取c代表的类型的实例。<strong>但是此方法要求对应的类</strong>。</p><h3 id="泛化的Class对象引用"><a href="#泛化的Class对象引用" class="headerlink" title="泛化的Class对象引用"></a>泛化的Class对象引用</h3><p>Class对象可以通过<code>Class&lt;Type&gt;</code>的方法产生特定类型的类引用，创建了<strong>使用类型限定后</strong>的Class对象引用<strong>不能再赋值给除本身和子类的其他的Class对象</strong>。</p><blockquote><p>注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如<code>Integer</code>继承自<code>Number</code>，而<code>Integer Class对象</code>却不是<code>Number Class对象</code>的子类。</p></blockquote><p>使用通配符<code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>（实际上是等价的），而且会免除编译器警告，看图：<img src="/images/image-20190308105552914.png" alt="image-20190308105552914"></p><p>一种更好的用法，<code>Class&lt;? extends Type&gt;</code>，这种类型限定比直接<code>Class&lt;Type&gt;</code>好的地方在于他产生的Class对象引用<strong>可赋值给Type本身及子类的Class对象</strong>，这种继承关系<strong>是Type所属的继承关系</strong>而<strong>不是对应的Class对象的继承关系</strong>。</p><h3 id="转型语法（不常用）"><a href="#转型语法（不常用）" class="headerlink" title="转型语法（不常用）"></a>转型语法（不常用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasts</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Building b = <span class="keyword">new</span> Building();</span><br><span class="line">        Class&lt;House&gt; houseType = House.class;</span><br><span class="line">        House h = houseType.cast(b);</span><br><span class="line">        h = (House) b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，使用<code>houseType.cast(b)</code>和<code>(House) b</code>效果一样，但是执行的工作却不同，具体内部实现尚未学习到。</p><h3 id="动态的类型检测"><a href="#动态的类型检测" class="headerlink" title="动态的类型检测"></a>动态的类型检测</h3><h4 id="obj-instanceof-ClassType"><a href="#obj-instanceof-ClassType" class="headerlink" title="obj instanceof ClassType"></a>obj instanceof ClassType</h4><p>返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。</p><h4 id="ClassType-isInstance"><a href="#ClassType-isInstance" class="headerlink" title="ClassType.isInstance()"></a>ClassType.isInstance()</h4><p>返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>区别主要是后者与前者动态等价，看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicEqual</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称</span></span><br><span class="line">        <span class="comment">// if (son instanceof father.getClass())&#123;</span></span><br><span class="line">        <span class="comment">//     ...</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。</span></span><br><span class="line">        <span class="keyword">if</span> (father.getClass().isInstance(son))&#123;</span><br><span class="line">            System.out.println(<span class="string">"isInstance is Dynamic"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>isInstance()</code>的存在可以替代<code>instanceof</code>，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：</p><ul><li>使用<code>instanceof</code>时可能需要使用<code>switch-case</code>语句；当需要添加一个子类时，需要修改<code>switch-case</code>内部代码。</li><li>而使用<code>isInstance()</code>时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。</li></ul><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="反射与RTTI的区别"><a href="#反射与RTTI的区别" class="headerlink" title="反射与RTTI的区别"></a>反射与RTTI的区别</h4><ul><li>RTTI：编译器在编译时打开和检查<code>.class</code>文件（获取类的Class类对象信息）</li><li>反射：JVM在运行时打开和检查<code>.class</code>文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取<code>.class</code>文件）</li></ul><h4 id="类方法提取器"><a href="#类方法提取器" class="headerlink" title="类方法提取器"></a>类方法提取器</h4><p>通过Class对象引用：调用<code>getMethods()</code>方法获取该类及其父类的方法列表，调用<code>getConstructors()</code>方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个<strong>非public类的非public方法是无法被获取的</strong>。</p><h4 id="接口与类型信息"><a href="#接口与类型信息" class="headerlink" title="接口与类型信息"></a>接口与类型信息</h4><p>interface关键字的一种重要目标就是允许程序员<strong>隔离构件，进而降低耦合性</strong>。</p><h4 id="包权限安全吗？"><a href="#包权限安全吗？" class="headerlink" title="包权限安全吗？"></a>包权限安全吗？</h4><p>直接看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HiddenC.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public C.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public C.g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"package C.u()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"protected C.v()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private C.w()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HiddenImplementation.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        A a = HiddenC.makeA();</span><br><span class="line">        a.f();</span><br><span class="line">        System.out.println(a.getClass().getName());</span><br><span class="line">        callHiddenMethod(a, <span class="string">"g"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"u"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"v"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callHiddenMethod</span><span class="params">(Object a, String methodName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取a中的方法</span></span><br><span class="line">        Method g = a.getClass().getDeclaredMethod(methodName);</span><br><span class="line">        <span class="comment">// 修改该方法的权限</span></span><br><span class="line">        g.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用该方法</span></span><br><span class="line">        g.invoke(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">public C.f()</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">public C.g()</span></span><br><span class="line"><span class="comment">package C.u()</span></span><br><span class="line"><span class="comment">protected C.v()</span></span><br><span class="line"><span class="comment">private C.w()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:)</span></span><br></pre></td></tr></table></figure><ul><li>当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用<code>setAccessble(true)</code>后被调用。</li><li>只发布<code>.class</code>文件也是没办法避免此问题，<code>javap -private</code>命令可以反编译<code>.class</code>文件，<code>-private</code>参数约定显示所有的成员</li><li>同样，内部类和匿名内部类也是没办法避免此情况</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="指定类型有保证吗？"><a href="#指定类型有保证吗？" class="headerlink" title="指定类型有保证吗？"></a>指定类型有保证吗？</h3><blockquote><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p></blockquote><p>例如对于<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>，二者的实例调用<code>.getClass()</code>获取的Class对象时相同的，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erase</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; s = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class&lt;?&gt; i = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(s == i);</span><br><span class="line">        System.out.println(s.getName());</span><br><span class="line">        System.out.println(s.getTypeParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">java.util.ArrayList</span></span><br><span class="line"><span class="comment">[Ljava.lang.reflect.TypeVariable;@68f7aae2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>但是，如果在一个<code>ArrayList&lt;String&gt;</code>类型的实例中添加<code>Integer</code>会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is an apple"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectAdd</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; s = strings.getClass();</span><br><span class="line">        Method method = s.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(strings, <span class="number">1</span>);</span><br><span class="line">        method.invoke(strings, <span class="string">"2"</span>);</span><br><span class="line">        method.invoke(strings, <span class="number">3</span>);</span><br><span class="line">        method.invoke(strings, <span class="keyword">new</span> Apple());</span><br><span class="line">        System.out.println(Arrays.toString(strings.toArray()));</span><br><span class="line">        <span class="keyword">for</span> (Object o : strings)&#123;</span><br><span class="line">            System.out.println(o.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, This is an apple]</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">class Apple</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>我们可以看到上述代码使用反射机制成功的在<code>ArrayList&lt;String&gt;</code>里面添加了<code>Integer</code>，原因在于<code>ArrayList</code>的泛型实现<code>ArrayList&lt;E&gt;</code>使其被擦除为<code>ArrayList&lt;Object&gt;</code>，从而通过反射机制找到其<code>add(E e)</code>方法时，实际上是<code>add(Object o)</code>，而我们代码中的<code>Method method = s.getMethod(&quot;add&quot;, Object.class);</code>恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。</p><h3 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++的区别"></a>与C++的区别</h3><p><strong>C++:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate2</span><span class="params">()</span> </span>&#123; obj.noF(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF()::f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontHaveF</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">noF</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Don't have f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">    <span class="comment">// manipulator.manipulate2();  无法编译</span></span><br><span class="line">    DontHaveF dhf;</span><br><span class="line">    Manipulator&lt;DontHaveF&gt; manipulator2(dhf);</span><br><span class="line">    <span class="comment">// manipulator2.manipulate();  无法编译</span></span><br><span class="line">    manipulator2.manipulate2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF()::f()</span></span><br><span class="line"><span class="comment">Don't have f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>模板类<code>Manipulator</code>在编译时期便可以检测到函数<code>f()</code>、<code>noF()</code>是在类型参数<t>中存在的，这是在编译器看到声明<code>Manipulator&lt;HasF&gt; manipulator(hf)</code>和<code>Manipulator&lt;DontHaveF&gt; manipulator2(dhf)</code>所产生的结果。</t></p><p>然而Java中却无法实现这样的操作：</p><p><strong>Java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HasF.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f();"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manipulation.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.f() <span class="comment">// 会报编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulation = <span class="keyword">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class="line">        manipulation.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java在编译过程中，<code>Manipulator&lt;T&gt;</code>是无法确定其类型参数，只知道他是一个<code>Object实例</code>，因此obj<strong>只能调用Object基类所有的公开方法</strong>。若想实现C++的操作有两种办法(目前我已知的只有这两种)。</p><ul><li><p>为<code>T</code>限定参数类型（给定边界），即声明时指定其所继承的基类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用反射机制调用<code>f()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;?&gt; oc = obj.getClass();</span><br><span class="line">        Method method = oc.getMethod(<span class="string">"f"</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulation = <span class="keyword">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class="line">        manipulation.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF.f();</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="擦除带来的问题"><a href="#擦除带来的问题" class="headerlink" title="擦除带来的问题"></a>擦除带来的问题</h3><blockquote><p>擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。</p></blockquote><p>泛型<strong>不能用于显式地引用运行时类型的操作之中</strong>，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。</p><p>也就是说，需要时刻提醒自己，我只是<strong>看起来好像拥有</strong>有关参数的类型信息而已。实际上，<strong>它只是一个Object！</strong></p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>既然编译器会<code>擦除</code>类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的<code>边界</code>：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Orange o = (Orange) flist.get(0); 运行时错误</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());  编译错误</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());  编译错误</span></span><br><span class="line">        System.out.println(flist.contains(a));</span><br><span class="line">        System.out.println(flist.contains(<span class="keyword">new</span> Apple()));</span><br><span class="line">        System.out.println(flist.indexOf(<span class="keyword">new</span> Apple()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>对于使用了通配符的<code>List&lt;? extends Fruit&gt; flist</code>来说，其需要用到类型参数的方法例如<code>add()</code>参数也变成了<code>&lt;? extends Fruit&gt;</code>，然而编译器并不能知道这里需要哪一个具体的子类型，于是<strong>编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。</strong></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>完整的容器分类法：</p><p><img src="/images/image-20190312200304819.png" alt="image-20190312200304819"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>采用了链地址法，也就是<strong>数组+链表</strong>的方式。主干是一个<code>Entry</code>数组，链表是为了解决哈希冲突而存在的。<code>HashMap</code>中的链表越少，性能越好。</p><h4 id="Entry数组长度为2的次幂"><a href="#Entry数组长度为2的次幂" class="headerlink" title="Entry数组长度为2的次幂"></a>Entry数组长度为2的次幂</h4><ul><li>由于在计算<code>key</code>的<code>插入位置</code>时用到了<code>hash &amp; (length-1)</code>，<code>hash</code>是<code>key</code>计算出来的哈希值，想象一下当<code>length</code>不为2的次幂时，<code>length-1</code>的二进制必然有<code>0位</code>，那么意味着该位为<code>0</code>的位置永远不可能被当做<code>插入位置</code>，造成了严重的空间浪费。</li><li>由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即<code>equal()</code>操作多了起来，效率也就慢了。</li></ul><h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p><code>HashMap</code>当<code>Entry</code>数组元素超过<code>数组大小*loadFactor</code>时，就会进行数组扩容。<code>loadFactor</code>默认值为0.75。此时<code>Entry</code>数组大小会扩大一倍，保证了2的次幂大小。</p><p>扩容的时候所有的<code>key</code>需要重新计算哈希值。</p><h4 id="JDK1-8优化"><a href="#JDK1-8优化" class="headerlink" title="JDK1.8优化"></a>JDK1.8优化</h4><p>由于1.8之前的<code>HashMap</code>在<code>hash</code>冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>HashTable</code>在结构上与<code>HashMap</code>基本相同，下面总结其不同点：</p><ul><li><code>HashMap</code>可有<code>null key</code>，<code>HashTable</code>获取<code>null key</code>会报空指针异常</li><li><code>HashTable</code>有<code>synchronized</code>方法同步，线程安全；<code>HashMap</code>线程不安全</li><li><code>Hash</code>值计算方法不同</li><li><code>HashTable</code>初始大小为<code>11</code>，扩容机制为<code>2*old+1</code>；<code>HashMap</code>初始大小为<code>16</code>，扩容机制为<code>2*old</code></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>JDK1.7</code>版本中的<code>ConcurrentHashMap</code>比<code>HashMap</code>多了一层<code>Segment</code>，其中<code>Segment</code>继承于<code>ReentrantLock</code>：<strong>一次<code>put</code>操作会调用<code>scanAndLockForPut()</code>方法自旋获取锁</strong>；<strong>而一次<code>get</code>操作则不需要加锁，<code>value</code>用<code>volatile</code>关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效</strong>。</p><p><code>JDK1.8</code>版本移除了<code>segment</code>，有一个<code>Node</code>数组相当于<code>HashMap</code>中的<code>Entry</code>数组。同时采用了<code>CAS+synchronized关键字</code>进行<code>put</code>操作。<code>put</code>操作步骤如下：</p><ul><li>根据<code>key</code>计算出<code>hashcode</code>；</li><li>判断是否需要进行初始化；</li><li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功；</li><li>判断是否需要进行扩容；</li><li>如果都不满足，则利用 <code>synchronized</code> 锁写入数据；</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="Brian-Goetz的线程同步规则"><a href="#Brian-Goetz的线程同步规则" class="headerlink" title="Brian Goetz的线程同步规则"></a>Brian Goetz的线程同步规则</h3><blockquote><p>如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，<strong>读写线程</strong>都必须用相同的监视器锁同步。</p></blockquote><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池的作用是<strong>限制系统中执行线程的数量</strong>，根据系统情况可以<strong>自动或手动</strong>设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。</p><ul><li><code>newSingleThreadExecutor()</code>：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。</li><li><code>newFixedThreadPool()</code>：创建固定大小的线程池。</li><li><code>newCachedThreadPool()</code>：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。</li><li><code>newScheduledThreadPool()</code>：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。</li></ul><h3 id="任务的返回值"><a href="#任务的返回值" class="headerlink" title="任务的返回值"></a>任务的返回值</h3><p>通常实现<code>Runnable</code>接口的类是没有返回值的，要想任务在完成时返回一个值可实现<code>Callable&lt;T&gt;</code>接口，其泛型类型参数表示方法<code>call()</code>的返回值，并且需要使用<code>ExecutorService.submit()</code>方法调用他。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result of TaskWithResult"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.err.println(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output：</span></span><br><span class="line"><span class="comment">result of TaskWithResult0</span></span><br><span class="line"><span class="comment">result of TaskWithResult1</span></span><br><span class="line"><span class="comment">result of TaskWithResult2</span></span><br><span class="line"><span class="comment">result of TaskWithResult3</span></span><br><span class="line"><span class="comment">result of TaskWithResult4</span></span><br><span class="line"><span class="comment">result of TaskWithResult5</span></span><br><span class="line"><span class="comment">result of TaskWithResult6</span></span><br><span class="line"><span class="comment">result of TaskWithResult7</span></span><br><span class="line"><span class="comment">result of TaskWithResult8</span></span><br><span class="line"><span class="comment">result of TaskWithResult9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>对象的<code>submit()</code>方法会返回一个<code>Future&lt;T&gt;</code>对象，泛型类型参数即是实现<code>Callable&lt;T&gt;</code>的类型参数。<code>get()</code>方法会返回结果，若任务未完成，<code>get()</code>会阻塞。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。</p><p>但是注意优先级高的线程也有几率比优先级底的线程执行的少。</p><p>优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。</p><h3 id="Thread-yield-可靠吗？"><a href="#Thread-yield-可靠吗？" class="headerlink" title="Thread.yield()可靠吗？"></a>Thread.yield()可靠吗？</h3><p><code>Thread.yield()</code>源码中提及了该方法的效果：<strong>当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。</strong>意即此处的<code>让步</code>只是一厢情愿，发出让步的线程同样可以继续执行。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程<strong>并不属于程序中不可或缺的部分</strong>。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p><p>执行<code>main()</code>就是一个非后台线程，当<code>main()</code>没有执行结束时，程序就不会终止。</p><p>后台线程创建的线程也将是后台线程。</p><p>同时要注意在后台线程的<code>run()</code>方法中若有<code>finally</code>子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。</p><h3 id="Thread还是Runnable"><a href="#Thread还是Runnable" class="headerlink" title="Thread还是Runnable"></a>Thread还是Runnable</h3><p>创建多线程任务可以继承<code>Thread</code>类重写其<code>run()</code>方法，也可以实现<code>Runnable</code>接口实现其<code>run()</code>方法。</p><p>实际应用中，<code>Runnable</code>还是比较有优势的：</p><ul><li>避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）</li><li>多个线程区处理同一资源，而非独立处理（这句话有问题）</li></ul><p>注意，一开始在理解这里的时候我出现了误解，什么叫<strong>处理同一资源</strong>，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了<strong>(待确认)</strong>，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"-- val: "</span> + val--);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">if</span>  (val &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"-- val: "</span> + val--);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">if</span> (val &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnableAndThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> TestRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        <span class="comment">// a.只有1个线程处理一个数据</span></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// b.5个不同线程处理不同数据</span></span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="comment">// c.5个不同线程处理相同数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="comment">// d.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execRun = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execRun.execute(runnable);</span><br><span class="line">        <span class="comment">// e.5个不同线程处理5个不同数据</span></span><br><span class="line">        ExecutorService execRun2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execRun2.execute(<span class="keyword">new</span> TestRunnable());</span><br><span class="line">        <span class="comment">// f.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execThread = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            execThread.execute(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// g.5个不同线程处理5个不同数据</span></span><br><span class="line">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execThread2.execute(<span class="keyword">new</span> TestThread());</span><br><span class="line">        <span class="comment">// i.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execThread2.execute(<span class="keyword">new</span> Thread(runnable));</span><br><span class="line"></span><br><span class="line">        execRun.shutdown();</span><br><span class="line">        execRun2.shutdown();</span><br><span class="line">        execThread.shutdown();</span><br><span class="line">        execThread2.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：<strong>c、d、i</strong>实际上是相同的，<strong>b、g</strong>是相同的，而<strong>a</strong>和<strong>f</strong>看起来相同，但是实际作用却差别很大，待研究。</p><p>实际上，<strong>a</strong>是错误的用法，<strong>b</strong>、<strong>c</strong>基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个<strong>线程安全的外部对象</strong>。</p><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>冲突是多线程问题必须解决的任务，Java使用<code>synchronized</code>关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当<strong>某一个任务第一次给该对象加锁时，计数变为1</strong>，此后<strong>只有这个相同的任务能继续给该对象加锁</strong>，计数会递增；<strong>每当离开一个synchronized方法时，计数递减</strong>，直到计数变为0时，对象被解锁。要注意，<strong>每个访问该临界资源的方法都必须被同步</strong>，否则就不会正确地工作。</p><p>通常<code>synchronized</code>关键字标识方法时，是在<code>this</code>上面同步，也可在方法中使用<code>synchronized(synObject){}</code>域，<strong>以在特定的对象上同步</strong>，因此不同对象上的锁是相互无关的。</p><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock对象必须被显式地创建、锁定和释放。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 显式声明</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lock()方法创建临界资源</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="comment">// return语句必须出现在try子句中</span></span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// unlock()方法完成清理工作</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>synchronize</code>相比，显式的<code>Lock</code>优点在于可以使用<code>finally子句</code>将系统维护在正常的状态，而在使用<code>synchronize</code>关键字时，某些事物失败了就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"untimed - tryLock(): "</span> + captured);</span><br><span class="line">            System.out.println(<span class="string">"untimed - isHeldByCurrentThread(): "</span> + lock.isHeldByCurrentThread());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (captured) </span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"timed - tryLock(2, TimeUnit.SECONDS): "</span> + captured);</span><br><span class="line">            System.out.println(<span class="string">"timed - isHeldByCurrentThread(): "</span> + lock.isHeldByCurrentThread());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (captured)</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">        <span class="comment">// 匿名内部类创建单独的Thread来获取锁，而未释放</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">                System.out.println(<span class="string">"main - isHeldByCurrentThread(): "</span> + al.lock.isHeldByCurrentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">untimed - tryLock(): true</span></span><br><span class="line"><span class="comment">untimed - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">timed - tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">timed - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">main - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">untimed - tryLock(): false</span></span><br><span class="line"><span class="comment">untimed - isHeldByCurrentThread(): false</span></span><br><span class="line"><span class="comment">timed - tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">timed - isHeldByCurrentThread(): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>看代码就很容易理解了。</p><h4 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h4><p>原子操作<strong>有可能无需同步机制</strong>，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是<strong>不可视的</strong>，因此不同的任务对应用状态有不同的视图。</p><p><strong>volatile关键字</strong>确保了前面提及的可视性，以及当一个域被声明为volatile时，那么<strong>只要对这个域产生了写操作，所有的读操作都可以看到这个修改</strong>。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。</p><p>所以<strong>非volatile域</strong>上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。</p><p>因此多个任务在同时访问某个域时，<strong>要么使用volatile关键字限定，要么经由同步机制访问</strong>，以保证一致性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            i++; i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面这个例子，程序找到奇数时便终止，理想状态下，通过<code>evenIncrement()</code>加2，<code>i</code>应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时<code>i</code>也不是<code>volatile</code>的，因此还存在可视性问题（当然，这里仅仅使用<code>volatile</code>限定<code>i</code>是不够的，因为<code>i++</code>操作不是原子性的）。下面使用<code>Lock</code>显式加锁以实现同步：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            i++; i++; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">            System.out.println(val);</span><br><span class="line">            <span class="keyword">if</span> (val%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>上面说到<strong>原子操作是较少的</strong>，而<code>JSE5</code>引入了<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。</p><h3 id="ReetrantLock"><a href="#ReetrantLock" class="headerlink" title="ReetrantLock"></a>ReetrantLock</h3><p>ReentrantLock是一个<strong>可重入</strong>的<strong>互斥锁</strong>，又被称为”<strong>独占锁</strong>“。</p><blockquote><p><strong>可重入锁</strong>指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。</p><p><strong>独占锁</strong>指的是同一时间点锁只能被一个线程获取。</p></blockquote><p>同时ReentrantLock也分为<strong>公平锁</strong>和<strong>非公平锁</strong>，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。</p><h3 id="ReentrantReedWriteLock"><a href="#ReentrantReedWriteLock" class="headerlink" title="ReentrantReedWriteLock"></a>ReentrantReedWriteLock</h3><p>顾名思义，ReentrantReadWriteLock维护了<strong>读取锁</strong>和<strong>写入锁</strong>。</p><p>读取锁用于只读操作，是<strong>共享锁</strong>，能被多个线程获取；</p><p>写入锁用于写入操作，是<strong>独占锁</strong>，只能被一个线程获取。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li>新建（new）</li><li>就绪（Runnable）</li><li>阻塞（Blocked）<ul><li>调用<code>sleep(milliseconds)</code>方法使任务休眠</li><li>调用<code>wait()</code>方法挂起</li><li>等待输入输出完成</li><li>获取锁失败</li></ul></li><li>死亡（Dead）</li></ul><h3 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p>与<code>sleep()</code>和<code>yield()</code>不同，调用<code>wait()</code>时<strong>需要释放当前线程获取的锁</strong>，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了<code>notifyAll()</code>方法时，线程被唤醒。</p><p>但是要注意，使用<code>wait()</code>的时候需要用<code>while</code>循环包围：</p><ul><li>为了检查线程是否被意外唤醒</li></ul><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h4><p><code>notifyAll()</code>用来唤醒等待<strong>某个锁</strong>的所有<strong>挂起的任务</strong>。<code>等待某个锁</code>指的是某些需要获取共同的锁的线程，<code>notifyAll()</code>可以唤醒这些线程，而不是程序中所有被挂起的线程。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个并发进程因争夺系统资源而产生相互等待的现象。</p><p>四个必要条件：</p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><h3 id="免锁容器"><a href="#免锁容器" class="headerlink" title="免锁容器"></a>免锁容器</h3><p>免锁容器的策略是：对容器的修改可以与读取操作<strong>同时发生</strong>，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。</p><p>这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。<code>synchronized</code>关键字的实现就是悲观锁。</p><h4 id="CAS-Compare-And-Swap-技术"><a href="#CAS-Compare-And-Swap-技术" class="headerlink" title="CAS(Compare And Swap)技术"></a>CAS(Compare And Swap)技术</h4><p>CAS是用来实现乐观锁的一种方法，原理见<a href="https://www.jianshu.com/p/ae25eb3cfb5d" target="_blank" rel="noopener">这里</a>。</p><p>CAS机制使用3个基本操作数：<strong>内存地址<code>V</code></strong>，<strong>旧的预期值<code>A</code></strong>，<strong>要修改的新值<code>B</code></strong>。</p><p>更新一个变量的时候，只有当<code>A</code>和<code>V</code>的实际值相同时，才会将<code>V</code>对应的值修改为<code>B</code>。</p><p>缺点：</p><ul><li>ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子性</li></ul><p>未完~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;垃圾回收器—GC&quot;&gt;&lt;a href=&quot;#垃圾回收器—GC&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器—GC&quot;&gt;&lt;/a&gt;垃圾回收器—GC&lt;/h2&gt;&lt;p&gt;众所周知，Java中的GC负责回收&lt;strong&gt;无用对象占用的内存资源&lt;/strong&gt;，
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.guitoubing.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.guitoubing.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库与内存数据库实验报告</title>
    <link href="http://blog.guitoubing.top/2019/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://blog.guitoubing.top/2019/03/05/数据库与内存数据库实验报告/</id>
    <published>2019-03-05T12:34:59.000Z</published>
    <updated>2019-10-20T08:55:42.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验前准备"><a href="#一、实验前准备" class="headerlink" title="一、实验前准备"></a>一、实验前准备</h2><h3 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h3><p><img src="/images/image-20190114060005845.png" alt="image-20190114060005845"></p><h3 id="时间计算标准"><a href="#时间计算标准" class="headerlink" title="时间计算标准"></a>时间计算标准</h3><h4 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h4><p>首先，本实验的目的是优化数据库，减少数据库语句执行的时间，在此之前，我们要明白一点<code>数据库执行时间</code>这句话包含了哪些东西。我们从数据库执行一条SQL语句的过程来看，对于MySQL、Oracle、TimesTen这些具有内部优化的数据库来说，一般的执行步骤是：</p><p><img src="/images/image-20190113214926175.png" alt="image-20190113214926175"></p><p>而我们的关注点应放在语句执行这一步骤上。</p><h4 id="语句执行步骤进一步深入"><a href="#语句执行步骤进一步深入" class="headerlink" title="语句执行步骤进一步深入"></a>语句执行步骤进一步深入</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>MySQL的执行时间为以下项目的加和：</p><table><thead><tr><th>State</th><th>Desription</th></tr></thead><tbody><tr><td>1. Checking permissions</td><td>检查用户的权限</td></tr><tr><td>2. Opening tables</td><td>打开表</td></tr><tr><td>3. Init</td><td>初始化过程</td></tr><tr><td>4. System lock</td><td>获取锁</td></tr><tr><td>5. Optimizing</td><td>优化SQL语句</td></tr><tr><td>6. Statistics</td><td>分析SQL语句</td></tr><tr><td>7. Preparing</td><td>准备执行条件</td></tr><tr><td>8. Executing</td><td>执行SQL语句</td></tr><tr><td>9. Sending data</td><td>进行磁盘的IO以及数据的发送返回</td></tr><tr><td>10. End</td><td>执行结束</td></tr><tr><td>11. Closing tables</td><td>关闭表</td></tr><tr><td>12. Freeing items</td><td>释放资源</td></tr><tr><td>13. Cleaning up</td><td>清理缓存以及临时空间</td></tr></tbody></table><h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><p>一条SQL语句在进入<code>语句执行</code>这一步骤之后，若不在高速缓存中，数据库会从数据文件中把<code>所在位置</code>移动到<code>高速缓存</code>中而后返回给客户端。这也就意味着，同一条语句在以后的执行中都只从高速缓存取数据（前提是高速缓存<code>未被清除</code>）。这样想的话，我们要做的优化应该是一条SQL语句在第一次进入数据库时数据库作出的应答。</p><p>那么，我们通过数据库工具来查看执行的SQL语句的时间应该是不准的：<strong>因为我们不知道这条语句是不是第一次执行，或者说我们不知道高速缓存中有没有我们需要的数据</strong>。这里我们选择使用Oracle的执行计划来看SQL语句的准确的执行过程以及其<code>开销</code>。如下图：</p><p><img src="/images/image-20190113211220925.png" alt="image-20190113211220925"></p><p>我们的关注点在上图中的<code>COST</code>，cost是Oracle里判定效率的唯一标准，Oracle的优化器会计算当前SQL语句的最低cost方案，而后为其选择执行计划。Oracle中定义了语句的一次执行开销<code>cost = CPU cost + IO cost</code>，对于cost，我们可以理解为一次过程所需要访问的Block数量，那么执行时间就是<code>t = Block数量 * Block处理时间</code>。</p><p>后续实验过程中的Oracle部分我们都是通过执行计划及cost来做对比。为此我们写了一个procedure来记录一条语句执行计划中记录的cost：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 计算query的cost</span><br><span class="line">create or replace procedure calc_cost(query_ varchar2, func_ number, desc_ varchar2) is</span><br><span class="line">  cpu_cost number := 0;</span><br><span class="line">  io_cost number := 0;</span><br><span class="line">  cost_ number := 0;</span><br><span class="line">  -- 一条SQL语句的唯一标识</span><br><span class="line">  hash_v number := 0;</span><br><span class="line">  -- 获取上述标识</span><br><span class="line">  select_v_sql varchar2(255) := &apos;select hash_value into :x from v$sql a where a.SQL_TEXT like &apos;&apos;:y&apos;&apos;&apos;;</span><br><span class="line">  -- 获取cost</span><br><span class="line">  select_v_sql_plan varchar2(255) := &apos;select max(cpu_cost) , max(io_cost) into :x :y from V$SQL_PLAN a where hash_value=:z&apos;;</span><br><span class="line">  -- 结果保存</span><br><span class="line">  insert_result varchar2(255) := &apos;insert into t_cost_record values(:x,:y,:z,:a,:b,:c)&apos;;</span><br><span class="line">begin</span><br><span class="line">  execute immediate select_v_sql using hash_v, query_;</span><br><span class="line">  execute immediate select_v_sql_plan using cpu_cost, io_cost, cost_;</span><br><span class="line">  execute immediate insert_result using id_seq.nextval, func_, cpu_cost, io_cost, cost_, desc_;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h5 id="TimesTen"><a href="#TimesTen" class="headerlink" title="TimesTen"></a>TimesTen</h5><p>对于TimesTen来说，不如Oracle的优化器来的智能，它完全靠速度制胜。Oracle中我们讨论了执行时间<code>t = Block数量 * Block处理时间</code>，TimesTen就是在Block处理时间上有很大的优势。遗憾的是TimesTen中没有作为本身的高速缓存这一说，这也就意味着一条SQL语句进入TimesTen时都要经过<code>SQL Prepare -&gt; SQL Execution -&gt; SQL Fetch</code>这一完整的过程，如下：</p><p><img src="/images/image-20190114052126486.png" alt="image-20190114052126486"></p><h2 id="二、MySQL实验过程"><a href="#二、MySQL实验过程" class="headerlink" title="二、MySQL实验过程"></a>二、MySQL实验过程</h2><p>功能：查询电影评论平均分排行前一百的电影</p><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select  m.name_, sum(c1.score) as movie_avg_comment_score</span><br><span class="line">from movie m  , comment_1 c1</span><br><span class="line">where m.id_ = c1.movie_id</span><br><span class="line">group by m.name_</span><br><span class="line">order by movie_avg_comment_score desc</span><br><span class="line">limit 100;</span><br></pre></td></tr></table></figure><h3 id="仅有主键索引"><a href="#仅有主键索引" class="headerlink" title="仅有主键索引"></a>仅有主键索引</h3><p>执行之后得到如下的时间消耗：</p><p><img src="/images/time_3.2_4min.png" alt="time_3.2_4min"></p><p>这个时间相比其他数据库慢得多（oracle 约4s)，不符合预期的耗时，且在执行时mysqld的cpu占用率非常高。于是根据以下步骤查看sql执行慢的原因。</p><h3 id="MySQL进程表"><a href="#MySQL进程表" class="headerlink" title="MySQL进程表"></a>MySQL进程表</h3><p>使用<code>show processlist</code>命令查看正在执行的sql语句列表：</p><p><img src="/images/process_list.png" alt="process_list"></p><p>可以看到当前执行的语句就是我们的目标语句，并且没有其他语句在与当前查询语句竞争资源，所以应该把语句执行过慢点原因定位到查询语句本身。</p><h3 id="解释执行计划"><a href="#解释执行计划" class="headerlink" title="解释执行计划"></a>解释执行计划</h3><p>通过查看process list得知对应语句有问题之后，使用<code>describe</code>命令查看当前SQL语句的执行计划，MySQL的执行计划与其他相关参数：</p><p><img src="/images/explain_3.2.png" alt="explain_3.2"></p><p>可以看到在执行计划中，movie表有可选的主码索引，但是在这个场景中mysql并没有选择使用主码索引，没有使用索引是导致时间过慢点一个原因，于是可以考虑在电影名字字段上建立索引。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>为了进一步查看SQL语句具体的系统能耗分布，我们选择使用<code>profiling</code>来分析我们SQL语句的执行过程，在没有创建其他索引的情况下我们得到如下的时间消耗分析：</p><p><img src="/images/detail_3.2.png" alt="detail_3.2"></p><p>我们可以看到其中能耗占比最高的是 <code>Sending data</code>项，查看官方文档相关解释：</p><blockquote><p>The thread is reading and processing rows for a <code>SELECT</code> statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.</p><p>该线程正在读取和处理SELECT语句的行，并将数据发送到客户端。 由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态</p></blockquote><p>所以这个与我们的磁盘IO的速度以及网络的传输速度有关，磁盘的IO除了受到硬件本身的限制之外还会与数据库的索引有关，更换性能更好的磁盘或者建立适当的索引以减少磁盘IO数量都可以提高查询语句的执行速度。</p><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>根据以上分析过程得到的结论，我们在电影表的名字字段上建立合适的索引，我们在mysql中选择了B-Tree索引。</p><p>建立索引之后再查看相同SQL语句的执行计划：</p><p><img src="/images/explain_3.2_index.png" alt="explain_3.2_index"></p><p><code>key</code>字段上的值从原来的<code>null</code> 变成了我们刚刚创建的索引。</p><p>执行该SQL语句，并在结束后使用<code>Profiling</code>查看优化后的执行时间：</p><p>sending data: 从磁盘读取数据，将数据返回，表示磁盘IO</p><p>create index：使用临时表来处理select语句</p><p><img src="/images/detail_index_3.2.png" alt="detail_index_3.2"></p><p>可以看到<code>Sending data</code>的值明显小于优化前，总的执行时间也变为优化前的1/5，所以增加索引能够在很大程度上加快查询的速度。</p><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>综合其他实验，在大数据的处理上MySQL数据库的性能远不如ORACLE及TIMESTEN数据库，有数十倍的耗时差距，而且MySQL作为一个轻量级的数据库，支持的索引类型也少于其他两个数据库，在SQL语句的优化方面也不如ORACLE数据库那般强大。所以在当前的实验环境下我们更倾向于使用ORACLE数据库与TIMESTEN数据库进行对比。</p><h2 id="三、Oracle实验过程"><a href="#三、Oracle实验过程" class="headerlink" title="三、Oracle实验过程"></a>三、Oracle实验过程</h2><h3 id="实验1：SQL各子句条件顺序对查询效率的影响"><a href="#实验1：SQL各子句条件顺序对查询效率的影响" class="headerlink" title="实验1：SQL各子句条件顺序对查询效率的影响"></a>实验1：SQL各子句条件顺序对查询效率的影响</h3><h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_ <span class="keyword">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class="line"><span class="keyword">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID <span class="keyword">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> T_REGION.NAME_=<span class="string">'美国'</span> <span class="keyword">AND</span> T_MOVIE.SCORE_&gt;<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="实验方式"><a href="#实验方式" class="headerlink" title="实验方式"></a>实验方式</h4><p>通过对MySQL、Oracle、TimesTen中SQL语句中select、from、where子句的排序顺序进行调换，观察执行计划的改变</p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><ol><li>SELECT子句中，结果集的排序方式不会影响执行计划</li><li>FROM子句中，各个表的排序方式不会影响执行计划</li><li>WHERE子句中，各个条件的排序方式不会影响执行计划，优化器会首先将筛选条件应用于表进行过滤，最后逐次执行表的连接。</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>自Oracle6以来，一直采用RBO（Rule-Based Optimization 基于规则的优化器），其基于一套严格死板的使用规则。由于其对于规则的崇尚性，SQL语句的写法则尤为重要。而自Oracle8以来，Oracle引入了一种新的优化方式，即CBO（Cost-Based Optimization 基于代价的优化器），从Oracle 10g开始RBO被完全舍弃。使用CBO优化器时，对SQL语句的要求变得没有那么苛刻，优化器会选择开销比较小的方式执行，而不由用户所写的表的顺序、条件的顺序决定。MySQL与TimesTen的优化器也是如此，有其自己的选择。</p><blockquote><h5 id="连接方式和连接顺序"><a href="#连接方式和连接顺序" class="headerlink" title="连接方式和连接顺序"></a>连接方式和连接顺序</h5><p><strong>连接顺序</strong>：连接顺序表明以哪张表为驱动表来连接其他表的先后顺序。即以某张表为基点，根据其中的信息再去访问其他的表。</p><p><strong>连接方式</strong>：简单来讲，就是两个表获得满足条件的数据时的连接过程。主要有三种表连接方式，嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）。</p><h6 id="排序-合并连接"><a href="#排序-合并连接" class="headerlink" title="排序-合并连接"></a>排序-合并连接</h6><p>假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id)</p><p>内部连接过程：</p><p>a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序</p><p>b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序</p><p>c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接）</p><p>延伸：</p><p>如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。</p><p>故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。<strong>不过遗憾的是</strong>，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。</p><p>排序-合并连接的表无驱动顺序，谁在前面都可以；</p><p>排序-合并连接<strong>适用</strong>的连接条件有： <strong>&lt;   &lt;=   =   &gt;   &gt;= ，不适用</strong>的连接条件有： <strong>&lt;&gt;    like</strong></p><h6 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h6><p>内部连接过程：</p><p>a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p><p>b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中</p><p>c) ……</p><p>若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。</p><p>因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。</p><p>嵌套循环的表有驱动顺序，注意选择合适的驱动表。嵌套循环连接有一个其他连接方式没有的好处是：<strong>可以先返回已经连接的行</strong>，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。</p><p>应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。</p><h6 id="哈希连接"><a href="#哈希连接" class="headerlink" title="哈希连接"></a>哈希连接</h6><p><strong>哈希连接只适用于等值连接（即连接条件为  =  ）</strong></p><p>HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式；</p><p>内部连接过程简述：</p><p>a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）</p><p>b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据</p></blockquote><h3 id="实验2：B树索引与位图索引的比较"><a href="#实验2：B树索引与位图索引的比较" class="headerlink" title="实验2：B树索引与位图索引的比较"></a>实验2：B树索引与位图索引的比较</h3><h4 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 小基数</span></span><br><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class="line"><span class="keyword">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class="line"><span class="keyword">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> T_REGION.NAME_=<span class="string">'美国'</span></span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.SCORE_&gt;<span class="number">6</span>;</span><br><span class="line"><span class="comment">-- 大基数</span></span><br><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class="line"><span class="keyword">FROM</span> T_ACTOR,T_ACT,T_MOVIE</span><br><span class="line"><span class="keyword">WHERE</span> T_ACTOR.NAME_=<span class="string">'Tom Byron'</span></span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.SCORE_&gt;<span class="number">6</span></span><br><span class="line"><span class="keyword">AND</span> T_ACTOR.ID_=T_ACT.ACTOR_ID</span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.ID_=T_ACT.MOVIE_ID;</span><br></pre></td></tr></table></figure><h4 id="索引语句"><a href="#索引语句" class="headerlink" title="索引语句"></a>索引语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- B树</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IX_MOVIE_SCORE <span class="keyword">ON</span> T_MOVIE(SCORE_);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IX_MOVIE_NAME <span class="keyword">ON</span> T_MOVIE(NAME_);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IX_ACTOR_NAME <span class="keyword">ON</span> T_ACTOR(NAME_);</span><br><span class="line"><span class="comment">-- BitMap</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">BITMAP</span> <span class="keyword">INDEX</span> IXBM_MOVIE_NAME <span class="keyword">ON</span> T_MOVIE(NAME_);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">BITMAP</span> <span class="keyword">INDEX</span> IXBM_MOVIE_SCORE <span class="keyword">ON</span> T_MOVIE(SCORE_);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">BITMAP</span> <span class="keyword">INDEX</span> IXBM_ACTOR_NAME <span class="keyword">ON</span> T_ACTOR(NAME_);</span><br></pre></td></tr></table></figure><h4 id="查询消耗"><a href="#查询消耗" class="headerlink" title="查询消耗"></a>查询消耗</h4><p>B树索引（小基数）</p><p><img src="/images/1-B%E6%A0%91%E7%B4%A2%E5%BC%95.png" alt="B树索引"></p><p>位图索引（小基数）</p><p><img src="/images/1-%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.png" alt="位图索引"></p><p>不加索引（大基数）</p><p><img src="/images/image-20190113230831573.png" alt="image-20190113230831573"></p><p>B树索引（大基数）</p><p><img src="/images/image-20190113230717837.png" alt="image-20190113230717837"></p><p>位图索引（大基数）</p><p><img src="/images/image-20190113230627090.png" alt="image-20190113230627090"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>即使在字段基数较大的情况下，位图索引依然有比B树索引更好的表现。但是有个问题，创建位图索引时所需的时间更长。此外，由于表中该字段的更改都会导致对位图的修改，所以位图索引不适用于并发的情况。</p><h3 id="实验3：Oracle优化器对索引的选择"><a href="#实验3：Oracle优化器对索引的选择" class="headerlink" title="实验3：Oracle优化器对索引的选择"></a>实验3：Oracle优化器对索引的选择</h3><blockquote><h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><ul><li>B树索引（默认的索引）</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; CREATE INDEX IX_MOVIE_SCORE ON T_MOVIE(SCORE_);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>位图索引：以位图的形式存储每个值对应的的一组rowid</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; CREATE BITMAP INDEX IXBM_REGION_NAME ON T_REGION(NAME_);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>基于函数的索引：利于对某个字段查询时需要同时使用函数或计算的情景</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; CREATE INDEX upper_ix ON employees (UPPER(last_name)); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>分区索引：本地分区索引的分区完全依赖于其索引所在表，而全局分区索引的分区机制和表分区可能一样也可能不一样</p><ul><li>range范围分区</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;   CREATE INDEX cost_ix ON sales (amount_sold)</span><br><span class="line">&gt;    GLOBAL PARTITION BY RANGE (amount_sold)</span><br><span class="line">&gt;       (PARTITION p1 VALUES LESS THAN (1000),</span><br><span class="line">&gt;        PARTITION p2 VALUES LESS THAN (2500),</span><br><span class="line">&gt;        PARTITION p3 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>hash哈希分区</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;   CREATE INDEX cust_last_name_ix ON customers (cust_last_name)</span><br><span class="line">&gt;   GLOBAL PARTITION BY HASH (cust_last_name)</span><br><span class="line">&gt;   PARTITIONS 4;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>list列表分区：一个分区对应指定列的特定的值，以列举的方式进行分区</li><li>组合分区（range-hash，range-list）</li></ul><h5 id="什么时候用索引"><a href="#什么时候用索引" class="headerlink" title="什么时候用索引"></a>什么时候用索引</h5><p>对于Oracle的CBO来说，只有在使用索引能提高效率（估算的效率）时才会使用索引。对于程序员自己进行数据库管理的时候，一般有：</p><p><strong>需要使用索引来优化查询的情况：</strong></p><ul><li>一个属性的值分布非常广，变化的范围跨度很大。</li><li>一般来说，常常需要被用在SQL语句的where中的限制条件的属性最好为其建立索引。</li><li>表经常被访问且需要访问的数据量仅占一部分。</li></ul><p><strong>不适合用索引的情况：</strong></p><ul><li>表很小</li><li>表经常被更新</li><li>属性不经常作为where中的限制条件的属性存在</li><li>查询得到的数据占总量的很大部分</li></ul><p>对于数据经常更新的情况，DBA要定时进行索引的重构（rebuild）以维持索引的可用性。</p><h5 id="影响优化器决策的因素"><a href="#影响优化器决策的因素" class="headerlink" title="影响优化器决策的因素"></a>影响优化器决策的因素</h5><ul><li>进行全表扫描需要读取的数据块数量；</li><li>进行索引查询需要读取的数据块数量，这主要是基于对WHERE子句谓词返回的记录数目估计；</li><li>进行全表扫描时多块读的相关开销，以及为满足索引查询进行的单块读的开销；</li><li>内存中对缓存中的索引块和数据块数目的假设。</li></ul><h5 id="索引失效的可能原因"><a href="#索引失效的可能原因" class="headerlink" title="索引失效的可能原因"></a>索引失效的可能原因</h5><p>以下是一些常见的定义了索引当Oracle并未使用的原因：</p><ul><li>不等于情况，即“&lt;&gt;”</li><li>字符串匹配like中百分号在第一位的情况，即“%XXX”</li><li>表没有进行分析更新统计信息</li><li>使用复合索引但单独引用且非复合索引的第一属性</li><li>对索引进行计算，此时需要建立索引函数</li><li>属性为字符串但在where中没有加引号</li><li>使用not in，not exists</li><li>使用了其他索引</li></ul><h4 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h4><p>如果想要强制使用索引，则可以在查询语句的select单词后加上/*+index (tablename indexname)*/，这样可以规定Oracle选择使用indexname的索引的执行计划。该方法已在前面实验中使用，不再赘述。</p></blockquote><h4 id="sql语句-1"><a href="#sql语句-1" class="headerlink" title="sql语句"></a>sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class="line"><span class="keyword">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class="line"><span class="keyword">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> T_REGION.NAME_=<span class="string">'美国'</span></span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.SCORE_&gt;<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="查询消耗-1"><a href="#查询消耗-1" class="headerlink" title="查询消耗"></a>查询消耗</h4><p>不用索引（不论是B树索引还是位图索引都不使用）</p><p><img src="/images/3-%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95.png" alt="3-不用索引"></p><p>强制使用B树索引</p><p><img src="/images/3-%E5%BC%BA%E5%88%B6B%E6%A0%91.png" alt="3-强制B树"></p><p>强制使用位图索引</p><p><img src="/images/3-%E5%BC%BA%E5%88%B6%E4%BD%8D%E5%9B%BE.png" alt="3-强制位图"></p><h4 id="sql语句-2"><a href="#sql语句-2" class="headerlink" title="sql语句"></a>sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, T_MOVIE.YEAR_</span><br><span class="line"><span class="keyword">FROM</span> T_MOVIE,T_MOVIE_REGION,T_REGION</span><br><span class="line"><span class="keyword">WHERE</span> T_REGION.ID_=T_MOVIE_REGION.REGION_ID</span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.ID_=T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> T_REGION.NAME_=<span class="string">'美国'</span></span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.SCORE_&gt;<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h4 id="查询消耗-2"><a href="#查询消耗-2" class="headerlink" title="查询消耗"></a>查询消耗</h4><p>B树索引（未使用）</p><p><img src="/images/3-B%E6%A0%91.png" alt="3-B树"></p><p>位图索引</p><p><img src="/images/3-%E4%BD%8D%E5%9B%BE.png" alt="3-位图"></p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>由此可见，即使在有索引的情况下，oracle优化器也可能选择不使用索引。CBO优化器会对每种执行计划计算一个COST，并采用COST最小的执行计划。如果一个表有索引或多种索引，其会选择最好的一种索引方式扫描表，或者甚至不用索引而用全局扫描方式。</p><p>另外对于符合筛选条件的数据，当占全表的比例越小、数据量越小时，使用索引的可能性越大。如在这次实验中，条件为”T_MOVIE.SCORE_ &gt;9”时会使用索引，而”T_MOVIE.SCORE_ &gt;6”时不会。</p><p>此外，由于位图索引导致的COST要小于B树索引，因此在相同的查询中，使用位图索引的可能性比B树索引更大。</p><h3 id="实验4：Oracle分区索引"><a href="#实验4：Oracle分区索引" class="headerlink" title="实验4：Oracle分区索引"></a>实验4：Oracle分区索引</h3><h4 id="sql语句-3"><a href="#sql语句-3" class="headerlink" title="sql语句"></a>sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T_COMMENT.SUMMARY_,T_COMMENT.SCORE_,T_COMMENT.TIME_</span><br><span class="line"><span class="keyword">FROM</span> T_COMMENT,T_MOVIE</span><br><span class="line"><span class="keyword">WHERE</span> T_MOVIE.ID_=T_COMMENT.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> T_COMMENT.SCORE_&gt;<span class="number">6</span></span><br><span class="line"><span class="keyword">AND</span> T_MOVIE.NAME_=<span class="string">'Blindsided'</span>;</span><br></pre></td></tr></table></figure><h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><ol><li><p>未分区表+无索引</p><p><img src="/images/5-1-1.png" alt="5-1-1"></p></li><li><p>未分区表+B树索引</p><p><img src="/images/5-2.png" alt="5-2"></p></li><li><p>未分区表+位图索引</p><p><img src="/images/5-3.png" alt="5-3"></p></li><li><p>分区表+无索引</p><p><img src="/images/5-4-1.png" alt="5-4-1"></p></li><li><p>分区表+全局不分区B树索引</p><p><img src="/images/5-5-1.png" alt="5-5-1"></p></li><li><p>分区表+本地(哈希分区)B树索引</p><p><img src="/images/5-6.png" alt="5-6"></p></li><li><p>分区表+本地(哈希分区)位图索引</p><p><img src="/images/5-7.png" alt="5-7"></p></li><li><p>分区表+全局哈希分区索引</p><p><img src="/images/5-8.png" alt="5-8"></p></li><li><p>分区表+全局范围分区索引</p><p><img src="/images/5-9.png" alt="5-9"></p></li></ol><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ol><li><p>在未建索引时，分区表的COST是未分区表的十倍多。原因是分区所依据的键（字段）不是直接的查询条件——我们以评论表的movie_id字段为依据建哈希分区表，但在查询的时候并不直接以movie_id为查询条件。导致连接表的时候，需要访问多个分区，反而造成COST大大增长。</p><p>后来我们重新设计一个以movie_id为查询条件的sql语句，结果显示分区表的COST大约是未分区表的1/4（一共分了4个区），证明在以分区依据的字段为直接查询条件时，分区表能够体现比较好的性能，能够避免对一部分数据的访问。</p></li><li><p>在分区表上建索引比在未分区表上建索引后的开销更小，不论分区表上的索引是全局还是本地，不论是否是分区索引。在我们的实验场景中，尽管movie_id不是直接的查询条件而是join表的条件，但是在添加索引后，依然能够大大减少join表的开销从而提升效率。</p></li><li><p>在我们的实验场景中，全局的分区索引，不论是哈希分区还是范围分区，COST是一样的。</p></li><li><p>本地索引的效率略微比全局索引的效率好。根据查到的资料，本地索引的可维护性好，能够自动维护，不需要人工干预，但因把索引分成多个分区导致每次的索引访问都需要遍历所有索引分区，所以索引访问性能下降。因此比较适合OLAP系统。而全局索引的可维护性差，分区表发生改变时，需要用命令手动更新索引，但索引访问性能比本地分区索引要好。因此比较适合OLTP系统。</p></li></ol><h3 id="实验5：Oracle使用复合索引"><a href="#实验5：Oracle使用复合索引" class="headerlink" title="实验5：Oracle使用复合索引"></a>实验5：Oracle使用复合索引</h3><h4 id="SQL语句-1"><a href="#SQL语句-1" class="headerlink" title="SQL语句"></a>SQL语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> T_COMMENT_1.SUMMARY_, T_COMMENT_1.SCORE_</span><br><span class="line"><span class="keyword">from</span> T_COMMENT_1, T_MOVIE</span><br><span class="line"><span class="keyword">where</span> T_MOVIE.ID_ = T_COMMENT_1.MOVIE_ID <span class="keyword">and</span> T_COMMENT_1.SCORE_ &gt; <span class="number">7</span> <span class="keyword">and</span> T_MOVIE.NAME_ = <span class="string">'The Notebook'</span>;</span><br></pre></td></tr></table></figure><p>第一次查询：T_COMMENT_1上只有主键的唯一索引。</p><p>第二次查询：在MOVIE_ID上建立一个B-tree索引COMMENT_1_MOVIE。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> COMMENT_1_MOVIE <span class="keyword">on</span> T_COMMENT_1(MOVIE_ID);</span><br></pre></td></tr></table></figure><p>第三次查询：使第二次的索引invisible，在SCORE_上建立一个B-tree索引T_COMMENT_SCORE_INDEX。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> COMMENT_1_MOVIE <span class="keyword">invisible</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> T_COMMENT_SCORE_INDEX <span class="keyword">on</span> T_COMMENT_1(SCORE_);</span><br></pre></td></tr></table></figure><p>第四次查询：将第二次和第三次的索引都保持为visible，在MOVIE_ID和SCORE_上建立一个复合索引COMMENT_1_MOVIE_SCORE。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> COMMENT_1_MOVIE <span class="keyword">visible</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> COMMENT_1_MOVIE_SCORE <span class="keyword">on</span> T_COMMENT_1(MOVIE_ID, SCORE_);</span><br></pre></td></tr></table></figure><h4 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h4><p><strong>第一次查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.48.45.png" alt="屏幕快照 2019-01-13 下午10.48.45"></p><p>全表扫描，花销很大</p><p><strong>第二次查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.47.49.png" alt="屏幕快照 2019-01-13 下午10.47.49"></p><p>利用在MOVIE_ID上的索引，在T_COMMENT_1中访问的数据量和花销都大幅度下降。</p><p><strong>第三次查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.50.07.png" alt="屏幕快照 2019-01-13 下午10.50.07"></p><p>如果只有在SCORE_上的索引，根据CBO，Oracle并没有使用这个索引，而是依旧使用全表扫描，可知该索引并没有提升性能。</p><p>易知，如果在这个时候将MOVIE_ID上的索引设为visible，Oracle会使用MOVIE_ID上的索引。</p><p><strong>第四次查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%8810.57.10.png" alt="屏幕快照 2019-01-13 下午10.57.10"></p><p>Oracle使用了复合索引，尽管在当前问题下COST花销与只有MOVIE_ID的索引差不多，但是其访问的记录数（CARDINALITY）显著减小，体现了复合索引给查询带来的性能提升。</p><h3 id="实验6：物化视图对SQL查询性能的提升"><a href="#实验6：物化视图对SQL查询性能的提升" class="headerlink" title="实验6：物化视图对SQL查询性能的提升"></a>实验6：物化视图对SQL查询性能的提升</h3><h4 id="SQL语句-2"><a href="#SQL语句-2" class="headerlink" title="SQL语句"></a>SQL语句</h4><p><strong>原始查询语句：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> T_DIRECTOR.NAME_, T_MOVIE.NAME_ MOVIE_NAME, <span class="keyword">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class="line"><span class="keyword">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class="line"><span class="keyword">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class="keyword">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class="keyword">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_ <span class="keyword">and</span> T_DIRECTOR.NAME_ <span class="keyword">like</span> <span class="string">'黑泽明%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_ ;</span><br></pre></td></tr></table></figure><p>创建一个<strong>普通视图</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> DIRECTOR_MOVIE_FAKE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class="keyword">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class="line"><span class="keyword">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class="line"><span class="keyword">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class="keyword">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class="keyword">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure><p>使用普通视图进行查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> NAME_, MOVIE_NAME, SCORE <span class="keyword">from</span> DIRECTOR_MOVIE_FAKE <span class="keyword">where</span> NAME_ <span class="keyword">like</span> <span class="string">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure><p>创建<strong>物化视图</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> DIRECTOR_MOVIE</span><br><span class="line"><span class="keyword">BUILD</span> <span class="keyword">IMMEDIATE</span></span><br><span class="line"><span class="keyword">REFRESH</span> <span class="keyword">FORCE</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DEMAND</span></span><br><span class="line"><span class="keyword">ENABLE</span> <span class="keyword">QUERY</span> REWRITE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_ MOVIE_NAME, T_MOVIE.ID_ MOVIE_ID, T_MOVIE.YEAR_, <span class="keyword">AVG</span>(T_COMMENT_1.SCORE_) SCORE</span><br><span class="line"><span class="keyword">from</span> T_DIRECTOR, T_DIRECT, T_MOVIE, T_COMMENT_1</span><br><span class="line"><span class="keyword">where</span> T_DIRECTOR.ID_ = T_DIRECT.DIRECTOR_ID <span class="keyword">and</span> T_DIRECT.MOVIE_ID = T_MOVIE.ID_ <span class="keyword">and</span> T_COMMENT_1.MOVIE_ID = T_MOVIE.ID_</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> T_DIRECTOR.NAME_, T_DIRECTOR.ID_, T_MOVIE.NAME_, T_MOVIE.ID_, T_MOVIE.YEAR_;</span><br></pre></td></tr></table></figure><p>设置<strong>创建时生成数据</strong>，<strong>按需要刷新</strong>，<strong>刷新方式为FORCE</strong>。</p><p>根据视图进行如上查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> NAME_, MOVIE_NAME, SCORE <span class="keyword">from</span> DIRECTOR_MOVIE <span class="keyword">where</span> NAME_ <span class="keyword">like</span> <span class="string">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure><p>由于物化视图与表类似，可以给其建立索引，以下给导演名<strong>建立索引</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">BITMAP</span> <span class="keyword">INDEX</span> DIRECTOR_MOVIE_INAME_INDEX <span class="keyword">ON</span> DIRECTOR_MOVIE (NAME_);</span><br></pre></td></tr></table></figure><p><strong>再次使用物化视图查询</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> NAME_, MOVIE_NAME, SCORE <span class="keyword">from</span> DIRECTOR_MOVIE <span class="keyword">where</span> NAME_ <span class="keyword">like</span> <span class="string">'黑泽明%'</span>;</span><br></pre></td></tr></table></figure><h4 id="实验结果-3"><a href="#实验结果-3" class="headerlink" title="实验结果"></a>实验结果</h4><p><strong>使用原始查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png" alt="屏幕快照 2019-01-14 上午12.27.37"></p><p>具有极大的花销。</p><p><strong>创建视图后的查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.30.46.png" alt="屏幕快照 2019-01-14 上午12.30.46"></p><p>其执行计划与<strong>原始查询</strong>一致。</p><p><strong>创建物化视图后的查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.33.27.png" alt="屏幕快照 2019-01-14 上午12.33.27"></p><p>其<strong>直接在物化视图中进行查询</strong>，执行计划即为简单，花销大幅度减小。</p><p><strong>给物化视图创建索引后的查询：</strong></p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-14%20%E4%B8%8A%E5%8D%8812.35.22.png" alt="屏幕快照 2019-01-14 上午12.35.22"></p><p>建立索引后通过范围索引扫描该物化视图进行查询，其COST数字小得令人惊奇。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>1.建立普通视图并不能提升性能。因为普通是虚拟的，对视图的操作实际都转变为了对各表的SQL操作，其与原始查询完全一致。</p><p>2.物化视图是一种物理表，对于物化视图的查询是直接的，跟表一样。因此建立物化视图可以大幅度减小花销，但是同时，物化视图也会产生大量的维护成本。因此程序员应该根据实际情况建立物化视图以优化查询。</p><p>3.物化视图同样可以增添索引，增加索引后Oracle对物化视图可以通过索引进行扫描，进一步提高效率。</p><blockquote><h5 id="物化视图与普通视图"><a href="#物化视图与普通视图" class="headerlink" title="物化视图与普通视图"></a>物化视图与普通视图</h5><p>视图只是一种虚拟表。实际上，<strong>对视图的查询真正转换成了相应的SQL语句再对各表进行连接查询，因此其性能提升有限，只是方便了使用</strong>。</p><p>而物化视图是实质化的视图，是<strong>物理表</strong>，可以像表一样进行查询，建立索引，占用真正的存储空间，需要被刷新。</p><h5 id="刷新模式"><a href="#刷新模式" class="headerlink" title="刷新模式"></a>刷新模式</h5><p><strong>on demand：</strong>顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性;</p><p><strong>on commit</strong>：提交触发，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢。</p><p>创建物化视图时未作指定，则Oracle按 on demand 模式来创建。</p><h5 id="刷新方法"><a href="#刷新方法" class="headerlink" title="刷新方法"></a>刷新方法</h5><p><strong>完全刷新（COMPLETE）</strong>： 会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。 </p><p><strong>快速刷新（FAST）</strong>： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。</p><p><strong>FORCE方式</strong>： 这是默认的数据刷新方式。Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。</p></blockquote><h3 id="实验7：Oracle-In-Memory性能分析"><a href="#实验7：Oracle-In-Memory性能分析" class="headerlink" title="实验7：Oracle In Memory性能分析"></a>实验7：Oracle In Memory性能分析</h3><h4 id="Sql语句"><a href="#Sql语句" class="headerlink" title="Sql语句"></a>Sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T_MOVIE.NAME_, <span class="keyword">SUM</span>(T_COMMENT_2.SCORE_) s <span class="keyword">FROM</span> T_MOVIE,T_COMMENT_2 <span class="keyword">WHERE</span> T_MOVIE.ID_=T_COMMENT_2.MOVIE_ID <span class="keyword">GROUP</span> <span class="keyword">BY</span> T_MOVIE.NAME_ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="设置In-Memory"><a href="#设置In-Memory" class="headerlink" title="设置In Memory"></a>设置In Memory</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T_MOVIE.NAME_ <span class="keyword">IN</span> <span class="keyword">MEMORY</span>;</span><br></pre></td></tr></table></figure><h4 id="实验结果-4"><a href="#实验结果-4" class="headerlink" title="实验结果"></a>实验结果</h4><p><strong>原始查询</strong>：</p><p><img src="/images/no-inmemory.png" alt="no-inmemory"></p><p><strong>In Memory查询：</strong></p><p><img src="/images/inmemory.png" alt="inmemory"></p><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>遗憾的是与想象的不同，Oracle和Oracle In Memory在COST上面结果相同，但是事实上在我们同样的实验环境下测试二者时间时，In Memory确实会比Oracle好很多。其实简单思考一下，这是应该的，前面我们说过执行时间<code>t = Block数量 * Block处理时间</code>，不难知道差距还是出在Block处理时间上。</p><h3 id="实验8：Oracle执行计划浅析-Oracle表的访问方式"><a href="#实验8：Oracle执行计划浅析-Oracle表的访问方式" class="headerlink" title="实验8：Oracle执行计划浅析(Oracle表的访问方式)"></a>实验8：Oracle执行计划浅析(Oracle表的访问方式)</h3><p>对T_MOVIE表进行查询，其本身有在其主码(ID_)上的UNIQUE INDEX和LENGTH_上的B-tree INDEX。</p><h4 id="根据UNIQUE-INDEX（ID-）返回唯一记录"><a href="#根据UNIQUE-INDEX（ID-）返回唯一记录" class="headerlink" title="根据UNIQUE INDEX（ID_）返回唯一记录"></a>根据UNIQUE INDEX（ID_）返回唯一记录</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_MOVIE <span class="keyword">where</span> ID_ = <span class="number">20050</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.14.59.png" alt="屏幕快照 2019-01-13 下午9.14.59"></p><p>使用的是索引唯一扫描</p><h4 id="根据ID-返回少部分记录"><a href="#根据ID-返回少部分记录" class="headerlink" title="根据ID_返回少部分记录"></a>根据ID_返回少部分记录</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_MOVIE <span class="keyword">where</span> ID_ &lt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.25.22.png" alt="屏幕快照 2019-01-13 下午9.25.22"></p><p>使用的是索引范围扫描</p><h4 id="根据LENGTH-返回大量数据"><a href="#根据LENGTH-返回大量数据" class="headerlink" title="根据LENGTH_返回大量数据"></a>根据LENGTH_返回大量数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_MOVIE <span class="keyword">where</span> LENGTH_ &lt;<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20190114004746346.png" alt="image-20190114004746346"></p><h4 id="全查询MOVIE-和TYPE-返回其ID"><a href="#全查询MOVIE-和TYPE-返回其ID" class="headerlink" title="全查询MOVIE_和TYPE_返回其ID_"></a>全查询MOVIE_和TYPE_返回其ID_</h4><p><strong>全查询MOVIE_：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ID_ <span class="keyword">from</span> T_MOVIE;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.32.45.png" alt="屏幕快照 2019-01-13 下午9.32.45"></p><p>采用的是索引快速扫描（因为数据量较多）</p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.38.39.png" alt="屏幕快照 2019-01-13 下午9.38.39"></p><p>且返回结果无顺序（从578开始，一段有序，即代表是一个索引数据块）。</p><p><strong>全查询TYPE_:</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ID_ <span class="keyword">from</span> T_TYPE;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.35.11.png" alt="屏幕快照 2019-01-13 下午9.35.11"></p><p>采用的是索引全扫描（因为数据量较小）</p><p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-13%20%E4%B8%8B%E5%8D%889.37.57.png" alt="屏幕快照 2019-01-13 下午9.37.57"></p><p>返回结果有顺序</p><blockquote><h3 id="执行计划中的访问方式"><a href="#执行计划中的访问方式" class="headerlink" title="执行计划中的访问方式"></a>执行计划中的访问方式</h3><p>访问方式即分为全表扫描（TABLE ACCESS FULL）和各种类型索引扫描（TABLE INDEX SCAN）。Oracle会根据表和索引的信息，推算执行的SQL语句从表中取多少数据以及这些数据是怎么分布的。</p><h4 id="TABLE-ACCESS-FULL（全表扫描）"><a href="#TABLE-ACCESS-FULL（全表扫描）" class="headerlink" title="TABLE ACCESS FULL（全表扫描）"></a>TABLE ACCESS FULL（全表扫描）</h4><p><strong>Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 where限制条件</strong>。全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作来提升吞吐量。<strong>数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上</strong>。</p><h4 id="TABLE-ACCESS-ROWID（通过ROWID的表存取）"><a href="#TABLE-ACCESS-ROWID（通过ROWID的表存取）" class="headerlink" title="TABLE ACCESS ROWID（通过ROWID的表存取）"></a>TABLE ACCESS ROWID（通过ROWID的表存取）</h4><p><strong>ROWID是由Oracle自动加在表中每行最后的一列伪列</strong>，表中并不会物理存储ROWID的值。程序员可以像使用其它列一样使用它，但不能对该列的值进行增、删、改操作。一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。</p><p>ROWID可以被视为每条记录的“指针”。<strong>它指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法</strong>。</p><h4 id="TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）"><a href="#TABLE-ACCESS-BY-INDEX-SCAN（索引扫描）" class="headerlink" title="TABLE ACCESS BY INDEX SCAN（索引扫描）"></a>TABLE ACCESS BY INDEX SCAN（索引扫描）</h4><p>在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。因此索引扫描其实分为两步：扫描索引得到对应的ROWID；通过ROWID定位到具体的行读取数据。</p><p>索引扫描主要分为以下几种：</p><h5 id="INDEX-UNIQUE-SCAN-索引唯一扫描"><a href="#INDEX-UNIQUE-SCAN-索引唯一扫描" class="headerlink" title="INDEX UNIQUE SCAN 索引唯一扫描"></a>INDEX UNIQUE SCAN 索引唯一扫描</h5><p>对应UNIQUE INDEX（唯一性索引）的扫描方式，其<strong>只会应用在返回一条记录的情况下</strong>。该点在之前的实验中已经描述。</p><h5 id="INDEX-RANGE-SCAN-索引范围扫描"><a href="#INDEX-RANGE-SCAN-索引范围扫描" class="headerlink" title="INDEX RANGE SCAN 索引范围扫描"></a>INDEX RANGE SCAN 索引范围扫描</h5><p>主要是使用在需要返回多行记录的情况下，常见为以下三种：</p><ul><li>在唯一索引列上使用了范围操作符（如：&gt;   &lt;   &lt;&gt;   &gt;=   &lt;=   between）</li><li>在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）</li><li>对非唯一索引列上进行的任何查询</li></ul><p>如果在查询的过程中需要访问的记录数很多，分布很广，这个时候Oracle会根据CBO原则认为使用索引的花销可能比全表扫描大，会使用全表扫描。</p><h5 id="INDEX-FULL-SCAN-索引全扫描"><a href="#INDEX-FULL-SCAN-索引全扫描" class="headerlink" title="INDEX FULL SCAN 索引全扫描"></a>INDEX FULL SCAN 索引全扫描</h5><p>进行全索引扫描时，查询出的数据都必须从索引中可以直接得到。其常发生在要查询的列包含唯一索引且需要对表中的所有数据都要查询。<strong>索引全扫描返回的结果有顺序。</strong></p><h5 id="INDEX-FAST-FULL-SCAN-索引快速全扫描"><a href="#INDEX-FAST-FULL-SCAN-索引快速全扫描" class="headerlink" title="INDEX FAST FULL SCAN 索引快速全扫描"></a>INDEX FAST FULL SCAN 索引快速全扫描</h5><p>索引快速全扫描与索引全扫描类似，只是其在查找索引时会用一种更为快速的方式（简单来说是根据索引块的物理顺序而省去较为繁琐的逻辑顺序），其更适合于数据量大的表进行全查询，<strong>其一个特点就是返回的记录不按照顺序。</strong></p></blockquote><h2 id="四、TimesTen实验过程"><a href="#四、TimesTen实验过程" class="headerlink" title="四、TimesTen实验过程"></a>四、TimesTen实验过程</h2><h3 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h3><p>调用自己改写的 AliTT11.sql，查看 SQLPrepare，SQLExecute，FetchLoop 的查询时间；</p><p>所有实验中，查询时间分为增加索引前、增加索引后、按照 timesten 建议添加索引三类，针对每一类时间分别有第一次执行时间和之后的平均查询时间两种；</p><p>在首次执行查询语句时，timesten首先需要对语句进行预编译，因此首次执行的 SQLPrepare 时间相比之后的时间较长，之后的准备时间就相应缩短了很多。</p><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>某地区评分6以上的所有电影的名字和上映时间</p><h4 id="查询语句-1"><a href="#查询语句-1" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBIM.T_MOVIE.NAME_, DBIM.T_MOVIE.YEAR_</span><br><span class="line"><span class="keyword">FROM</span> DBIM.T_MOVIE, DBIM.T_MOVIE_REGION, DBIM.T_REGION</span><br><span class="line"><span class="keyword">WHERE</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class="line"><span class="keyword">AND</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> DBIM.T_REGION.NAME_ = <span class="string">'美国'</span></span><br><span class="line"><span class="keyword">AND</span> DBIM.T_MOVIE.SCORE_ &gt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="添加的索引"><a href="#添加的索引" class="headerlink" title="添加的索引"></a>添加的索引</h4><table><thead><tr><th>表明</th><th>列名</th><th>索引类型</th><th>是否唯一</th></tr></thead><tbody><tr><td>Movie</td><td>id_</td><td>hash</td><td>unique</td></tr><tr><td>Movie</td><td>score_</td><td>range</td><td></td></tr><tr><td>Region</td><td>id_</td><td>hash</td><td>unique</td></tr><tr><td>Movie_region</td><td>region_id</td><td>hash</td><td></td></tr><tr><td>Movie_region</td><td>movie_id</td><td>hash</td></tr></tbody></table><h4 id="查询时间"><a href="#查询时间" class="headerlink" title="查询时间"></a>查询时间</h4><table><thead><tr><th>时间类型</th><th>Before1</th><th>Before2</th><th>After1</th><th>After2</th><th>建议1</th><th>建议2</th><th>提高百分比</th></tr></thead><tbody><tr><td>SQLPrepare</td><td>0.001845</td><td>0.000059</td><td>0.000878</td><td>0.000054</td><td>0.000807</td><td>0.000055</td><td></td></tr><tr><td>SQLExecute</td><td>0.075809</td><td>0.061819</td><td>0.000037</td><td>0.000025</td><td>0.000034</td><td>0.000025</td><td>99.96%</td></tr><tr><td>FetchLoop</td><td>0.000004</td><td>0.000002</td><td>0.000002</td><td>0.000001</td><td>0.000003</td><td>0.000002</td></tr></tbody></table><ul><li>执行计划 (before)</li></ul><p><img src="/images/11b.PNG" alt="11b"></p><ul><li>执行计划 (after)</li></ul><p><img src="/images/11a.PNG" alt="11a"></p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>添加索引后速度大大提升，因为在 region 表中指定了查询条件，添加索引后可以快速从表项中匹配到指定条件的项；在添加之前，timesten 自动帮我们在 movie 表上的 id 字段上添加了临时哈希索引，除此之外，我们额外为几个 where 条件语句的查询字段都增加了索引， 因此提高了效率。</p><p>执行计划</p><ul><li><p>before</p><p>在两层嵌套循环中，顺序执行在region表中的查询、region表与联系表的join，循环结束后生成一个指定地区内的所有电影联系表；内层嵌套完成后，通过散列索引匹配movie表与内存循环生成的联系表，join筛选后生成结果列表</p></li><li><p>after</p><p>添加索引之后，过程与添加之前相同，但由于内层循环内使用散列索引而不是顺序执行，因此查询速度比较快，加上没有临时创建索引的时间开销，所以相比之下大大提高了查询效率。</p></li></ul><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h4><p>所有地区全部电影的平均评分排行榜（前100）</p><h4 id="查询语句-2"><a href="#查询语句-2" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> DBIM.T_REGION.NAME_, <span class="keyword">SUM</span>(DBIM.T_MOVIE.SCORE_) s</span><br><span class="line"><span class="keyword">FROM</span> DBIM.T_REGION, DBIM.T_MOVIE_REGION, DBIM.T_MOVIE</span><br><span class="line"><span class="keyword">WHERE</span> DBIM.T_MOVIE.ID_ = DBIM.T_MOVIE_REGION.MOVIE_ID</span><br><span class="line"><span class="keyword">AND</span> DBIM.T_REGION.ID_ = DBIM.T_MOVIE_REGION.REGION_ID</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DBIM.T_REGION.NAME_</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s <span class="keyword">DESC</span>) <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">101</span>;</span><br></pre></td></tr></table></figure><h4 id="添加的索引-1"><a href="#添加的索引-1" class="headerlink" title="添加的索引"></a>添加的索引</h4><table><thead><tr><th>表明</th><th>列名</th><th>索引类型</th><th>是否唯一</th></tr></thead><tbody><tr><td>Movie</td><td>id_</td><td>hash</td><td>unique</td></tr><tr><td>Movie</td><td>score_</td><td>range</td><td></td></tr><tr><td>Region</td><td>name_</td><td>hash</td><td>unique</td></tr><tr><td>Region</td><td>id_</td><td>hash</td><td>unique</td></tr><tr><td>Movie_region</td><td>region_id</td><td>hash</td><td></td></tr><tr><td>Movie_region</td><td>movie_id</td><td>hash</td></tr></tbody></table><h4 id="查询时间-1"><a href="#查询时间-1" class="headerlink" title="查询时间"></a>查询时间</h4><table><thead><tr><th>时间类型</th><th>Before(1)</th><th>Before(2)</th><th>After(1)</th><th>After(2)</th><th>建议(1)</th><th>建议(2)</th><th>提高百分比</th></tr></thead><tbody><tr><td>SQLPrepare</td><td>0.001253</td><td>0.000081</td><td>0.001004</td><td>0.000054</td><td>0.000985</td><td>0.000056</td><td></td></tr><tr><td>SQLExecute</td><td>0.353111</td><td>0.335902</td><td>0.337983</td><td>0.313458</td><td>0.313004</td><td>0.312695</td><td>7%</td></tr><tr><td>FetchLoop</td><td>0.000045</td><td>0.000020</td><td>0.000018</td><td>0.000018</td><td>0.000018</td><td>0.000017</td></tr></tbody></table><ul><li>执行计划 (before)</li></ul><p><img src="/images/12b.PNG" alt="12b"></p><ul><li>执行计划 (after)</li></ul><p><img src="/images/12a.PNG" alt="12a"></p><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><p>添加索引之前，timesten 自动在 movie 和 region 表的 id 字段上都设置了相应的哈希索引，而我们添加索引后与添加之前的执行计划中的索引项没有差别，因此效率几乎没有变化，加上 sum 聚合操作、group by、order by 操作都要进行费时间的全表扫描，所以需要较长时间完成查询。</p><blockquote><h5 id="实验1和2分析总结"><a href="#实验1和2分析总结" class="headerlink" title="实验1和2分析总结"></a>实验1和2分析总结</h5><p>指定条件的查询：</p><ul><li><p>建立索引之前</p><p>timesten在某个相对较小的表上建立临时索引（散列索引或范围索引），在其他表上进行顺序扫描，执行查询语句中的条件匹配，建立索引的过程会造成时间上的消耗；</p></li><li><p>建立索引之后</p><p>自己建立的索引覆盖timesten优化建立的索引，由于索引提前建立，因此没有建立索引带来的额外时间开销，而且在此类查询中我们在所有查询涉及字段上都建立了索引（tt自身优化通常只在一个表上建立索引），所以与建立索引之前相比有极大的性能提升。</p></li></ul><p>聚合查询：</p><ul><li><p>执行计划Before：</p><p>先顺序扫描关系表act的记录字段id，利用临时HASH索引 actor.id_，将act表中对应记录与act的记录通过字段相连；对(这些/该)拼接记录逐条利用临时HASH索引 movie.id ,接上movie表中符合条件的记录字段。</p></li><li><p>执行计划After：</p><p>先顺序扫描关系表movie的记录字段id ，利用HASH索引 act.id_，将act表中对应记录与act的记录通过字段相连；针对第一次hash检索出的 act.id，再对(这些/该)拼接记录逐条利用临时HASH索引 actor.id ,接上actor表中符合条件的记录字段。</p></li><li><p>主要原因在于：第一次顺序扫描的关系表act，外码引用actor表的主码(1:1)，movie表(1:1)，hash索引查询唯一记录快；第二次顺序扫描的表为movie表，将对应多条act表里的记录（1:many），对应多个演员(1:many)。</p></li></ul></blockquote><h3 id="实验3：AWT"><a href="#实验3：AWT" class="headerlink" title="实验3：AWT"></a>实验3：AWT</h3><h4 id="创建-AWT-直写缓存组"><a href="#创建-AWT-直写缓存组" class="headerlink" title="创建 AWT 直写缓存组"></a>创建 AWT 直写缓存组</h4><ul><li>缓存表<ul><li>t_moive</li><li>t_comment_1</li></ul></li><li>选择理由<ul><li>动态缓存组适用于不从 oracle 中预加载数据的场景</li><li>Movie 表和评论表体量较大，不需要从 oracle 中提前加载</li></ul></li></ul><h4 id="测试-AWT-修改数据"><a href="#测试-AWT-修改数据" class="headerlink" title="测试 AWT 修改数据"></a>测试 AWT 修改数据</h4><ul><li><p>修改电影评论表</p></li><li><p>修改语句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE DBIM.T_COMMENT_1</span><br><span class="line">SET SUMMARY_=&apos;A&apos;</span><br><span class="line">WHERE DBIM.T_COMMENT_1.SCORE_&gt;8</span><br><span class="line">AND DBIM.T_COMMENT_1.MOVIE_ID = 1;</span><br></pre></td></tr></table></figure></li><li><p>踩坑</p><ul><li>update语句指定修改的表名后，set字段不需要再次声明表名（否则报错）</li><li>修改数据前要开启 replication agent</li><li>执行update语句后要提交事务</li></ul></li></ul><h3 id="实验4：查看不同数据类型对查询效率的影响"><a href="#实验4：查看不同数据类型对查询效率的影响" class="headerlink" title="实验4：查看不同数据类型对查询效率的影响"></a>实验4：查看不同数据类型对查询效率的影响</h3><h4 id="表字节大小"><a href="#表字节大小" class="headerlink" title="表字节大小"></a>表字节大小</h4><table><thead><tr><th>表名</th><th>行数</th><th>字节大小</th><th>有数据类型映射的字节大小</th><th>节约百分比</th></tr></thead><tbody><tr><td>Movie</td><td>292352</td><td>47301232（nomapping）</td><td>26293000（optimal）</td><td>45%</td></tr><tr><td>Comment</td><td>9805336</td><td>2528884600（nomapping）</td><td>404967952（optimal）</td><td>84%</td></tr></tbody></table><h4 id="压缩设置"><a href="#压缩设置" class="headerlink" title="压缩设置"></a>压缩设置</h4><p><img src="/images/image-20190114062154430.png" alt="image-20190114062154430"></p><h4 id="数据类型映射结果"><a href="#数据类型映射结果" class="headerlink" title="数据类型映射结果"></a>数据类型映射结果</h4><table><thead><tr><th>表</th><th>字段</th><th>noMapping</th><th>standardMapping</th><th>aggressive</th></tr></thead><tbody><tr><td>Region</td><td>id_</td><td>NUMBER(11,0)</td><td>TT_BIGINT</td><td>TT_SMALINT</td></tr><tr><td>Region</td><td>name_</td><td>VARCHAR(255 BYTE)</td><td>VARCHAR(255 BYTE)</td><td>VARCHAR(80 BYTE)</td></tr></tbody></table><h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><ul><li>对相同的表来说，从 oracle 导入 timesten 中如果不进行压缩（nomapping），与进行最优化数据类型映射+aggressive mapping + optimal compression 相比，大约浪费了45%的空间；</li><li>对于不同数量级的表来说，千万数量级的 comment 表不进行压缩时浪费84%所有的空间，比十万数量级的 movie 表浪费的空间多了接近一倍。</li></ul><h3 id="实验5：根据优化建议建立索引"><a href="#实验5：根据优化建议建立索引" class="headerlink" title="实验5：根据优化建议建立索引"></a>实验5：根据优化建议建立索引</h3><h4 id="SQL语句-3"><a href="#SQL语句-3" class="headerlink" title="SQL语句"></a>SQL语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Command&gt; call ttIndexAdviceCaptureOutput(0);</span><br><span class="line">&lt; 6, create index T_MOVIE_i1 on DBIM.T_MOVIE(ID_); &gt;</span><br><span class="line">&lt; 7, create index T_COMMENT_1_i2 on DBIM.T_COMMENT_1(MOVIE_ID,SCORE_); &gt;</span><br><span class="line">2 rows found.</span><br></pre></td></tr></table></figure><h4 id="实验对象"><a href="#实验对象" class="headerlink" title="实验对象"></a>实验对象</h4><ul><li>实验3.2语句</li></ul><h4 id="实验结果-5"><a href="#实验结果-5" class="headerlink" title="实验结果"></a>实验结果</h4><ul><li>Before：自己建立索引后的查询时间</li><li>After：根据 timesten 查询优化建议建立索引后的查询时间</li></ul><table><thead><tr><th>时间类型</th><th>Before(1)</th><th>Before(2)</th><th>After(1)</th><th>After(2)</th><th>提高百分比</th></tr></thead><tbody><tr><td>SQLPrepare</td><td>0.001527</td><td>0.000049</td><td>0.000822</td><td>0.000049</td><td></td></tr><tr><td>SQLExecute</td><td>4.139655</td><td>3.556375</td><td>3.301318</td><td>3.302092</td><td>7.18%</td></tr><tr><td>FetchLoop</td><td>0.000047</td><td>0.000027</td><td>0.000018</td><td>0.000017</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、实验前准备&quot;&gt;&lt;a href=&quot;#一、实验前准备&quot; class=&quot;headerlink&quot; title=&quot;一、实验前准备&quot;&gt;&lt;/a&gt;一、实验前准备&lt;/h2&gt;&lt;h3 id=&quot;机器配置&quot;&gt;&lt;a href=&quot;#机器配置&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="http://blog.guitoubing.top/tags/Oracle/"/>
    
      <category term="Timesten" scheme="http://blog.guitoubing.top/tags/Timesten/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库期末项目文档</title>
    <link href="http://blog.guitoubing.top/2018/12/31/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://blog.guitoubing.top/2018/12/31/数据仓库期末项目文档/</id>
    <published>2018-12-31T09:32:45.000Z</published>
    <updated>2019-10-20T08:55:17.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。</p><a id="more"></a><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><ul><li><p>操作系统：macOS Mojave 10.14.1</p></li><li><p>硬件：Core i5 &amp; 16GB RAM</p></li><li><p>软件：Neo4j Desktop Version 1.1.10 (1.1.10.436)</p></li><li><p>选择理由：</p><ul><li>高性能：Neo4j以图的遍历算法来帮助查询数据，查询时从一个节点开始，根据其连接的关系，快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li><li>灵活性：图数据结构的自然伸展特性及其非结构化的数据格式让Neo4j的数据库设计可以具有很大的伸缩性和灵活性，使其可以随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用，因此在项目后期的推进中，我们也可以不断的快速修改neo4j数据库中的内容来满足我们的查询需求。</li><li>直观性：图数据库使用图的形式作为数据库最主要的展现形式，可以更清楚的帮助我们理解整个数据库中数据之间的联系，Cypher语言的灵活性也帮助我们更轻松的操控数据库</li></ul></li><li><p>存储模型简介：</p><ul><li>本项目中主要建立了Neo4j的两个不同的库，一个库是围绕电影的相关信息，我们在其中存储了和电影有关的所有信息，包括导演，制片人，演员，类别，语言，字幕，编剧等等，节点与节点之间通过不同的关系相连接。第二个库针对合作关系，分别存储了导演，演员，以及类别，通过节点与节点之间的关系，记录他们彼此的合作次数，类别的引入也帮助我们分析导演的执导风格。</li></ul></li><li><p>存储模型：图</p></li><li>性能对比分析：<ul><li>数据存储：Neo4j对于图的存储自然是经过特别优化的。不像传统数据库的一条记录一条数据的存储方式，Neo4j的存储方式是：节点的类别，属性，边的类别，属性等都是分开存储的，这将大大有助于提高图形数据库的性能。在Neo4j 中属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。</li><li>数据读写：在Neo4j中，存储节点时，每个节点都有指向其邻居节点的指针，可以让我们在O(1)的时间内找到邻居节点。另外，按照官方的说法，在Neo4j中边是最重要的,是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历。邻近查询帮助Neo4j始终查找的是有限的局部数据，不会对整个数据库进行搜索。所以，Neo4j具有非常高效的查询性能，相比于RDBMS可以提高数倍乃至数十倍的查询速度。而且查询速度不会因数据量的增长而下降。</li></ul></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><p>操作系统：macOS Mojave 10.14.1 Beta</p></li><li><p>硬件：Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz/ 4 GB 1600 MHz DDR3</p></li><li><p>软件：Docker 1.13.1/ MySQL 5.7</p></li><li><p>选择理由：</p><p>MySQL是时下使用率最高的几款关系型数据库之一，且其体积相较其他关系型数据库更小巧且性能不输大型关系型数据库。关系型数据库是我们最常接触也是在对数据进行存储时会最先想到的数据库类型。我们想要借助关系型数据库以及行式存储对我们的数据进行存储，并通过对应的数据库操作对存储对数据进行分析/查询，实现我们对应的目的。</p></li><li><p>存储模型简介：</p><p>在本项目中我们选择雪花模型作为我们关系型数据库的存储模型。雪花存储模型使用规范化的数据，数据在数据库内部是组织好的，消除冗余以减少数据量。相比之下，星型模型使用的是反规范化的数据，会在存储时存储大量的冗余数据。规范化存储数据同时也带来查询时间上的消耗，其查询更新速度会慢于星型存储模型。但是考虑到我们项目到数据单表最大12万左右，对于这个数量级到数据星型模型的查询速度相比雪花模型没有非常明显的差距，而雪花模型能够帮助我们减少了很多不必要的冗余数据的存储，所以我们选用了雪花模型。我们的数据库设计了实体表与关系表，各个实体表有自己的唯一的主键，实体表之间的联系使用关系表进行关联，减少了很多实体数据的存储，符合第三范式。</p></li><li><p>性能分析：</p><p>在一开始，我们并没有对每个表建立相应的索引，在这种情况下我们单表的query速度在一个可接受的范围内，但是一旦涉及多表联合查询，如查询每个导演执导的电影数量时，需要关联三张表，在这种情况下查询速度非常的慢，因为其中涉及来表的结合与数据的聚合查询。针对联合查询过慢的速度下，我们为每张实体表以及关系表建立主码索引，并且在常用的搜索字段，如电影的上映日期上建立对应的索引，并且在这种大量数据的情况需要先对表建立索引再将数据导入，因为导入数据之后再建立索引会消耗大量的时间。索引建立之后再进行同样的多表联合查询操作，可以发现速度得到了明显的提升，在当前十万级别的数据量下查询耗时基本在五十毫秒之内。所以在MySQL中建立适当的索引能够在很大程度上提升查询的速度，同时也会牺牲一定的查询/更新效率。</p><p><img src="/images/ERFinal.png" alt="ERFinal"></p></li></ul><h3 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h3><ul><li>操作系统：windows10</li><li>硬件：Intel(R) Core(TM) i5-6300HQ CPU @2.30GHz &amp; 8GB RAM</li><li>软件：influx1.7.1</li><li>选择理由：<br>首先，查询场景中有用到对世界特性比较敏感的数据，例如，根据时间查询等，所以使用influxDB。influxDB继承了LSM Tree的顺序写入的特点，所以写入性能很好（先把大量的数据顺序写，然后持久化到磁盘。）时序数据库每次读取数据都是读取固定series的指定时间范围的连续数据，因为是顺序写入，所以这种读取比较快速。</li><li>存储模型简介：<br>influxdb中我们主要存 电影id，电影类别，电影语言，电影观看人数，电影上映时间。其中，将电影类别与电影语言当做tag存储，电影id以及电影观看人数当做field存储，其中上映时间就是时间戳存储。</li><li>存储模型：<br><img src="/images/527DE0D27244EE625AD2D099AACDF4BA-6182656.png" alt="527DE0D27244EE625AD2D099AACDF4BA"></li><li><p>性能对比分析：</p><p>InfluxDB用于存储大量的时间序列数据，并对这些数据进行快速的实时分析。SQL数据库也可以提供时序的功能，但时序并不是其目的。<br>在InfluxDB中，timestamp标识了在任何给定数据series中的单个点。就像关系型数据库中的主键。<br>InfluxDB考虑到schema可能随时间而改变，因此赋予了其便利的动态能力。但是由于在项目中，时间相关的数据较为固定，因此其性能的体现并不是特别好。</p></li></ul><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><ul><li><p>操作系统：macOS Mojave 10.14.1</p></li><li><p>硬件：Core i7 &amp; 16GB RAM</p></li><li><p>软件：Hive 3.1.1 &amp; Hadoop 3.1.1 &amp; MySQL 5.7</p></li><li><p>选择理由：</p><p>Hive首先有很多以上数据库所不具有的优点，如扩展性和容错性，本项目我们选择hive来处理一部分数据主要是作为MySQL数据库的对照。针对我们项目的百万级的数据量来对比分析关系型数据库和分布式数据库在数据量较大时的性能优劣性，以此窥见数据仓库对比于数据库的所展现出来的优点。同时对于项目中的部分功能需求组合采用hive与其他数据库分治的方式，来实现复杂的功能需求，以此来学习工程中数据仓库与普通数据库结合的实现方法。而由于数据量及需求的限制，我们只可窥见数据仓库其作用的冰山一角，希望藉此加深我们对数据仓库的理解。</p></li><li><p>存储模型简介：</p><p>在hive中我们存储的数据与MySQL中一样。因此建立了与MySQL完全相同的存储结构。另外针对hive本身自带的不同的存储模型，我们还创建了textfile和ORCfile两种表存储结构。</p></li><li><p>分布式架构：</p><p><img src="/images/hive_arg.png" alt="h"></p></li><li><p>性能对比分析：</p><p>从我们对于MySQL和Hive这两种比较有可比性的数据库之间的对比来说，MySQL的执行时间基本上是远远快于Hive的执行时间的。<br>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；<br>其次，Hive官网有句话”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集中，最多的数据集是700多万条的用户评论数据，而基本功能的实现都是操作在数据量仅有10万余条的电影数据，我们猜测是数据量限制了Hive体现其优越性。因此我们作了如下实验：在等量的数据量变化上，我们比较二者变化前后的执行的时间，得到下表：<br><img src="/images/表1.png" alt="表1"><br>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而Hive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。然而在这过程中，我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件，我们创建了t_comment表存储用户评论信息，表数据文件如下：<br><img src="/images/hive_textfile1.png" alt="h1"><br><img src="/images/hive_textfile2.png" alt="h2"><br>从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点，我们创建了t_comment_orc表，并从t_comment中把数据原封不动的导入进来，可见表数据文件如下：<br><img src="/images/hive_orc1.png" alt="h3"><br>不难看到ORC表文件(260MB)明显比TextFile表文件(705MB)小多了，至于性能，同样对于上述实验，我们添加了ORC表的结果：<br><img src="/images/表2.png" alt="表2"><br>结果显而易见，当数据达到数百万量级时，Hive<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。<br>通过以上两点以及常识我们不难看出：</p><ul><li><p>限制Hive的效率的因素：</p><ul><li><p>数据量</p></li><li><p>计算框架</p><p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使</p></li><li><p>网络通信</p><p>由于我们的集群搭建在Docker容器中，其间数据通过程序写定的程序通道传输而非真实的网络通信，因此暂且看不出网络对执行的影响，而真实场景中，这必是一项重要的考虑因素</p></li></ul></li><li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p></li><li>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</li></ul><p>其三，上述操作均是在单表查询的前提下，但是在多表查询情况下Hive的效率如何呢？先看测试结果，我们仅在”导演-执导-电影”三表上做了多表查询，执行”某导演执导电影的数量”的操作，执行时间记录如下：<br><img src="/images/表3.png" alt="表3"><br>此现象引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表是很特殊的，其没有主键、外键同时库中各个表之间的冗余会很明显，这使得管理人员方便针对各种功能设计所需的信息表，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一。</p></li></ul><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p><img src="/images/image-20181231003424471.png" alt="image-20181231003424471"><img src="/images/image-20181231003442918-6187682.png" alt="image-20181231003442918"></p><p><img src="/images/image-20181231003457997-6187698.png" alt="image-20181231003457997"><img src="/images/image-20181231003513281-6187713.png" alt="image-20181231003513281"></p><ul><li><p>走势变化：</p><p>由图可见，四种数据库中执行时间都是先较多然后减少最后趋于稳定，我们对其分析可能是jdbc在首次连接时需要较多时间进行网络通信，当一次连接建立后，我们并没有关闭该连接，在此基础上程序执行后续的事务才应当是其真实的操作时间。</p></li><li><p>功能对比：</p><p>不同的数据库，在不同的功能需求下各有优劣。举个例子，在查询实体间的关系时，对于完全符合3NF的关系型数据库来说，可能需要多表连接查询，这明显会消耗大量时间，而对于基于relation的数据库例如Neo4j来说，类似查询正是其强项。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>本项目使用了JavaWeb框架，并基于sementicUI进行前端开发。</li><li>在数据库选择上，我们使用了Mysql，hive，Neo4j以及influxDB四个不同的数据库进行横向纵向比对，通过实现一定的基本功能搜索以及多表联查，统计他们的性能，查询时间等数据并进行相应的分析，对于不同数据库的优劣势有了更为清晰的了解。</li><li>在项目过程中，我们将上课学到的知识应用到实践中，尝试了雪花，星型等不同的存储结构，并根据自己的项目实情选择了最适合我们的项目存储结构。针对不同的实验现象，我们也通过网络等资源来进行辅助学习，帮助我们更好的了解不同数据库以及其不同的存储，读取等方式。</li><li>项目过程中，特别感谢老师和助教们的帮助，让我们更为深入了解了数据仓库技术，为我们今后的项目实践打下了扎实的基础。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本项目我们基于Stanford University中的Amazon Movie Comment数据，利用爬虫技术爬取了数十万的电影信息数据以及数百万计的电影评论数据，并通过搭建Neo4j图数据库、MySQL关系型数据库、Influx时序数据库及Hive分布式数据库对数据进行存储、分析及实现功能，同时对于部分功能需求针对这4种数据库进行效率对比分析。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="大三上笔记" scheme="http://blog.guitoubing.top/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据仓库" scheme="http://blog.guitoubing.top/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop - 云计算期末项目</title>
    <link href="http://blog.guitoubing.top/2018/12/31/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
    <id>http://blog.guitoubing.top/2018/12/31/云计算期末项目文档/</id>
    <published>2018-12-31T09:31:32.000Z</published>
    <updated>2019-10-20T08:55:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云计算期末项目文档"><a href="#云计算期末项目文档" class="headerlink" title="云计算期末项目文档"></a>云计算期末项目文档</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h3><p><img src="/images/image-20181228192856958-5996536.png" alt="image-20181228192856958"></p><h3 id="集群机器"><a href="#集群机器" class="headerlink" title="集群机器"></a><a name="a1">集群机器</a></h3><table><thead><tr><th style="text-align:center">主机名</th><th style="text-align:center">内存</th><th style="text-align:center">IP</th><th style="text-align:center">软件</th><th style="text-align:center">运行进程</th></tr></thead><tbody><tr><td style="text-align:center">node0</td><td style="text-align:center">512MB</td><td style="text-align:center">192.168.137.200</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">node1</td><td style="text-align:center">512MB</td><td style="text-align:center">192.168.137.201</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">node2</td><td style="text-align:center">512MB</td><td style="text-align:center">192.168.137.202</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">master</td><td style="text-align:center">2GB</td><td style="text-align:center">192.168.137.100</td><td style="text-align:center">Hadoop,Hive,MySql</td><td style="text-align:center">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td></tr><tr><td style="text-align:center">master1</td><td style="text-align:center">2GB</td><td style="text-align:center">192.168.137.10</td><td style="text-align:center">Hadoop,Hive</td><td style="text-align:center">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td></tr><tr><td style="text-align:center">slave1</td><td style="text-align:center">1GB</td><td style="text-align:center">192.168.137.101</td><td style="text-align:center">Hadoop</td><td style="text-align:center">JournalNode,DataNode,NodeManager</td></tr><tr><td style="text-align:center">slave2</td><td style="text-align:center">1GB</td><td style="text-align:center">192.168.137.102</td><td style="text-align:center">Hadoop</td><td style="text-align:center">DataNode,NodeManager</td></tr><tr><td style="text-align:center">slave3</td><td style="text-align:center">1GB</td><td style="text-align:center">192.168.137.103</td><td style="text-align:center">Hadoop</td><td style="text-align:center">DataNode,NodeManager</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">8GB</td><td style="text-align:center">192.168.137.1</td><td style="text-align:center">应用服务器</td></tr></tbody></table><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>集群使用VirtualBox创建了8台虚拟机模拟真实环境中的分布式集群<sub><del>(因机器内存不够，特地为此买了内存条及SSD)</del></sub>，虚拟机全部使用CentOS7-x86_64系统，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），Windows本机作为应用程序服务器用于连接此集群。</p><h3 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h3><p>此集群中机器的系统基本配置几乎是一样的，只是在后期所担任的角色不同，因此这里我创建了一台虚拟机，而后将环境配好后复制了7台，而后针对其所担任角色进行针对性修改。</p><p>首先创建了一台裸机，要解决的第一个问题是虚拟机与主机的网络通信，这里我采用VirtualBox中的<code>Host-Only</code>连接方式，以保证虚拟机与主机之间正常的网络通信，同时需要在主机上共享网络，以保证虚拟机同时还能访问互联网。</p><p>在主机网络设置中共享网络：</p><p><img src="/images/image-20181228201105314-5999065.png" alt="image-20181228201105314"></p><p>在VirtualBox中执行以下操作设置主机连接方式：</p><p><img src="/images/image-20181228200129326-5998489.png" alt="image-20181228200129326"></p><p>在虚拟机终端执行以下操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改虚拟机的IP、子网掩码</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class="line"><span class="comment"># 修改为以下内容</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">IPADDR=192.168.137.100</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># 修改网关地址</span></span><br><span class="line">vim /etc/sysconfig/network</span><br><span class="line"><span class="comment"># 修改为以下内容</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">GATEWAY=192.168.137.1</span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># 修改主机名为master，后续过程中访问本机只需要主机名而不用敲IP</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname master</span><br><span class="line"><span class="comment"># 关闭并停用防火墙，由于这里使用的是局域网，因此无需太多考虑网络安全</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment"># 重启网络服务</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment"># 尝试从虚拟机ping网关以及从主机ping虚拟机hostname或者ip，若都能ping通说明网络配置成功</span></span><br><span class="line">ping 192.168.137.1</span><br><span class="line"><span class="comment"># 从虚拟机ping外网查看是否可以连接互联网，这里测试百度IP：61.135.169.105</span></span><br><span class="line">ping 61.135.169.105</span><br><span class="line"><span class="comment"># 修改hosts文件，添加局域网中其他主机的主机名与ip的映射</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"><span class="comment"># 修改为以下内容</span></span><br><span class="line">192.168.137.100 master</span><br><span class="line">192.168.137.10 master1</span><br><span class="line">192.168.137.101 slave1</span><br><span class="line">192.168.137.102 slave2</span><br><span class="line">192.168.137.103 slave3</span><br><span class="line">192.168.137.200 node0</span><br><span class="line">192.168.137.201 node1</span><br><span class="line">192.168.137.202 node2</span><br><span class="line">0.0.0.0 localhost</span><br><span class="line"><span class="comment"># 保存退出</span></span><br></pre></td></tr></table></figure><p>至此，虚拟机网络配置已完成，下面安装Hadoop 2.9.2及Hive 2.3.4（下载、解压步骤省略），并执行一些准备工作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先添加Hadoop和Hive相关环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 添加下列内容</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_MAPRED_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/hadoop</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=<span class="variable">$HADOOP_HOME</span>/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/usr/<span class="built_in">local</span>/hive</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HIVE_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 保存退出，并使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>Hadoop和Hive的配置需放到各台虚拟机上分别执行，因为不同虚拟机所需要的配置不同。</p><h3 id="虚拟机复制"><a href="#虚拟机复制" class="headerlink" title="虚拟机复制"></a>虚拟机复制</h3><p>上述步骤已经创建好了一个虚拟机，下面需要复制出7个，并对每台机器针对性的进行一些修改。</p><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>对于每台虚拟机需要执行以下几个步骤以保证9台机器之间形成一个网络：</p><ul><li><p>修改IP</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br></pre></td></tr></table></figure><p>针对<a href="#a1">集群机器</a>中定义的IP将<code>IPADDR</code>项修改为对应的IP</p></li><li><p>修改主机名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hostnamectl <span class="built_in">set</span>-hostname XXX</span><br></pre></td></tr></table></figure><p>针对<a href="#a1">集群机器</a>中定义的主机名执行以上命令修改为特定的主机名</p></li><li><p>重启网络服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ping各个节点测试是否成功</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping master</span><br><span class="line">ping master1</span><br><span class="line">ping slave1</span><br><span class="line">ping slave2</span><br><span class="line">ping slave3</span><br><span class="line">ping node0</span><br><span class="line">ping node1</span><br><span class="line">ping node2</span><br><span class="line">ping 192.168.137.1</span><br><span class="line">ping 61.135.169.105</span><br></pre></td></tr></table></figure></li></ul><h4 id="Hadoop配置"><a href="#Hadoop配置" class="headerlink" title="Hadoop配置"></a>Hadoop配置</h4><h5 id="修改core-site-xml"><a href="#修改core-site-xml" class="headerlink" title="修改core-site.xml"></a>修改core-site.xml</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HADOOP_HOME</span>/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure><ul><li><p>作用：Hadoop集群的核心配置文件</p></li><li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p></li><li><p>内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/var/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>node0:2181,node1:2182,node2:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 允许访问此hdfs的主机和群组，此处设置为任意 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml"></a>修改hdfs-site.xml</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HADOOP_HOME</span>/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure><ul><li><p>作用：hdfs集群配置文件</p></li><li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p></li><li><p>内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定dfs文件存储位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/var/hadoop-data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定文件备份份数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定机器运行情况检查时间间隔 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.heartbead.recheck-interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>3000000ms<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定hdfs的nameservice为ns，和core-site.xml保持一致 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- NS下面的NameNode --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master1:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://master:8485;master1:8485;slave1:8485/ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/journaldata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启机器故障自动切换主从机器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定failover切换的方法(java类的名称) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定failover切换的方法，这里使用ssh通信方式交换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                sshfence</span><br><span class="line">                shell(/bin/true)</span><br><span class="line">                <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ssh切换方法需要指定私钥文件位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>假设当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3(在此时间间隔内可能会出现文件数量紊乱的现象)，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li><li>当使用jdbc访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li></ul></li></ul><h5 id="修改slaves文件"><a href="#修改slaves文件" class="headerlink" title="修改slaves文件"></a>修改slaves文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HADOOP_HOME</span>/etc/hadoop/slaves</span><br></pre></td></tr></table></figure><ul><li><p>作用：为各个master指定为其工作的slave</p></li><li><p>需要修改的机器：master、master1</p></li><li><p>内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave1</span><br><span class="line">slave2</span><br><span class="line">slave3</span><br></pre></td></tr></table></figure></li></ul><h5 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml"></a>修改yarn-site.xml</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HADOOP_HOME</span>/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure><ul><li><p>作用：yarn集群的核心配置文件</p></li><li><p>需要修改的机器：master、master1、slave1、slave2、slave3</p></li><li><p>内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启用yarn集群的高可用机制 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定ResourceManager集群id，可为任意字串 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yrc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定两台ResourceManager的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定两台ResourceManager的主机名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定两台ResourceManager的web端口，正常情况为8088 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master1:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定管理集群的Zookeeper集群的地址及对应端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>node0:2181,node1:2181,node2:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定jar包路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.application.classpath<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml"></a>修改mapred-site.xml</h5><ul><li><p>作用：指定MapReduce操作的基本属性</p></li><li><p>需要修改的机器：master、master1</p></li><li><p>内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.application.classpath<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/*:/usr/local/hadoop/share/hadoop/common/*:/usr/local/hadoop/share/hadoop/hdfs:/usr/local/hadoop/share/hadoop/hdfs/lib/*:/usr/local/hadoop/share/hadoop/hdfs/*:/usr/local/hadoop/share/hadoop/yarn:/usr/local/hadoop/share/hadoop/yarn/lib/*:/usr/local/hadoop/share/hadoop/yarn/*:/usr/local/hadoop/share/hadoop/mapreduce/lib/*:/usr/local/hadoop/share/hadoop/mapreduce/*:/usr/local/hadoop/contrib/capacity-scheduler/*.jar<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>MapReduce是不一定依赖yarn的，但一般使用yarn框架来实现MapReduce</li><li>此项若是不配，一些job只会在本机跑，而不会分发给其他机器</li></ul></li></ul><h5 id="修改hive-site-xml"><a href="#修改hive-site-xml" class="headerlink" title="修改hive-site.xml"></a>修改hive-site.xml</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HIVE_HOME</span>/conf/hive-site.xml</span><br></pre></td></tr></table></figure><ul><li><p>作用：hive的基本配置</p></li><li><p>需要修改的机器：master、master1</p></li><li><p>内容：</p><ul><li><p>修改<code>hive.server2.webui.host</code></p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.webui.host<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;hostname&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The host address the HiveServer2 WebUI will listen on<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p></li><li><p>修改<code>hive.server2.bind.host</code></p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.thrift.bind.host<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;hostname&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Bind host on which to run the HiveServer2 Thrift service.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其中<code>${hostname}</code>需要改成对应的主机名称(master与master1)，或者都改为<code>0.0.0.0</code></p></li><li><p>修改<code>hive.server2.zookeeper.namespace</code></p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.zookeeper.namespace<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hiveserver2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The parent node in ZooKeeper used by HiveServer2 when supporting dynamic service discovery.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  注意两个hiveserver节点的该值应设置为一样，指定了改值后，每当一个hiveserver节点启动时，在Zookeeper集群中，目录树下的hiveserver2文件夹下就可以看到该节点注册到Zookeeper中。</p></li><li><p>修改<code>javax.jdo.option.ConnectionURL</code>、<code>javax.jdo.option.ConnectionPassword</code>和<code>javax.jdo.option.ConnectionDriverName</code></p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&amp;amp;allowPublicKeyRetrieval=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      JDBC connect string for a JDBC metastore.</span><br><span class="line">      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class="line">      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  这里两个节点的数据库连接字符串也应该是一样的，需要知道的是这里只有master节点安装并运行了mysql服务，存储hive元数据的均在此mysql数据库中，意即存储元数据信息是与master1无关的，实际上mysql服务器可以在网络上的任意位置(<del>此处我一开始也误解了，以为master和master1节点都需要存储hive的元数据</del>)。</p><p>  另外，mysql的连接jar包需要下载并复制到hive的lib目录下。</p></li></ul></li></ul><p>至此整个Hadoop集群已经搭建完毕，却未完，需要使用Zookeeper集群来实现集群的高可用性（HA）。</p><h4 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h4><p>对于剩下的node0、node1、node2三台机器是用于搭建Zookeeper集群的，因此需要安装并配置Zookeeper-3.4.10：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/zookeeper/conf/zoo.cfg</span><br><span class="line"><span class="comment"># 添加一下内容</span></span><br><span class="line">server.1=192.168.137.200:2888:3888</span><br><span class="line">server.2=192.168.137.201:2888:3888</span><br><span class="line">server.3=192.168.137.202:2888:3888</span><br><span class="line"><span class="comment"># 保存并关闭</span></span><br></pre></td></tr></table></figure><h4 id="ssh免密登录配置"><a href="#ssh免密登录配置" class="headerlink" title="ssh免密登录配置"></a>ssh免密登录配置</h4><ul><li><p>作用：保证任何一台机器都可通过ssh免密访问其他机器，这对于使用sshfence策略的failover机制是很必要的</p></li><li><p>需要修改的机器：所有机器</p></li><li><p>内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入用户目录下的`.ssh`目录</span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> .ssh/</span><br><span class="line"><span class="comment"># 创建公钥私钥对</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># 将公钥发送给其他所有节点，hostname需对应每一台机器更改为其主机名执行一遍</span></span><br><span class="line">ssh-copy-id <span class="variable">$&#123;hostname&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>至此，Hadoop集群与Zookeeper集群已搭建完毕，接下来需要启动之。</p><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p>在master机器上执行以下操作以初始化数据库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HIVE_HOME</span></span><br><span class="line">schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure><p>此命令执行完之后将会在mysql中创建hive的元数据表，以存储hive的表结构及其他属性。</p><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>在master机器上执行以下操作以启动集群：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目功能需求"><a href="#项目功能需求" class="headerlink" title="项目功能需求"></a>项目功能需求</h2><h3 id="项目主题"><a href="#项目主题" class="headerlink" title="项目主题"></a>项目主题</h3><p><strong>超市销售管理系统</strong></p><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><h4 id="商品进货"><a href="#商品进货" class="headerlink" title="商品进货"></a>商品进货</h4><p><strong>功能点说明</strong>：超市管理员查询供应商，并根据结果输入从该供应商进货的商品信息</p><p><strong>数据需求</strong>：查询供应商，新增进货记录，新增商品</p><h4 id="查询商品"><a href="#查询商品" class="headerlink" title="查询商品"></a>查询商品</h4><p><strong>功能点说明</strong>：超市管理员通过商品名搜索库存中的所有相关商品</p><p><strong>数据需求</strong>：查询商品</p><h4 id="生成订单"><a href="#生成订单" class="headerlink" title="生成订单"></a>生成订单</h4><p>功能点说明：超市管理员查询相应商品并将其添加至订单中，添加完毕后生成订单</p><p>数据需求：查询商品，新增购买记录，新增订单</p><h3 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h3><p>基于面向对象的思想，我们在分析数据需求的时候简单地将我们的系统分为两个模块：进货和购买，这两个模块都以商品为核心。因此在构建实体-联系模型时，我们也根据这个思想出发，将E-R图分为了两个模块。</p><h4 id="总体E-R图"><a href="#总体E-R图" class="headerlink" title="总体E-R图"></a>总体E-R图</h4><p><img src="/images/image-20181231170852678-6247332.png" alt="image-20181231170852678"></p><h4 id="进货模块E-R图"><a href="#进货模块E-R图" class="headerlink" title="进货模块E-R图"></a>进货模块E-R图</h4><p><img src="/images/image-20181231170913607-6247353.png" alt="image-20181231170913607"></p><p>进货模块主要包含两个实体集，公司（Corporation）和商品（Commodity）。商品中包含着超市库存商品的信息如商品名称、数量、价格，公司类包含供应商的信息如公司名称、地址、国家等。两个实体之间有着关系集供应（Supply），表示某商品从某公司进货。由于一种商品可能从多个公司进货，一个公司也可能供应多种商品，因此他们之间的关系应该是多对多。供应关系集同时还具有属性，表示进货的信息包括数量、成本、时间。</p><h4 id="购买模块E-R图"><a href="#购买模块E-R图" class="headerlink" title="购买模块E-R图"></a>购买模块E-R图</h4><p><img src="/images/image-20181231170937495-6247377.png" alt="image-20181231170937495"></p><p>购买模块包含的实体集有商品（Commodity）和订单（Bill）。订单表示一次完整购买的总订单（包含购买的所有商品情况），包含的信息有总价、折扣、实际价格等。商品和订单之间有关系集购买（Purchase），由于一个订单包含多个商品，一个商品也会被多次购买，因此这个关系是多对多的。同时，购买关系还具有属性，表示订单中的每一种商品购买的数量和小计价格。</p><h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><p>根据E-R模型的转化，我们生成了5张表，分别是：Corporation（公司），Supply（供应），Commodity（商品），Purchase（购买），Bill（订单）。表的详细设计如下：</p><h6 id="Commodity表"><a href="#Commodity表" class="headerlink" title="Commodity表"></a>Commodity表</h6><table><thead><tr><th>字段名</th><th>数据类型</th><th>长度</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>ID</td><td>number</td><td>10</td><td>商品的ID</td><td>PK</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>商品名称</td><td></td></tr><tr><td>quantity</td><td>decimal</td><td>10,2</td><td>商品库存量</td><td></td></tr><tr><td>price</td><td>decimal</td><td>10,2</td><td>商品单价</td></tr></tbody></table><h6 id="Corporation表"><a href="#Corporation表" class="headerlink" title="Corporation表"></a>Corporation表</h6><table><thead><tr><th>字段名</th><th>数据类型</th><th>长度</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>ID</td><td>number</td><td>10</td><td>公司的ID</td><td>PK</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>公司名称</td><td></td></tr><tr><td>address</td><td>varchar</td><td>20</td><td>公司地址</td><td></td></tr><tr><td>country</td><td>varchar</td><td>10</td><td>公司所在国家</td><td></td></tr><tr><td>business</td><td>varchar</td><td>10</td><td>公司业务</td></tr></tbody></table><h6 id="Bill表"><a href="#Bill表" class="headerlink" title="Bill表"></a>Bill表</h6><table><thead><tr><th>字段名</th><th>数据类型</th><th>长度</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>ID</td><td>number</td><td>10</td><td>订单的ID</td><td>PK</td></tr><tr><td>totalprice</td><td>decimal</td><td>10,2</td><td>订单总价</td><td></td></tr><tr><td>discount</td><td>decimal</td><td>10,2</td><td>订单折扣</td><td></td></tr><tr><td>finalprice</td><td>decimal</td><td>10,2</td><td>订单实际总价</td><td></td></tr><tr><td>realpay</td><td>decimal</td><td>10,2</td><td>顾客付款</td><td></td></tr><tr><td>charge</td><td>decimal</td><td>10,2</td><td>找钱</td></tr></tbody></table><h6 id="Supply表"><a href="#Supply表" class="headerlink" title="Supply表"></a>Supply表</h6><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">数据类型</th><th>长度</th><th style="text-align:left">说明</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">corID</td><td style="text-align:left">number</td><td>10</td><td style="text-align:left">供应公司的ID</td><td>PK;   FK，参照于Corporation的ID</td></tr><tr><td style="text-align:left">productID</td><td style="text-align:left">number</td><td>10</td><td style="text-align:left">商品的ID</td><td>PK；FK，参照于Commodity的ID</td></tr><tr><td style="text-align:left">amount</td><td style="text-align:left">decimal</td><td>10,2</td><td style="text-align:left">商品供应数量</td><td></td></tr><tr><td style="text-align:left">totalcost</td><td style="text-align:left">number</td><td>6</td><td style="text-align:left">商品供应总成本</td><td></td></tr><tr><td style="text-align:left">supplydate</td><td style="text-align:left">datetime</td><td>0</td><td style="text-align:left">供应日期</td></tr></tbody></table><h6 id="Purchase表"><a href="#Purchase表" class="headerlink" title="Purchase表"></a>Purchase表</h6><table><thead><tr><th>字段名</th><th>数据类型</th><th>长度</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>productID</td><td>number</td><td>10</td><td>购买商品的ID</td><td>PK；参照于Commodity的ID</td></tr><tr><td>billID</td><td>number</td><td>10</td><td>订单ID</td><td>PK；参照于Bill的ID</td></tr><tr><td>amount</td><td>decimal</td><td>10,2</td><td>购买该商品数量</td><td></td></tr><tr><td>sumprice</td><td>decimal</td><td>10,2</td><td>购买该商品小计价格</td></tr></tbody></table><h4 id="数据库关系图"><a href="#数据库关系图" class="headerlink" title="数据库关系图"></a>数据库关系图</h4><p>根据表的设计和之间的外码约束，绘制出数据库的关系图：</p><p><img src="/images/image-20181231171547272-6247747.png" alt="image-20181231171547272"></p><h3 id="Hive中的实际存储"><a href="#Hive中的实际存储" class="headerlink" title="Hive中的实际存储"></a>Hive中的实际存储</h3><p>经过多次尝试与实验，发现Hive中实际上是不支持表间外键联系的，因此我们在实际存储上述的表结构时将所有的外键均去除了。</p><blockquote><p>这引出了数据仓库在实际应用中的一种常见处理方式：为了提高速度而产生数据冗余。Hive中的表结构的特殊性，使得使用人员方便针对各种功能设计所需的信息表，而非使用传统的符合3NF或者其他范式的表结构，这也是数据仓库作为大量数据集的OLAP最佳选择的原因之一(其消除了由于大量表间连接时而产生的冗余操作，这是很典型的以<strong>空间</strong>换取<strong>时间</strong>的策略)。</p></blockquote><h2 id="项目实现方法"><a href="#项目实现方法" class="headerlink" title="项目实现方法"></a>项目实现方法</h2><p>整个项目我们使用传统的JavaWeb框架。后端使用Servlet处理数据交互，使用JDBC连接Zookeeper管理的Hiveserver2集群；前端使用Bootstrap框架完成基本的项目展示功能：</p><p><img src="/images/1.png" alt="1"></p><p>​                                            图1：查看库存</p><p><img src="/images/2.png" alt="2"></p><p>​                                            图2：查看历史账单</p><p><img src="/images/3.png" alt="3"></p><p>​                                            图3：创建新账单</p><p>我们深知本项目重点在分布式集群而非前端展示上，因此我们组将95%的精力放在项目的理论理解、环境搭建、性能提升以及实践使用上。</p><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><h3 id="HA的原理理解及实现"><a href="#HA的原理理解及实现" class="headerlink" title="HA的原理理解及实现"></a>HA的原理理解及实现</h3><p>HA的实现是我们组在搭建集群时遇到的最大的难题，如何协调其主次关系、如何保证网络通信、如何确定哪些进程应该运行在哪些合适的机器上，举个例子：在我们完成集群搭建到了最后启动Hive时，启动了两个Hive客户端进程和两个Hiveserver2服务端进程，而两个Hive客户端又共用了同一个MySQL服务器，导致jdbc在连接Zookeeper时会随机访问到两个Hive客户端，这导致了数据库数据时而一致、时而不一致，后来我们在Hive的配置文件将其连接Hive客户端改为同一个后将其解决了。诸如此类的小问题我们遇到了很多很多，最后都一一得到了解决。</p><h3 id="Hive与MySQL的横向对比"><a href="#Hive与MySQL的横向对比" class="headerlink" title="Hive与MySQL的横向对比"></a>Hive与MySQL的横向对比</h3><p>我们发现Hadoop集群启动后，前端与后端进行数据交互的速度很慢，于是我们使用MySQL与Hive做了简单的对比，结果很让我们困惑：MySQL的执行时间基本上是远远快于Hive的执行时间的。</p><p>我们从以下角度进行了思考与实验：</p><p>首先，考虑我们在这两种数据库中执行的操作，如果对于一开始数据从文件进入数据库中这一过程忽略的话，我们整个项目执行的都是OLAP即联机分析处理操作。Hive作为一个经典的数据仓库工具，本身应该是擅长执行OLAP操作的，因此暂且认为”操作”不是造成二者执行时间差异的原因；</p><p>其次，Hive官网有句话”Hive在大型数据集上会表现出优越的性能”，考虑到我们的项目数据集中，最多的数据集是数百万条的商品库存数据，我们猜测是数据量限制了Hive体现其优越性。因此我们作了如下实验：将数据量从10W变化到1000W，然后观察在等量的数据量变化上，二者执行时间的变化，得到下表：</p><table><thead><tr><th>数据库类型</th><th style="text-align:right">10W数据</th><th style="text-align:center">1000W数据</th></tr></thead><tbody><tr><td>MySQL</td><td style="text-align:right">9ms</td><td style="text-align:center">271ms</td></tr><tr><td>Hive(textfile)</td><td style="text-align:right">1428ms</td><td style="text-align:center">5100ms</td></tr></tbody></table><p>就时间来说，很显然MySQL更胜一筹，但从增长比例来说，MySQL从9ms增长至271ms增长约为30倍，而Hive增长约为5倍，由此我们可窥见Hive在大量数据集时性能会更加优越。</p><p>然而在这过程中，我们所使用的Hive所采用的为textfile存储结构，意即内容即文件，表数据完全按照表结构存储成为文本文件。从Hive官方文档我们得知Hive有其他更加优越的存储格式，它包含SequenceFile、RCFile、ORCFile，因此我们采取了所谓最优的ORCFile来Duplicate了用户评论表，想以此对比ORCFile之于TextFile的优点。存储中源数据文件大小为872MB，当使用textfile格式存储时，Hive会将我们导入的文件原封不动的移动到hdfs的Hive数据文件目录下，而使用ORCFile格式存储时文件大小只有260MB大小，这是其优点之一：<strong>文件压缩</strong>。至于性能，我们执行了上述同样的实验：</p><table><thead><tr><th>数据库类型</th><th style="text-align:right">10W数据</th><th style="text-align:center">1000W数据</th></tr></thead><tbody><tr><td>MySQL</td><td style="text-align:right">9ms</td><td style="text-align:center">271ms</td></tr><tr><td>Hive(textfile)</td><td style="text-align:right">1428ms</td><td style="text-align:center">5100ms</td></tr><tr><td>Hive(ORC)</td><td style="text-align:right">110ms</td><td style="text-align:center">126ms</td></tr></tbody></table><p>结果显而易见，当数据达到数百万量级时，Hive在存储模式<strong>较优</strong>的使用方法下已经要比MySQL要稍显胜势了。</p><p>通过以上两点我们不难总结出以下几点：</p><ul><li><p>限制Hive的效率的因素：</p><ul><li><p>数据量</p><p>在百万数据量以下时，Hadoop是很难发挥出其优点的</p></li><li><p>计算框架</p><p>Hive在我们项目中使用的是MapReduce框架来执行分布式计算，然而比现在已经有很多比MapReduce快得多的计算框架例如Spark等，因此若使用这些框架必定会使Hive执行效率更上一层</p></li><li><p>网络通信</p><p>由于我们的集群搭建在虚拟机中，其间数据通过真实的网络通信传输，虽然少了中间光纤传递的过程，但是在建立连接到发送数据到取消连接这一过程所耗费的时间都是很难被忽略的，因此生产环境下的Hadoop集群对网络带宽的要求是很高的</p></li></ul></li><li><p>百万级数据的OLAP场景或者OLTP操作需求较多的场景下，MySQL(关系型数据库)是优选</p></li><li><p>千万乃至亿万级数据的批处理、分析场景，Hive(数据仓库/分布式数据库)在存储、读取、分析效率上都要更优</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云计算期末项目文档&quot;&gt;&lt;a href=&quot;#云计算期末项目文档&quot; class=&quot;headerlink&quot; title=&quot;云计算期末项目文档&quot;&gt;&lt;/a&gt;云计算期末项目文档&lt;/h1&gt;&lt;h2 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Hadoop" scheme="http://blog.guitoubing.top/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://blog.guitoubing.top/tags/Hadoop/"/>
    
      <category term="云计算" scheme="http://blog.guitoubing.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop-Tags</title>
    <link href="http://blog.guitoubing.top/2018/12/12/Hadoop-Tags/"/>
    <id>http://blog.guitoubing.top/2018/12/12/Hadoop-Tags/</id>
    <published>2018-12-11T16:33:02.000Z</published>
    <updated>2019-10-20T08:53:50.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新中……</p></blockquote><a id="more"></a><h1 id="Hadoop-Tags"><a href="#Hadoop-Tags" class="headerlink" title="Hadoop Tags"></a>Hadoop Tags</h1><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ol><li><p>NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等）</p></li><li><p>文件分块默认最小块128M</p></li><li><p><code>jps</code>命令查看NameNode/DataNode是否启动</p><ol><li><del>jps在jdk8u191中好像不适用，暂未找到解决方法</del></li></ol></li><li><p><code>ip:9870</code>利用web界面查看Hadoop节点信息（Mac上端口号为<code>50070</code>）</p></li><li><p>进入用户目录下的<code>.ssh</code>目录，执行<code>ssh-keygen -t rsa</code>创建公钥私钥，使用<code>ssh-copy-id ${hostname}</code>将公钥传给每个节点（NameNode和DataNode都需要）</p></li><li><p>使用<code>hadoop fs -ls /</code>查看Hadoop上所有文件，使用<code>hadoop fs -put ${filename} /</code>上传文件…</p></li><li><p><code>hdfs-site.xml</code>中修改<code>dfs.replication</code>配置可修改文件备份份数（默认为3），修改<code>dfs.namenode.heartbead.recheck-interval</code>指定Hadoop检查机器运行情况的时间间隔（默认3000000ms）</p><p>注意：</p><ol><li>例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的<code>dfs.namenode.heartbead.recheck-interval</code>时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。</li><li>当使用java访问hdfs时，不会使用<code>hdfs-site.xml</code>中的<code>dfs.replication</code>，而会默认使用3，可在java的<code>configuration</code>中配置为指定值</li></ol></li><li><p><code>分鱼展</code>:分块、冗余、可扩展</p></li></ol><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><ol><li><p>ResourceManage</p></li><li><p>NodeManage一般与DataNode放一起 </p></li><li><p>Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用</p></li><li><p><code>yarn-site.xml</code>的配置</p><p><strong>注意：master与slaves都需要进行配置。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>mapred-site.xml</code>的配置</p><p><strong>注意：</strong></p><ul><li>仅NameNode需要配置</li><li>MapReduce不一定需要Yarn</li><li>若不配MapReduce，其会仅在单机跑</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><ol><li><p>创建Hive、Hadoop环境变量，方便敲命令</p></li><li><p>修改<code>hive-site.xml</code></p><ol><li>hive的conf目录下刚初始化时没有hive-site.xml，需要将<code>hive-default.xml.template</code>复制一份更名为hive-site.xml</li><li>将hive-site.xml中所有的(4个)<code>${system:java.io.tmpdir}</code>替换为<code>/usr/local/hive/tmp</code>，将所有的(4个)<code>${system:user.name}</code>替换为<code>root</code></li></ol></li><li><p>进入hive根目录，执行</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">schematool -initSchema -dbType derby</span><br></pre></td></tr></table></figure><ul><li>上述命令执行完毕后会在对应目录下新建metastore_db目录，用于存储数据目录</li><li>derby是hive自带的小数据库，后续需要将derby更换成mysql(TODO)</li></ul></li><li><p>在该目录下启动执行<code>hive</code></p><p><strong>注意：</strong></p><ul><li>hive命令执行时，必须与metastore_db在同一目录下</li><li>hive启动前需要将hdfs也启动，不然会报错</li></ul></li><li><p>hive连接mysql</p><ul><li><p>关于虚拟机安装了mysql数据库，主机无法连接的问题如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select &apos;host&apos; from user where user=&apos;root&apos;</span><br><span class="line">    -&gt; ;</span><br><span class="line">+------+</span><br><span class="line">| host |</span><br><span class="line">+------+</span><br><span class="line">| localhost |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update user set host = &apos;%&apos; where user =&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select &apos;host&apos;   from user where user=&apos;root&apos;;</span><br><span class="line">+------+</span><br><span class="line">| host |</span><br><span class="line">+------+</span><br><span class="line">|  %   |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>解决jdbc连接hive时出现<code>Open Session Error</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hadoop.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>hive表存储格式</p><ol><li>TextFile</li><li>SequenceFile</li><li>RCFile</li><li>ORCFile</li></ol></li></ol><h1 id="HA的实现"><a href="#HA的实现" class="headerlink" title="HA的实现"></a>HA的实现</h1><h2 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h2><ul><li>Hadoop 2.9.2</li><li>Hive 2.3.4</li><li>MySQL 5.7</li><li>Zookeeper 3.4.10</li><li>JDK 8u191</li></ul><h2 id="集群结构图"><a href="#集群结构图" class="headerlink" title="集群结构图"></a>集群结构图</h2><blockquote><p>共9台机器，其中3台ZooKeeper集群，5台Hadoop集群（2台Master，3台Slave），1台应用服务器</p></blockquote><table><thead><tr><th style="text-align:center">主机名</th><th style="text-align:center">IP</th><th style="text-align:center">软件</th><th style="text-align:center">运行进程</th></tr></thead><tbody><tr><td style="text-align:center">node0</td><td style="text-align:center">192.168.137.200</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">node1</td><td style="text-align:center">192.168.137.201</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">node2</td><td style="text-align:center">192.168.137.202</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">QuorumPeerMain</td></tr><tr><td style="text-align:center">master</td><td style="text-align:center">192.168.137.100</td><td style="text-align:center">Hadoop,Hive,MySql</td><td style="text-align:center">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2,MySql</td></tr><tr><td style="text-align:center">master1</td><td style="text-align:center">192.168.137.10</td><td style="text-align:center">Hadoop,Hive</td><td style="text-align:center">JournalNode,NameNode,ResourceManager,<br>DFSZKFailoverController,HiveServer2</td></tr><tr><td style="text-align:center">slave1</td><td style="text-align:center">192.168.137.101</td><td style="text-align:center">Hadoop</td><td style="text-align:center">JournalNode,DataNode,NodeManager</td></tr><tr><td style="text-align:center">slave2</td><td style="text-align:center">192.168.137.102</td><td style="text-align:center">Hadoop</td><td style="text-align:center">DataNode,NodeManager</td></tr><tr><td style="text-align:center">slave3</td><td style="text-align:center">192.168.137.103</td><td style="text-align:center">Hadoop</td><td style="text-align:center">DataNode,NodeManager</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">192.168.137.1</td><td style="text-align:center">应用服务器</td></tr></tbody></table><h2 id="集群启动步骤"><a href="#集群启动步骤" class="headerlink" title="集群启动步骤"></a>集群启动步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 在三台zookeeper上启动zkServer</span><br><span class="line">zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> master上执行hdfs和yarn集群的启动</span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> master1上的ResourceManager不知道为何不会自动启动，因此手动</span><br><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> master和master1上都要启动hiveserver2</span><br><span class="line">hiveserver2</span><br></pre></td></tr></table></figure><h2 id="关于二级缓存的若干事宜"><a href="#关于二级缓存的若干事宜" class="headerlink" title="关于二级缓存的若干事宜"></a>关于<a href="http://www.datanucleus.org/products/accessplatform_3_0/jpa/cache.html" target="_blank" rel="noopener">二级缓存</a>的若干事宜</h2><p>在集群启动完毕之后，我在master的hive中使用<code>create table test(...)</code>语句创建了一个表并导入了一些数据，而后通过应用执行该表的相关查询后，发现时不时提示表<code>test</code>不存在，通过hive查看master和master1的表结构，发现master1中竟然没有表test，查阅资料后看到一篇博文<a href="https://blog.csdn.net/lalaguozhe/article/details/9184593" target="_blank" rel="noopener">《hive datanucleus cache 不一致问题》</a>，是关于hive中的DataNucleus二级缓存的设置，<code>datanucleus.cache.level2.type</code>的设置(<code>none</code>,<code>soft</code>,<code>weak</code>)直接影响二级缓存是否启用，关于二级缓存的具体机制我还没弄清楚，之后我又在<a href="https://docs.hortonworks.com/HDPDocuments/HDP2/HDP-2.6.5/bk_command-line-installation/content/set_up_hive_hcat_configuration_files.html" target="_blank" rel="noopener">Hortonworks</a>的文档中看到下面的话：</p><blockquote><p><strong>Important</strong>:<br>Hortonworks recommends that deployments <font color="red"><strong>disable the DataNucleus cache</strong></font> by setting the value of the datanucleus.cache.level2.type configuration parameter to none. The datanucleus.cache.level2 configuration parameter is ignored, and assigning a value of none to this parameter does not have the desired effect.</p></blockquote><p>可能是Hiveserver2本身在HA的层面就不建议修改库、表结构，因此若要更改表结构或者创建新表同时实现数据同步，我试了以下两种方式均可实现：</p><ol><li><p>第一种关闭并重新初始化集群，启动master和所有的DataNode，在master上执行建库建表导入数据，而后启动master1将其作为standby初始化，这时master1会同步master的数据，最后启动master和master1的hiveserver2</p></li><li><p>第二种是同时在master和master1的hive客户端上执行同样的建表语句，而后在master(或者master1)上执行<code>load</code>命令加载数据，即可同步数据</p><blockquote><p>第二种方法又出现了个有趣的问题：导入数据完成后，在两台机器上分别执行<code>count</code>操作会发现由于加载数据的机器count正常，另一台机器count结果为0，但是执行<code>select *</code>又确实能发现数据存在，就很玄学。</p></blockquote></li></ol><h1 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h1><ul><li>安全与权限（kerberos）</li><li>Secondary NameNode（check point NameNode）</li><li>HA（High Ability）实现</li><li>Federation，超大规模数据中心</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更新中……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="http://blog.guitoubing.top/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://blog.guitoubing.top/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>内存数据库 - Best Practice</title>
    <link href="http://blog.guitoubing.top/2018/11/24/Practice/"/>
    <id>http://blog.guitoubing.top/2018/11/24/Practice/</id>
    <published>2018-11-24T06:18:44.000Z</published>
    <updated>2019-10-20T08:54:12.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Oracle专家的三次授课。</p></blockquote><a id="more"></a><h1 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h1><h2 id="创建用户并分配权限"><a href="#创建用户并分配权限" class="headerlink" title="创建用户并分配权限"></a>创建用户并分配权限</h2><h3 id="创建测试schema，命名为test"><a href="#创建测试schema，命名为test" class="headerlink" title="创建测试schema，命名为test"></a>创建测试schema，命名为test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user test identified by test;</span><br></pre></td></tr></table></figure><h3 id="分配连接资源"><a href="#分配连接资源" class="headerlink" title="分配连接资源"></a>分配连接资源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant connect,resource to test;</span><br><span class="line">grant execute on dbms_lock to test;</span><br><span class="line">grant execute on UTL_FILE to test;</span><br></pre></td></tr></table></figure><h3 id="为test用户创建external-data目录以及分配权限"><a href="#为test用户创建external-data目录以及分配权限" class="headerlink" title="为test用户创建external_data目录以及分配权限"></a>为test用户创建external_data目录以及分配权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create directory external_data as &apos;/home/oracle/data&apos;;</span><br><span class="line">grant read,write on directory external_data to test;</span><br></pre></td></tr></table></figure><blockquote><p>要注意oracle用户必须拥有对这里的external_data路径读写的权限。</p></blockquote><h3 id="分配表空间权限"><a href="#分配表空间权限" class="headerlink" title="分配表空间权限"></a>分配表空间权限</h3><p>我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间：</p><ul><li><strong>SYSTEM</strong> - 存储数据字典</li><li><strong>SYSAUX</strong> - 存储辅助应用程序的数据</li><li><strong>TEMP</strong> - 存储数据库临时对象</li><li><strong>USERS</strong> - 存储各个用户创建的对象</li><li><strong>UNDOTBS</strong> - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询</li><li>……</li></ul><p>而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- DBA下执行：</span><br><span class="line">-- 查看数据库中的所有表空间</span><br><span class="line">select * from v$tablespace;</span><br><span class="line">-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)</span><br><span class="line">select username,default_tablespace from dba_users where username=&apos;TEST&apos;;</span><br><span class="line">-- 为用户赋予当前表空间下的权限</span><br><span class="line">alter user test quota unlimited on users;</span><br><span class="line">--  或者制定用户可用大小：</span><br><span class="line">alter user test quota 50M on users;</span><br></pre></td></tr></table></figure><h2 id="连接用户，建表，跑存储过程和函数"><a href="#连接用户，建表，跑存储过程和函数" class="headerlink" title="连接用户，建表，跑存储过程和函数"></a>连接用户，建表，跑存储过程和函数</h2><h3 id="连接test用户"><a href="#连接test用户" class="headerlink" title="连接test用户"></a>连接test用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 在系统命令下连接</span><br><span class="line">cd $ORACLE_HOME/bin</span><br><span class="line">./sqlplus test/test</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在进入sqlplus后的连接</span><br><span class="line">conn test/test</span><br></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_ID IS &apos;主键&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS &apos;手机号段&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_CITY IS &apos;城市&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS &apos;固话区号&apos;;</span><br><span class="line">COMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS &apos;邮政编码&apos;;</span><br><span class="line">COMMENT ON TABLE T_MOBILES  IS &apos;号段表&apos;;</span><br><span class="line"></span><br><span class="line">create table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);</span><br><span class="line">--*注：因f_id导入时缺少数据，所有先不设置为PK.</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_ID IS &apos;主键&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_NO IS &apos;通话号码&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS &apos;开始时间&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_END_TIME IS &apos;结束时间&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_DURATION IS &apos;通话时长&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_PROVINCE IS &apos;省份地区&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_PLATFORM IS &apos;运营商&apos;;</span><br><span class="line">COMMENT ON COLUMN T_RECORDS.F_MOBILE IS &apos;手机号码标志&apos;;</span><br><span class="line">COMMENT ON TABLE T_RECORDS  IS &apos;通话清单表&apos;;</span><br></pre></td></tr></table></figure><h3 id="创建ctl文件导入csv数据"><a href="#创建ctl文件导入csv数据" class="headerlink" title="创建ctl文件导入csv数据"></a>创建ctl文件导入csv数据</h3><p>进入<code>external_data</code>路径下并创建以下文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/oracle/data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi control_mobiles.ctl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi control_records.ctl</span></span><br></pre></td></tr></table></figure><p><code>control_mobiles.ctl:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA</span><br><span class="line">CHARACTERSET UTF8</span><br><span class="line">INFILE &apos;/home/oracle/data/mobiles.csv&apos;</span><br><span class="line">TRUNCATE INTO TABLE t_mobiles</span><br><span class="line">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">TRAILING NULLCOLS</span><br><span class="line">(</span><br><span class="line">F_ID,</span><br><span class="line">F_MOBILE_HEAD,</span><br><span class="line">F_PROVINCE,</span><br><span class="line">F_CITY,</span><br><span class="line">F_PLATFORM,</span><br><span class="line">F_TEL_HEAD,</span><br><span class="line">F_ZIPCODE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>control_records.ctl:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA</span><br><span class="line">CHARACTERSET UTF8</span><br><span class="line">INFILE &apos;/home/oracle/data/records.csv&apos;</span><br><span class="line">TRUNCATE INTO TABLE t_records</span><br><span class="line">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">TRAILING NULLCOLS</span><br><span class="line">(</span><br><span class="line">F_NO,</span><br><span class="line">F_BEGIN_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class="line">F_END_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;,</span><br><span class="line">F_DURATION INTEGER EXTERNAL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在该路径下执行导入操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="variable">$ORACLE_HOME</span>/bin/sqlldr userid=<span class="built_in">test</span>/<span class="built_in">test</span> control=control_mobiles.ctl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="variable">$ORACLE_HOME</span>/bin/sqlldr userid=<span class="built_in">test</span>/<span class="built_in">test</span> control=control_records.ctl</span></span><br></pre></td></tr></table></figure><blockquote><p>教程中命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ sqlldr userid=<span class="built_in">test</span>/<span class="built_in">test</span>@orcl control=control_mobiles.ctl</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即在导入时指定<code>连接字符串</code>（这里的orcl实际上是连接字符串的别名），其在<code>$ORACLE_HOME/network/admin/tnsname.ora</code>中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。</p><p>既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是<code>连接字符串</code>和<code>服务名</code>的区别，oracle有个默认服务名<code>XE</code>，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; jdbc:oracle:thin:@localhost:1521:XE</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 命令格式：sqlplus username/password@host:port/service_name</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键</span><br><span class="line">create sequence seq_records increment by 1 start with 1 ;</span><br><span class="line"></span><br><span class="line">-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键</span><br><span class="line">update t_records set f_id=seq_records.nextval;</span><br><span class="line">alter table t_records add constraint t_records_pk primary key (f_id);</span><br><span class="line"></span><br><span class="line">-- 3、创建并初始化同步锁表，用于多线程同步控制</span><br><span class="line">CREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));</span><br><span class="line">COMMENT ON COLUMN T_LOCK.F_NAME IS &apos;锁名&apos;;</span><br><span class="line">COMMENT ON COLUMN T_LOCK.F_INDEX IS &apos;锁的当前值&apos;;</span><br><span class="line">COMMENT ON TABLE T_LOCK  IS &apos;同步锁表&apos;;</span><br><span class="line">insert into T_LOCK values(&apos;_RECORD_INDEX&apos;,0);</span><br><span class="line"></span><br><span class="line">-- 4、在电话号段表中创建唯一性索引，提高号段检索速度</span><br><span class="line">create unique index uniq_mobile_head on t_mobiles(f_mobile_head);</span><br><span class="line">update t_mobiles set f_province = &apos;内蒙古&apos; where f_province = &apos;内蒙&apos;;</span><br><span class="line"></span><br><span class="line">-- 5、创建日志表，用于记录程序执行过程中的日志信息。</span><br><span class="line">create table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));</span><br><span class="line">COMMENT ON COLUMN T_LOG.F_TIME IS &apos;日志时间&apos;;</span><br><span class="line">COMMENT ON COLUMN T_LOG.F_HEAD IS &apos;日志类型标志&apos;;</span><br><span class="line">COMMENT ON COLUMN T_LOG.F_CONTENT IS &apos;日志内容&apos;;</span><br><span class="line">COMMENT ON TABLE T_LOG  IS &apos;日志表&apos;;</span><br></pre></td></tr></table></figure><h2 id="创建函数和存储过程"><a href="#创建函数和存储过程" class="headerlink" title="创建函数和存储过程"></a>创建函数和存储过程</h2><h3 id="声明函数和存储过程"><a href="#声明函数和存储过程" class="headerlink" title="声明函数和存储过程"></a>声明函数和存储过程</h3><ul><li>函数is_mobile，判断通话号码是否为手机号码</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--函数：判断通话号码是否为手机号码</span><br><span class="line">CREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2)</span><br><span class="line">    RETURN BOOLEAN IS</span><br><span class="line"></span><br><span class="line">    v_phone VARCHAR2(20);</span><br><span class="line">    v_head VARCHAR2(2);</span><br><span class="line">BEGIN</span><br><span class="line">    --检查参数func</span><br><span class="line">    IF phone IS NULL THEN</span><br><span class="line">        RETURN FALSE;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">--去除前后空格</span><br><span class="line">    v_phone := TRIM(phone);</span><br><span class="line"></span><br><span class="line">--去除号码前面的0</span><br><span class="line">    IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class="line">        v_phone := substr(v_phone, 2);</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">--检查手机号码长度</span><br><span class="line">    IF substr(v_phone,0,1) &lt;&gt; &apos;1&apos; OR LENGTH(v_phone) &lt;&gt; 11 THEN</span><br><span class="line">        RETURN FALSE;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">--截取号码前两位</span><br><span class="line">    v_head := substr(v_phone,1,2);</span><br><span class="line"></span><br><span class="line">    IF v_head = &apos;13&apos; OR v_head = &apos;14&apos; OR v_head =&apos;15&apos; OR v_head =&apos;17&apos; OR v_head = &apos;18&apos; THEN</span><br><span class="line">        RETURN TRUE;</span><br><span class="line">    ELSE</span><br><span class="line">        RETURN FALSE;</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程init，清空t_log，同时t_lock置零</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程：初始化测试数据</span><br><span class="line">CREATE OR REPLACE PROCEDURE init IS</span><br><span class="line">    CURSOR job_cursor IS SELECT JOB FROM user_jobs;</span><br><span class="line">BEGIN</span><br><span class="line">--重置处理位置为0</span><br><span class="line">    EXECUTE IMMEDIATE &apos;update t_lock set f_index=0&apos;;</span><br><span class="line"></span><br><span class="line">--清除日志表中的记录</span><br><span class="line">    EXECUTE IMMEDIATE &apos;truncate table t_log&apos;;</span><br><span class="line"></span><br><span class="line">--重置话单表中的记录</span><br><span class="line">    EXECUTE IMMEDIATE &apos;update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1&apos;;</span><br><span class="line">    COMMIT;</span><br><span class="line"></span><br><span class="line">    FOR tmp_job IN job_cursor LOOP</span><br><span class="line">        dbms_job.broken(tmp_job.JOB,TRUE,sysdate);</span><br><span class="line">        dbms_job.REMOVE(tmp_job.JOB);</span><br><span class="line">    END LOOP;</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程print，打印日志，存到T_LOG表中</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程：打印日志</span><br><span class="line">CREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) IS</span><br><span class="line">BEGIN</span><br><span class="line">--dbms_output.put_line(to_char(&apos;yyyy-mm-dd hh24:mi:ss&apos;)||&apos;,&apos;||prefix||&apos;,&apos;||content);</span><br><span class="line">INSERT INTO t_log VALUES(sysdate,prefix, content);</span><br><span class="line">COMMIT;</span><br><span class="line">EXCEPTION</span><br><span class="line">WHEN OTHERS THEN</span><br><span class="line">dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class="line">dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程show，显示当前处理情况</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程：显示当前处理情况</span><br><span class="line">CREATE OR REPLACE PROCEDURE show IS</span><br><span class="line">--待处理记录总数</span><br><span class="line">    v_record_count NUMBER;</span><br><span class="line"></span><br><span class="line">--当前日志表记录总数</span><br><span class="line">    v_log_count NUMBER;</span><br><span class="line"></span><br><span class="line">--当前数据处理位置</span><br><span class="line">    v_current_index NUMBER;</span><br><span class="line"></span><br><span class="line">--用户Job表游标</span><br><span class="line">    CURSOR job_cursor IS SELECT * FROM user_jobs;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">    SELECT COUNT(1) INTO v_log_count FROM t_log;</span><br><span class="line">    SELECT f_index INTO v_current_index FROM t_lock;</span><br><span class="line">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(&apos;log count: &apos;||v_log_count);</span><br><span class="line">    dbms_output.put_line(&apos;record count: &apos;||v_record_count);</span><br><span class="line">    dbms_output.put_line(&apos;current index: &apos;||v_current_index);</span><br><span class="line"></span><br><span class="line">--清除用户job记录</span><br><span class="line">    FOR tmp_job IN job_cursor LOOP</span><br><span class="line">        dbms_output.put_line(&apos;job:&apos;||tmp_job.JOB||&apos;,broken:&apos;||tmp_job.broken||&apos;,total_time:&apos;||tmp_job.total_time||&apos;,failures:&apos;||tmp_job.failures||&apos;,interval:&apos;||tmp_job.INTERVAL||&apos;,last_sec:&apos;||tmp_job.last_sec||&apos;,next_sec:&apos;||tmp_job.next_sec);</span><br><span class="line"></span><br><span class="line">    END LOOP;</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程process_data，提交一个job处理数据</li></ul><blockquote><p><strong>共享锁和排它锁:</strong></p><ul><li><p>当某事务对数据添加共享锁时，此时该事务<code>只能读不能写</code>，其他事务只能对该数据添加共享锁，而不能添加排它锁</p></li><li><p>当某事务对数据添加排它锁时，此时该事务<code>既能读又能写</code>，其他事务不能对该数据添加任何锁</p></li></ul><p><strong>autocommit需要关掉:</strong></p><p>假设现在有三个job对T_LOCK表进行并发读写，如下：</p><p><img src="/images/image-20181124202306595.png" alt="image-20181124202306595"></p><p>步骤如下：</p><p><img src="/images/锁.png" alt="锁"></p><p>阻塞情况：</p><p><img src="/images/锁2.png" alt="锁2"></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程：处理数据</span><br><span class="line">CREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS</span><br><span class="line">    --定义常量</span><br><span class="line">    c_record_index CONSTANT VARCHAR2(20)   :=&apos;_RECORD_INDEX&apos;;</span><br><span class="line">    c_process_prefix CONSTANT VARCHAR2(20) := &apos;[  PROCESS ]&apos;;</span><br><span class="line">    c_select_record_sql VARCHAR2(100)  := &apos;select * from t_records where f_id &gt;= :x and f_id &lt;= :y&apos;;</span><br><span class="line">    c_select_mobile_sql VARCHAR2(100)  := &apos;select * from t_mobiles where f_mobile_head = :x&apos;;</span><br><span class="line">    c_update_mobile_sql VARCHAR2(100)  := &apos;update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z&apos;;</span><br><span class="line">    c_update_record_sql VARCHAR2(100)  := &apos;update t_records set f_mobile = 0 where f_id = :n&apos;;</span><br><span class="line">    v_record_count NUMBER;</span><br><span class="line">    v_current_index NUMBER;</span><br><span class="line">    v_begin_index NUMBER;</span><br><span class="line">    v_end_index NUMBER;</span><br><span class="line">    v_id NUMBER;</span><br><span class="line">    v_phone VARCHAR2(20);</span><br><span class="line">    v_province VARCHAR2(20);</span><br><span class="line">    v_platform VARCHAR2(20);</span><br><span class="line">    --定义动态游标</span><br><span class="line">    TYPE ty_record_cursor IS REF CURSOR;</span><br><span class="line">    record_cursor ty_record_cursor;</span><br><span class="line">    mobile_cursor ty_record_cursor;</span><br><span class="line">    v_record_row t_records%rowtype;</span><br><span class="line">    v_mobile_row t_mobiles%rowtype;</span><br><span class="line">BEGIN</span><br><span class="line">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], running...&apos;);</span><br><span class="line">    --获取待处理的记录总数</span><br><span class="line">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class="line">    PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], records count: &apos;||v_record_count);</span><br><span class="line">    LOOP</span><br><span class="line">        --获取记录锁</span><br><span class="line">        SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE;</span><br><span class="line">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], current index: &apos;||v_current_index);</span><br><span class="line">        IF v_current_index = v_record_count THEN</span><br><span class="line">            PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], finished.&apos;);</span><br><span class="line">            EXIT;</span><br><span class="line">        END IF;</span><br><span class="line">        --记录本次处理的开始和结束记录位置</span><br><span class="line">        v_end_index := v_current_index + batch_size;</span><br><span class="line">        IF v_end_index &gt; v_record_count THEN</span><br><span class="line">            v_end_index := v_record_count;</span><br><span class="line">        END IF;</span><br><span class="line">        --提交事务，释放锁</span><br><span class="line">        UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index;</span><br><span class="line">        COMMIT;</span><br><span class="line">        --计算开始位置</span><br><span class="line">        v_begin_index := v_current_index +1;</span><br><span class="line">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], begin index:&apos;||v_begin_index||&apos;, end index:&apos;||v_end_index);</span><br><span class="line">        --test：dbms_lock.sleep(5);</span><br><span class="line">        --查询一批记录进行逐个处理</span><br><span class="line">        OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index;</span><br><span class="line">        LOOP</span><br><span class="line">            FETCH record_cursor INTO v_record_row;</span><br><span class="line">            EXIT WHEN record_cursor%notfound;</span><br><span class="line">            v_id    := v_record_row.f_id;</span><br><span class="line">            v_phone := v_record_row.f_no;</span><br><span class="line">            IF is_mobile(v_phone) THEN</span><br><span class="line">                v_phone := TRIM(v_phone);</span><br><span class="line">                IF substr(v_phone,0,1) = &apos;0&apos; THEN</span><br><span class="line">                    v_phone := substr(v_phone, 2);</span><br><span class="line">                END IF;</span><br><span class="line">                --PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], id:&apos;||v_id||&apos;, phone:&apos;||v_phone);</span><br><span class="line">                --更新话单记录中的省份、运营商以及手机类型标志</span><br><span class="line">                OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7);</span><br><span class="line">                    FETCH mobile_cursor INTO v_mobile_row;</span><br><span class="line">                    v_province := v_mobile_row.f_province;</span><br><span class="line">                    v_platform := v_mobile_row.f_platform;</span><br><span class="line">                    --FETCH mobile_cursor INTO v_province, v_platform;</span><br><span class="line">                CLOSE mobile_cursor;</span><br><span class="line">--更新话单记录的运营商、省份地区信息</span><br><span class="line">                EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id;</span><br><span class="line">            ELSE</span><br><span class="line">                --更新话单记录为非移动号码类型</span><br><span class="line">                EXECUTE IMMEDIATE c_update_record_sql USING v_id;</span><br><span class="line">            END IF;</span><br><span class="line">--提交事务</span><br><span class="line">            COMMIT;</span><br><span class="line">        END LOOP;</span><br><span class="line">        CLOSE record_cursor;</span><br><span class="line">        PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], processed index: &apos;||v_end_index);</span><br><span class="line">    END LOOP;</span><br><span class="line">EXCEPTION</span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class="line">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程generate_csv_report，生成报表</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程：生成报表</span><br><span class="line">CREATE OR REPLACE PROCEDURE generate_csv_report IS</span><br><span class="line">c_report_prefix CONSTANT VARCHAR2(20) := &apos;[  REPORT  ]&apos;;</span><br><span class="line">    v_report_1  UTL_FILE.FILE_TYPE;</span><br><span class="line">    v_report_2  UTL_FILE.FILE_TYPE;</span><br><span class="line">    CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC;</span><br><span class="line">    cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;</span><br><span class="line">BEGIN</span><br><span class="line">    --生成报表1，根据运营商分类汇总各省份地区的通话量</span><br><span class="line">    v_report_1 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report1.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class="line">    FOR cur_tmp IN report_1_cursor LOOP</span><br><span class="line">        UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || &apos;,&apos; || cur_tmp.f_province || &apos;,&apos; || cur_tmp.total);</span><br><span class="line">    END LOOP;</span><br><span class="line">    UTL_FILE.FCLOSE(v_report_1);</span><br><span class="line">    --生成报表2，根据各省份地区汇总各运营商的通话量</span><br><span class="line">    v_report_2 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report2.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767);</span><br><span class="line">    FOR cur_tmp IN report_2_cursor LOOP</span><br><span class="line">        UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || &apos;,&apos; || cur_tmp.f_platform || &apos;,&apos; ||  cur_tmp.total);</span><br><span class="line">    END LOOP;</span><br><span class="line">    UTL_FILE.FCLOSE(v_report_2);</span><br><span class="line">    PRINT(c_report_prefix, &apos;generated reports.&apos;);</span><br><span class="line">    EXCEPTION</span><br><span class="line">        WHEN OTHERS THEN</span><br><span class="line">            dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class="line">            dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量</li></ul><blockquote><p><strong><a href="https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_job.htm#BABHCBFD" target="_blank" rel="noopener">dbms_job</a>:</strong></p><p>用于管理job的package</p><p><strong>oracle限定的job_queue_processes:</strong></p><p>oracle中有一个对任务可启动进程的数量进行限制的参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SQL&gt; show parameter job_queue_processes;</span><br><span class="line">&gt; NAME     TYPE VALUE</span><br><span class="line">&gt; ----------------------------------------------------------</span><br><span class="line">&gt; job_queue_processeses integer 10</span><br><span class="line">&gt;</span><br><span class="line">&gt; SQL&gt; alter system set job_queue_processes=0...1000;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>使用ctrl+c是无法停止job的:</strong></p><p>可使用<code>top</code>命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS</span><br><span class="line">    --定义常量</span><br><span class="line">    c_record_index CONSTANT VARCHAR2(20):=&apos;_RECORD_INDEX&apos;;</span><br><span class="line">  c_analysis_prefix CONSTANT VARCHAR2(20):= &apos;[ ANALYSIS ]&apos;;</span><br><span class="line">    --当前处理位置</span><br><span class="line">    v_record_index NUMBER;</span><br><span class="line">    --待处理的记录总数</span><br><span class="line">    v_record_count NUMBER;</span><br><span class="line">    --保存临时创建的job no</span><br><span class="line">    v_tmp_jobno NUMBER;</span><br><span class="line">    --开始结束时间</span><br><span class="line">    v_begin_time NUMBER;</span><br><span class="line">    v_process_end_time NUMBER;</span><br><span class="line">    v_analysis_end_time NUMBER;</span><br><span class="line">    --异常变量</span><br><span class="line">    e_invalid_input EXCEPTION;</span><br><span class="line">BEGIN</span><br><span class="line">    PRINT(c_analysis_prefix, &apos; start analysis...&apos;);</span><br><span class="line">    --输入参数检查</span><br><span class="line">    IF job_count &lt; 1 OR batch_size&lt;1 THEN</span><br><span class="line">        RAISE e_invalid_input;</span><br><span class="line">    END IF;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos; checked input parameters.&apos;);</span><br><span class="line">    --记录开始时间</span><br><span class="line">    v_begin_time := dbms_utility.get_time;</span><br><span class="line">    --获取待处理的记录总数</span><br><span class="line">    SELECT COUNT(1) INTO v_record_count FROM t_records;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos; records count: &apos;||v_record_count);</span><br><span class="line">    --开始计算重置为0</span><br><span class="line">    UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index;</span><br><span class="line">    COMMIT;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos; reset index to zero.&apos;);</span><br><span class="line">    --提交多个job</span><br><span class="line">    FOR I IN 1.. job_count LOOP</span><br><span class="line">        dbms_job.submit(v_tmp_jobno,&apos;begin process_data(&apos;||I||&apos;,&apos;||batch_size||&apos;); end;&apos;);</span><br><span class="line">        PRINT(c_analysis_prefix, &apos; submitted new job, no: &apos;||v_tmp_jobno);</span><br><span class="line">    END LOOP;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos; created &apos;||job_count||&apos; jobs.&apos;);</span><br><span class="line">    --定时检查处理进度</span><br><span class="line">    LOOP</span><br><span class="line">        SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index;</span><br><span class="line">        PRINT(c_analysis_prefix, &apos; current index: &apos;||v_record_index);</span><br><span class="line">        IF v_record_index = v_record_count THEN</span><br><span class="line">            PRINT(c_analysis_prefix, &apos; processed all records, exiting...&apos;);</span><br><span class="line">            EXIT;</span><br><span class="line">        ELSE</span><br><span class="line">            dbms_lock.sleep(5);--暂停等待5秒</span><br><span class="line">        END IF;</span><br><span class="line">    END LOOP;</span><br><span class="line">    v_process_end_time := dbms_utility.get_time;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class="line">    dbms_output.put_line(&apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;);</span><br><span class="line">    --分类汇总产生报表</span><br><span class="line">    generate_csv_report;</span><br><span class="line">    --结束时间</span><br><span class="line">    v_analysis_end_time := dbms_utility.get_time;</span><br><span class="line">    PRINT(c_analysis_prefix, &apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class="line">    dbms_output.put_line(&apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);</span><br><span class="line">--异常捕获部分</span><br><span class="line">EXCEPTION</span><br><span class="line">    WHEN e_invalid_input THEN</span><br><span class="line">        dbms_output.put_line(&apos;Invalid input values, job_count:&apos;||job_count||&apos;, batch_size:&apos;||batch_size);</span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line">        dbms_output.put_line(&apos;Error code: &apos;||SQLCODE);</span><br><span class="line">        dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ul><li>存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 调用多次analysis，指定不同的job数和批数</span><br><span class="line">create or replace procedure mul_analysis is</span><br><span class="line">    -- 最小job数</span><br><span class="line">    v_begin_job_no NUMBER := 3;</span><br><span class="line">    -- 最大job数</span><br><span class="line">    v_end_job_no NUMBER := 8;</span><br><span class="line">    -- 每次增长的batch数量</span><br><span class="line">    v_range NUMBER := 2000;</span><br><span class="line">    -- 最小batch数量</span><br><span class="line">    v_begin_range NUMBER := 1000;</span><br><span class="line">    -- 最大batch数量</span><br><span class="line">    v_end_range NUMBER := 10000;</span><br><span class="line">    -- 当前range</span><br><span class="line">    range NUMBER;</span><br><span class="line">    begin</span><br><span class="line">        for I in v_begin_job_no..v_end_job_no LOOP</span><br><span class="line">            range := v_begin_range;</span><br><span class="line">            LOOP</span><br><span class="line">                -- 清洗表</span><br><span class="line">                init();</span><br><span class="line">                -- 分析</span><br><span class="line">                analysis(I, range);</span><br><span class="line">                range := range+v_range;</span><br><span class="line">-- range增长到10000则停止</span><br><span class="line">                if range &gt; v_end_range then</span><br><span class="line">                    exit;</span><br><span class="line">                end if;</span><br><span class="line">            end loop;</span><br><span class="line">        end loop;</span><br><span class="line">    end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="执行函数和存储过程"><a href="#执行函数和存储过程" class="headerlink" title="执行函数和存储过程"></a>执行函数和存储过程</h3><blockquote><p>在sqlplus中执行函数和存储过程之前需先打开serveroutput，即：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SQL&gt; set serveroutput on;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这是因为存储过程中用到了<code>dbms_output.put_line</code>，上述语句是相当于告诉pl/sql引擎将<code>dbms_output.put_line</code>传递到缓冲区的内容输出到主控制台上。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call init();</span><br><span class="line">call analysis(4,1000);</span><br></pre></td></tr></table></figure><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>通过执行<code>mul_analysis()</code>对一系列job和batch组合值进行测试，结果如下：</p><p><img src="/images/image-20181124205409162.png" alt="image-20181124205409162"></p><h1 id="Lesson-2"><a href="#Lesson-2" class="headerlink" title="Lesson 2"></a>Lesson 2</h1><h2 id="创建用户并分配权限-1"><a href="#创建用户并分配权限-1" class="headerlink" title="创建用户并分配权限"></a>创建用户并分配权限</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user audittest identified by audittest;</span><br></pre></td></tr></table></figure><h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant connect,resource to audittest;</span><br><span class="line">grant execute on dbms_lock to audittest;</span><br><span class="line">alter user audittest quota unlimited on users;</span><br><span class="line">conn audittest/audittest;</span><br></pre></td></tr></table></figure><h2 id="创建表及其他对象"><a href="#创建表及其他对象" class="headerlink" title="创建表及其他对象"></a>创建表及其他对象</h2><h3 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h3><blockquote><p>注意：</p><p>这里在创建表时添加了<code>ENABLE</code>限制条件，oracle中对表和列的约束有<code>Enable</code>/<code>Disable</code>(启用/禁用)和<code>Validate</code>/<code>NoValidate</code>(验证/不验证)</p><p>举两个例子：</p><p><strong>需更改的错误：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; -- 创建表，对name字段添加唯一性约束</span><br><span class="line">&gt; drop table T_TEST;</span><br><span class="line">&gt; create table T_TEST(</span><br><span class="line">&gt;   id int primary key ,</span><br><span class="line">&gt;   name varchar2(10) constraint unique_name unique disable</span><br><span class="line">&gt; );</span><br><span class="line">&gt; -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错</span><br><span class="line">&gt; begin</span><br><span class="line">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class="line">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class="line">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class="line">&gt; end;</span><br><span class="line">&gt; select * from T_TEST;</span><br><span class="line">&gt; -- 修改掉违反唯一性约束的值</span><br><span class="line">&gt; update T_TEST set name=&apos;chen&apos; where id=3;</span><br><span class="line">&gt; -- 使得唯一性约束生效</span><br><span class="line">&gt; alter table T_TEST modify constraint unique_name enable;</span><br><span class="line">&gt; select * from T_TEST;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>需保留的错误：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; -- 创建表，无约束</span><br><span class="line">&gt; drop table T_TEST;</span><br><span class="line">&gt; create table T_TEST(</span><br><span class="line">&gt;   id int primary key ,</span><br><span class="line">&gt;   name varchar2(10)</span><br><span class="line">&gt; );</span><br><span class="line">&gt; -- 一些old的记录本身可能存在重复数据</span><br><span class="line">&gt; begin</span><br><span class="line">&gt;   insert into T_TEST values (1, &apos;tan&apos;);</span><br><span class="line">&gt;   insert into T_TEST values (2, &apos;rui&apos;);</span><br><span class="line">&gt;   insert into T_TEST values (3, &apos;tan&apos;);</span><br><span class="line">&gt; end;</span><br><span class="line">&gt; select * from T_TEST;</span><br><span class="line">&gt; -- 对name列创建非唯一性索引</span><br><span class="line">&gt; create index i_name on T_TEST(name);</span><br><span class="line">&gt; -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引</span><br><span class="line">&gt; alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;</span><br><span class="line">&gt; -- 此时无法插入name相同的数据了</span><br><span class="line">&gt; insert into T_TEST values (4, &apos;tan&apos;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--部门表</span><br><span class="line">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class="line">&quot;F_MANAGER&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line"> CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_CODE&quot; IS &apos;部门编号&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_MANAGER&quot; IS &apos;部门经理&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class="line"></span><br><span class="line">--用户表</span><br><span class="line">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CODE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class="line">&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line"> CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_CODE&quot; IS &apos;员工编号&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_TELEPHONE&quot; IS &apos;固话&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class="line"></span><br><span class="line">--客户信息表</span><br><span class="line">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class="line">&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class="line">&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class="line">&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class="line">&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line">&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class="line"> PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class="line">&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_CITY&quot; VARCHAR2(45 BYTE),</span><br><span class="line">&quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE,</span><br><span class="line">&quot;F_PARTNER&quot; VARCHAR2(45 BYTE),</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE,</span><br><span class="line">&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line">&quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE,</span><br><span class="line"> CONSTRAINT &quot;T_CUSTOMER_HISTORY_PK&quot; PRIMARY KEY (&quot;F_ID&quot;, &quot;F_VERSION&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">--客户信息历史表</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;  IS &apos;客户信息历史表&apos;;</span><br><span class="line"></span><br><span class="line">--审计表</span><br><span class="line">CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_TABLE_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_ROW_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NEW_VERSION&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_COLUMN_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_OLD_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_NEW_VALUE&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_OPERATOR_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_OPERATION_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line"> CONSTRAINT &quot;T_AUDIT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_TABLE_NAME&quot; IS &apos;表名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ROW_ID&quot; IS &apos;业务数据主键&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VERSION&quot; IS &apos;新的版本号&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_COLUMN_NAME&quot; IS &apos;字段&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OLD_VALUE&quot; IS &apos;原值&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VALUE&quot; IS &apos;新值&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATOR_ID&quot; IS &apos;操作用户&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATION_TIME&quot; IS &apos;操作时间&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;  IS &apos;审计表&apos;;</span><br></pre></td></tr></table></figure><h3 id="创建索引、序列"><a href="#创建索引、序列" class="headerlink" title="创建索引、序列"></a>创建索引、序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建复合索引</span><br><span class="line">CREATE INDEX &quot;AUDITTEST&quot;.&quot;IDX_TABLE_ROWID&quot; ON &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot; (&quot;F_TABLE_NAME&quot;, &quot;F_ROW_ID&quot;) ;</span><br><span class="line">-- 创建序列</span><br><span class="line">CREATE SEQUENCE  SEQ_AUDIT_PK  INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建触发器</span><br><span class="line">create or replace trigger trg_customer_audit</span><br><span class="line">before update on t_customer</span><br><span class="line">for each row</span><br><span class="line">declare</span><br><span class="line">    c_insert_sql constant varchar2(100) := &apos;insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)&apos;;</span><br><span class="line">    c_table_name constant varchar2(20)  := &apos;T_CUSTOMER&apos;;</span><br><span class="line">    v_column_name varchar2(20);</span><br><span class="line">begin</span><br><span class="line">    --记录当前数据到历史表</span><br><span class="line">    insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version);</span><br><span class="line"></span><br><span class="line">    --递增记录的版本号</span><br><span class="line">    :new.f_version := :old.f_version+1;</span><br><span class="line"></span><br><span class="line">    --判断字段变化</span><br><span class="line">    if updating(&apos;F_LINKMAN&apos;) then</span><br><span class="line">        v_column_name := &apos;联系人&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    if updating(&apos;F_MOBILE&apos;) then</span><br><span class="line">        v_column_name := &apos;手机号码&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    if updating(&apos;F_TELEPHONE&apos;) then</span><br><span class="line">        v_column_name := &apos;固定电话&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    if updating(&apos;F_EMAIL&apos;) then</span><br><span class="line">        v_column_name := &apos;电子邮箱&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    if updating(&apos;F_ADDRESS&apos;) then</span><br><span class="line">        v_column_name := &apos;联系地址&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    if updating(&apos;F_BALANCE&apos;) then</span><br><span class="line">        v_column_name := &apos;余额&apos;;</span><br><span class="line">        execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id;</span><br><span class="line">    end if;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--创建过程</span><br><span class="line">--过程：重设序列值</span><br><span class="line">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class="line">IS</span><br><span class="line">    v_val NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><h4 id="过程reset-seq"><a href="#过程reset-seq" class="headerlink" title="过程reset_seq"></a>过程reset_seq</h4><blockquote><p>将序列为输入参数seq_name的值重置</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--过程：重设序列值</span><br><span class="line">create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )</span><br><span class="line">IS</span><br><span class="line">    v_val NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val;</span><br><span class="line"></span><br><span class="line">    EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="过程init"><a href="#过程init" class="headerlink" title="过程init"></a>过程init</h4><blockquote><p>truncate(截断)所有表，重设序列，并添加初始值</p><p>注意：</p><p><strong><code>truncate</code>与<code>delete</code>的区别</strong>：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。</p><p>truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。</p><p>但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; -- 创建表，f_id字段引用T_TEST的主码id</span><br><span class="line">&gt; drop table T_TEST2;</span><br><span class="line">&gt; create table T_TEST2(</span><br><span class="line">&gt;   id1 int primary key ,</span><br><span class="line">&gt;   f_id int,</span><br><span class="line">&gt;   constraint fk</span><br><span class="line">&gt;   foreign key (f_id)</span><br><span class="line">&gt;     references T_TEST(id) on delete cascade</span><br><span class="line">&gt; );</span><br><span class="line">&gt; select *</span><br><span class="line">&gt; from T_TEST2;</span><br><span class="line">&gt; insert into T_TEST2 values(1, 1);</span><br><span class="line">&gt; -- 可级联删除</span><br><span class="line">&gt; delete from T_TEST;</span><br><span class="line">&gt; -- 将外码置为禁用</span><br><span class="line">&gt; alter table T_TEST2 modify constraint fk disable validate ;</span><br><span class="line">&gt; -- 可截断（当不禁用外码时无法截断）</span><br><span class="line">&gt; truncate table T_TEST;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--过程：数据初始化</span><br><span class="line">create or replace procedure init is</span><br><span class="line">begin</span><br><span class="line">    --清除数据</span><br><span class="line">    execute immediate &apos;truncate table t_audit&apos;;</span><br><span class="line">    execute immediate &apos;truncate table t_customer_history&apos;;</span><br><span class="line">    execute immediate &apos;truncate table t_customer&apos;;</span><br><span class="line">    execute immediate &apos;truncate table t_user&apos;;</span><br><span class="line">    execute immediate &apos;truncate table t_department&apos;;</span><br><span class="line">    --重调序列</span><br><span class="line">    reset_seq(&apos;seq_audit_pk&apos;);</span><br><span class="line"></span><br><span class="line">    --插入部门</span><br><span class="line">    insert into t_department values(1,&apos;销售部&apos;,&apos;D01&apos;,NULL,&apos;李明&apos;,&apos;备注1...&apos;);</span><br><span class="line">    insert into t_department values(2,&apos;销售部-北京分部&apos;,&apos;D0101&apos;,1,&apos;赵军&apos;,&apos;备注2...&apos;);</span><br><span class="line">    insert into t_department values(3,&apos;销售部-上海分部&apos;,&apos;D0102&apos;,1,&apos;张华&apos;,&apos;备注3...&apos;);</span><br><span class="line">    insert into t_department values(4,&apos;销售部-深圳分部&apos;,&apos;D0103&apos;,1,&apos;王兵&apos;,&apos;备注4...&apos;);</span><br><span class="line"></span><br><span class="line">    --插入用户</span><br><span class="line">    insert into t_user values(1,1,&apos;仲芳芳&apos;,&apos;U8201&apos;,&apos;女&apos;,&apos;13771234101&apos;,&apos;02131231011&apos;,&apos;use1@samtech.com&apos;,&apos;备注1...&apos;);</span><br><span class="line">    insert into t_user values(2,1,&apos;李明申&apos;,&apos;U8202&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;02131231012&apos;,&apos;use2@samtech.com&apos;,&apos;备注2...&apos;);</span><br><span class="line">    insert into t_user values(3,2,&apos;张雪&apos;, &apos;U8203&apos;,&apos;女&apos;,&apos;13771234103&apos;,&apos;02131231013&apos;,&apos;use3@samtech.com&apos;,&apos;备注3...&apos;);</span><br><span class="line">    insert into t_user values(4,2,&apos;王刚&apos;, &apos;U8204&apos;,&apos;男&apos;,&apos;13771234104&apos;,&apos;02131231014&apos;,&apos;use4@samtech.com&apos;,&apos;备注4...&apos;);</span><br><span class="line">    insert into t_user values(5,3,&apos;赵昌日&apos;,&apos;U8205&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;02131231015&apos;,&apos;use5@samtech.com&apos;,&apos;备注5...&apos;);</span><br><span class="line">    insert into t_user values(6,3,&apos;孙晓华&apos;,&apos;U8206&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;02131231016&apos;,&apos;use6@samtech.com&apos;,&apos;备注6...&apos;);</span><br><span class="line">    insert into t_user values(7,4,&apos;陈亚男&apos;,&apos;U8207&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;02131231017&apos;,&apos;use7@samtech.com&apos;,&apos;备注7...&apos;);</span><br><span class="line">    insert into t_user values(8,4,&apos;刘兵超&apos;,&apos;U8208&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;02131231018&apos;,&apos;use8@samtech.com&apos;,&apos;备注8...&apos;);</span><br><span class="line"></span><br><span class="line">    --插入客户</span><br><span class="line">    insert into t_customer</span><br><span class="line">    values(1,&apos;C1808001&apos;,&apos;上海市永辉电子股份有限公司&apos;,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;02135681589&apos;,&apos;ming@google.com&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;上海市&apos;,12082,&apos;上海中远&apos;,&apos;备注...&apos;,&apos;张娜&apos;,0,1,sysdate,1,sysdate,1);</span><br><span class="line">    commit;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="修改客户信息过程"><a href="#修改客户信息过程" class="headerlink" title="修改客户信息过程"></a>修改客户信息过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--过程：修改客户地址</span><br><span class="line">create or replace procedure modify_address</span><br><span class="line">(p_row_id in number,p_address in varchar2, p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_address,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated address successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改客户余额</span><br><span class="line">create or replace procedure modify_balance</span><br><span class="line">(p_row_id in number,p_balance in number, p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_balance,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated balance successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改客户电子邮箱</span><br><span class="line">create or replace procedure modify_email</span><br><span class="line">(p_row_id in number,p_email in varchar2, p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_email,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated email successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改客户联系人</span><br><span class="line">create or replace procedure modify_linkman</span><br><span class="line">(p_row_id in number,p_linkman_name in varchar2, p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_linkman_name,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated linkman name successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改客户联系人信息</span><br><span class="line">create or replace procedure modify_linkman_info</span><br><span class="line">(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2,</span><br><span class="line"> p_telephone in varchar2,p_email in varchar2,p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_linkman=:1, f_mobile=:2,</span><br><span class="line">    f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6&apos;</span><br><span class="line">    using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated linkman info successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改联系手机</span><br><span class="line">create or replace procedure modify_mobile</span><br><span class="line">(p_row_id in number,p_mobile in varchar2,p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_mobile,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">--过程：修改联系固话</span><br><span class="line">create or replace procedure modify_telephone</span><br><span class="line">(p_row_id in number,p_telephone in varchar2,p_operator in number)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    --校验参数省略</span><br><span class="line">    --...</span><br><span class="line">    execute immediate &apos;update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos;</span><br><span class="line">    using p_telephone,p_operator,p_row_id;</span><br><span class="line">    commit;</span><br><span class="line">    dbms_output.put_line(&apos;Updated mobile successfully.&apos;);</span><br><span class="line"></span><br><span class="line">    --异常捕获省略</span><br><span class="line">    --...</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 初始化</span><br><span class="line">call init();</span><br><span class="line"></span><br><span class="line">-- 更改客户信息</span><br><span class="line">begin</span><br><span class="line">modify_linkman(1,&apos;李明顺&apos;,1);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_mobile(1,&apos;13771083211&apos;,2);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_balance(1,20020,3);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_address(1,&apos;中国上海市嘉定区xxx路&apos;,4);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_email(1,&apos;test1@163.com&apos;,5);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_telephone(1,&apos;02183652145&apos;,6);</span><br><span class="line">dbms_lock.sleep(1);</span><br><span class="line">modify_linkman_info(1,&apos;张雨轩&apos;,&apos;15332892301&apos;,&apos;02188881111&apos;,&apos;zhangyx@gmail.com&apos;,7);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">-- 审计</span><br><span class="line">select * from T_AUDIT;</span><br><span class="line"></span><br><span class="line">-- 回滚客户信息</span><br><span class="line">-- 方法1：</span><br><span class="line">update t_customer a</span><br><span class="line">set(</span><br><span class="line">a.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,</span><br><span class="line">a.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,</span><br><span class="line">a.f_modified_id,a.f_modified_time</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">(</span><br><span class="line">select b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,</span><br><span class="line">b.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,</span><br><span class="line">b.f_deleted_tag,5,sysdate</span><br><span class="line">from t_customer_history b where b.f_id=a.f_id and b.f_version=3</span><br><span class="line">)</span><br><span class="line">where a.f_id=1;</span><br><span class="line">-- 方法2：</span><br><span class="line">merge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)</span><br><span class="line">when matched then</span><br><span class="line">update set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,</span><br><span class="line">a.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,</span><br><span class="line">a.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;</span><br><span class="line"></span><br><span class="line">-- 查看验证数据</span><br><span class="line">select * from t_customer where f_id=1</span><br><span class="line">union</span><br><span class="line">select * from t_customer_history where f_id=1 and f_version=3;</span><br></pre></td></tr></table></figure><h1 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title="Lesson 3"></a>Lesson 3</h1><h2 id="创建用户并分配权限-2"><a href="#创建用户并分配权限-2" class="headerlink" title="创建用户并分配权限"></a>创建用户并分配权限</h2><h3 id="创建用户-1"><a href="#创建用户-1" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user permission identified by permission;</span><br></pre></td></tr></table></figure><h3 id="分配权限-1"><a href="#分配权限-1" class="headerlink" title="分配权限"></a>分配权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant connect,resource to permission;</span><br><span class="line">alter user permisson quota unlimited on users;</span><br><span class="line">conn permission/permission;</span><br></pre></td></tr></table></figure><h2 id="创建表及其他对象-1"><a href="#创建表及其他对象-1" class="headerlink" title="创建表及其他对象"></a>创建表及其他对象</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><blockquote><p>方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。</p></blockquote><h4 id="创建表-2"><a href="#创建表-2" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">--方案一</span><br><span class="line">--部门表</span><br><span class="line">CREATE TABLE T_DEPARTMENT</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class="line">&quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line"> CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_DEPARTMENT&quot;  IS &apos;部门表&apos;;</span><br><span class="line"></span><br><span class="line">--用户表</span><br><span class="line">CREATE TABLE &quot;T_USER&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class="line">&quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class="line">&quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line"> CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_USER&quot;  IS &apos;用户表&apos;;</span><br><span class="line"></span><br><span class="line">--客户信息表</span><br><span class="line">CREATE TABLE &quot;T_CUSTOMER&quot;</span><br><span class="line">(&quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class="line">&quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class="line">&quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">&quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line">&quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line"> PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_CUSTOMER&quot;  IS &apos;客户信息表&apos;;</span><br></pre></td></tr></table></figure><h4 id="创建过程-1"><a href="#创建过程-1" class="headerlink" title="创建过程"></a>创建过程</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--过程：数据初始化</span><br><span class="line">CREATE OR REPLACE PROCEDURE INIT IS</span><br><span class="line">BEGIN</span><br><span class="line">    --清除数据</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER&apos;;</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER&apos;;</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT&apos;;</span><br><span class="line"></span><br><span class="line">    --插入部门</span><br><span class="line">    INSERT INTO T_DEPARTMENT VALUES(1,&apos;公司&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT VALUES(2,&apos;行政部&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT VALUES(3,&apos;销售部&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT VALUES(4,&apos;电销组&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT VALUES(5,&apos;推销组&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class="line"></span><br><span class="line">    --插入用户</span><br><span class="line">    INSERT INTO T_USER VALUES(1,1,&apos;管理员&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(2,3,&apos;李明申&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(3,4,&apos;张雪&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(4,4,&apos;王刚&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(5,4,&apos;赵昌日&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(6,5,&apos;孙晓华&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(7,5,&apos;陈亚男&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(8,5,&apos;刘兵超&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(9,3,&apos;陈彬&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class="line">    INSERT INTO T_USER VALUES(10,3,&apos;王军&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class="line"></span><br><span class="line">    --插入客户</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,3,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,4,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,5,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,6,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,7,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,8,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,9,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,10,SYSDATE);</span><br><span class="line">    COMMIT;</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on;</span><br><span class="line">exec init;</span><br></pre></td></tr></table></figure><h5 id="查询自己的客户"><a href="#查询自己的客户" class="headerlink" title="查询自己的客户"></a>查询自己的客户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_customer A WHERE A.f_created_id=&amp;id;</span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;id</code>是所查询人员的ID</p></blockquote><h5 id="查询某领导下属人员的所有客户"><a href="#查询某领导下属人员的所有客户" class="headerlink" title="查询某领导下属人员的所有客户"></a>查询某领导下属人员的所有客户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t_user a  where exists(</span><br><span class="line">SELECT 1 FROM t_department b</span><br><span class="line">WHERE a.f_dept_id=b.f_id and b.f_manager_id=&amp;id</span><br><span class="line">CONNECT BY b.F_PARENT_ID = PRIOR b.F_ID</span><br><span class="line">start with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&amp;id));</span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;id</code>是该领导的ID</p></blockquote><h4 id="当部门结构或员工归属调整时，权限编码如何处理？"><a href="#当部门结构或员工归属调整时，权限编码如何处理？" class="headerlink" title="当部门结构或员工归属调整时，权限编码如何处理？"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>对于方案一，只需要更改员工直属领导ID即可</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><blockquote><p>方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可</p></blockquote><h4 id="创建表-3"><a href="#创建表-3" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--方案二</span><br><span class="line">--部门表</span><br><span class="line">CREATE TABLE T_DEPARTMENT_2</span><br><span class="line">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_PARENT_ID&quot; NUMBER(6,0),</span><br><span class="line"> &quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">  CONSTRAINT &quot;T_DEPARTMENT_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_CODE&quot; IS &apos;部门编码&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_DEPARTMENT_2&quot;  IS &apos;部门表2&apos;;</span><br><span class="line"></span><br><span class="line">--用户表</span><br><span class="line">CREATE TABLE &quot;T_USER_2&quot;</span><br><span class="line">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line">    &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL,</span><br><span class="line"> &quot;F_MOBILE&quot; VARCHAR2(20 BYTE),</span><br><span class="line"> &quot;F_EMAIL&quot; VARCHAR2(50 BYTE),</span><br><span class="line"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">  CONSTRAINT &quot;T_USER_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_CODE&quot; IS &apos;用户编码&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_USER_2&quot;  IS &apos;用户表2&apos;;</span><br><span class="line"></span><br><span class="line">--客户信息表</span><br><span class="line">CREATE TABLE &quot;T_CUSTOMER_2&quot;</span><br><span class="line">(  &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_EMAIL&quot; VARCHAR2(60 BYTE),</span><br><span class="line"> &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE),</span><br><span class="line"> &quot;F_REMARK&quot; VARCHAR2(200 BYTE),</span><br><span class="line">    &quot;F_ACCESS_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE,</span><br><span class="line"> &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE,</span><br><span class="line">  PRIMARY KEY (&quot;F_ID&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ACCESS_CODE&quot; IS &apos;权限编码&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;</span><br><span class="line">COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;</span><br><span class="line">COMMENT ON TABLE &quot;T_CUSTOMER_2&quot;  IS &apos;客户信息表2&apos;;</span><br><span class="line"></span><br><span class="line">-- 创建人员更改历史表</span><br><span class="line">CREATE TABLE T_USER_HISTORY(</span><br><span class="line">  ID NUMBER(6,0) PRIMARY KEY ,</span><br><span class="line">  F_ID NUMBER(6,0) ,</span><br><span class="line">  O_DEP_ID NUMBER(6,0) ,</span><br><span class="line">  O_ACCESS_CODE VARCHAR2(50 BYTE) ,</span><br><span class="line">  N_DEP_ID  NUMBER(6,0),</span><br><span class="line">  N_ACCESS_CODE VARCHAR2(50 BYTE),</span><br><span class="line">  TIME DATE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.ID IS &apos;PK&apos;;</span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.F_ID IS &apos;修改的人员ID&apos;;</span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS &apos;旧的部门&apos;;</span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS &apos;旧的权限&apos;;</span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS &apos;新的部门&apos;;</span><br><span class="line">COMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS &apos;新的权限&apos;;</span><br><span class="line">COMMENT ON TABLE T_USER_HISTORY IS &apos;用户权限更改历史&apos;;</span><br></pre></td></tr></table></figure><h4 id="创建过程-2"><a href="#创建过程-2" class="headerlink" title="创建过程"></a>创建过程</h4><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--过程：数据初始化</span><br><span class="line">CREATE OR REPLACE PROCEDURE INIT2 IS</span><br><span class="line">BEGIN</span><br><span class="line">    --清除数据</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER_2&apos;;</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_2&apos;;</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT_2&apos;;</span><br><span class="line">    EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_HISTORY&apos;;</span><br><span class="line"></span><br><span class="line">    --插入部门</span><br><span class="line">    INSERT INTO T_DEPARTMENT_2 VALUES(1,&apos;公司&apos;,&apos;1&apos;,NULL,1,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT_2 VALUES(2,&apos;行政部&apos;,&apos;101&apos;,1,1,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT_2 VALUES(3,&apos;销售部&apos;,&apos;102&apos;,1,2,&apos;REMARK...&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT_2 VALUES(4,&apos;电销组&apos;,&apos;10201&apos;,3,3,&apos;销售部电销组&apos;);</span><br><span class="line">    INSERT INTO T_DEPARTMENT_2 VALUES(5,&apos;推销组&apos;,&apos;10202&apos;,3,6,&apos;销售部推销组&apos;);</span><br><span class="line"></span><br><span class="line">    --插入用户</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(1,1,&apos;管理员&apos;,&apos;1&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(2,3,&apos;李明申&apos;,&apos;102&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(3,4,&apos;张雪&apos;,  &apos;10201&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(4,4,&apos;王刚&apos;,  &apos;1020101&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(5,4,&apos;赵昌日&apos;,&apos;1020102&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(6,5,&apos;孙晓华&apos;,&apos;10202&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(7,5,&apos;陈亚男&apos;,&apos;1020201&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(8,5,&apos;刘兵超&apos;,&apos;1020202&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(9,3,&apos;陈彬&apos;,  &apos;10203&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;);</span><br><span class="line">    INSERT INTO T_USER_2 VALUES(10,3,&apos;王军&apos;, &apos;10204&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;);</span><br><span class="line"></span><br><span class="line">    --插入客户</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(1,&apos;上海市永辉电子股份有限公司&apos;     ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,&apos;10201&apos;,3,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(2,&apos;上海博运汽车销售有限公司&apos;      ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,&apos;1020101&apos;,4,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos;   ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,&apos;1020102&apos;,5,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(4,&apos;上海定丰霖贸易有限公司&apos;        ,&apos;赵兰&apos;  ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,&apos;10202&apos;,6,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(5,&apos;上海东俊科技有限公司&apos;          ,&apos;张军&apos;  ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,&apos;1020201&apos;,7,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos;  ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,&apos;1020202&apos;,8,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(7,&apos;南宁云讯科技有限公司&apos;          ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,&apos;10203&apos;,9,SYSDATE);</span><br><span class="line">    INSERT INTO T_CUSTOMER_2 VALUES(8,&apos;沈阳优速家政服务有限公司&apos;       ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,&apos;10204&apos;,10,SYSDATE);</span><br><span class="line">    COMMIT;</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h5 id="将某员工调换到某部门"><a href="#将某员工调换到某部门" class="headerlink" title="将某员工调换到某部门"></a>将某员工调换到某部门</h5><p><img src="/images/image-20181126025537963.png" alt="image-20181126025537963"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 更改用户到特定部门</span><br><span class="line">CREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS</span><br><span class="line">  -- 旧部门</span><br><span class="line">  O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE;</span><br><span class="line">  -- 旧权限</span><br><span class="line">  O_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class="line">  -- 部门权限前缀</span><br><span class="line">  DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class="line">  -- 部门当前人数</span><br><span class="line">  DEP_USER_COUNT T_USER_2.F_CODE%TYPE;</span><br><span class="line">  -- 本部门下的部门数</span><br><span class="line">  DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE;</span><br><span class="line">  -- 新权限</span><br><span class="line">  N_ACCESS_CODE T_USER_2.F_CODE%TYPE;</span><br><span class="line">  -- 更新该员工权限</span><br><span class="line">  C_UPDATE_USER VARCHAR2(100) := &apos;UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3&apos;;</span><br><span class="line">  -- 更新所有该员工的客户的ACCESS权限</span><br><span class="line">  C_UPDATE_CUSTOMER VARCHAR2(100) := &apos;UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2&apos;;</span><br><span class="line">  -- 插入一条修改记录</span><br><span class="line">  C_INSERT_HISTORY VARCHAR2(100) := &apos;INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)&apos;;</span><br><span class="line">  BEGIN</span><br><span class="line">    -- 旧部门</span><br><span class="line">    SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class="line">    -- 旧权限</span><br><span class="line">    SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID;</span><br><span class="line">    -- 新部门权限作为前缀</span><br><span class="line">    SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID;</span><br><span class="line">    -- 计算该部门人员数量</span><br><span class="line">    SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID;</span><br><span class="line">    -- 计算子部门数量</span><br><span class="line">    SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2;</span><br><span class="line">    -- 若新部门与旧部门相同，无需更改</span><br><span class="line">    IF N_DEP_ID=O_DEP_ID THEN</span><br><span class="line">      RETURN;</span><br><span class="line">    END IF;</span><br><span class="line">    -- 新权限CODE</span><br><span class="line">    IF DEP_DEP_COUNT &gt; DEP_USER_COUNT THEN</span><br><span class="line">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1);</span><br><span class="line">    ELSE</span><br><span class="line">      N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1);</span><br><span class="line">    end if;</span><br><span class="line">    -- 输出相关变量</span><br><span class="line">    dbms_output.put_line(&apos;DEP_USER_COUNT : &apos; || DEP_USER_COUNT);</span><br><span class="line">    dbms_output.put_line(&apos;DEP_DEP_COUNT : &apos; || DEP_DEP_COUNT);</span><br><span class="line">    -- 输出相关变量</span><br><span class="line">    dbms_output.put_line(&apos;DEP_ACCESS_CODE_PREFIX : &apos; || DEP_ACCESS_CODE_PREFIX);</span><br><span class="line">    dbms_output.put_line(&apos;C_F_ID : &apos; || C_F_ID);</span><br><span class="line">    dbms_output.put_line(&apos;O_ACCESS_CODE : &apos; || O_ACCESS_CODE);</span><br><span class="line">    dbms_output.put_line(&apos;N_DEP_ID : &apos; || N_DEP_ID);</span><br><span class="line">    dbms_output.put_line(&apos;N_ACCESS_CODE : &apos; || N_ACCESS_CODE);</span><br><span class="line">    -- 更新该员工权限</span><br><span class="line">    EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID;</span><br><span class="line">    -- 更新所有该员工的客户的ACCESS权限</span><br><span class="line">    EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID;</span><br><span class="line">    -- 插入一条修改记录</span><br><span class="line">    EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE;</span><br><span class="line">    -- 提交</span><br><span class="line">    COMMIT;</span><br><span class="line">  END;</span><br><span class="line">  /</span><br></pre></td></tr></table></figure><h4 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 员工部门历史记录主码序列</span><br><span class="line">CREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1;</span><br></pre></td></tr></table></figure><h4 id="执行-2"><a href="#执行-2" class="headerlink" title="执行"></a>执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t_customer_2 where f_access_code like &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure><blockquote><p><code>xxx%</code>指匹配所有以<code>xxx</code>开头的权限码</p></blockquote><h4 id="当部门结构或员工归属调整时，权限编码如何处理？-1"><a href="#当部门结构或员工归属调整时，权限编码如何处理？-1" class="headerlink" title="当部门结构或员工归属调整时，权限编码如何处理？"></a>当部门结构或员工归属调整时，权限编码如何处理？</h4><p>方案二中，调用新增的过程<code>CHANGE_TO_DEPARTMENT</code>即可级联更改权限码。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Oracle专家的三次授课。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="TimesTen" scheme="http://blog.guitoubing.top/tags/TimesTen/"/>
    
      <category term="内存数据库" scheme="http://blog.guitoubing.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>感谢Docker,让我远离环境配置</title>
    <link href="http://blog.guitoubing.top/2018/11/12/%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85Oracle-12c/"/>
    <id>http://blog.guitoubing.top/2018/11/12/使用Docker安装Oracle-12c/</id>
    <published>2018-11-12T15:26:45.000Z</published>
    <updated>2019-10-20T08:55:13.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker"></a>Why Docker</h2><p>自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。</p><p>这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。</p><p>偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。</p><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h4 id="Docker安装并启动Oracle-12c"><a href="#Docker安装并启动Oracle-12c" class="headerlink" title="Docker安装并启动Oracle 12c"></a>Docker安装并启动Oracle 12c</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的</span></span><br><span class="line">docker search oracle</span><br><span class="line">docker pull sath89/oracle-12c</span><br><span class="line"><span class="comment"># 查看已安装的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><blockquote><p>由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：<a href="https://blog.csdn.net/huludan/article/details/52713799" target="_blank" rel="noopener">Docker切换国内镜像下载源</a></p></blockquote><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="built_in">log</span>记录oracle启动的容器号</span></span><br><span class="line">log=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前容器初始化进程</span></span><br><span class="line">docker logs -f $log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示docker中当前运行的容器(可查看到容器ID)</span></span><br><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure><blockquote><p>正常情况下，第一次创建容器应称之为<code>初始化</code>，而以后创建的容器都应基于上次的历史数据，称作<code>容器的数据持久化</code>，在上述命令中<code>-v</code>后的<code>:</code>之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，<code>:</code>后面是在容器中想要访问<code>当前系统的共享文件</code>的路径。</p><p>因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c</span><br></pre></td></tr></table></figure><blockquote><p>至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。</p><p>同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。</p></blockquote><h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入特定的容器，<span class="variable">$&#123;ContainerID&#125;</span>为上述查看到的容器ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)</span></span><br><span class="line">sudo docker exec -it $&#123;ContainerID&#125; env LANG=C.UTF-8 /bin/bash</span><br></pre></td></tr></table></figure><h5 id="连接oracle数据库"><a href="#连接oracle数据库" class="headerlink" title="连接oracle数据库"></a>连接oracle数据库</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@1386ef844664:/<span class="comment"># su oracle</span></span><br><span class="line">oracle@1386ef844664:/$ <span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span></span><br><span class="line">oracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba</span><br></pre></td></tr></table></figure><h5 id="Oracle数据库设置字符集"><a href="#Oracle数据库设置字符集" class="headerlink" title="Oracle数据库设置字符集"></a>Oracle数据库设置字符集</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看数据库编码，结果最下面一行则是目前编码</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> select * from nls_database_parameters <span class="built_in">where</span> parameter =<span class="string">'NLS_CHARACTERSET'</span>;   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 关闭数据库</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> shutdown immediate;               </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 启动到 mount状态，oracle分为4个状态，详情请百度</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> startup mount;                    </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置session ，下同</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> ALTER SYSTEM ENABLE RESTRICTED SESSION;                        </span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;</span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> ALTER SYSTEM SET AQ_TM_PROCESSES=0;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 打开oracle到 open状态</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> alter database open;                               </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改编码为 ZHS16GBK</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> ALTER DATABASE character <span class="built_in">set</span> INTERNAL_USE ZHS16GBK;                </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启oracle ，先关闭，再启动</span></span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> shutdown immediate;                      </span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> startup;</span></span><br></pre></td></tr></table></figure><h2 id="升华"><a href="#升华" class="headerlink" title="升华"></a>升华</h2><p>Docker真的好用！（俗</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-Docker&quot;&gt;&lt;a href=&quot;#Why-Docker&quot; class=&quot;headerlink&quot; title=&quot;Why Docker&quot;&gt;&lt;/a&gt;Why Docker&lt;/h2&gt;&lt;p&gt;自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。&lt;/p&gt;
&lt;p&gt;这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。&lt;/p&gt;
&lt;p&gt;偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Docker" scheme="http://blog.guitoubing.top/tags/Docker/"/>
    
      <category term="Oracle" scheme="http://blog.guitoubing.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>记一次Win10+Fedora双系统的小折腾</title>
    <link href="http://blog.guitoubing.top/2018/11/06/%E8%AE%B0%E4%B8%80%E6%AC%A1Win10-Fedora%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%8F%E6%8A%98%E8%85%BE/"/>
    <id>http://blog.guitoubing.top/2018/11/06/记一次Win10-Fedora双系统的小折腾/</id>
    <published>2018-11-06T13:21:10.000Z</published>
    <updated>2019-10-20T08:56:28.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。<br>我在Google上搜了类似的问题，大多是诸如以下的原因：</p><a id="more"></a><ul><li>主板供电不足（我使用的是台式机应该不会有这个问题）</li><li>BIOS中系统时间不正确（我也未曾修改过该时间）</li></ul><p>这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在</p><h3 id="问题出现的环境背景及自己尝试过哪些方法"><a href="#问题出现的环境背景及自己尝试过哪些方法" class="headerlink" title="问题出现的环境背景及自己尝试过哪些方法"></a>问题出现的环境背景及自己尝试过哪些方法</h3><h4 id="系统相关信息："><a href="#系统相关信息：" class="headerlink" title="系统相关信息："></a>系统相关信息：</h4><p>主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中）</p><h4 id="尝试过得方法："><a href="#尝试过得方法：" class="headerlink" title="尝试过得方法："></a>尝试过得方法：</h4><ol><li>曾使用PE系统中的引导修复工具修复Win10引导，无果</li><li>在Fedora中安装了<code>grub工具</code>尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件<code>\Windows\System32\winload.efi</code>上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性）</li><li>至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果</li></ol><h3 id="问题截图"><a href="#问题截图" class="headerlink" title="问题截图"></a>问题截图</h3><p><img src="/images/bVbjaD6.jpeg" alt="Win10报错"></p><p>如上所示，错误信息提示文件<code>\Windows\System32\winload.efi</code>出错，导致我一直陷入找<code>winload.efi</code>文件错误的怪圈。</p><h3 id="问题解决方法"><a href="#问题解决方法" class="headerlink" title="问题解决方法"></a>问题解决方法</h3><p>鼓捣大半天，我仍然无法解决此问题，便在<a href="https://segmentfault.com/q/1010000016923264" target="_blank" rel="noopener">SegmentFault</a>上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主<a href="https://segmentfault.com/u/fenghengzhi/" target="_blank" rel="noopener">冯恒智</a>，一言点睛。</p><h4 id="具体解决方法如下（划重点）："><a href="#具体解决方法如下（划重点）：" class="headerlink" title="具体解决方法如下（划重点）："></a>具体解决方法如下（划重点）：</h4><p>在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\EFI\Microsoft\Boot\BCD），发现其中的<strong>【启动设备】</strong>项下的<strong>启动磁盘</strong>和<strong>启动分区</strong>项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见<a href="https://blog.csdn.net/testcs_dn/article/details/47904937" target="_blank" rel="noopener">此博客</a>）。</p><p><img src="/images/image-20181106214511931.png" alt="bootice选项"></p><h4 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h4><p>我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的<strong>启动磁盘</strong>和<strong>启动分区</strong>两项，而其他都未曾影响？待解……</p><h4 id="就很玄学（挠头"><a href="#就很玄学（挠头" class="headerlink" title="就很玄学（挠头"></a>就很玄学（挠头</h4><h4 id="11月7日更新"><a href="#11月7日更新" class="headerlink" title="11月7日更新"></a>11月7日更新</h4><p>SegmentFault上的答主<a href="https://segmentfault.com/u/fenghengzhi/" target="_blank" rel="noopener">冯恒智</a>又回复了我的问题，如下：</p><blockquote><p>并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。&lt;br&gt;我在Google上搜了类似的问题，大多是诸如以下的原因：&lt;/p&gt;
    
    </summary>
    
      <category term="Win10" scheme="http://blog.guitoubing.top/categories/Win10/"/>
    
    
      <category term="Win10" scheme="http://blog.guitoubing.top/tags/Win10/"/>
    
      <category term="Linux" scheme="http://blog.guitoubing.top/tags/Linux/"/>
    
      <category term="双系统" scheme="http://blog.guitoubing.top/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="引导修复" scheme="http://blog.guitoubing.top/tags/%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java - JavaFX学习小记</title>
    <link href="http://blog.guitoubing.top/2018/10/28/JavaFX-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://blog.guitoubing.top/2018/10/28/JavaFX-学习小记/</id>
    <published>2018-10-27T16:08:25.000Z</published>
    <updated>2019-10-20T08:53:56.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaFX小记"><a href="#JavaFX小记" class="headerlink" title="JavaFX小记"></a>JavaFX小记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>JavaFX</p><p><code>JavaFX</code>是由<a href="https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">甲骨文(Oracle)公司</a>推出的一系列的产品和技术，主要应用于创建Rich Internet application(<a href="https://zh.wikipedia.org/wiki/RIA" target="_blank" rel="noopener">RIAs</a>)，它是一个跨平台的桌面应用程序开发框架。</p></li></ul><a id="more"></a><ul><li><p>典型的MVC架构</p><ul><li>定义<code>Model</code>，使用<code>javafx.beans</code>封装类型定义属性类型</li><li>使用<code>fxml</code>文件创建<code>View</code>，利用SceneBuilder工具进行布局</li><li>创建<code>Controller</code>实现动作操作以及<code>Model</code>和<code>View</code>的联系</li></ul></li></ul><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><ul><li><strong>创建FXML文件，利用SceneBuilder工具进行布局</strong></li></ul><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><ul><li><p><strong>定义<code>Model</code>中的<code>Person</code>类，使用<code>Property</code>和<code>Bind</code></strong></p><p><code>java.beans</code>包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，<code>Property</code>和<code>Bind</code>方便我们实现以下功能：当某个属性如<code>First Name</code>被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考<a href="https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm" target="_blank" rel="noopener">JavaFX文档</a>。</p><p><strong>Person.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.IntegerProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.ObjectProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleIntegerProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleObjectProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleStringProperty;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.StringProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Model class for a Person.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringProperty firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringProperty lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringProperty street;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntegerProperty postalCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringProperty city;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectProperty&lt;LocalDate&gt; birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor with some initial data.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = <span class="keyword">new</span> SimpleStringProperty(firstName);</span><br><span class="line">        <span class="keyword">this</span>.lastName = <span class="keyword">new</span> SimpleStringProperty(lastName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some initial dummy data, just for convenient testing.</span></span><br><span class="line">        <span class="keyword">this</span>.street = <span class="keyword">new</span> SimpleStringProperty(<span class="string">"some street"</span>);</span><br><span class="line">        <span class="keyword">this</span>.postalCode = <span class="keyword">new</span> SimpleIntegerProperty(<span class="number">1234</span>);</span><br><span class="line">        <span class="keyword">this</span>.city = <span class="keyword">new</span> SimpleStringProperty(<span class="string">"some city"</span>);</span><br><span class="line">        <span class="keyword">this</span>.birthday = <span class="keyword">new</span> SimpleObjectProperty&lt;LocalDate&gt;(LocalDate.of(<span class="number">1999</span>, <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName.set(firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringProperty <span class="title">firstNameProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName.set(lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringProperty <span class="title">lastNameProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStreet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> street.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStreet</span><span class="params">(String street)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.street.set(street);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringProperty <span class="title">streetProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> street;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPostalCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postalCode.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPostalCode</span><span class="params">(<span class="keyword">int</span> postalCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postalCode.set(postalCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerProperty <span class="title">postalCodeProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postalCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city.set(city);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringProperty <span class="title">cityProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(LocalDate birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday.set(birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectProperty&lt;LocalDate&gt; <span class="title">birthdayProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>ObservableList</code>管理<code>Person</code></strong></p><p>前一点所述的<u><strong>后续</strong></u>操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是<code>ObservableList</code>，<code>ObservableList</code>继承了<code>List</code>类、实现了<code>Observable</code>接口，其实现视图和数据同步的方法是在声明<code>ObservableList</code>时为方法传递一个监听器，此监听器需要会通过监听<code>personData</code>的变化同步改变视图中对应的值，可参考<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html" target="_blank" rel="noopener">ObservableList文档</a></p><p><strong>Main.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*......Other variables......*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The data of a observable list of Persons</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ObservableList&lt;Person&gt; personData = FXCollections.observableArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObservableList&lt;Person&gt; <span class="title">getPersonData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Tan"</span>, <span class="string">"Rui"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Chen"</span>, <span class="string">"Chao"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Liang"</span>, <span class="string">"Chengwei"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Xiao"</span>, <span class="string">"Xin"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Li"</span>, <span class="string">"Yang"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Chen"</span>, <span class="string">"Runqian"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Liang"</span>, <span class="string">"Yongchao"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Luo"</span>, <span class="string">"Jihao"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Chen"</span>, <span class="string">"Zhi"</span>));</span><br><span class="line">        personData.add(<span class="keyword">new</span> Person(<span class="string">"Fan"</span>, <span class="string">"Fan"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ......Other function..... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="PersonOverviewController-java"><a href="#PersonOverviewController-java" class="headerlink" title="PersonOverviewController.java"></a>PersonOverviewController.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.fxml.FXML;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Label;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TableColumn;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TableView;</span><br><span class="line"><span class="keyword">import</span> com.tanrui.Main;</span><br><span class="line"><span class="keyword">import</span> com.tanrui.model.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonOverviewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TableView&lt;Person&gt; personTable;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TableColumn&lt;Person, String&gt; firstNameColumn;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TableColumn&lt;Person, String&gt; lastNameColumn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label firstNameLabel;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label lastNameLabel;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label streetLabel;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label postalCodeLabel;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label cityLabel;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label birthdayLabel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the main application.</span></span><br><span class="line">    <span class="keyword">private</span> Main main;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The constructor.</span></span><br><span class="line"><span class="comment">     * The constructor is called before the initialize() method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonOverviewController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes the controller class. This method is automatically called</span></span><br><span class="line"><span class="comment">     * after the fxml file has been loaded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize the person table with the two columns.</span></span><br><span class="line">        firstNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class="line">        lastNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is called by the main application to give a reference back to itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> main</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMain</span><span class="params">(Main main)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.main = main;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add observable list data to the table</span></span><br><span class="line">        personTable.setItems(main.getPersonData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>@FXML</code>注解（Annotation）</strong></p><p>使用<code>@FXML</code>注解可以将操作的属性、方法绑定到<code>FXML</code>文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用<code>@FXML</code>注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！</p></li><li><p><strong><code>initialize()</code>方法</strong></p><p><code>initialize()</code>字面意思可知其是用于初始化对应<code>FXML</code>文件中的属性，此方法会在加载<code>FXML</code>文件时被自动执行，此时，所有的<code>FXML</code>属性都应已被初始化</p></li><li><p><strong><code>setCellValueFactory(...)</code>方法</strong></p><p>我们对表格列上使用<code>setCellValueFactory(...)</code>方法来确定为特定列使用前面<code>Person</code>的某个属性。<code>-&gt;</code>表示使用的是<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank" rel="noopener">Lambdas</a>特性；另外一种方法是使用<a href="https://docs.oracle.com/javase/8/javafx/api/" target="_blank" rel="noopener">PropertyValueFactory</a>(待研究…)。</p><p>这里我们之所以可以使用<code>cellData -&gt; cellData.getValue().firstNameProperty()</code>，便是因为之前我们将Person的属性都定义为<code>javafx.beans</code>中的封装属性，<code>firstNameProperty()</code>等方法都会在声明成<code>Beans</code>封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便</p></li></ul><h3 id="连接Main和PersonOverviewController"><a href="#连接Main和PersonOverviewController" class="headerlink" title="连接Main和PersonOverviewController"></a>连接Main和PersonOverviewController</h3><ul><li><p><strong><code>showPersonOverview()</code> 方法</strong></p><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shows the person overview inside the root layout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPersonOverview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Load person overview.</span></span><br><span class="line">        FXMLLoader loader = <span class="keyword">new</span> FXMLLoader();</span><br><span class="line">        loader.setLocation(Main.class.getResource(<span class="string">"view/PersonOverview.fxml"</span>));</span><br><span class="line">        AnchorPane personOverview = (AnchorPane) loader.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set person overview into the center of root layout.</span></span><br><span class="line">        rootLayout.setCenter(personOverview);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give the controller access to the main app.</span></span><br><span class="line">        PersonOverviewController controller = loader.getController();</span><br><span class="line">        controller.setMain(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="将View与Controller绑定"><a href="#将View与Controller绑定" class="headerlink" title="将View与Controller绑定"></a>将View与Controller绑定</h3><p>我们还需要为<code>FXML文件</code>指定其对应的<code>Controller</code>，以及<code>FXML元素</code>与<code>控制器的属性</code>的对应关系，这是因为FXML文件中的元素只能被对应<code>Controller</code>修改更新，若在其他方法中修改会产生运行时错误。例如：在<code>PersonOverviewController.java</code>中将某个<code>Label</code>返回到<code>Main.java</code>中而后在其中修改该<code>Label</code>的值，意即在<code>非FX线程</code>中执行<code>FX线程</code>相关的任务，则会造成当前的线程阻塞，解决方法之一是使用<code>Platform.runLater()</code>方法，如下所示，括号中的<code>FX线程</code>相关任务便不会阻塞当前进程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Platform.runLater(() -&gt; &#123;</span><br><span class="line">        ………相关FX线程代码………</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，最好的选择还是讲<code>FX线程</code>任务和其他任务区分开来，将特定的<code>FXML文件</code>与对应的<code>Controller</code>联系起来，当需要建立联系时可通过之前所说的使用<code>java.beans</code>、<code>ObservableList</code>等方法实现动态更新视图。</p><ul><li><p><strong>为<code>FXML文件</code>指定<code>Controller</code></strong></p><p>在Eclipse中好像有图形化界面直接为<code>FXML文件</code>选择<code>Controller</code>的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。</p><p><strong>PersonOverview.fxml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">AnchorPane</span> <span class="attr">maxHeight</span>=<span class="string">"-Infinity"</span> <span class="attr">maxWidth</span>=<span class="string">"-Infinity"</span> <span class="attr">minHeight</span>=<span class="string">"-Infinity"</span> <span class="attr">minWidth</span>=<span class="string">"-Infinity"</span> <span class="attr">prefHeight</span>=<span class="string">"300.0"</span> <span class="attr">prefWidth</span>=<span class="string">"600.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://javafx.com/javafx/8.0.121"</span> <span class="attr">xmlns:fx</span>=<span class="string">"http://javafx.com/fxml/1"</span> <span class="attr">fx:controller</span>=<span class="string">"com.tanrui.view.PersonOverviewController"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">children</span>&gt;</span></span><br><span class="line">        &lt;? ... 内容省略 ... ?&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">AnchorPane</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上述代码所述，在顶层节点（此处是<code>AnchorPane</code>）标签中添加属性如下：<code>fx:controller=&quot;com.tanrui.view.PersonOverviewController”</code>，以此为<code>FXML文件</code>指定<code>Controller</code></p></li><li><p>为<code>FXML元素</code>指定<code>fx:id</code>，使其绑定对应的<code>控制器属性</code></p><p><img src="/img/image-20181023205748006.png" alt="image-20181023205748006"></p><p>如图，选定特定元素，在右侧界面找到<code>Code</code>-&gt;<code>fx:id</code>，将其对应的控制器属性填入即可</p></li></ul><h3 id="Details界面更新"><a href="#Details界面更新" class="headerlink" title="Details界面更新"></a>Details界面更新</h3><ul><li><p><strong><code>showPersonDetails(Person person)</code>方法</strong></p><p><code>showPersonDetails(Person person)</code>方法用于使用Person实例的数据填写标签。</p><p><strong>PersonOverviewController.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fills all text fields to show details about the person.</span></span><br><span class="line"><span class="comment"> * If the specified person is null, all text fields are cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> person the person or null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPersonDetails</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the labels with info from the person object.</span></span><br><span class="line">        firstNameLabel.setText(person.getFirstName());</span><br><span class="line">        lastNameLabel.setText(person.getLastName());</span><br><span class="line">        streetLabel.setText(person.getStreet());</span><br><span class="line">        postalCodeLabel.setText(Integer.toString(person.getPostalCode()));</span><br><span class="line">        cityLabel.setText(person.getCity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> We need a way to convert the birthday into a String!</span></span><br><span class="line">        <span class="comment">// birthdayLabel.setText(...);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Person is null, remove all the text.</span></span><br><span class="line">        firstNameLabel.setText(<span class="string">""</span>);</span><br><span class="line">        lastNameLabel.setText(<span class="string">""</span>);</span><br><span class="line">        streetLabel.setText(<span class="string">""</span>);</span><br><span class="line">        postalCodeLabel.setText(<span class="string">""</span>);</span><br><span class="line">        cityLabel.setText(<span class="string">""</span>);</span><br><span class="line">        birthdayLabel.setText(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>监听用户在人员表中的选择</strong></p><p><strong>PersonOverviewController.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FXML</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the person table with the two columns.</span></span><br><span class="line">    firstNameColumn.setCellValueFactory(</span><br><span class="line">            cellData -&gt; cellData.getValue().firstNameProperty());</span><br><span class="line">    lastNameColumn.setCellValueFactory(</span><br><span class="line">            cellData -&gt; cellData.getValue().lastNameProperty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear person details.</span></span><br><span class="line">    showPersonDetails(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen for selection changes and show the person details when changed.</span></span><br><span class="line">    personTable.getSelectionModel().selectedItemProperty().addListener(</span><br><span class="line">            (observable, oldValue, newValue) -&gt; showPersonDetails(newValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除按钮事件"><a href="#删除按钮事件" class="headerlink" title="删除按钮事件"></a>删除按钮事件</h3><p>我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下：</p><p><strong>PersonOverviewController.java</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the user clicks on the delete button.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeletePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class="line">        <span class="keyword">if</span> (selectedIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            personTable.getItems().remove(selectedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class="string">"No Person Selected"</span>, <span class="string">"Please select a person in the table."</span>).ShowSpecificDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>从上述代码可以看到我们使用了条件判断语句来判断<code>selectedIndex</code>的值，当其小于0时，正常情况我们应该会让其抛出<code>ArrayIndexOutOfBoundsException</code>异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了<code>controlsfx</code>包，用于弹出各类提示框（可在<a href="http://fxexperience.com/controlsfx/" target="_blank" rel="noopener">ControlsFX</a>官网获取）。</p><p><code>controlsfx</code>有两个主要的版本，同时对于不同的版本，二者的用法也不同：</p><ul><li>对于Java 8，需要下载<a href="http://fxexperience.com/downloads/controlsfx-8-40-14/" target="_blank" rel="noopener">ControlsFX 8.40.14</a>包</li><li>对于Java 9及以上，需要下载<a href="http://fxexperience.com/downloads/controlsfx-9-0-0/" target="_blank" rel="noopener">ControlsFX 9.0.0</a>包</li></ul><p>我们这里用到的是Java 10，因此使用<code>ControlsFX 9.0.0</code>，使用方法如下：</p><p><strong>ShowDialog.java</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Alert;</span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Util to create and show Dialog.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tan Rui</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowDialog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stage stage;</span><br><span class="line">    <span class="keyword">private</span> Alert.AlertType type;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShowDialog</span><span class="params">(Stage stage, Alert.AlertType type, String title, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stage = stage;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowSpecificDialog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Alert dlg = <span class="keyword">new</span> Alert(type);</span><br><span class="line">        dlg.initOwner(stage);</span><br><span class="line">        dlg.setTitle(title);</span><br><span class="line">        dlg.getDialogPane().setContentText(message);</span><br><span class="line">        dlg.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PersonOverviewController.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the user clicks on the delete button.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDeletePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> selectedIndex = personTable.getSelectionModel().getSelectedIndex();</span><br><span class="line">        <span class="keyword">if</span> (selectedIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            personTable.getItems().remove(selectedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class="string">"No Person Selected"</span>, <span class="string">"Please select a person in the table."</span>).ShowSpecificDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="新建和编辑对话框"><a href="#新建和编辑对话框" class="headerlink" title="新建和编辑对话框"></a>新建和编辑对话框</h3><blockquote><p>Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是：</p><ol><li>创建FXML文件，使用SceneBuilder编辑界面；</li><li>创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等；</li><li>连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性；</li><li>在Main函数中加载该控制器</li></ol></blockquote><p>为之前的<code>New</code>和<code>Edit</code>按钮添加动作，弹出对话框（新的Stage）。</p><h4 id="设计对话框"><a href="#设计对话框" class="headerlink" title="设计对话框"></a>设计对话框</h4><p>创建<code>PersonEditDialog.fxml</code>，完成弹出对话框的设计：</p><p><img src="/img/image-20181027150559447.png" alt="image-20181027150559447"></p><h4 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h4><p>为对话框创建控制器<code>PersonEditDialogController.java</code>。</p><p><strong>PersonEditDialogController.java：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tanrui.util.ShowDialog;</span><br><span class="line"><span class="keyword">import</span> javafx.fxml.FXML;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Alert;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TextField;</span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tanrui.model.Person;</span><br><span class="line"><span class="keyword">import</span> com.tanrui.util.DateUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dialog to edit details of a person.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marco Jakob</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEditDialogController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField firstNameField;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField lastNameField;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField streetField;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField postalCodeField;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField cityField;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> TextField birthdayField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stage dialogStage;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> okClicked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes the controller class. This method is automatically called</span></span><br><span class="line"><span class="comment">     * after the fxml file has been loaded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the stage of this dialog.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dialogStage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDialogStage</span><span class="params">(Stage dialogStage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dialogStage = dialogStage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the person to be edited in the dialog.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line"></span><br><span class="line">        firstNameField.setText(person.getFirstName());</span><br><span class="line">        lastNameField.setText(person.getLastName());</span><br><span class="line">        streetField.setText(person.getStreet());</span><br><span class="line">        postalCodeField.setText(Integer.toString(person.getPostalCode()));</span><br><span class="line">        cityField.setText(person.getCity());</span><br><span class="line">        birthdayField.setText(DateUtil.format(person.getBirthday()));</span><br><span class="line">        birthdayField.setPromptText(<span class="string">"dd.mm.yyyy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the user clicked OK, false otherwise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOkClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> okClicked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the user clicks ok.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInputValid()) &#123;</span><br><span class="line">            person.setFirstName(firstNameField.getText());</span><br><span class="line">            person.setLastName(lastNameField.getText());</span><br><span class="line">            person.setStreet(streetField.getText());</span><br><span class="line">            person.setPostalCode(Integer.parseInt(postalCodeField.getText()));</span><br><span class="line">            person.setCity(cityField.getText());</span><br><span class="line">            person.setBirthday(DateUtil.parse(birthdayField.getText()));</span><br><span class="line"></span><br><span class="line">            okClicked = <span class="keyword">true</span>;</span><br><span class="line">            dialogStage.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the user clicks cancel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dialogStage.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Validates the user input in the text fields.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the input is valid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInputValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String errorMessage = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstNameField.getText() == <span class="keyword">null</span> || firstNameField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid first name!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastNameField.getText() == <span class="keyword">null</span> || lastNameField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid last name!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (streetField.getText() == <span class="keyword">null</span> || streetField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid street!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postalCodeField.getText() == <span class="keyword">null</span> || postalCodeField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid postal code!\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer.parseInt(postalCodeField.getText());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                errorMessage += <span class="string">"No valid postal code (must be an integer)!\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cityField.getText() == <span class="keyword">null</span> || cityField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid city!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (birthdayField.getText() == <span class="keyword">null</span> || birthdayField.getText().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            errorMessage += <span class="string">"No valid birthday!\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!DateUtil.validDate(birthdayField.getText())) &#123;</span><br><span class="line">                errorMessage += <span class="string">"No valid birthday. Use the format dd.mm.yyyy!\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errorMessage.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ShowDialog(dialogStage, Alert.AlertType.ERROR, <span class="string">"Invalid Fields"</span>, <span class="string">"Please correct invalid fields"</span>).ShowSpecificDialog();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于该控制器的一些事情应该注意：</p><ol><li><code>setPerson(…)</code>方法可以从其它类中调用，用来设置编辑的人员。</li><li>当用户点击OK按钮时，调用<code>handleOK()</code>方法。首先，通过调用<code>isInputValid()</code>方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给<code>setPerson(…)</code>。</li><li>布尔值<code>okClicked</code>被使用，以便调用者决定用户是否点击OK或者Cancel按钮。</li></ol><h4 id="连接视图和控制器"><a href="#连接视图和控制器" class="headerlink" title="连接视图和控制器"></a>连接视图和控制器</h4><p>使用已经创建的视图（FXML）和控制器，需要连接到一起。</p><ol><li>使用SceneBuilder打开<code>PersonEditDialog.fxml</code>文件</li><li>在左边的<em>Controller</em>组中选择<code>PersonEditDialogController</code>作为控制器类</li><li>设置所有<strong>TextField</strong>的<code>fx:id</code>到相应的控制器字段上。</li><li>设置两个按钮的<strong>onAction</strong>到相应的处理方法上。</li></ol><h4 id="在Main中部署该控制器"><a href="#在Main中部署该控制器" class="headerlink" title="在Main中部署该控制器"></a>在Main中部署该控制器</h4><p><strong>Main.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Opens a dialog to edit details for the specified person. If the user</span></span><br><span class="line"><span class="comment"> * clicks OK, the changes are saved into the provided person object and true</span></span><br><span class="line"><span class="comment"> * is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> person the person object to be edited</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the user clicked OK, false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">showPersonEditDialog</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Load the fxml file and create a new stage for the popup dialog.</span></span><br><span class="line">        FXMLLoader loader = <span class="keyword">new</span> FXMLLoader();</span><br><span class="line">        loader.setLocation(Main.class.getResource(<span class="string">"view/PersonEditDialog.fxml"</span>));</span><br><span class="line">        AnchorPane page = (AnchorPane) loader.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the dialog Stage.</span></span><br><span class="line">        Stage dialogStage = <span class="keyword">new</span> Stage();</span><br><span class="line">        dialogStage.setTitle(<span class="string">"Edit Person"</span>);</span><br><span class="line">        dialogStage.initModality(Modality.WINDOW_MODAL);</span><br><span class="line">        dialogStage.initOwner(primaryStage);</span><br><span class="line">        Scene scene = <span class="keyword">new</span> Scene(page);</span><br><span class="line">        dialogStage.setScene(scene);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the person into the controller.</span></span><br><span class="line">        PersonEditDialogController controller = loader.getController();</span><br><span class="line">        controller.setDialogStage(dialogStage);</span><br><span class="line">        controller.setPerson(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show the dialog and wait until the user closes it</span></span><br><span class="line">        dialogStage.showAndWait();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> controller.isOkClicked();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为主界面中<code>New</code>和<code>Edit</code>按钮创建OnAction方法，这些方法将从<code>Main</code>中调用<code>showPersonEditDialog(…)</code>方法。</p><p><strong>PersonOverviewController.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the user clicks the new button. Opens a dialog to edit</span></span><br><span class="line"><span class="comment"> * details for a new person.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FXML</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNewPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person tempPerson = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">boolean</span> okClicked = main.showPersonEditDialog(tempPerson);</span><br><span class="line">    <span class="keyword">if</span> (okClicked) &#123;</span><br><span class="line">        main.getPersonData().add(tempPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the user clicks the edit button. Opens a dialog to edit</span></span><br><span class="line"><span class="comment"> * details for the selected person.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FXML</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleEditPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person selectedPerson = personTable.getSelectionModel().getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span> (selectedPerson != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> okClicked = main.showPersonEditDialog(selectedPerson);</span><br><span class="line">        <span class="keyword">if</span> (okClicked) &#123;</span><br><span class="line">            showPersonDetails(selectedPerson);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, <span class="string">"No Person Selected"</span>, <span class="string">"Please select a person in the table."</span>).ShowSpecificDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在<code>PersonOverview.fxml</code>中为New和Edit两个按钮绑定对应的OnAction方法：</p><p><img src="/img/image-20181027164439676.png" alt="image-20181027164439676"></p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>我们有很多种方法来实现应用数据的持久化，例如：</p><ul><li>使用数据库存储</li><li>使用Json文件存储</li><li>使用XML文件存储</li><li>……</li></ul><p>这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是：</p><ol><li>每次打开应用可加载上一次的用户数据</li><li>用户可选择保存当前数据到指定XML文件</li><li>用户可选择从指定XML文件加载数据</li></ol><h4 id="使用Preferences保存应用状态"><a href="#使用Preferences保存应用状态" class="headerlink" title="使用Preferences保存应用状态"></a>使用Preferences保存应用状态</h4><p><code>Java</code>提供了<code>Preferences</code>类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），<code>Preferences</code>类底层对各类操作系统进行了封装（实际上是<code>Windows系统</code>、<code>OS X系统</code>和<code>类Unix文件系统</code>三种），用户配置在<code>Windows系统</code>上可能保存在注册表中、在<code>类Unix文件系统</code>上可能保存在<code>/tmp</code>下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道<code>Preferences</code>类是用来保存用户配置即可。用法如下：</p><p><strong>Main.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the person file preference, i.e. the file that was last opened.</span></span><br><span class="line"><span class="comment">     * The preference is read from the OS specific registry. If no such</span></span><br><span class="line"><span class="comment">     * preference can be found, null is returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getPersonFilePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class="line">        String filePath = prefs.get(<span class="string">"filePath"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (filePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(filePath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the file path of the currently loaded file. The path is persisted in</span></span><br><span class="line"><span class="comment">     * the OS specific registry.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file the file or null to remove the path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonFilePath</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        Preferences prefs = Preferences.userNodeForPackage(Main.class);</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prefs.put(<span class="string">"filePath"</span>, file.getPath());</span><br><span class="line">            <span class="comment">// Update the stage title.</span></span><br><span class="line">            primaryStage.setTitle(<span class="string">"AddressApp - "</span> + file.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prefs.remove(<span class="string">"filePath"</span>);</span><br><span class="line">            <span class="comment">// Update the stage title.</span></span><br><span class="line">            primaryStage.setTitle(<span class="string">"AddressApp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="使用JAXB"><a href="#使用JAXB" class="headerlink" title="使用JAXB"></a>使用JAXB</h4><p><code>JAXB包</code>是Java中提供的对数据进行<code>编列(marshall)</code>成XML文件以及对XML文件<code>反编列(unmarshall)</code>为数据结构的包，<code>Java SE</code>中有如下支持类型：<code>JAXB 2.0</code>是<code>JDK 1.6</code>的组成部分。<code>JAXB 2.2.3</code>是<code>JDK 1.7以上</code>的组成部分，而实际上在<code>Java 9</code>之后就已将<code>JAXB</code>包移除，因此使用时需添加额外的lib包，详情可见博客<a href="https://blog.csdn.net/hadues/article/details/79188793" target="_blank" rel="noopener">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a>。</p><h5 id="JAXB模型类"><a href="#JAXB模型类" class="headerlink" title="JAXB模型类"></a>JAXB模型类</h5><p>我们希望持久化的数据应该是<code>Main</code>中的<code>personData</code>，而<code>JAXB</code>有以下要求：</p><ul><li>使用<code>@XmlRootElement</code>定义<code>XML根元素</code>的名称</li><li>使用<code>@XmlElement</code>指定一个<code>XML元素</code>，可选</li></ul><p>而<code>Main</code>中的<code>personData</code>是<code>ObservableList</code>类型，由于<code>ObservableList</code>类型不支持添加注解，因此我们需要创建另外一个能保存<code>Person</code>列表同时又能存储为<code>XML文件</code>的类，如下。</p><p><strong>PersonListWrapper.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlElement;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper class to wrap a list of persons. This is used for saving the</span></span><br><span class="line"><span class="comment"> * list of persons to XML.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XmlRootElement</span>(name = <span class="string">"persons"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonListWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersons</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.persons = persons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用JAXB读写数据到XML文件"><a href="#使用JAXB读写数据到XML文件" class="headerlink" title="使用JAXB读写数据到XML文件"></a>使用JAXB读写数据到XML文件</h5><p>我们将读写XML文件的逻辑放到<code>Main类</code>中，<code>Controller</code>在用到相应的逻辑时，直接调用<code>Main</code>中的方法即可。</p><p><strong>Main.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads person data from the specified file. The current person data will</span></span><br><span class="line"><span class="comment"> * be replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPersonDataFromFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JAXBContext context = JAXBContext</span><br><span class="line">                .newInstance(PersonListWrapper.class);</span><br><span class="line">        Unmarshaller um = context.createUnmarshaller();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reading XML from the file and unmarshalling.</span></span><br><span class="line">        PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file);</span><br><span class="line"></span><br><span class="line">        personData.clear();</span><br><span class="line">        personData.addAll(wrapper.getPersons());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the file path to the registry.</span></span><br><span class="line">        setPersonFilePath(file);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// catches ANY exception</span></span><br><span class="line">        <span class="keyword">new</span> ShowDialog(<span class="keyword">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class="string">"Error"</span>, <span class="string">"Could not save data to file:\n"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Saves the current person data to the specified file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePersonDataToFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class);</span><br><span class="line">        Marshaller m = context.createMarshaller();</span><br><span class="line">        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrapping our person data.</span></span><br><span class="line">        PersonListWrapper wrapper = <span class="keyword">new</span> PersonListWrapper();</span><br><span class="line">        wrapper.setPersons(personData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Marshalling and saving XML to the file.</span></span><br><span class="line">        m.marshal(wrapper, file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the file path to the registry.</span></span><br><span class="line">        setPersonFilePath(file);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// catches ANY exception</span></span><br><span class="line">        <span class="keyword">new</span> ShowDialog(<span class="keyword">this</span>.getPrimaryStage(), Alert.AlertType.ERROR, <span class="string">"Error"</span>, <span class="string">"Could not save data to file:\n"</span> + file.getPath()).ShowSpecificDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>编组(marshall):savePersonDataToFile(…)</code>和<code>解组(unmarshall):loadPersonDataFromFile(…)</code>已准备好，下面在界面中使用它。</p><h4 id="创建打开和保存菜单"><a href="#创建打开和保存菜单" class="headerlink" title="创建打开和保存菜单"></a>创建打开和保存菜单</h4><h5 id="为File菜单添加子项"><a href="#为File菜单添加子项" class="headerlink" title="为File菜单添加子项"></a>为File菜单添加子项</h5><p><img src="/img/image-20181027232418408.png" alt="image-20181027232418408"></p><h5 id="处理菜单相应动作"><a href="#处理菜单相应动作" class="headerlink" title="处理菜单相应动作"></a>处理菜单相应动作</h5><p><code>Controller</code>中使用<code>FileChooser</code>的方法，<code>FileChooser</code>同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。</p><p>本类中使用了<code>FileChooser.ExtensionFilter</code>，对文件系统中文件进行过滤，保留<code>.xml</code>结尾的文件。</p><p>当用户选择特定文件而后点击<code>打开</code>按钮时，会返回该文件，否则返回<code>Null</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tanrui.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tanrui.Main;</span><br><span class="line"><span class="keyword">import</span> com.tanrui.util.ShowDialog;</span><br><span class="line"><span class="keyword">import</span> javafx.fxml.FXML;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Alert;</span><br><span class="line"><span class="keyword">import</span> javafx.stage.FileChooser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The controller for the root layout. The root layout provides the basic</span></span><br><span class="line"><span class="comment"> * application layout containing a menu bar and space where other JavaFX</span></span><br><span class="line"><span class="comment"> * elements can be placed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootLayoutController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the main application</span></span><br><span class="line">    <span class="keyword">private</span> Main main;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is called by the main application to give a reference back to itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> main</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMain</span><span class="params">(Main main)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.main = main;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an empty address book.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        main.getPersonData().clear();</span><br><span class="line">        main.setPersonFilePath(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Opens a FileChooser to let the user select an address book to load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileChooser fileChooser = <span class="keyword">new</span> FileChooser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set extension filter</span></span><br><span class="line">        FileChooser.ExtensionFilter extFilter = <span class="keyword">new</span> FileChooser.ExtensionFilter(</span><br><span class="line">                <span class="string">"XML files (*.xml)"</span>, <span class="string">"*.xml"</span>);</span><br><span class="line">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show save file dialog</span></span><br><span class="line">        File file = fileChooser.showOpenDialog(main.getPrimaryStage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">            main.loadPersonDataFromFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Saves the file to the person file that is currently open. If there is no</span></span><br><span class="line"><span class="comment">     * open file, the "save as" dialog is shown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File personFile = main.getPersonFilePath();</span><br><span class="line">        <span class="keyword">if</span> (personFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            main.savePersonDataToFile(personFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleSaveAs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Opens a FileChooser to let the user select a file to save to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSaveAs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileChooser fileChooser = <span class="keyword">new</span> FileChooser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set extension filter</span></span><br><span class="line">        FileChooser.ExtensionFilter extFilter = <span class="keyword">new</span> FileChooser.ExtensionFilter(</span><br><span class="line">                <span class="string">"XML files (*.xml)"</span>, <span class="string">"*.xml"</span>);</span><br><span class="line">        fileChooser.getExtensionFilters().add(extFilter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show save file dialog</span></span><br><span class="line">        File file = fileChooser.showSaveDialog(main.getPrimaryStage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Make sure it has the correct extension</span></span><br><span class="line">            <span class="keyword">if</span> (!file.getPath().endsWith(<span class="string">".xml"</span>)) &#123;</span><br><span class="line">                file = <span class="keyword">new</span> File(file.getPath() + <span class="string">".xml"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            main.savePersonDataToFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Opens an about dialog.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAbout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, <span class="string">"About"</span>, <span class="string">"Author: Tan\\nWebsite: https://guitoubing.top"</span>).ShowSpecificDialog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes the application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Opens the birthday statistics.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleShowBirthdayStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        main.showBirthdayStatistics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="连接FXML文件和Controller、绑定菜单和对应动作"><a href="#连接FXML文件和Controller、绑定菜单和对应动作" class="headerlink" title="连接FXML文件和Controller、绑定菜单和对应动作"></a>连接FXML文件和Controller、绑定菜单和对应动作</h5><p><img src="/img/image-20181027233726178.png" alt="image-20181027233726178"></p><p><img src="/img/image-20181027233529314.png" alt="image-20181027233529314"></p><h5 id="在Main中部署该控制器-1"><a href="#在Main中部署该控制器-1" class="headerlink" title="在Main中部署该控制器"></a>在Main中部署该控制器</h5><p><strong>Main.java:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes the root layout.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRootLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Load root layout from fxml file.</span></span><br><span class="line">           FXMLLoader loader = <span class="keyword">new</span> FXMLLoader();</span><br><span class="line">           loader.setLocation(Main.class.getResource(<span class="string">"view/RootLayout.fxml"</span>));</span><br><span class="line">           rootLayout = (BorderPane) loader.load();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Show the scene containing the root layout.</span></span><br><span class="line">           Scene scene = <span class="keyword">new</span> Scene(rootLayout);</span><br><span class="line">           primaryStage.setScene(scene);</span><br><span class="line"></span><br><span class="line">           RootLayoutController controller = loader.getController();</span><br><span class="line">           controller.setMain(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           primaryStage.show();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       File file = getPersonFilePath();</span><br><span class="line">       <span class="keyword">if</span> (file != <span class="keyword">null</span>)&#123;</span><br><span class="line">           loadPersonDataFromFile(file);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://code.makery.ch/" target="_blank" rel="noopener">code.makery —— JavaFX中文教程</a></li><li><a href="https://www.tutorialspoint.com/javafx/" target="_blank" rel="noopener">JavaFX Tutorial</a></li><li><a href="https://blog.csdn.net/hadues/article/details/79188793" target="_blank" rel="noopener">真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException</a></li><li><a href="http://fxexperience.com/controlsfx/" target="_blank" rel="noopener">fxexperience —— ControlFX</a></li><li><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank" rel="noopener">Java SE8 —— Lambda</a></li><li>…………</li></ol><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本博主要是在学习<a href="https://code.makery.ch/" target="_blank" rel="noopener">code.makery —— JavaFX中文教程</a>博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是<code>JDK 8u40</code>，我这里使用的是<code>Java 10 2018-03-20</code>）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击<a href="http://getme.guitoubing.top/JavaFX_PRE.zip" target="_blank" rel="noopener">JavaFX-Test</a>中获取源码。</p><p>希望藉此次<code>JavaFX</code>学习开启我的Java源码学习之旅，道阻且长！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaFX小记&quot;&gt;&lt;a href=&quot;#JavaFX小记&quot; class=&quot;headerlink&quot; title=&quot;JavaFX小记&quot;&gt;&lt;/a&gt;JavaFX小记&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JavaFX&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaFX&lt;/code&gt;是由&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%B2%E9%AA%A8%E6%96%87%E5%85%AC%E5%8F%B8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;甲骨文(Oracle)公司&lt;/a&gt;推出的一系列的产品和技术，主要应用于创建Rich Internet application(&lt;a href=&quot;https://zh.wikipedia.org/wiki/RIA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RIAs&lt;/a&gt;)，它是一个跨平台的桌面应用程序开发框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.guitoubing.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.guitoubing.top/tags/Java/"/>
    
      <category term="JavaFX" scheme="http://blog.guitoubing.top/tags/JavaFX/"/>
    
  </entry>
  
  <entry>
    <title>内存数据库 - 课程笔记</title>
    <link href="http://blog.guitoubing.top/2018/09/02/TimesTen%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.guitoubing.top/2018/09/02/TimesTen内存数据库课程笔记/</id>
    <published>2018-09-02T12:59:50.000Z</published>
    <updated>2019-10-20T08:54:57.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存计算与内存数据库"><a href="#内存计算与内存数据库" class="headerlink" title="内存计算与内存数据库"></a>内存计算与内存数据库</h1><h2 id="第零章"><a href="#第零章" class="headerlink" title="第零章"></a>第零章</h2><p>OLTP：行存储（记录：元组），联机事务处理</p><p>OLAP：列存储（key-value），联机分析处理</p><h2 id="Timesten操作小记"><a href="#Timesten操作小记" class="headerlink" title="Timesten操作小记"></a>Timesten操作小记</h2><a id="more"></a><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><blockquote><p>系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga)</p></blockquote><h3 id="创建DSN（Data-Source-Name）"><a href="#创建DSN（Data-Source-Name）" class="headerlink" title="创建DSN（Data Source Name）"></a>创建DSN（Data Source Name）</h3><blockquote><p>逻辑名，用于标识某一数据库连接</p></blockquote><h4 id="打开数据库配置文件-通常称为系统ODBC-INI配置文件"><a href="#打开数据库配置文件-通常称为系统ODBC-INI配置文件" class="headerlink" title="打开数据库配置文件(通常称为系统ODBC.INI配置文件)"></a>打开数据库配置文件(通常称为<code>系统ODBC.INI配置文件</code>)</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TT_HOME</span>/info</span><br><span class="line">$ gedit sys.odbc.ini</span><br></pre></td></tr></table></figure><h4 id="在数据库DSN列表中添加需要新建的数据库名称"><a href="#在数据库DSN列表中添加需要新建的数据库名称" class="headerlink" title="在数据库DSN列表中添加需要新建的数据库名称"></a>在数据库DSN列表中添加需要新建的数据库名称</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示</span></span><br><span class="line"><span class="section">[ODBC Data Sources]</span></span><br><span class="line"><span class="attr">my_ttdb</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">TT_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">sampledb_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">cachedb1_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">repdb1_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">repdb2_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Driver</span><br><span class="line"><span class="attr">sampledbCS_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Client Driver</span><br><span class="line"><span class="attr">cachedb1CS_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Client Driver</span><br><span class="line"><span class="attr">repdb1CS_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Client Driver</span><br><span class="line"><span class="attr">repdb2CS_1122</span>=TimesTen <span class="number">11.2</span>.<span class="number">2</span> Client Driver</span><br></pre></td></tr></table></figure><h4 id="为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中"><a href="#为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中" class="headerlink" title="为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中"></a>为2中创建的数据库添加配置，<u><strong>日志文件与检查点文件应存储在不同磁盘中</strong></u></h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置my_ttdb</span></span><br><span class="line"><span class="section">[my_ttdb]</span></span><br><span class="line"><span class="comment"># 数据库监听器驱动位置</span></span><br><span class="line"><span class="attr">Driver</span>=/home/oracle/TimesTen/tt1122/lib/libtten.so </span><br><span class="line"><span class="comment"># DataStore为检查点文件存储位置</span></span><br><span class="line"><span class="attr">DataStore</span>=/u02/ttdata/datastores/my_ttdb </span><br><span class="line"><span class="comment"># LogDir为日志文件存储位置</span></span><br><span class="line"><span class="attr">LogDir</span>=/u03/ttdata/logs</span><br><span class="line"><span class="comment"># 以下两个Size是TimesTen内存数据库的内存分配</span></span><br><span class="line"><span class="attr">PermSize</span>=<span class="number">40</span></span><br><span class="line"><span class="attr">TempSize</span>=<span class="number">32</span></span><br><span class="line"><span class="comment"># 数据库的字符集</span></span><br><span class="line"><span class="attr">DatabaseCharacterSet</span>=AL32UTF8</span><br></pre></td></tr></table></figure><blockquote><p>TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客<a href="https://blog.csdn.net/stevensxiao/article/details/51050831" target="_blank" rel="noopener"><strong><u>如何更改TimesTen数据库的大小</u></strong></a>。</p></blockquote><h4 id="保存配置文件并关闭"><a href="#保存配置文件并关闭" class="headerlink" title="保存配置文件并关闭"></a>保存配置文件并关闭</h4><h3 id="数据库服务器基本命令"><a href="#数据库服务器基本命令" class="headerlink" title="数据库服务器基本命令"></a>数据库服务器基本命令</h3><h4 id="查看服务器状态"><a href="#查看服务器状态" class="headerlink" title="查看服务器状态"></a>查看服务器状态</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttstatus</span><br><span class="line">TimesTen status report as of Thu Sep 27 04:08:30 2018</span><br><span class="line"></span><br><span class="line">Daemon pid 2637 port 53392 instance tt1122</span><br><span class="line">TimesTen server pid 2646 started on port 53393</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">Accessible by group oracle</span><br><span class="line">End of report</span><br></pre></td></tr></table></figure><h4 id="启动-停止数据库"><a href="#启动-停止数据库" class="headerlink" title="启动/停止数据库"></a>启动/停止数据库</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttdaemonadmin -stop</span><br><span class="line">TimesTen Daemon stopped.</span><br><span class="line">[oracle@timesten-hol info]$ ttstatus</span><br><span class="line">ttStatus: Could not connect to the TimesTen daemon.</span><br><span class="line">If the TimesTen daemon is not running, please start it</span><br><span class="line">by running <span class="string">"ttDaemonAdmin -start"</span>.</span><br><span class="line">[oracle@timesten-hol info]$ ttdaemonadmin -start</span><br><span class="line">TimesTen Daemon startup OK.</span><br><span class="line">[oracle@timesten-hol info]$ ttstatus</span><br><span class="line">TimesTen status report as of Thu Sep 27 04:10:00 2018</span><br><span class="line"></span><br><span class="line">Daemon pid 6522 port 53392 instance tt1122</span><br><span class="line">TimesTen server pid 6531 started on port 53393</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">Accessible by group oracle</span><br><span class="line">End of report</span><br></pre></td></tr></table></figure><h3 id="创建TimesTen内存数据库"><a href="#创建TimesTen内存数据库" class="headerlink" title="创建TimesTen内存数据库"></a>创建TimesTen内存数据库</h3><blockquote><p>默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过<code>ttadmin -RAMPolicy</code>修改，后面会说到。</p><p>也就是说，默认情况下（前提是RAM策略为<code>inUse</code>，下一节会讲到RAM策略的修改），每次在执行<code>connect “dsn=ttdb_name”</code>连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是<code>创建</code>而不是<code>连接到</code>。</p></blockquote><h4 id="连接到特定DSN，创建内存数据库"><a href="#连接到特定DSN，创建内存数据库" class="headerlink" title="连接到特定DSN，创建内存数据库"></a>连接到特定DSN，创建内存数据库</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttisql</span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">Command&gt; connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure><p>或者直接在ttisql中指定DSN名称：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttisql <span class="string">"dsn=my_ttdb"</span></span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">(Default setting AutoCommit=1)</span><br><span class="line">[oracle@timesten-hol ~]$ ttisql my_ttdb</span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">connect <span class="string">"DSN=my_ttdb"</span>;</span><br><span class="line">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">(Default setting AutoCommit=1)</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：重复运行<code>connect “dsn=ttdb_name”</code>命令可以看到命令行中显示了多了连接，这是什么作用呢？</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; Command&gt; connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">&gt; (Default setting AutoCommit=1)</span><br><span class="line">&gt; Command&gt; connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">&gt; (Default setting AutoCommit=1)</span><br><span class="line">&gt; con1: Command&gt; connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">&gt; (Default setting AutoCommit=1)</span><br><span class="line">&gt; con2: Command&gt; connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">&gt; (Default setting AutoCommit=1)</span><br><span class="line">&gt; con3: Command&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="查看内存数据库的内存分配及容量"><a href="#查看内存数据库的内存分配及容量" class="headerlink" title="查看内存数据库的内存分配及容量"></a>查看内存数据库的内存分配及容量</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt; dssize</span><br><span class="line"></span><br><span class="line">  PERM_ALLOCATED_SIZE:      40960</span><br><span class="line">  PERM_IN_USE_SIZE:         9453</span><br><span class="line">  PERM_IN_USE_HIGH_WATER:   9453</span><br><span class="line">  TEMP_ALLOCATED_SIZE:      32768</span><br><span class="line">  TEMP_IN_USE_SIZE:         9442</span><br><span class="line">  TEMP_IN_USE_HIGH_WATER:   9505</span><br></pre></td></tr></table></figure><h4 id="使用Host命令可以调用操作系统级别的指令"><a href="#使用Host命令可以调用操作系统级别的指令" class="headerlink" title="使用Host命令可以调用操作系统级别的指令"></a>使用Host命令可以调用操作系统级别的指令</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt; host ttstatus;</span><br><span class="line">TimesTen status report as of Thu Sep 27 04:37:28 2018</span><br><span class="line"></span><br><span class="line">Daemon pid 6522 port 53392 instance tt1122</span><br><span class="line">TimesTen server pid 6531 started on port 53393</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">Data store /u01/ttdata/datastores/my_ttdb</span><br><span class="line">There are 12 connections to the data store</span><br><span class="line">Shared Memory KEY 0x1200c904 ID 2785297</span><br><span class="line">PL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000</span><br><span class="line">Type            PID     Context             Connection Name              ConnID</span><br><span class="line">Process         6973    0x0000000000c72c00  my_ttdb                           1</span><br><span class="line">Subdaemon       6529    0x00000000012d3360  Manager                         142</span><br><span class="line">Subdaemon       6529    0x000000000132a1e0  Rollback                        141</span><br><span class="line">Subdaemon       6529    0x000000000140b360  HistGC                          139</span><br><span class="line">Subdaemon       6529    0x0000000001420070  AsyncMV                         140</span><br><span class="line">Subdaemon       6529    0x00000000014b4e00  Log Marker                      136</span><br><span class="line">Subdaemon       6529    0x0000000001509a30  Deadlock Detector               135</span><br><span class="line">Subdaemon       6529    0x000000000151e620  Flusher                         134</span><br><span class="line">Subdaemon       6529    0x0000000001533210  Checkpoint                      133</span><br><span class="line">Subdaemon       6529    0x00000000016286b0  Monitor                         132</span><br><span class="line">Subdaemon       6529    0x00007f95880208e0  Aging                           138</span><br><span class="line">Subdaemon       6529    0x00007f958808f900  IndexGC                         137</span><br><span class="line">Replication policy  : Manual</span><br><span class="line">Cache Agent policy  : Manual</span><br><span class="line">PL/SQL enabled.</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">Accessible by group oracle</span><br><span class="line">End of report</span><br></pre></td></tr></table></figure><h3 id="修改RAM策略"><a href="#修改RAM策略" class="headerlink" title="修改RAM策略"></a>修改RAM策略</h3><blockquote><p>上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为<code>inUse</code>的情况，下面会讲到当RAM策略设置为<code>Manual</code>时创建内存数据库的过程。</p><p><code>Manual</code>策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而<code>inUse</code>策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。</p></blockquote><h4 id="查看当前RAM策略"><a href="#查看当前RAM策略" class="headerlink" title="查看当前RAM策略"></a>查看当前RAM策略</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttadmin my_ttdb</span><br><span class="line">RAM Residence Policy            : inUse</span><br><span class="line">Replication Agent Policy        : manual</span><br><span class="line">Replication Manually Started    : False</span><br><span class="line">Cache Agent Policy              : manual</span><br><span class="line">Cache Agent Manually Started    : False</span><br></pre></td></tr></table></figure><h4 id="修改RAM策略为手动模式（Manual）"><a href="#修改RAM策略为手动模式（Manual）" class="headerlink" title="修改RAM策略为手动模式（Manual）"></a>修改RAM策略为手动模式（Manual）</h4><blockquote><p>手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdb</span><br><span class="line">RAM Residence Policy            : manual</span><br><span class="line">Manually Loaded In RAM          : False</span><br><span class="line">Replication Agent Policy        : manual</span><br><span class="line">Replication Manually Started    : False</span><br><span class="line">Cache Agent Policy              : manual</span><br><span class="line">Cache Agent Manually Started    : False</span><br><span class="line">[oracle@timesten-hol info]$ ttisql <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class="line">The <span class="built_in">command</span> failed.</span><br><span class="line">Done.</span><br><span class="line">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure><h4 id="向内存中装载数据"><a href="#向内存中装载数据" class="headerlink" title="向内存中装载数据"></a>向内存中装载数据</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttadmin -ramload my_ttdb</span><br><span class="line">RAM Residence Policy            : manual</span><br><span class="line">Manually Loaded In RAM          : True</span><br><span class="line">Replication Agent Policy        : manual</span><br><span class="line">Replication Manually Started    : False</span><br><span class="line">Cache Agent Policy              : manual</span><br><span class="line">Cache Agent Manually Started    : False</span><br><span class="line">[oracle@timesten-hol info]$ ttisql <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;</span><br><span class="line">(Default setting AutoCommit=1)</span><br><span class="line">Command&gt;</span><br></pre></td></tr></table></figure><h4 id="从内存中卸载数据"><a href="#从内存中卸载数据" class="headerlink" title="从内存中卸载数据"></a>从内存中卸载数据</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdb</span><br><span class="line">RAM Residence Policy            : manual</span><br><span class="line">Manually Loaded In RAM          : False</span><br><span class="line">Replication Agent Policy        : manual</span><br><span class="line">Replication Manually Started    : False</span><br><span class="line">Cache Agent Policy              : manual</span><br><span class="line">Cache Agent Manually Started    : False</span><br><span class="line">[oracle@timesten-hol info]$ ttisql <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line"></span><br><span class="line">Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Type ? or <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"exit"</span> to quit ttIsql.</span><br><span class="line"></span><br><span class="line">connect <span class="string">"dsn=my_ttdb"</span>;</span><br><span class="line">  707: Attempt to connect to a data store that has been manually unloaded from RAM</span><br><span class="line">The <span class="built_in">command</span> failed.</span><br><span class="line">Done.</span><br><span class="line">[oracle@timesten-hol info]$</span><br></pre></td></tr></table></figure><h3 id="日志和检查点"><a href="#日志和检查点" class="headerlink" title="日志和检查点"></a>日志和检查点</h3><h4 id="查看日志文件，提交之前会预写日志"><a href="#查看日志文件，提交之前会预写日志" class="headerlink" title="查看日志文件，提交之前会预写日志"></a>查看日志文件，<strong><u>提交之前会预写日志</u></strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt; host ls -al /u03/ttdata/logs/my*</span><br><span class="line">-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4</span><br><span class="line">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0</span><br><span class="line">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1</span><br><span class="line">-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2</span><br></pre></td></tr></table></figure><h4 id="查看检查点"><a href="#查看检查点" class="headerlink" title="查看检查点"></a>查看检查点</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt; host ls -al /u02/ttdata/datastores/my*</span><br><span class="line">-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0</span><br><span class="line">-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1</span><br></pre></td></tr></table></figure><h4 id="手动更新检查点文件"><a href="#手动更新检查点文件" class="headerlink" title="手动更新检查点文件"></a>手动更新检查点文件</h4><blockquote><p>非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。</p><p>如下调用检查点文件：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; call ttckpt;</span><br><span class="line">Command&gt; call ttckpt;</span><br></pre></td></tr></table></figure><h3 id="ttisql基本命令——用户操作"><a href="#ttisql基本命令——用户操作" class="headerlink" title="ttisql基本命令——用户操作"></a>ttisql基本命令——用户操作</h3><h4 id="创建用户，可在表sys-all-users中查找所有的用户信息"><a href="#创建用户，可在表sys-all-users中查找所有的用户信息" class="headerlink" title="创建用户，可在表sys.all_users中查找所有的用户信息"></a>创建用户，可在表<code>sys.all_users</code>中查找所有的用户信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; select * from sys.all_users;</span><br><span class="line">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class="line">6 rows found.</span><br><span class="line">Command&gt; create user tthr identified by tthr;</span><br><span class="line"></span><br><span class="line">User created.</span><br><span class="line"></span><br><span class="line">Command&gt; select * from sys.all_users;</span><br><span class="line">&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;</span><br><span class="line">&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;</span><br><span class="line">&lt; TTHR, 12, 2018-09-28 23:11:57.126074 &gt;</span><br><span class="line">7 rows found.</span><br></pre></td></tr></table></figure><h4 id="给用户分配权限"><a href="#给用户分配权限" class="headerlink" title="给用户分配权限"></a>给用户分配权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; grant create session to tthr;</span><br><span class="line">Command&gt; grant create table to tthr;</span><br><span class="line">Command&gt; grant create view to tthr;</span><br><span class="line">Command&gt; grant create sequence to tthr;</span><br></pre></td></tr></table></figure><h4 id="查看当前数据库系统内用户权限"><a href="#查看当前数据库系统内用户权限" class="headerlink" title="查看当前数据库系统内用户权限"></a>查看当前数据库系统内用户权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; select * from sys.dba_sys_privs;</span><br><span class="line">&lt; SYS, ADMIN, YES &gt;</span><br><span class="line">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class="line">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class="line">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class="line">9 rows found.</span><br></pre></td></tr></table></figure><h4 id="撤回用户权限"><a href="#撤回用户权限" class="headerlink" title="撤回用户权限"></a>撤回用户权限</h4><blockquote><p>以下示例展示了如何从用户撤回权限（赋予<code>delete any table</code>权限后再撤回该权限）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; grant delete any table to tthr;</span><br><span class="line">Command&gt; select * from sys.dba_sys_privs;</span><br><span class="line">&lt; SYS, ADMIN, YES &gt;</span><br><span class="line">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class="line">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class="line">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; TTHR, DELETE ANY TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class="line">10 rows found.</span><br><span class="line">Command&gt; revoke delete any table from tthr;</span><br><span class="line">Command&gt; select * from sys.dba_sys_privs;</span><br><span class="line">&lt; SYS, ADMIN, YES &gt;</span><br><span class="line">&lt; SYSTEM, ADMIN, YES &gt;</span><br><span class="line">&lt; ORACLE, ADMIN, YES &gt;</span><br><span class="line">&lt; SCOTT, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; SCOTT, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SESSION, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE TABLE, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE VIEW, NO &gt;</span><br><span class="line">&lt; TTHR, CREATE SEQUENCE, NO &gt;</span><br><span class="line">9 rows found.</span><br></pre></td></tr></table></figure><h3 id="ttisql基本命令——数据库对象操作"><a href="#ttisql基本命令——数据库对象操作" class="headerlink" title="ttisql基本命令——数据库对象操作"></a>ttisql基本命令——数据库对象操作</h3><h4 id="关闭自动提交"><a href="#关闭自动提交" class="headerlink" title="关闭自动提交"></a>关闭自动提交</h4><blockquote><p>意即每次执行事务后，均需要执行<code>commit</code>以提交事务。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; autocommit off;</span><br></pre></td></tr></table></figure><h4 id="建表、插入数据"><a href="#建表、插入数据" class="headerlink" title="建表、插入数据"></a>建表、插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command&gt; create table ttemployees</span><br><span class="line">       &gt; (employee_id NUMBER(6) NOT NULL,</span><br><span class="line">       &gt; last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB,</span><br><span class="line">       &gt; PRIMARY KEY (employee_id) )</span><br><span class="line">       &gt; UNIQUE HASH ON (employee_id) PAGES = 1;</span><br><span class="line">Command&gt; insert into ttemployees values (1, &apos;Smith&apos;, &apos;2009-02-23&apos;, &apos;excellent&apos;); </span><br><span class="line">1 row inserted.</span><br><span class="line">Command&gt; insert into ttemployees values (2, &apos;King&apos;, &apos;2005-08-05&apos;, &apos;great&apos;);</span><br><span class="line">1 row inserted.</span><br><span class="line">Command&gt; insert into ttemployees values (3, &apos;Taylor&apos;, &apos;2012-01-28&apos;, EMPTY_CLOB());</span><br><span class="line">1 row inserted.</span><br><span class="line">Command&gt; commit;</span><br></pre></td></tr></table></figure><h4 id="一些命令总结"><a href="#一些命令总结" class="headerlink" title="一些命令总结"></a>一些命令总结</h4><blockquote><ul><li>tables and alltables - Lists tables</li><li>indexes and allindexes - Lists indexes</li><li>views and allviews - Lists views</li><li>sequences and allsequences - Lists sequences</li><li>synonyms and allsynonyms - Lists synonyms</li><li>functions and allfunctions - Lists PL/SQL functions</li><li>procedures and allprocedures - Lists PL/SQL procedures</li><li>packages and allpackages - Lists PL/SQL packages</li></ul></blockquote><h3 id="PLSQL编程"><a href="#PLSQL编程" class="headerlink" title="PLSQL编程"></a>PLSQL编程</h3><h4 id="创建plsqldb、pls用户、运行sql脚本"><a href="#创建plsqldb、pls用户、运行sql脚本" class="headerlink" title="创建plsqldb、pls用户、运行sql脚本"></a>创建plsqldb、pls用户、运行sql脚本</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> ttOptUpdateStats;</span><br><span class="line">// 更新统计数据，用于分析生成最优执行计划</span><br></pre></td></tr></table></figure><h4 id="使用sql-developer连接TimesTen和Oracle"><a href="#使用sql-developer连接TimesTen和Oracle" class="headerlink" title="使用sql developer连接TimesTen和Oracle"></a>使用sql developer连接TimesTen和Oracle</h4><p>配置如下：</p><p><img src="/images/image-20181018140355729.png" alt="TimesTen数据库连接配置"></p><p><img src="/images/image-20181018140412582.png" alt="Oracle数据库连接配置"></p><h4 id="plsql语法"><a href="#plsql语法" class="headerlink" title="plsql语法"></a>plsql语法</h4><blockquote><h2 id="What-Is-a-PL-SQL-Package"><a href="#What-Is-a-PL-SQL-Package" class="headerlink" title="What Is a PL/SQL Package?"></a>What Is a PL/SQL Package?</h2><p>A <strong>package</strong> is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The <strong>specification</strong> (<strong>spec</strong> for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The <strong>body</strong> fully defines cursors and subprograms, and so implements the spec.</p><p><code>包</code>是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，<code>规范</code>和<code>主体</code>，主体不是必要的。<code>规范</code>是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。<code>主体</code>将完全定义游标和子程序，以此实现<code>规范</code>。</p><p>As <a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#5871" target="_blank" rel="noopener">Figure 9-1</a> shows, you can think of the spec as an operational interface and of the body as a “black box.” You can debug, enhance, or replace a package body without changing the interface (package spec) to the package.</p><p><img src="/images/image-20181018143452887.png" alt="包"></p><p>——<a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/09_packs.htm#362" target="_blank" rel="noopener">Oracle PL/SQL Package文档</a></p></blockquote><p><code>1_package.sql:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE PACKAGE test AS</span><br><span class="line"></span><br><span class="line">  -- Declare a record for the desired EMP fields</span><br><span class="line">  TYPE empRecType IS RECORD (</span><br><span class="line">    r_empno  EMP.EMPNO%TYPE,</span><br><span class="line">      -- 使用EMP表中EMPNO的类型</span><br><span class="line">    r_ename  EMP.ENAME%TYPE,</span><br><span class="line">    r_salary EMP.SAL%TYPE</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  -- Declare a Ref Cursor type</span><br><span class="line">  TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值</span><br><span class="line"></span><br><span class="line">  -- A parameterized cursor，定义</span><br><span class="line">  -- 游标</span><br><span class="line">  CURSOR low_paid (num PLS_INTEGER) IS</span><br><span class="line">    SELECT empno </span><br><span class="line">      FROM emp</span><br><span class="line">      WHERE rownum &lt;= num</span><br><span class="line">      ORDER BY sal ASC;</span><br><span class="line">-- 过程(IN表示输入，OUT表示输出)</span><br><span class="line">  PROCEDURE ddl_dml</span><br><span class="line">    (myComment IN  VARCHAR2,</span><br><span class="line">     errCode   OUT PLS_INTEGER, -- 整型</span><br><span class="line">     errText   OUT VARCHAR2); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PROCEDURE givePayRise</span><br><span class="line">    (num       IN  PLS_INTEGER,</span><br><span class="line">     name      OUT EMP.ENAME%TYPE, </span><br><span class="line">     -- name是plsql中的保留字，应该尽量避免使用保留字</span><br><span class="line">     errCode   OUT PLS_INTEGER,</span><br><span class="line">     errText   OUT VARCHAR2); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PROCEDURE getCommEmps</span><br><span class="line">    (empRefCur IN OUT EmpCurType,</span><br><span class="line">     errCode   OUT PLS_INTEGER,</span><br><span class="line">     errText   OUT VARCHAR2); </span><br><span class="line"></span><br><span class="line">  -- Associative array</span><br><span class="line">  TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type</span><br><span class="line">  INDEX BY PLS_INTEGER; -- indexed by pls_integer</span><br><span class="line">  </span><br><span class="line">  FUNCTION get_sum_multiples</span><br><span class="line">   ( multiple IN PLS_INTEGER,</span><br><span class="line">     num      IN PLS_INTEGER</span><br><span class="line">   ) RETURN sum_multiples;</span><br><span class="line"></span><br><span class="line">END test;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE BODY test AS</span><br><span class="line"></span><br><span class="line">  PROCEDURE ddl_dml</span><br><span class="line">    (myComment IN  VARCHAR2,</span><br><span class="line">     errCode   OUT PLS_INTEGER,</span><br><span class="line">     errText   OUT VARCHAR2) IS</span><br><span class="line"></span><br><span class="line">    sql_str                    VARCHAR2(256);</span><br><span class="line">    name_already_exists        EXCEPTION;</span><br><span class="line">    insufficient_privileges    EXCEPTION;</span><br><span class="line">    PRAGMA EXCEPTION_INIT(name_already_exists,     -0955);</span><br><span class="line">    PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031);</span><br><span class="line">    seq_value                  number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  BEGIN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BEGIN</span><br><span class="line">      sql_str := &apos;create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))&apos;;</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(sql_str);</span><br><span class="line">      execute immediate sql_str;</span><br><span class="line">    EXCEPTION</span><br><span class="line">      WHEN name_already_exists THEN</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore existing table errors&apos;);</span><br><span class="line">      WHEN insufficient_privileges THEN</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&apos;  Ignore insufficient privileges errors&apos;);</span><br><span class="line">    END;</span><br><span class="line"></span><br><span class="line">    -- Cast num_col1 and char_col values</span><br><span class="line">    insert into temp values (1, 1, myComment);</span><br><span class="line"></span><br><span class="line">    commit;</span><br><span class="line"></span><br><span class="line">    errCode := 0;</span><br><span class="line">    errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">  EXCEPTION</span><br><span class="line">  </span><br><span class="line">    WHEN name_already_exists THEN</span><br><span class="line"></span><br><span class="line">      errCode := 0;</span><br><span class="line">      errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line"></span><br><span class="line">      errCode  := SQLCODE;</span><br><span class="line">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class="line"></span><br><span class="line">  END ddl_dml;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PROCEDURE givePayRise</span><br><span class="line">    (num       IN  PLS_INTEGER,</span><br><span class="line">     name      OUT EMP.ENAME%TYPE,</span><br><span class="line">     errCode   OUT PLS_INTEGER,</span><br><span class="line">     errText   OUT VARCHAR2) IS</span><br><span class="line"></span><br><span class="line">   -- Can use PLSQL collections within TimesTen PLSQL</span><br><span class="line">   TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE;</span><br><span class="line">   lowest_paid lowest_paid_type;</span><br><span class="line"></span><br><span class="line">   i           PLS_INTEGER; </span><br><span class="line">   numRows     PLS_INTEGER;</span><br><span class="line">   lucky_index PLS_INTEGER; </span><br><span class="line">   lucky_emp   EMP.EMPNO%TYPE; </span><br><span class="line"></span><br><span class="line">  BEGIN</span><br><span class="line"></span><br><span class="line">    -- Initialize the output variable</span><br><span class="line">    name := &apos;Nobody&apos;;</span><br><span class="line"></span><br><span class="line">    -- Initialize the collection</span><br><span class="line">    lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">    i := 1;</span><br><span class="line">    </span><br><span class="line">    -- Constrain the resultset size</span><br><span class="line">    IF num &lt; 1 OR num &gt; 10 THEN</span><br><span class="line"></span><br><span class="line">      -- If bad inputs, default to 5 rows</span><br><span class="line">      numRows := 5;</span><br><span class="line">    ELSE</span><br><span class="line">      numRows := num;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- Create the cursor resultset with up to &apos;numRows&apos; rows</span><br><span class="line">    OPEN low_paid( numRows );</span><br><span class="line"></span><br><span class="line">    LOOP</span><br><span class="line"></span><br><span class="line">      -- Get the current empid</span><br><span class="line">      FETCH low_paid INTO lowest_paid(i);</span><br><span class="line"></span><br><span class="line">      EXIT WHEN low_paid%NOTFOUND;</span><br><span class="line"></span><br><span class="line">      -- Increment the PLSQL table index</span><br><span class="line">      i := i + 1;</span><br><span class="line"></span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- Close the cursor</span><br><span class="line">    CLOSE low_paid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- List the subset of lowest paid employees</span><br><span class="line">    FOR j in lowest_paid.FIRST .. numRows LOOP</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(&apos;  Lowest paid empno &apos; || j || &apos; is &apos; || lowest_paid(j) );</span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- Randomly choose one of the lowest paid employees for a 10% pay raise.</span><br><span class="line">    lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); </span><br><span class="line">    lucky_emp := lowest_paid(lucky_index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- Give lucky_emp a 10% pay raise and return their name</span><br><span class="line">    UPDATE emp</span><br><span class="line">      SET sal = sal * 1.1</span><br><span class="line">      WHERE empno = lucky_emp</span><br><span class="line">      RETURNING ename INTO name;</span><br><span class="line"></span><br><span class="line">    COMMIT;</span><br><span class="line"></span><br><span class="line">    errCode := 0;</span><br><span class="line">    errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">  EXCEPTION</span><br><span class="line">  </span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line"></span><br><span class="line">      errCode  := SQLCODE;</span><br><span class="line">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class="line"></span><br><span class="line">  END givePayRise;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PROCEDURE getCommEmps</span><br><span class="line">    (empRefCur IN OUT EmpCurType,</span><br><span class="line">     errCode   OUT PLS_INTEGER,</span><br><span class="line">     errText   OUT VARCHAR2) IS</span><br><span class="line"></span><br><span class="line">    salesGuy empRecType;</span><br><span class="line"></span><br><span class="line">  BEGIN </span><br><span class="line"></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos; &apos;);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;Displaying the refcursor for the sales people&apos;);</span><br><span class="line"></span><br><span class="line">    -- The refcursor (empRefCur) result was opened before calling this procedure</span><br><span class="line">    LOOP</span><br><span class="line">      FETCH empRefCur INTO salesGuy;</span><br><span class="line">      EXIT WHEN empRefCur%NOTFOUND;</span><br><span class="line"></span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename);</span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    CLOSE empRefCur;</span><br><span class="line"></span><br><span class="line">    errCode := 0;</span><br><span class="line">    errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">  EXCEPTION</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line"></span><br><span class="line">      errCode  := SQLCODE;</span><br><span class="line">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class="line"></span><br><span class="line">  END getCommEmps;</span><br><span class="line"></span><br><span class="line">  FUNCTION get_sum_multiples</span><br><span class="line">   ( multiple IN PLS_INTEGER,</span><br><span class="line">     num      IN PLS_INTEGER</span><br><span class="line">   ) RETURN sum_multiples</span><br><span class="line">   IS</span><br><span class="line">     s sum_multiples;</span><br><span class="line">  BEGIN</span><br><span class="line">    FOR i in 1..num LOOP</span><br><span class="line">      s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples</span><br><span class="line">    END LOOP;</span><br><span class="line">    RETURN s;</span><br><span class="line">  END get_sum_multiples;</span><br><span class="line"></span><br><span class="line">BEGIN  -- package initialization goes here</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized package test&apos;);</span><br><span class="line">END test;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><code>2_call_package.sql:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on;</span><br><span class="line"></span><br><span class="line">declare</span><br><span class="line">  errCode      PLS_INTEGER;</span><br><span class="line">  errtext      VARCHAR2(256);</span><br><span class="line">  myRefCur     test.EmpCurType; -- 使用test包中定义的类型</span><br><span class="line">  salesPerson  test.empRecType;</span><br><span class="line">  name         EMP.ENAME%TYPE;</span><br><span class="line">  n           PLS_INTEGER := 5; -- number of multiples to sum for display</span><br><span class="line">  sn          PLS_INTEGER := 10; -- number of multiples to sum</span><br><span class="line">  m           PLS_INTEGER := 3; -- multiple</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">    dbms_output.put_line(&apos; &apos;);</span><br><span class="line">    dbms_output.put_line(&apos; &apos;);</span><br><span class="line">    dbms_output.put_line(&apos; &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Find some of the lowest paid employees and give a random employee a 10% pay raise&apos;);</span><br><span class="line">    -- Give a lowely paid random employee a 10% pay raise</span><br><span class="line">    test.givePayRise(5, name, errCode, errText);</span><br><span class="line">    if errCode != 0 then</span><br><span class="line">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class="line">    else</span><br><span class="line">      dbms_output.put_line(name || &apos; got the 10% payraise&apos;);</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    -- Open a refcursor</span><br><span class="line">    OPEN myRefCur FOR</span><br><span class="line">      SELECT empno, ename, sal</span><br><span class="line">      FROM emp</span><br><span class="line">      WHERE comm IS NOT NULL;</span><br><span class="line"></span><br><span class="line">    -- display the resultset of the refcursor</span><br><span class="line">    test.getCommEmps(myRefCur, errCode, errText);</span><br><span class="line">    if errCode != 0 then</span><br><span class="line">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class="line">    end if;</span><br><span class="line"></span><br><span class="line">    dbms_output.put_line(&apos; &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Do some DDL and DML in a stored procedure&apos;);</span><br><span class="line">    test.ddl_dml(&apos;hi&apos;, errCode, errText);</span><br><span class="line">    if errCode != 0 then</span><br><span class="line">      dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class="line">    end if;</span><br><span class="line">    </span><br><span class="line">    -- associative arrays</span><br><span class="line">    dbms_output.put_line(&apos; &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Use an associative array to compute the sum of multiples&apos;);</span><br><span class="line">    dbms_output.put_line(</span><br><span class="line">      &apos;Sum of the first &apos; || TO_CHAR(n) || &apos; multiples of &apos; || TO_CHAR(m) </span><br><span class="line">       || &apos; is &apos; ||  TO_CHAR(test.get_sum_multiples (m, sn)(n)));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><code>3_create_package_workload.sql:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE PACKAGE workload AS</span><br><span class="line"></span><br><span class="line">  PROCEDURE oltp_read_only (</span><br><span class="line">    v_id      IN  PLS_INTEGER,</span><br><span class="line">    v_n       IN  PLS_INTEGER,</span><br><span class="line">    v_m       IN  PLS_INTEGER,</span><br><span class="line">    errCode   OUT PLS_INTEGER,</span><br><span class="line">    errText   OUT VARCHAR2);</span><br><span class="line"></span><br><span class="line">  PROCEDURE oltp_read_write (</span><br><span class="line">    v_id      IN  PLS_INTEGER,</span><br><span class="line">    v_n       IN  PLS_INTEGER,</span><br><span class="line">    v_m       IN  PLS_INTEGER,</span><br><span class="line">    v_c       IN  CHAR,</span><br><span class="line">    v_p       IN  VARCHAR2,</span><br><span class="line">    errCode   OUT PLS_INTEGER,</span><br><span class="line">    errText   OUT VARCHAR2);</span><br><span class="line"></span><br><span class="line">END workload;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE BODY workload AS</span><br><span class="line"></span><br><span class="line">  -- Private package variables used for package initialization</span><br><span class="line">  theErrCode PLS_INTEGER   := 0;</span><br><span class="line">  theErrText VARCHAR2(256) := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">  -- Using shared package cursors for efficiency</span><br><span class="line">  CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class="line">     SELECT c </span><br><span class="line">       FROM sbtest </span><br><span class="line">       WHERE id BETWEEN n AND m;</span><br><span class="line"></span><br><span class="line">  CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class="line">     SELECT c </span><br><span class="line">       FROM sbtest </span><br><span class="line">       WHERE id BETWEEN n AND m</span><br><span class="line">       ORDER BY c;</span><br><span class="line"></span><br><span class="line">  CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS</span><br><span class="line">     SELECT DISTINCT c </span><br><span class="line">       FROM sbtest </span><br><span class="line">       WHERE id BETWEEN n AND m</span><br><span class="line">       ORDER BY c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  -- The workload read only workload</span><br><span class="line">  PROCEDURE oltp_read_only (</span><br><span class="line">    v_id      IN  PLS_INTEGER,</span><br><span class="line">    v_n       IN  PLS_INTEGER,</span><br><span class="line">    v_m       IN  PLS_INTEGER,</span><br><span class="line">    errCode   OUT PLS_INTEGER,</span><br><span class="line">    errText   OUT VARCHAR2) IS</span><br><span class="line"></span><br><span class="line">    -- Store the result of the column &apos;c&apos;</span><br><span class="line">    cValue  char(120);</span><br><span class="line"></span><br><span class="line">    -- Store the sum of the rows in (n..m)</span><br><span class="line">    sumK    number(38,0);</span><br><span class="line"></span><br><span class="line">  BEGIN</span><br><span class="line"></span><br><span class="line">    errCode := 0;</span><br><span class="line">    errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">    -- oltp point query</span><br><span class="line">    FOR i in 1 .. 10 LOOP</span><br><span class="line"></span><br><span class="line">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class="line">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class="line">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line"></span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- oltp range query (using a cursor for loop)</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class="line">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class="line">    LOOP</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class="line">      null;</span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- olpt range SUM() query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class="line">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class="line"></span><br><span class="line">    -- oltp range ORDER BY query (using explicit fetches)</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class="line">    OPEN range_order_query(v_n, v_m);</span><br><span class="line">    LOOP</span><br><span class="line">      FETCH range_order_query INTO cValue;</span><br><span class="line">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line">    END LOOP;</span><br><span class="line">    CLOSE range_order_query;</span><br><span class="line"></span><br><span class="line">    -- oltp range DISTINCT query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class="line">    OPEN range_distinct_query(v_n, v_m);</span><br><span class="line">    LOOP</span><br><span class="line">      FETCH range_distinct_query INTO cValue;</span><br><span class="line">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line">    END LOOP;</span><br><span class="line">    CLOSE range_distinct_query;</span><br><span class="line"></span><br><span class="line">  EXCEPTION</span><br><span class="line"></span><br><span class="line">    WHEN NO_DATA_FOUND THEN</span><br><span class="line"></span><br><span class="line">      errCode  := 0;</span><br><span class="line">      errText  := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line"></span><br><span class="line">      errCode  := SQLCODE;</span><br><span class="line">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class="line"></span><br><span class="line">  END oltp_read_only;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  -- The workload read + write workload</span><br><span class="line">  PROCEDURE oltp_read_write (</span><br><span class="line">    v_id      IN  PLS_INTEGER,</span><br><span class="line">    v_n       IN  PLS_INTEGER,</span><br><span class="line">    v_m       IN  PLS_INTEGER,</span><br><span class="line">    v_c       IN  CHAR,</span><br><span class="line">    v_p       IN  VARCHAR2,</span><br><span class="line">    errCode   OUT PLS_INTEGER,</span><br><span class="line">    errText   OUT VARCHAR2) IS</span><br><span class="line"></span><br><span class="line">    -- Store the result of the column &apos;c&apos;</span><br><span class="line">    cValue  char(120);</span><br><span class="line"></span><br><span class="line">    -- Store the sum of the rows in (n..m)</span><br><span class="line">    sumK    number(38,0);</span><br><span class="line"></span><br><span class="line">  BEGIN</span><br><span class="line"></span><br><span class="line">    errCode := 0;</span><br><span class="line">    errtext := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">    -- oltp point query</span><br><span class="line">    FOR i in 1 .. 10 LOOP</span><br><span class="line"></span><br><span class="line">      -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;);</span><br><span class="line">      SELECT c INTO cValue FROM sbtest WHERE id = v_id;</span><br><span class="line">      -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line"></span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- oltp range query (using a cursor for loop)</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;);</span><br><span class="line">    FOR range_rows IN range_query(v_n, v_m)</span><br><span class="line">    LOOP</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c);</span><br><span class="line">      null;</span><br><span class="line">    END LOOP;</span><br><span class="line"></span><br><span class="line">    -- olpt range SUM() query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;);</span><br><span class="line">    SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK);</span><br><span class="line"></span><br><span class="line">    -- oltp range ORDER BY query (using explict fetches)</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;);</span><br><span class="line">    OPEN range_order_query(v_n, v_m);</span><br><span class="line">    LOOP</span><br><span class="line">      FETCH range_order_query INTO cValue;</span><br><span class="line">      EXIT WHEN range_order_query%NOTFOUND;</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line">    END LOOP;</span><br><span class="line">    CLOSE range_order_query;</span><br><span class="line"></span><br><span class="line">    -- oltp range DISTINCT query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;);</span><br><span class="line">    OPEN range_distinct_query(v_n, v_m);</span><br><span class="line">    LOOP</span><br><span class="line">      FETCH range_distinct_query INTO cValue;</span><br><span class="line">      EXIT WHEN range_distinct_query%NOTFOUND;</span><br><span class="line">--      DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue);</span><br><span class="line">    END LOOP;</span><br><span class="line">    CLOSE range_distinct_query;</span><br><span class="line"></span><br><span class="line">    -- oltp UPDATES on index column</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on index column&apos;);</span><br><span class="line">    UPDATE sbtest </span><br><span class="line">      SET k = k + 1 </span><br><span class="line">      WHERE id = v_n;</span><br><span class="line"></span><br><span class="line">    -- oltp UPDATES on non-index column</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on non-index column&apos;);</span><br><span class="line">    UPDATE sbtest </span><br><span class="line">      SET c =  v_n</span><br><span class="line">      WHERE id = v_m; </span><br><span class="line"></span><br><span class="line">    -- oltp DELETE query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp DELETE query&apos;);</span><br><span class="line">    DELETE FROM sbtest </span><br><span class="line">      WHERE id = v_n;</span><br><span class="line"></span><br><span class="line">    -- oltp INSERT query</span><br><span class="line">--    DBMS_OUTPUT.PUT_LINE(&apos;oltp INSERT query&apos;);</span><br><span class="line">    INSERT INTO sbtest (id, k, c, pad)</span><br><span class="line">      VALUES (v_n, v_m, v_c, v_p);  </span><br><span class="line"></span><br><span class="line">    -- Commit the changes</span><br><span class="line">    COMMIT;</span><br><span class="line"></span><br><span class="line">  EXCEPTION</span><br><span class="line"></span><br><span class="line">    WHEN NO_DATA_FOUND THEN</span><br><span class="line"></span><br><span class="line">      errCode  := 0;</span><br><span class="line">      errText  := &apos;OK&apos;;</span><br><span class="line"></span><br><span class="line">    WHEN OTHERS THEN</span><br><span class="line"></span><br><span class="line">      errCode  := SQLCODE;</span><br><span class="line">      errText  := SUBSTR(SQLERRM, 1, 200);</span><br><span class="line"></span><br><span class="line">  END oltp_read_write;</span><br><span class="line"></span><br><span class="line">BEGIN  -- package initialization goes here</span><br><span class="line"></span><br><span class="line">  -- Run the procedures once to initialize everything</span><br><span class="line">  oltp_read_only(1, 1, 10, theErrCode, theErrText );</span><br><span class="line">  oltp_read_write(1, 1, 10, &apos;abc&apos;, &apos;def&apos;, theErrCode, theErrText );</span><br><span class="line"></span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(&apos;Initialized the workload package&apos;);</span><br><span class="line">END workload;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><code>4_call_workload.sql:</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on;</span><br><span class="line"></span><br><span class="line">declare</span><br><span class="line">  counter    PLS_INTEGER;</span><br><span class="line">  errCode    PLS_INTEGER;</span><br><span class="line">  errtext    VARCHAR2(256);</span><br><span class="line">  line1      VARCHAR2(256);</span><br><span class="line">  line2      VARCHAR2(256);</span><br><span class="line">  someText   sbtest.c%TYPE;</span><br><span class="line">  moreText   VARCHAR2(256);</span><br><span class="line">  i          PLS_INTEGER;</span><br><span class="line">  iterations PLS_INTEGER;</span><br><span class="line">  startTime  NUMBER;</span><br><span class="line">  endTime    NUMBER;</span><br><span class="line">  duration   NUMBER;</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">  -- Initialize the someText string</span><br><span class="line">  line1 := &apos;The quick brown foxy did da jumping thing over that lazy doggy. &apos;;</span><br><span class="line">  line2 := &apos;Question three, who was scott and who or what was tiger?&apos;;</span><br><span class="line">  someText := line1 || line2;</span><br><span class="line">  moreText := &apos;&apos;;</span><br><span class="line"> </span><br><span class="line">  -- Initialize the moreText string</span><br><span class="line">  FOR i in 1 .. 60 LOOP</span><br><span class="line">    moreText := moreText || &apos;a&apos;;</span><br><span class="line">  END LOOP;</span><br><span class="line">  </span><br><span class="line">  -- Get the start time in centi-seconds</span><br><span class="line">  startTime := DBMS_UTILITY.GET_TIME();</span><br><span class="line"></span><br><span class="line">  iterations := 10000;</span><br><span class="line">  for counter in 1 .. iterations LOOP</span><br><span class="line">    workload.oltp_read_only(1, 1, 1100, errCode, errtext);</span><br><span class="line">    if errCode != 0 then</span><br><span class="line">      exit;</span><br><span class="line">    end if;</span><br><span class="line">  end loop;</span><br><span class="line"></span><br><span class="line">  -- Get the end time in centi-seconds</span><br><span class="line">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class="line">  if errCode !=0 then </span><br><span class="line">    dbms_output.put_line(&apos;  &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class="line">  end if;</span><br><span class="line">  duration := endTime - startTime;</span><br><span class="line">  IF duration &gt; 0 THEN</span><br><span class="line">    dbms_output.put_line(&apos;  &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Called workload.oltp_read_only  &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class="line">  ELSE</span><br><span class="line">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class="line">  END IF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  iterations := 10000;</span><br><span class="line">  for counter in 1 .. iterations LOOP</span><br><span class="line">    workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext);</span><br><span class="line">    if errCode != 0 then</span><br><span class="line">      exit;</span><br><span class="line">    end if;</span><br><span class="line">  end loop;</span><br><span class="line"></span><br><span class="line">  -- Get the end time in centi-seconds</span><br><span class="line">  endTime := DBMS_UTILITY.GET_TIME();</span><br><span class="line"></span><br><span class="line">  if errCode !=0 then </span><br><span class="line">    dbms_output.put_line(&apos;  &apos;);</span><br><span class="line">    dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext);</span><br><span class="line">  end if;</span><br><span class="line"></span><br><span class="line">  duration := endTime - startTime;</span><br><span class="line">  IF duration &gt; 0 THEN</span><br><span class="line">    dbms_output.put_line(&apos;Called workload.oltp_read_write &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) );</span><br><span class="line">  ELSE</span><br><span class="line">    dbms_output.put_line(&apos;Could not get valid timing info&apos;);</span><br><span class="line">  END IF;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存计算与内存数据库&quot;&gt;&lt;a href=&quot;#内存计算与内存数据库&quot; class=&quot;headerlink&quot; title=&quot;内存计算与内存数据库&quot;&gt;&lt;/a&gt;内存计算与内存数据库&lt;/h1&gt;&lt;h2 id=&quot;第零章&quot;&gt;&lt;a href=&quot;#第零章&quot; class=&quot;headerlink&quot; title=&quot;第零章&quot;&gt;&lt;/a&gt;第零章&lt;/h2&gt;&lt;p&gt;OLTP：行存储（记录：元组），联机事务处理&lt;/p&gt;
&lt;p&gt;OLAP：列存储（key-value），联机分析处理&lt;/p&gt;
&lt;h2 id=&quot;Timesten操作小记&quot;&gt;&lt;a href=&quot;#Timesten操作小记&quot; class=&quot;headerlink&quot; title=&quot;Timesten操作小记&quot;&gt;&lt;/a&gt;Timesten操作小记&lt;/h2&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="TimesTen" scheme="http://blog.guitoubing.top/tags/TimesTen/"/>
    
      <category term="内存数据库" scheme="http://blog.guitoubing.top/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C# - dotnet基本配置及EFCore连接Mysql</title>
    <link href="http://blog.guitoubing.top/2018/06/26/Dotnet/"/>
    <id>http://blog.guitoubing.top/2018/06/26/Dotnet/</id>
    <published>2018-06-26T08:57:08.000Z</published>
    <updated>2019-10-20T08:53:34.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前奏部分"><a href="#前奏部分" class="headerlink" title="前奏部分"></a>前奏部分</h2><ul><li><p>下载并安装<a href="https://www.microsoft.com/net/learn/get-started/" target="_blank" rel="noopener">dotnet core</a></p></li><li><p>下载并安装<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>（需要把vscode添加到path中）</p></li></ul><a id="more"></a><ul><li><p>vscode中搜索并安装C#插件、NuGet Package Manager插件</p><blockquote><p><img src="http://getme.guitoubing.top/image-20180607144445947.png" alt="image-20180607144445947"></p></blockquote></li><li><p>新建项目</p><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir dotnet</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> dotnet</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> dotnet new mvc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> code .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择</p><blockquote><p><img src="http://getme.guitoubing.top/image-20180607145223693.png" alt="image-20180607145123118"></p></blockquote><blockquote><p>添加包时以下代码将自动在dotnet.csproj中添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.AspNetCore.All"</span> <span class="attr">Version</span>=<span class="string">"2.0.6"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Sqlite"</span> <span class="attr">Version</span>=<span class="string">"2.1.0"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Tools"</span> <span class="attr">Version</span>=<span class="string">"2.1.0"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Sqlite.Design"</span> <span class="attr">Version</span>=<span class="string">"2.0.0-preview1-final"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Tools.DotNet"</span> <span class="attr">Version</span>=<span class="string">"2.1.0-preview1-final"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Pomelo.EntityFrameworkCore.MySql"</span> <span class="attr">Version</span>=<span class="string">"2.1.0-rc1-final"</span>/&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Pomelo.EntityFrameworkCore.MySql.Design"</span> <span class="attr">Version</span>=<span class="string">"1.1.2"</span>/&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="Model部分"><a href="#Model部分" class="headerlink" title="Model部分"></a>Model部分</h2><ul><li><p>连接数据库创建实体：</p><p>在vscode终端中输入以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotnet ef dbcontext scaffold &quot;server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;&quot; Pomelo.EntityFrameworkCore.MySql -o Models</span><br></pre></td></tr></table></figure></li><li><p>dotnet ef两个问题</p><blockquote><p>问题1：No executable found matching command “dotnet-ef”<br>解决方法：dotnet.csproj中添加如下行： </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">DotNetCliToolReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Tools.DotNet"</span> <span class="attr">Version</span>=<span class="string">"2.1.0-preview1-final"</span>/&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>问题2：Version for package <code>Microsoft.EntityFrameworkCore.Tools.DotNet</code> could not be resolved.</p><p>原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可</p></blockquote><p>此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。<strong>至此MVC已完成Model部分</strong>。</p></li></ul><h2 id="Controller及View部分"><a href="#Controller及View部分" class="headerlink" title="Controller及View部分"></a>Controller及View部分</h2><ul><li><p>目前项目Models文件夹下已有DBFirst模式生成的实体文件：</p><p><img src="http://getme.guitoubing.top/image-20180607150002112.png" alt="image-20180607150002112"></p></li><li><p>我们选择Student的Model创建C-V视图</p><blockquote><p>这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; public IActionResult Index()&#123;</span><br><span class="line">&gt;         return View(_context.Student.ToList());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，<strong>View只负责处理布局，Controller只负责处理逻辑。</strong></p></blockquote><ul><li><p>创建StudentController.cs</p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; using System;</span><br><span class="line">&gt; using System.Collections.Generic;</span><br><span class="line">&gt; using System.Diagnostics;</span><br><span class="line">&gt; using System.Linq;</span><br><span class="line">&gt; using System.Threading.Tasks;</span><br><span class="line">&gt; using Microsoft.AspNetCore.Mvc;</span><br><span class="line">&gt; using dotnet.Models;</span><br><span class="line">&gt; using dotnet;</span><br><span class="line">&gt; </span><br><span class="line">&gt; public class StudentController : Controller&#123;</span><br><span class="line">&gt;     private universityContext _context;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     public StudentController(universityContext context)&#123;</span><br><span class="line">&gt;         _context = context;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     public IActionResult Index()&#123;</span><br><span class="line">&gt;         return View(_context.Student.ToList());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     public IActionResult Register()&#123;</span><br><span class="line">&gt;         return View();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     [HttpPost]</span><br><span class="line">&gt;     [ValidateAntiForgeryToken]</span><br><span class="line">&gt;     public IActionResult Register(Student student)&#123;</span><br><span class="line">&gt;         if(ModelState.IsValid)&#123;</span><br><span class="line">&gt;             _context.Student.Add(student);</span><br><span class="line">&gt;             _context.SaveChanges();</span><br><span class="line">&gt;             return RedirectToAction(&quot;Index&quot;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         return View(student);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建Student文件夹，以及对应路由的cshtml</p><blockquote><ul><li>Index.cshtml</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; @&#123;</span><br><span class="line">&gt;     ViewData["Title"] = "学生主页";</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">&lt;!-- 此处这个model声明不能忘记 --&gt;</span></span><br><span class="line">&gt; @model IEnumerable<span class="tag">&lt;<span class="name">dotnet.Student</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">th</span>&gt;</span>Id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">th</span>&gt;</span>系<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">th</span>&gt;</span>学分<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&gt;     @foreach (var item in Model)&#123;</span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Id)</span><br><span class="line">&gt;             <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;                 @Html.DisplayFor(modelItem =&gt; item.Name)</span><br><span class="line">&gt;             <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;                 @Html.DisplayFor(modelItem =&gt; item.DeptName)</span><br><span class="line">&gt;             <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;                 @Html.DisplayFor(modelItem =&gt; item.TotCred)</span><br><span class="line">&gt;             <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>Register.cshtml</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; @model dotnet.Student</span><br><span class="line">&gt; </span><br><span class="line">&gt; @&#123;</span><br><span class="line">&gt;     ViewData["Title"] = "注册";</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">form</span> <span class="attr">asp-controller</span>=<span class="string">"Student"</span> <span class="attr">asp-action</span>=<span class="string">"Register"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">label</span> <span class="attr">asp-for</span>=<span class="string">"Id"</span> <span class="attr">class</span>=<span class="string">"col-md-2 control-label"</span>&gt;</span>编号：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-10"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">asp-for</span>=<span class="string">"Id"</span>/&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">span</span> <span class="attr">asp-validation-for</span>=<span class="string">"Id"</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">label</span> <span class="attr">asp-for</span>=<span class="string">"Name"</span> <span class="attr">class</span>=<span class="string">"col-md-2 control-label"</span>&gt;</span>名字：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-10"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">asp-for</span>=<span class="string">"Name"</span>/&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">span</span> <span class="attr">asp-validation-for</span>=<span class="string">"Name"</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">label</span> <span class="attr">asp-for</span>=<span class="string">"DeptName"</span> <span class="attr">class</span>=<span class="string">"col-md-2 control-label"</span>&gt;</span>系：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-10"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">asp-for</span>=<span class="string">"DeptName"</span>/&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">span</span> <span class="attr">asp-validation-for</span>=<span class="string">"DeptName"</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">label</span> <span class="attr">asp-for</span>=<span class="string">"TotCred"</span> <span class="attr">class</span>=<span class="string">"col-md-2 control-label"</span>&gt;</span>学分：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-10"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">asp-for</span>=<span class="string">"TotCred"</span>/&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">span</span> <span class="attr">asp-validation-for</span>=<span class="string">"TotCred"</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-offset-2 col-md-10"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"保存"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>/&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>关于抛出以下错误的解决方法</p><ul><li><p>错误：</p><blockquote><p><img src="http://getme.guitoubing.top/image-20180607142732374.png" alt="image-20180607142732374"></p></blockquote></li><li><p>解决方法：</p><blockquote><p><img src="http://getme.guitoubing.top/dotnet%E9%85%8D%E7%BD%AE.png" alt="dotnet配置"></p><p>注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             services.AddDbContext&lt;universityContext&gt;();</span><br><span class="line">&gt;             services.AddMvc();</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; //if (!optionsBuilder.IsConfigured)&#123; </span><br><span class="line">&gt; optionsBuilder.UseMySql(&quot;server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;&quot;);</span><br><span class="line">&gt; //&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><ul><li><p>调试的方法</p><blockquote><ul><li><p>vscode下点按“开始调试”</p><p><img src="http://getme.guitoubing.top/image-20180607151747548.png" alt="image-20180607151747548"></p></li><li><p>浏览器将会自动跳转至localhost:5000</p><p><img src="http://getme.guitoubing.top/image-20180607152008469.png" alt="image-20180607152008469"></p></li><li><p>在URL中添加<u>/student</u>或<u>student/index</u>跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中：</p><p><img src="http://getme.guitoubing.top/image-20180607152229016.png" alt="image-20180607152229016"></p></li></ul></blockquote></li><li><p>戳这里下载<a href="http://getme.guitoubing.top/ASP.NET%20Core%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%20,%E5%BC%A0%E5%89%91%E6%A1%A5%20,2017.04%20,Pg319_14181929.pdf" target="_blank" rel="noopener">Asp.net Core开发实战.pdf</a></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前奏部分&quot;&gt;&lt;a href=&quot;#前奏部分&quot; class=&quot;headerlink&quot; title=&quot;前奏部分&quot;&gt;&lt;/a&gt;前奏部分&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载并安装&lt;a href=&quot;https://www.microsoft.com/net/learn/get-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dotnet core&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载并安装&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vscode&lt;/a&gt;（需要把vscode添加到path中）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C#" scheme="http://blog.guitoubing.top/categories/C/"/>
    
    
      <category term=".Net" scheme="http://blog.guitoubing.top/tags/Net/"/>
    
      <category term="数据库" scheme="http://blog.guitoubing.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>我们梦中见</title>
    <link href="http://blog.guitoubing.top/2018/06/26/2017-10-14/"/>
    <id>http://blog.guitoubing.top/2018/06/26/2017-10-14/</id>
    <published>2018-06-26T04:29:17.000Z</published>
    <updated>2019-02-26T05:47:30.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“Yeah It’s on. ”</p></blockquote><h3 id="26-06-2018"><a href="#26-06-2018" class="headerlink" title="26/06/2018"></a>26/06/2018</h3><p>当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。</p><h3 id="14-10-2017"><a href="#14-10-2017" class="headerlink" title="14/10/2017"></a>14/10/2017</h3><p>（是不是个技博自己心里没点B数？</p><a id="more"></a><p>应该说<a href="http://donggu.me/" target="_blank" rel="noopener">天明学长</a>在技术方面给予了很大的支持，为她打call！</p><p>说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？</p><p>买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。</p><h3 id="接下来是干货了（扯淡"><a href="#接下来是干货了（扯淡" class="headerlink" title="接下来是干货了（扯淡"></a>接下来是干货了（扯淡</h3><p>然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到<a href="http://donggu.me/" target="_blank" rel="noopener">天明学长</a>了，在她网站中得知有了个<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>的框架，仿佛看到了未来。至于<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>怎么用，<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>里面都很详尽了，这里讲几点用的时候踩过的坑，以备。</p><h4 id="config-YML配置，比较重要的几个地方"><a href="#config-YML配置，比较重要的几个地方" class="headerlink" title="_config.YML配置，比较重要的几个地方"></a>_config.YML配置，比较重要的几个地方</h4><h5 id="路径URL"><a href="#路径URL" class="headerlink" title="路径URL"></a>路径URL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http://guitoubing.top/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure><ul><li>url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错</li><li>在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。</li></ul><h5 id="Disqus插件"><a href="#Disqus插件" class="headerlink" title="Disqus插件"></a><a href="https://disqus.com/" target="_blank" rel="noopener">Disqus插件</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Disqus settings</span><br><span class="line">disqus_username: guitoubing</span><br></pre></td></tr></table></figure><p>因为多说已经关闭服务了，只能用<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>，而<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题<a href="https://github.com/kaijun/hexo-theme-huxblog/" target="_blank" rel="noopener">hexo-theme-huxblog</a>已经集成了<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 </p><h2 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Analytics settings</span><br><span class="line"># Baidu Analytics</span><br><span class="line">ba_track_id: bcfce8e737b***********04c164dc96</span><br><span class="line"># Google Analytics</span><br><span class="line">ga_track_id: &apos;UA-10*******-1&apos;            # Format: UA-xxxxxx-xx</span><br><span class="line">ga_domain: guitoubing.top</span><br></pre></td></tr></table></figure><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: ftpsync</span><br><span class="line">  host: guitoubing.top</span><br><span class="line">  user: webmaster@HK******</span><br><span class="line">  pass: tanrui106</span><br><span class="line">  remote: /WEB/</span><br><span class="line">  port: 21</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">deploy</a>就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。</p><h2 id="config-YML配置完成了就可以开始创作咯"><a href="#config-YML配置完成了就可以开始创作咯" class="headerlink" title="_config.YML配置完成了就可以开始创作咯"></a>_config.YML配置完成了就可以开始创作咯</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;blog&quot; </span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>都有详细使用方法，不赘述。</p><h2 id="有几句MMP当讲"><a href="#有几句MMP当讲" class="headerlink" title="有几句MMP当讲"></a>有几句MMP当讲</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？</span><br></pre></td></tr></table></figure><p>从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;26-06-2018&quot;&gt;&lt;a href=&quot;#26-06-2018&quot; class=&quot;headerlink&quot; title=&quot;26/06/2018&quot;&gt;&lt;/a&gt;26/06/2018&lt;/h3&gt;&lt;p&gt;当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。&lt;/p&gt;
&lt;h3 id=&quot;14-10-2017&quot;&gt;&lt;a href=&quot;#14-10-2017&quot; class=&quot;headerlink&quot; title=&quot;14/10/2017&quot;&gt;&lt;/a&gt;14/10/2017&lt;/h3&gt;&lt;p&gt;（是不是个技博自己心里没点B数？&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://blog.guitoubing.top/categories/life/"/>
    
    
      <category term="Hexo" scheme="http://blog.guitoubing.top/tags/Hexo/"/>
    
  </entry>
  
</feed>
