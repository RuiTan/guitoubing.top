<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en,zh-cn,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.1"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=7.0.1">


  <link rel="mask-icon" href="/images/favicon.png?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="垃圾回收器—GC众所周知，Java中的GC负责回收无用对象占用的内存资源，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于GC只释放那些经由new分配的内存，所以GC不知道如何释放该对象的这块”特殊”内存区域。 作为应对，Java允许在类中定义finalize()方法，它使得在GC回收该对象内存之前先调用finalize()方法，并在下一次GC回收发生时，真正回收">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习Java（更新中）">
<meta property="og:url" content="http://blog.guitoubing.top/2019/03/06/深入学习Java（更新中）/index.html">
<meta property="og:site_name" content="Archer">
<meta property="og:description" content="垃圾回收器—GC众所周知，Java中的GC负责回收无用对象占用的内存资源，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于GC只释放那些经由new分配的内存，所以GC不知道如何释放该对象的这块”特殊”内存区域。 作为应对，Java允许在类中定义finalize()方法，它使得在GC回收该对象内存之前先调用finalize()方法，并在下一次GC回收发生时，真正回收">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225225057306.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225225802212.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225230110077.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225230647640.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225232204967.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225232407098.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190225232630665.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190308105552914.png">
<meta property="og:image" content="http://blog.guitoubing.top/images/image-20190312200304819.png">
<meta property="og:updated_time" content="2019-03-27T16:25:32.529Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入学习Java（更新中）">
<meta name="twitter:description" content="垃圾回收器—GC众所周知，Java中的GC负责回收无用对象占用的内存资源，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于GC只释放那些经由new分配的内存，所以GC不知道如何释放该对象的这块”特殊”内存区域。 作为应对，Java允许在类中定义finalize()方法，它使得在GC回收该对象内存之前先调用finalize()方法，并在下一次GC回收发生时，真正回收">
<meta name="twitter:image" content="http://blog.guitoubing.top/images/image-20190225225057306.png">



  <link rel="alternate" href="/atom.xml" title="Archer" type="application/atom+xml"/>




  <link rel="canonical" href="http://blog.guitoubing.top/2019/03/06/深入学习Java（更新中）/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>深入学习Java（更新中） | Archer</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=UA-108090005-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-108090005-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archer</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">我们梦中见</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br/>Sitemap</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/ruitan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.guitoubing.top/2019/03/06/深入学习Java（更新中）/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rui"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/favicon.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archer"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入学习Java（更新中）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-06 21:01:30" itemprop="dateCreated datePublished" datetime="2019-03-06T21:01:30+08:00">2019-03-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-28 00:25:32" itemprop="dateModified" datetime="2019-03-28T00:25:32+08:00">2019-03-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/archives/" itemprop="url" rel="index"><span itemprop="name">archives</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="垃圾回收器—GC"><a href="#垃圾回收器—GC" class="headerlink" title="垃圾回收器—GC"></a>垃圾回收器—GC</h2><p>众所周知，Java中的GC负责回收<strong>无用对象占用的内存资源</strong>，但会有特殊情况：假定对象获得了一块”特殊”的内存区域（不是使用new创建的），由于<strong>GC只释放那些经由new分配的内存</strong>，所以GC不知道如何释放该对象的这块”特殊”内存区域。</p>
<p>作为应对，Java允许在类中定义<code>finalize()</code>方法，它使得在GC回收该对象内存之前先调用<code>finalize()</code>方法，并在下一次GC回收发生时，真正回收对象内存。举个例子：某个对象创建时会在屏幕上绘出一些图像，当没有明确将其从屏幕擦除时，图像便可能会永远存在在屏幕上，若在<code>finalize()</code>指定擦除的方法，那么在GC回收该对象时将会同时将其图像从屏幕上擦除。</p>
<p><strong>关键点：</strong></p>
<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等于”析构”</li>
<li>垃圾回收只与内存有关</li>
</ol>
<h3 id="避免使用finalize"><a href="#避免使用finalize" class="headerlink" title="避免使用finalize()"></a>避免使用finalize()</h3><blockquote>
<p>“终结函数无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页</p>
</blockquote>
<p>在Java中一切皆为对象，且创建对象的方法只有new，那么必然存在<strong>通过某种创建对象以外的方式为对象分配了存储空间</strong>。</p>
<p>Native Method(本地方法)是Java中调用非Java代码的方式，此时非Java代码中可能使用了malloc()等分配内存的函数而未使用free()对其释放，此时GC也不会去管这块内存，这就使得需要指定特定的finalize()方法来实现内存的释放。</p>
<p>可见，finalize()不是进行普遍的清理工作的合适方式，因此需要避免使用。</p>
<h3 id="终结条件的验证"><a href="#终结条件的验证" class="headerlink" title="终结条件的验证"></a>终结条件的验证</h3><p>但是finalize()有个有趣的用法——终结条件。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="comment">// Book类，约定其在被回收前必须被签入。</span></span><br><span class="line">	<span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line">	Book(<span class="keyword">boolean</span> checkedOut)&#123;</span><br><span class="line">		checkedOut = checkedOut;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">		checkedOut = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 终结条件，对象未被签入</span></span><br><span class="line">		<span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Error: checked out"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Book对象-novel</span></span><br><span class="line">		Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 将其签入</span></span><br><span class="line">		novel.checkIn();</span><br><span class="line">        <span class="comment">// 创建一个Book对象，此时该对象未被签入</span></span><br><span class="line">		<span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 强制执行垃圾回收，此时会先执行finalize</span></span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">Error: checked out</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们约定所有的Book对象在创建之前都必须被签入，但是在main中，由于疏忽有个新创建的对象未执行签入操作，此时执行垃圾回收，finalize()中的终结条件被激活，把错误反馈给使用者。</p>
<blockquote>
<p>注意这里使用的System.gc()强制调用垃圾回收器</p>
</blockquote>
<p>若没有finalize()将很难实现这种操作。</p>
<h3 id="GC如何工作"><a href="#GC如何工作" class="headerlink" title="GC如何工作"></a>GC如何工作</h3><h4 id="引用计数（未被使用过）"><a href="#引用计数（未被使用过）" class="headerlink" title="引用计数（未被使用过）"></a>引用计数（未被使用过）</h4><p>对象创建时便有引用计数，当引用计数变为0时，GC回收该对象内存空间。</p>
<p>缺陷：循环引用不适用，即出现”对象应该被回收，但引用计数不为0”的情况，称作”交互自引用的对象组”。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器：1</span></span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器：1</span></span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器：2</span></span><br><span class="line">        object1.object = object2;</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器：2</span></span><br><span class="line">        object2.object = object1;</span><br><span class="line">        <span class="comment">// object1指向的对象引用计数器减少为1</span></span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// object2指向的对象引用计数器减少为1</span></span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将<code>object1</code>和<code>object2</code>赋值为null，意即我们已经不需要该对象，但由于此时对象的引用计数器不为0导致这两个对象永远不会被回收。</p>
<h4 id="停止-复制（stop-and-copy）"><a href="#停止-复制（stop-and-copy）" class="headerlink" title="停止-复制（stop-and-copy）"></a>停止-复制（stop-and-copy）</h4><p>遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，将堆中<strong>所有存活的对象复制到另一个堆中</strong>，没有被复制的便都是垃圾了。</p>
<p>这种策略避免了上述”交互自引用的对象组”无法回收的情况，因为这两个对象不会被看作是存活的对象，即遍历的过程中根本找不到这两个对象（他们不在从GC Root出发连接所有存活结点构成的图中）。</p>
<p><strong>缺陷：效率低</strong></p>
<ol>
<li>复制需要在两个堆之间操作，即需要维护多一倍的空间；</li>
<li>当程序进入稳定状态之后，可能只产生少量垃圾，此时此策略仍然需要进行复制操作，很浪费。</li>
</ol>
<p>针对第2个情况，有另外一种策略，如下。</p>
<h4 id="标记-清扫（mark-and-sweep）"><a href="#标记-清扫（mark-and-sweep）" class="headerlink" title="标记-清扫（mark-and-sweep）"></a>标记-清扫（mark-and-sweep）</h4><p>同样遍历所有<strong>引用</strong>找到所有”活”的<strong>对象</strong>，同时会给该对象进行<strong>标记</strong>，当全部标记工作完成后，开始进行清理工作。没有被标记的对象将会被释放，因此剩下的堆空间是不连续的，此时GC需要使用其他整理的方法来清理内存碎片，称作”标记-整理”。</p>
<blockquote>
<p>注意，上面两种垃圾回收机制都不是在后台进行的，意即进行垃圾回收时会暂停程序。</p>
<p>许多文献中有关于”垃圾回收器是低优先级的后台进程”的说法，事实上早期版本的JVM使用这两种策略时并非如此。当可用内存不足时，垃圾回收器会暂停运行程序，而后开展”停止-复制”或”标记-清扫”工作。</p>
</blockquote>
<p>“标记-清扫”方式速度相当慢，但是当垃圾很少时，就很快了。</p>
<h4 id="自适应技术"><a href="#自适应技术" class="headerlink" title="自适应技术"></a>自适应技术</h4><p>JVM会进行监视，如果所有对象都很稳定，GC的效率降低的话，就切换到”标记-清扫”方式；同样，JVM也会跟踪”标记-清扫”方式，若堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是自适应技术。</p>
<p>这是早期Sun版本的垃圾回收器。</p>
<h4 id="分代垃圾收集（Generational-Garbage-Collection）"><a href="#分代垃圾收集（Generational-Garbage-Collection）" class="headerlink" title="分代垃圾收集（Generational Garbage Collection）"></a>分代垃圾收集（Generational Garbage Collection）</h4><p>上述无论是”停止-复制”、”标记-清扫”还是”标记-整理”对于日益增长的对象列表，效率会逐渐低下。</p>
<p><img src="/images/image-20190225225057306.png" alt="image-20190225225057306"></p>
<p>堆被分为三代：</p>
<ul>
<li><p>年轻代(Young Generation)</p>
<p>内存空间：<strong>eden:S0:S1 = 8:1:1</strong></p>
<p>S0和S1<strong>没有先后顺序</strong>，任何一个都可能是<strong>From survivor space</strong>和<strong>To survivor space</strong></p>
</li>
<li><p>年老代(Old Generation)</p>
<p>内存空间：年老代:年轻代 ≈ 2:1</p>
</li>
<li><p>持久代(Permanent Generation)</p>
<p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
</li>
</ul>
<p>下面说明一下对象在分配内存、老化、回收的过程：</p>
<ol>
<li><p>首先，任何新对象创建时内存都会分配在年轻代的<strong>eden space</strong>中，<strong>S0</strong>和<strong>S1</strong>两个<strong>幸存者空间(survivor space)</strong>起初都是空的<img src="/images/image-20190225225802212.png" alt="image-20190225225802212"></p>
</li>
<li><p>当eden space满时，会触发第一次<strong>较小的垃圾回收过程(minor garbage collection，minor GC)</strong><img src="/images/image-20190225230110077.png" alt="image-20190225230110077"></p>
<blockquote>
<p>实际上MinorGC不一定要等到eden space满了才触发</p>
</blockquote>
</li>
<li><p>eden space中所有存活对象(referenced objects)被复制到S0，其余对象(unreferenced objects)被视作垃圾，随eden space一起被回收<img src="/images/image-20190225230647640.png" alt="image-20190225230647640"></p>
</li>
<li><p>当下一次minor GC被触发时，eden space执行与第3点中相同的步骤，不过此时存活对象会被复制到S1，同时S0中的存活对象也会被复制到S1，此时S0和eden space都被回收。注意到此时S1有不同老化程度的对象<img src="/images/image-20190225232204967.png" alt="image-20190225232204967"></p>
</li>
<li><p>再当下一次minor GC被触发时，重复上述操作，幸存者空间变为S0，eden和S1中的存活对象都被复制到S0，同时老化，此时S1和eden space都被回收<img src="/images/image-20190225232407098.png" alt="image-20190225232407098"></p>
</li>
<li><p>当minor GC持续触发到对象老化程度达到一个阈值(此处为8)时，这些对象从年轻代提升到年老代<img src="/images/image-20190225232630665.png" alt="image-20190225232630665"></p>
</li>
<li><p>以上过程涵盖了整个年轻代老化的过程，最终，会在年老代触发<strong>完全的垃圾回收(major gabarge collector, major GC)</strong>，清理并压缩该块内存空间。</p>
<p>major GC被触发的原因：</p>
<ol>
<li><p>年老代（Tenured）被写满</p>
</li>
<li><p>持久代（Permanent）被写满</p>
</li>
<li><p>System.gc()被显式调用</p>
</li>
<li><p>上一次GC之后Heap的各域分配策略动态变化</p>
</li>
</ol>
</li>
</ol>
<h5 id="HotSpot-JVM的垃圾收集器"><a href="#HotSpot-JVM的垃圾收集器" class="headerlink" title="HotSpot JVM的垃圾收集器"></a>HotSpot JVM的垃圾收集器</h5><p><strong>Serial收集器（复制算法)</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
<p><strong>Serial Old收集器(标记-整理算法)</strong>：老年代单线程收集器，Serial收集器的老年代版本。</p>
<p><strong>ParNew收集器(停止-复制算法)</strong>：新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>
<p><strong>Parallel Scavenge收集器(停止-复制算法)</strong>：并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
<p><strong>Parallel Old收集器(停止-复制算法)</strong>：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
<p><strong>CMS(Concurrent Mark Sweep)收集器(标记-清扫算法)</strong>：高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>
<p>【参考：<a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解JVM(3)——7种垃圾收集器</a>】</p>
<h2 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h2><p>Java中的可变参数列表（JSE5之后）的使用与C的使用类似，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Integer a = <span class="number">1</span>;</span><br><span class="line">		Integer b = <span class="number">2</span>;</span><br><span class="line">		Integer c = <span class="number">3</span>;</span><br><span class="line">		Other.main(a, b);</span><br><span class="line">		Other.main(a, b, c);</span><br><span class="line">        Other.main();</span><br><span class="line">        Other.main(<span class="keyword">new</span> Object[]&#123;a, b&#125;);</span><br><span class="line">		Other.main(<span class="keyword">new</span> Object[]&#123;a, b, c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Object s : args)&#123;</span><br><span class="line">			System.out.println(s + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，当输入不同个数参数时，编译器会自动将其<strong>转换成数组</strong>，当参数本身就是数组时，编译器又<strong>不会进行转换</strong>，直接传递给函数。参数为空时编译器便<strong>直接传递一个空Object数组</strong>。</p>
<h3 id="可变参数列表的重载"><a href="#可变参数列表的重载" class="headerlink" title="可变参数列表的重载"></a>可变参数列表的重载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"first"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"second"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">		f(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，函数有<code>f(Character... args)</code>和<code>f(String... args)</code>两种重载方式，此时<code>f(&#39;a&#39;, &#39;b&#39;)</code>和<code>f(&quot;a&quot;, &quot;b&quot;)</code>都可正常调用，但是<code>f()</code>会报错，即两种重载都匹配。</p>
<p>此时可通过为其中一个重载函数添加一个非可变参数（可变参数必须位于参数列表最后）。但这样又会产生新的问题，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"first"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"second"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		f(<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">		f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，编译器也会报错，<code>f(&#39;a&#39;, &#39;b&#39;)</code>可匹配两个函数，(可能是)因为<code>char</code>类型可提升至<code>float</code>类型从而匹配第一个重载函数。</p>
<p>此时可为第二个重载函数也添加一个非可变参数，问题可得到解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"first"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> i, Character... args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"second"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		f(<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">		f(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种用法比较奇怪，因此”你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它”（《Java编程思想》105页）。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类对象对外围类对象的访问"><a href="#内部类对象对外围类对象的访问" class="headerlink" title="内部类对象对外围类对象的访问"></a>内部类对象对外围类对象的访问</h3><p>当外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向外围类对象的引用，因此内部类对象可以访问外部类对象的所有成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; items = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; items.length)&#123;</span><br><span class="line">            items[next++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span>(!selector.end())&#123;</span><br><span class="line">            System.out.print(selector.current() + <span class="string">" "</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sequence中的内部类SequenceSelector可以访问Sequence的全部成员，就像SequenceSelector自己拥有这些成员一样。</p>
<h3 id="内部类与静态内部类（嵌套类）"><a href="#内部类与静态内部类（嵌套类）" class="headerlink" title="内部类与静态内部类（嵌套类）"></a>内部类与静态内部类（嵌套类）</h3><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类：DotNew.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner dni = dn.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类：DotNewStatic.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNewStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        Inner() &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建静态内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNewStatic.Inner inner = <span class="keyword">new</span> DotNewStatic.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>Java支持<strong>创建一个继承自某基类的匿名类的对象</strong>，通过new表达式返回的引用被<strong>自动向上转型为对基类的引用</strong>。</p>
<p>匿名内部类可以使用默认构造器生成，也可以使用有参数的构造器。</p>
<p>注意，在匿名内部类中若想使用外部定义的对象，该外部对象的参数引用必须是<code>final</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Destination.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parcel9.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span></span>&#123;<span class="comment">// 外部变量dest被引用时需声明为final，否则产生编译时错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</span><br><span class="line">        Destination d = p.destination(<span class="string">"Tasmania"</span>);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是我使用的Java 10中，当dest不声明为final时也不会报错，虽然不会报错，但是当更改dest引用时会报前面所述的编译时错误（Local variable dest defined in an enclosing scope must be final or effectively final）。</p>
</blockquote>
<blockquote>
<p><strong>为什么匿名内部类访问外部变量必须是final的？</strong></p>
<ol>
<li><p>为了避免<strong>外部方法修改引用导致内部类得到的引用值不一致</strong>和<strong>内部类修改引用而导致外部方法的参数值在修改前和修改后不一致</strong></p>
</li>
<li><p>保证回调函数回调时可访问到变量（<strong>待研究</strong>）</p>
</li>
<li><p>反编译查看其实现细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;    <span class="comment">// 源代码</span></span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useMyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">final</span> Integer number = <span class="number">123</span>;</span><br><span class="line">&gt;            System.out.println(number);</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            MyInterface myInterface = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;                    System.out.println(number);</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;;</span><br><span class="line">&gt;            myInterface.doSomething();</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            System.out.println(number);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="comment">// 反编译结果</span></span><br><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">TryUsingAnonymousClass</span>$1</span></span><br><span class="line"><span class="class">&gt;            <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">final</span> TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">final</span> Integer paramInteger;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        TryUsingAnonymousClass$<span class="number">1</span>(TryUsingAnonymousClass <span class="keyword">this</span>$<span class="number">0</span>, Integer paramInteger) &#123;</span><br><span class="line">&gt;            <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt;            <span class="keyword">this</span>.paramInteger = paramInteger;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(<span class="keyword">this</span>.paramInteger);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>   注意到，number在实际使用时是作为构造函数的参数传入到匿名内部类的，也就是说匿名类内部在使用外部变量时<strong>实际上是做了个”拷贝”</strong>或者说<strong>“赋值”</strong>。若可以更改，则会造成数据不一致。</p>
</blockquote>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI(Run-Time Type Identifier)是Java能在运行时自动识别出某个类型的保证（RTTI在Java运行时维护类的相关信息），是<strong>多态的基础</strong>，由<strong>Class类实现</strong>。</p>
<h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>每当编写并且编译一个类时，在与类同名的<code>.class</code>文件中会自动产生一个<code>Class对象</code>。实现此过程的JVM子系统被称作<strong>类加载器</strong>。</p>
<p>Class对象仅在需要的时候才被加载，也就是所有的类都是<strong>只在对其第一次使用时</strong>，动态加载到JVM中的。所谓第一次使用指的是<strong>对类的非常量静态域的第一次引用。</strong></p>
<ul>
<li><p>要注意，<strong>类的构造器</strong>是<strong>隐性非常量静态域</strong>，所以使用new操作符生成对象也是产生这样的Class类引用。</p>
</li>
<li><p>与此同时，还可以使用<code>Class.forName(类名)</code>产生Class对象的引用，告诉JVM去加载这个类。当JVM未找到这个类，会抛出异常<code>ClassNotFoundException</code>。比如在JDBC连接数据库时常常用到的<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，就是告诉JVM去加载MySQL驱动。</p>
</li>
<li><p>当已经拥有某个类型的对象（实例）时，可通过调用<code>getClass()</code>方法来获取该类型的Class引用。</p>
</li>
<li><p>另一种方法，使用<strong>类字面变量</strong>。通过使用<code>类名.class</code>可获取此类的Class对象的引用，但是注意，此时<strong>此Class对象还未被初始化</strong>，还需要等到上述的<code>对类的非常量静态域的第一次引用</code>这一操作执行时才被初始化。</p>
<blockquote>
<p>使用.class方法获取Class对象引用实际包含三个步骤：</p>
<ol>
<li><strong>加载</strong>：类加载器创建Class对象</li>
<li><strong>链接</strong></li>
<li><strong>初始化</strong>：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li>
</ol>
<p>考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> java.util.Random;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">3</span>;</span><br><span class="line">&gt;     <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">&gt;         <span class="comment">// 创建Initable的Class对象的引用，Class对象未初始化</span></span><br><span class="line">&gt;         Class initable = Initable.class;</span><br><span class="line">&gt;         <span class="comment">// 仍然未初始化，因Initable.staticFinal是常数</span></span><br><span class="line">&gt;         System.out.println(Initable.staticFinal);</span><br><span class="line">&gt;         <span class="comment">// 触发了Initable的Class对象的初始化</span></span><br><span class="line">&gt;         System.out.println(Initable.staticFinal2);</span><br><span class="line">&gt;         <span class="comment">// 触发了Initable2的Class对象的初始化</span></span><br><span class="line">&gt;         System.out.println(Initable2.staticNonFinal);</span><br><span class="line">&gt;         <span class="comment">// 创建Initable3的Class对象的引用，同时会初始化此Class对象</span></span><br><span class="line">&gt;         Class initable3 = Class.forName(<span class="string">"Initable3"</span>);</span><br><span class="line">&gt;         <span class="comment">// 此时已初始化，无需再次初始化</span></span><br><span class="line">&gt;         System.out.println(Initable3.staticNonFinal);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>另外，当我拥有某个Class对象c的时候，我虽然<strong>不知道它确切类型</strong>，但是可以使用<code>c.newInstance()</code>来正确地获取c代表的类型的实例。<strong>但是此方法要求对应的类</strong>。</p>
<h3 id="泛化的Class对象引用"><a href="#泛化的Class对象引用" class="headerlink" title="泛化的Class对象引用"></a>泛化的Class对象引用</h3><p>Class对象可以通过<code>Class&lt;Type&gt;</code>的方法产生特定类型的类引用，创建了<strong>使用类型限定后</strong>的Class对象引用<strong>不能再赋值给除本身和子类的其他的Class对象</strong>。</p>
<blockquote>
<p>注意这里的子类指的是Class对象的继承关系，而不是类本身的继承关系，如<code>Integer</code>继承自<code>Number</code>，而<code>Integer Class对象</code>却不是<code>Number Class对象</code>的子类。</p>
</blockquote>
<p>使用通配符<code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>（实际上是等价的），而且会免除编译器警告，看图：<img src="/images/image-20190308105552914.png" alt="image-20190308105552914"></p>
<p>一种更好的用法，<code>Class&lt;? extends Type&gt;</code>，这种类型限定比直接<code>Class&lt;Type&gt;</code>好的地方在于他产生的Class对象引用<strong>可赋值给Type本身及子类的Class对象</strong>，这种继承关系<strong>是Type所属的继承关系</strong>而<strong>不是对应的Class对象的继承关系</strong>。</p>
<h3 id="转型语法（不常用）"><a href="#转型语法（不常用）" class="headerlink" title="转型语法（不常用）"></a>转型语法（不常用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasts</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Building b = <span class="keyword">new</span> Building();</span><br><span class="line">        Class&lt;House&gt; houseType = House.class;</span><br><span class="line">        House h = houseType.cast(b);</span><br><span class="line">        h = (House) b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，使用<code>houseType.cast(b)</code>和<code>(House) b</code>效果一样，但是执行的工作却不同，具体内部实现尚未学习到。</p>
<h3 id="动态的类型检测"><a href="#动态的类型检测" class="headerlink" title="动态的类型检测"></a>动态的类型检测</h3><h4 id="obj-instanceof-ClassType"><a href="#obj-instanceof-ClassType" class="headerlink" title="obj instanceof ClassType"></a>obj instanceof ClassType</h4><p>返回一个布尔值，告诉我们某个对象是不是某个特定类型的实例。</p>
<h4 id="ClassType-isInstance"><a href="#ClassType-isInstance" class="headerlink" title="ClassType.isInstance()"></a>ClassType.isInstance()</h4><p>返回一个布尔值，告诉我们某个对象的类型是不是可以被强转为某个特定类型。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>区别主要是后者与前者动态等价，看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicEqual</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// instanceof关键词后面必须跟类型的名称，意即其必须首先知道类型名称</span></span><br><span class="line">        <span class="comment">// if (son instanceof father.getClass())&#123;</span></span><br><span class="line">        <span class="comment">//     ...</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// isInstance()方法是类对象的方法，任何一种类型的类对象的引用都可调用该方法，简言之，其前面的Class类对象是可动态的。</span></span><br><span class="line">        <span class="keyword">if</span> (father.getClass().isInstance(son))&#123;</span><br><span class="line">            System.out.println(<span class="string">"isInstance is Dynamic"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>isInstance()</code>的存在可以替代<code>instanceof</code>，而且可使得代码更简洁。比如说有多个类{A1,A2,A3,…}都继承自A，现有一个A对象实例，要判断其为子类中的哪一个从而产生不同响应时：</p>
<ul>
<li>使用<code>instanceof</code>时可能需要使用<code>switch-case</code>语句；当需要添加一个子类时，需要修改<code>switch-case</code>内部代码。</li>
<li>而使用<code>isInstance()</code>时，可创建一个列表存储所有的子类类型，主程序只需要使用一个循环检测该实例即可；当需要添加一个子类时，只需要修改子类类型列表而不用修改程序代码。</li>
</ul>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="反射与RTTI的区别"><a href="#反射与RTTI的区别" class="headerlink" title="反射与RTTI的区别"></a>反射与RTTI的区别</h4><ul>
<li>RTTI：编译器在编译时打开和检查<code>.class</code>文件（获取类的Class类对象信息）</li>
<li>反射：JVM在运行时打开和检查<code>.class</code>文件（编译时可能没有此文件，但是在运行时必须在本地机器或者网络上获取<code>.class</code>文件）</li>
</ul>
<h4 id="类方法提取器"><a href="#类方法提取器" class="headerlink" title="类方法提取器"></a>类方法提取器</h4><p>通过Class对象引用：调用<code>getMethods()</code>方法获取该类及其父类的方法列表，调用<code>getConstructors()</code>方法获取该类的构造方法列表。要注意能获得的方法与该类的访问权限有关，一个<strong>非public类的非public方法是无法被获取的</strong>。</p>
<h4 id="接口与类型信息"><a href="#接口与类型信息" class="headerlink" title="接口与类型信息"></a>接口与类型信息</h4><p>interface关键字的一种重要目标就是允许程序员<strong>隔离构件，进而降低耦合性</strong>。</p>
<h4 id="包权限安全吗？"><a href="#包权限安全吗？" class="headerlink" title="包权限安全吗？"></a>包权限安全吗？</h4><p>直接看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HiddenC.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public C.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public C.g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"package C.u()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"protected C.v()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private C.w()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HiddenImplementation.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        A a = HiddenC.makeA();</span><br><span class="line">        a.f();</span><br><span class="line">        System.out.println(a.getClass().getName());</span><br><span class="line">        callHiddenMethod(a, <span class="string">"g"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"u"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"v"</span>);</span><br><span class="line">        callHiddenMethod(a, <span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callHiddenMethod</span><span class="params">(Object a, String methodName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取a中的方法</span></span><br><span class="line">        Method g = a.getClass().getDeclaredMethod(methodName);</span><br><span class="line">        <span class="comment">// 修改该方法的权限</span></span><br><span class="line">        g.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用该方法</span></span><br><span class="line">        g.invoke(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">public C.f()</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">public C.g()</span></span><br><span class="line"><span class="comment">package C.u()</span></span><br><span class="line"><span class="comment">protected C.v()</span></span><br><span class="line"><span class="comment">private C.w()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当我知道一个类中有哪些方法时，哪怕是private方法仍然可以在使用<code>setAccessble(true)</code>后被调用。</li>
<li>只发布<code>.class</code>文件也是没办法避免此问题，<code>javap -private</code>命令可以反编译<code>.class</code>文件，<code>-private</code>参数约定显示所有的成员</li>
<li>同样，内部类和匿名内部类也是没办法避免此情况</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="指定类型有保证吗？"><a href="#指定类型有保证吗？" class="headerlink" title="指定类型有保证吗？"></a>指定类型有保证吗？</h3><blockquote>
<p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>
</blockquote>
<p>例如对于<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>，二者的实例调用<code>.getClass()</code>获取的Class对象时相同的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erase</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; s = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class&lt;?&gt; i = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(s == i);</span><br><span class="line">        System.out.println(s.getName());</span><br><span class="line">        System.out.println(s.getTypeParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">java.util.ArrayList</span></span><br><span class="line"><span class="comment">[Ljava.lang.reflect.TypeVariable;@68f7aae2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>但是，如果在一个<code>ArrayList&lt;String&gt;</code>类型的实例中添加<code>Integer</code>会报编译期错误，这个很容易理解（静态类型检查）。但是上述的Class对象相同有给了我们可乘之机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is an apple"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectAdd</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; s = strings.getClass();</span><br><span class="line">        Method method = s.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(strings, <span class="number">1</span>);</span><br><span class="line">        method.invoke(strings, <span class="string">"2"</span>);</span><br><span class="line">        method.invoke(strings, <span class="number">3</span>);</span><br><span class="line">        method.invoke(strings, <span class="keyword">new</span> Apple());</span><br><span class="line">        System.out.println(Arrays.toString(strings.toArray()));</span><br><span class="line">        <span class="keyword">for</span> (Object o : strings)&#123;</span><br><span class="line">            System.out.println(o.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[1, 2, 3, This is an apple]</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">class Apple</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到上述代码使用反射机制成功的在<code>ArrayList&lt;String&gt;</code>里面添加了<code>Integer</code>，原因在于<code>ArrayList</code>的泛型实现<code>ArrayList&lt;E&gt;</code>使其被擦除为<code>ArrayList&lt;Object&gt;</code>，从而通过反射机制找到其<code>add(E e)</code>方法时，实际上是<code>add(Object o)</code>，而我们代码中的<code>Method method = s.getMethod(&quot;add&quot;, Object.class);</code>恰好可以找到包含这样一个参数列表的add方法，后面也就理所当然的可以添加任意类型(甚至是自定义的Apple类)的实例了。</p>
<h3 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++的区别"></a>与C++的区别</h3><p><strong>C++:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulator</span> &#123;</span></span><br><span class="line">    T obj;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Manipulator(T x) &#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manipulate2</span><span class="params">()</span> </span>&#123; obj.noF(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF()::f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontHaveF</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">noF</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Don't have f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasF hf;</span><br><span class="line">    Manipulator&lt;HasF&gt; manipulator(hf);</span><br><span class="line">    manipulator.manipulate();</span><br><span class="line">    <span class="comment">// manipulator.manipulate2();  无法编译</span></span><br><span class="line">    DontHaveF dhf;</span><br><span class="line">    Manipulator&lt;DontHaveF&gt; manipulator2(dhf);</span><br><span class="line">    <span class="comment">// manipulator2.manipulate();  无法编译</span></span><br><span class="line">    manipulator2.manipulate2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF()::f()</span></span><br><span class="line"><span class="comment">Don't have f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>模板类<code>Manipulator</code>在编译时期便可以检测到函数<code>f()</code>、<code>noF()</code>是在类型参数<t>中存在的，这是在编译器看到声明<code>Manipulator&lt;HasF&gt; manipulator(hf)</code>和<code>Manipulator&lt;DontHaveF&gt; manipulator2(dhf)</code>所产生的结果。</t></p>
<p>然而Java中却无法实现这样的操作：</p>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HasF.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f();"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manipulation.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.f() <span class="comment">// 会报编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulation = <span class="keyword">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class="line">        manipulation.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Java在编译过程中，<code>Manipulator&lt;T&gt;</code>是无法确定其类型参数，只知道他是一个<code>Object实例</code>，因此obj<strong>只能调用Object基类所有的公开方法</strong>。若想实现C++的操作有两种办法(目前我已知的只有这两种)。</p>
<ul>
<li><p>为<code>T</code>限定参数类型（给定边界），即声明时指定其所继承的基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用反射机制调用<code>f()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        obj = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;?&gt; oc = obj.getClass();</span><br><span class="line">        Method method = oc.getMethod(<span class="string">"f"</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        HasF hf = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulation = <span class="keyword">new</span> Manipulator&lt;HasF&gt;(hf);</span><br><span class="line">        manipulation.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">HasF.f();</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="擦除带来的问题"><a href="#擦除带来的问题" class="headerlink" title="擦除带来的问题"></a>擦除带来的问题</h3><blockquote>
<p>擦除的主要正当理由是从非泛化代码到繁华代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。</p>
</blockquote>
<p>泛型<strong>不能用于显式地引用运行时类型的操作之中</strong>，例如转型、instanceof、new表达式，因为在静态类型检测之后，泛型就已经被擦除了。</p>
<p>也就是说，需要时刻提醒自己，我只是<strong>看起来好像拥有</strong>有关参数的类型信息而已。实际上，<strong>它只是一个Object！</strong></p>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>既然编译器会<code>擦除</code>类型信息，那么擦除发生的地点是在哪儿呢？便是所谓的<code>边界</code>：对象进入和离开方法的地点，也就是编译器在执行类型检查并插入转型代码的地点。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple) flist.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Orange o = (Orange) flist.get(0); 运行时错误</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());  编译错误</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());  编译错误</span></span><br><span class="line">        System.out.println(flist.contains(a));</span><br><span class="line">        System.out.println(flist.contains(<span class="keyword">new</span> Apple()));</span><br><span class="line">        System.out.println(flist.indexOf(<span class="keyword">new</span> Apple()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>对于使用了通配符的<code>List&lt;? extends Fruit&gt; flist</code>来说，其需要用到类型参数的方法例如<code>add()</code>参数也变成了<code>&lt;? extends Fruit&gt;</code>，然而编译器并不能知道这里需要哪一个具体的子类型，于是<strong>编译器拒绝了所有对参数列表中涉及到了通配符的方法的调用，除了构造器。</strong></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>完整的容器分类法：</p>
<p><img src="/images/image-20190312200304819.png" alt="image-20190312200304819"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>采用了链地址法，也就是<strong>数组+链表</strong>的方式。主干是一个<code>Entry</code>数组，链表是为了解决哈希冲突而存在的。<code>HashMap</code>中的链表越少，性能越好。</p>
<h4 id="Entry数组长度为2的次幂"><a href="#Entry数组长度为2的次幂" class="headerlink" title="Entry数组长度为2的次幂"></a>Entry数组长度为2的次幂</h4><ul>
<li>由于在计算<code>key</code>的<code>插入位置</code>时用到了<code>hash &amp; (length-1)</code>，<code>hash</code>是<code>key</code>计算出来的哈希值，想象一下当<code>length</code>不为2的次幂时，<code>length-1</code>的二进制必然有<code>0位</code>，那么意味着该位为<code>0</code>的位置永远不可能被当做<code>插入位置</code>，造成了严重的空间浪费。</li>
<li>由于刚才的原因，数组可以使用的位置比数组长度小了很多，意味着进一步增加了碰撞的几率，意即<code>equal()</code>操作多了起来，效率也就慢了。</li>
</ul>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p><code>HashMap</code>当<code>Entry</code>数组元素超过<code>数组大小*loadFactor</code>时，就会进行数组扩容。<code>loadFactor</code>默认值为0.75。此时<code>Entry</code>数组大小会扩大一倍，保证了2的次幂大小。</p>
<p>扩容的时候所有的<code>key</code>需要重新计算哈希值。</p>
<h4 id="JDK1-8优化"><a href="#JDK1-8优化" class="headerlink" title="JDK1.8优化"></a>JDK1.8优化</h4><p>由于1.8之前的<code>HashMap</code>在<code>hash</code>冲突很大时，遍历链表将会效率很低，于是1.8中采用了红黑树部分代替链表，当链表长度到达阈值时，就会改用红黑树存储。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>HashTable</code>在结构上与<code>HashMap</code>基本相同，下面总结其不同点：</p>
<ul>
<li><code>HashMap</code>可有<code>null key</code>，<code>HashTable</code>获取<code>null key</code>会报空指针异常</li>
<li><code>HashTable</code>有<code>synchronized</code>方法同步，线程安全；<code>HashMap</code>线程不安全</li>
<li><code>Hash</code>值计算方法不同</li>
<li><code>HashTable</code>初始大小为<code>11</code>，扩容机制为<code>2*old+1</code>；<code>HashMap</code>初始大小为<code>16</code>，扩容机制为<code>2*old</code></li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>JDK1.7</code>版本中的<code>ConcurrentHashMap</code>比<code>HashMap</code>多了一层<code>Segment</code>，其中<code>Segment</code>继承于<code>ReentrantLock</code>：<strong>一次<code>put</code>操作会调用<code>scanAndLockForPut()</code>方法自旋获取锁</strong>；<strong>而一次<code>get</code>操作则不需要加锁，<code>value</code>用<code>volatile</code>关键词修饰的，保证了内存可见性，每次获取的必定是新值，由于不用加锁，所以很高效</strong>。</p>
<p><code>JDK1.8</code>版本移除了<code>segment</code>，有一个<code>Node</code>数组相当于<code>HashMap</code>中的<code>Entry</code>数组。同时采用了<code>CAS+synchronized关键字</code>进行<code>put</code>操作。<code>put</code>操作步骤如下：</p>
<ul>
<li>根据<code>key</code>计算出<code>hashcode</code>；</li>
<li>判断是否需要进行初始化；</li>
<li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功；</li>
<li>判断是否需要进行扩容；</li>
<li>如果都不满足，则利用 <code>synchronized</code> 锁写入数据；</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="Brian-Goetz的线程同步规则"><a href="#Brian-Goetz的线程同步规则" class="headerlink" title="Brian Goetz的线程同步规则"></a>Brian Goetz的线程同步规则</h3><blockquote>
<p>如果你正在写一个变量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，<strong>读写线程</strong>都必须用相同的监视器锁同步。</p>
</blockquote>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor用来管理Thread对象，简化了并发编程，允许管理异步任务的执行，而无须显式管理线程的声明周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#4(9).#2(9).#1(9).#2(8).#3(9).#4(8).#0(9).#1(8).#2(7).#3(8).#4(7).#0(8).#1(7).#2(6).#3(7).#4(6).#0(7).#1(6).#2(5).#3(6).#4(5).#0(6).#1(5).#2(4).#3(5).#4(4).#0(5).#1(4).#2(3).#3(4).#4(3).#0(4).#1(3).#2(2).#3(3).#4(2).#0(3).#1(2).#2(1).#3(2).#4(1).#0(2).#1(1).#2(LiftOff!).#3(1).#4(LiftOff!).#0(1).#1(LiftOff!).#0(LiftOff!).#3(LiftOff!).</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池的作用是<strong>限制系统中执行线程的数量</strong>，根据系统情况可以<strong>自动或手动</strong>设置线程数量，达到最佳运行效果。线程池中的线程若出现异常，会自动补充一个新线程以代替。</p>
<ul>
<li><code>newSingleThreadExecutor()</code>：创建一个单线程的线程池，所有的任务在等待队列中等待该线程。</li>
<li><code>newFixedThreadPool()</code>：创建固定大小的线程池。</li>
<li><code>newCachedThreadPool()</code>：创建一个可缓存的线程池。会根据任务数量自动添加和回收线程，线程池的大小依赖于JVM能够创建的最大线程大小。</li>
<li><code>newScheduledThreadPool()</code>：创建一个大小无限的线程池，此线程支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="任务的返回值"><a href="#任务的返回值" class="headerlink" title="任务的返回值"></a>任务的返回值</h3><p>通常实现<code>Runnable</code>接口的类是没有返回值的，要想任务在完成时返回一个值可实现<code>Callable&lt;T&gt;</code>接口，其泛型类型参数表示方法<code>call()</code>的返回值，并且需要使用<code>ExecutorService.submit()</code>方法调用他。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result of TaskWithResult"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.err.println(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output：</span></span><br><span class="line"><span class="comment">result of TaskWithResult0</span></span><br><span class="line"><span class="comment">result of TaskWithResult1</span></span><br><span class="line"><span class="comment">result of TaskWithResult2</span></span><br><span class="line"><span class="comment">result of TaskWithResult3</span></span><br><span class="line"><span class="comment">result of TaskWithResult4</span></span><br><span class="line"><span class="comment">result of TaskWithResult5</span></span><br><span class="line"><span class="comment">result of TaskWithResult6</span></span><br><span class="line"><span class="comment">result of TaskWithResult7</span></span><br><span class="line"><span class="comment">result of TaskWithResult8</span></span><br><span class="line"><span class="comment">result of TaskWithResult9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><code>ExecutorService</code>对象的<code>submit()</code>方法会返回一个<code>Future&lt;T&gt;</code>对象，泛型类型参数即是实现<code>Callable&lt;T&gt;</code>的类型参数。<code>get()</code>方法会返回结果，若任务未完成，<code>get()</code>会阻塞。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先权不会导致死锁，优先级较低的线程仅仅是执行的频率较低。</p>
<p>但是注意优先级高的线程也有几率比优先级底的线程执行的少。</p>
<p>优先级是否起作用也与操作系统及虚拟机版本相关联，会随着不同的线程调度器而产生不同的含义。</p>
<h3 id="Thread-yield-可靠吗？"><a href="#Thread-yield-可靠吗？" class="headerlink" title="Thread.yield()可靠吗？"></a>Thread.yield()可靠吗？</h3><p><code>Thread.yield()</code>源码中提及了该方法的效果：<strong>当前线程会给线程调度器一个暗示，说明我愿意让出当前资源供你调度，但是线程调度器可自由的选择是否忽略其暗示。</strong>意即此处的<code>让步</code>只是一厢情愿，发出让步的线程同样可以继续执行。</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程<strong>并不属于程序中不可或缺的部分</strong>。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。</p>
<p>执行<code>main()</code>就是一个非后台线程，当<code>main()</code>没有执行结束时，程序就不会终止。</p>
<p>后台线程创建的线程也将是后台线程。</p>
<p>同时要注意在后台线程的<code>run()</code>方法中若有<code>finally</code>子句，其中的语句也不一定会执行。因为随着非后台线程的结束，后台线程会突然终止。</p>
<h3 id="Thread还是Runnable"><a href="#Thread还是Runnable" class="headerlink" title="Thread还是Runnable"></a>Thread还是Runnable</h3><p>创建多线程任务可以继承<code>Thread</code>类重写其<code>run()</code>方法，也可以实现<code>Runnable</code>接口实现其<code>run()</code>方法。</p>
<p>实际应用中，<code>Runnable</code>还是比较有优势的：</p>
<ul>
<li>避免了由于Java的单继承体系带来的局限（实际上继承Thread也是可以避免，使用内部类）</li>
<li>多个线程区处理同一资源，而非独立处理（这句话有问题）</li>
</ul>
<p>注意，一开始在理解这里的时候我出现了误解，什么叫<strong>处理同一资源</strong>，意思指的是Thread类无法达到资源共享的目的，而Runnable可以。但是在使用线程池的时候，Thread又可以了<strong>(待确认)</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"-- val: "</span> + val--);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">if</span>  (val &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"-- val: "</span> + val--);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">if</span> (val &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnableAndThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> TestRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        <span class="comment">// a.只有1个线程处理一个数据</span></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// b.5个不同线程处理不同数据</span></span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="keyword">new</span> TestThread().start();</span><br><span class="line">        <span class="comment">// c.5个不同线程处理相同数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="comment">// d.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execRun = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execRun.execute(runnable);</span><br><span class="line">        <span class="comment">// e.5个不同线程处理5个不同数据</span></span><br><span class="line">        ExecutorService execRun2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execRun2.execute(<span class="keyword">new</span> TestRunnable());</span><br><span class="line">        <span class="comment">// f.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execThread = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            execThread.execute(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// g.5个不同线程处理5个不同数据</span></span><br><span class="line">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execThread2.execute(<span class="keyword">new</span> TestThread());</span><br><span class="line">        <span class="comment">// i.5个不同线程处理相同数据</span></span><br><span class="line">        ExecutorService execThread2 = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            execThread2.execute(<span class="keyword">new</span> Thread(runnable));</span><br><span class="line"></span><br><span class="line">        execRun.shutdown();</span><br><span class="line">        execRun2.shutdown();</span><br><span class="line">        execThread.shutdown();</span><br><span class="line">        execThread2.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：<strong>c、d、i</strong>实际上是相同的，<strong>b、g</strong>是相同的，而<strong>a</strong>和<strong>f</strong>看起来相同，但是实际作用却差别很大，待研究。</p>
<p>实际上，<strong>a</strong>是错误的用法，<strong>b</strong>、<strong>c</strong>基本上不用，而且，注意当需要共享数据的时候，通常不会在类中定义共享变量，而需要一个<strong>线程安全的外部对象</strong>。</p>
<h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>冲突是多线程问题必须解决的任务，Java使用<code>synchronized</code>关键字标识访问共享资源的方法，JVM负责跟踪对象被加锁的次数，注意，当对象被解锁（完全释放时）其加锁计数为0，显然此时所有任务都有几率向其加锁，当<strong>某一个任务第一次给该对象加锁时，计数变为1</strong>，此后<strong>只有这个相同的任务能继续给该对象加锁</strong>，计数会递增；<strong>每当离开一个synchronized方法时，计数递减</strong>，直到计数变为0时，对象被解锁。要注意，<strong>每个访问该临界资源的方法都必须被同步</strong>，否则就不会正确地工作。</p>
<p>通常<code>synchronized</code>关键字标识方法时，是在<code>this</code>上面同步，也可在方法中使用<code>synchronized(synObject){}</code>域，<strong>以在特定的对象上同步</strong>，因此不同对象上的锁是相互无关的。</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock对象必须被显式地创建、锁定和释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 显式声明</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lock()方法创建临界资源</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="comment">// return语句必须出现在try子句中</span></span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// unlock()方法完成清理工作</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>synchronize</code>相比，显式的<code>Lock</code>优点在于可以使用<code>finally子句</code>将系统维护在正常的状态，而在使用<code>synchronize</code>关键字时，某些事物失败了就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"untimed - tryLock(): "</span> + captured);</span><br><span class="line">            System.out.println(<span class="string">"untimed - isHeldByCurrentThread(): "</span> + lock.isHeldByCurrentThread());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (captured) </span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"timed - tryLock(2, TimeUnit.SECONDS): "</span> + captured);</span><br><span class="line">            System.out.println(<span class="string">"timed - isHeldByCurrentThread(): "</span> + lock.isHeldByCurrentThread());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (captured)</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">        <span class="comment">// 匿名内部类创建单独的Thread来获取锁，而未释放</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">                System.out.println(<span class="string">"main - isHeldByCurrentThread(): "</span> + al.lock.isHeldByCurrentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">untimed - tryLock(): true</span></span><br><span class="line"><span class="comment">untimed - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">timed - tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">timed - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">main - isHeldByCurrentThread(): true</span></span><br><span class="line"><span class="comment">untimed - tryLock(): false</span></span><br><span class="line"><span class="comment">untimed - isHeldByCurrentThread(): false</span></span><br><span class="line"><span class="comment">timed - tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">timed - isHeldByCurrentThread(): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>看代码就很容易理解了。</p>
<h4 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h4><p>原子操作<strong>有可能无需同步机制</strong>，因为操作是不可分的，一次操作进行的时候不会有其他操作的介入，但是实现原子操作是很难的，或者说原子操作是较少存在的。同时，即使操作是原子性的，操作的修改也可能暂时性地存储在本地处理器的缓存中，对于其他任务有可能是<strong>不可视的</strong>，因此不同的任务对应用状态有不同的视图。</p>
<p><strong>volatile关键字</strong>确保了前面提及的可视性，以及当一个域被声明为volatile时，那么<strong>只要对这个域产生了写操作，所有的读操作都可以看到这个修改</strong>。即使使用了本地缓存，volatile域的修改也会被立即写入到主存中。</p>
<p>所以<strong>非volatile域</strong>上的原子操作未刷新到主存中去，因此其他读操作未必会看到新值。</p>
<p>因此多个任务在同时访问某个域时，<strong>要么使用volatile关键字限定，要么经由同步机制访问</strong>，以保证一致性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            i++; i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面这个例子，程序找到奇数时便终止，理想状态下，通过<code>evenIncrement()</code>加2，<code>i</code>应该始终为偶数，但是由于缺少同步机制，可能导致不稳定的中间状态被读取即获取到奇数，同时<code>i</code>也不是<code>volatile</code>的，因此还存在可视性问题（当然，这里仅仅使用<code>volatile</code>限定<code>i</code>是不够的，因为<code>i++</code>操作不是原子性的）。下面使用<code>Lock</code>显式加锁以实现同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            i++; i++; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">            System.out.println(val);</span><br><span class="line">            <span class="keyword">if</span> (val%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>上面说到<strong>原子操作是较少的</strong>，而<code>JSE5</code>引入了<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等特殊的原子性变量类，这些类的一些方法在某些机器上可以是原子的。通常用在性能调优方面。</p>
<h3 id="ReetrantLock"><a href="#ReetrantLock" class="headerlink" title="ReetrantLock"></a>ReetrantLock</h3><p>ReentrantLock是一个<strong>可重入</strong>的<strong>互斥锁</strong>，又被称为”<strong>独占锁</strong>“。</p>
<blockquote>
<p><strong>可重入锁</strong>指的是某个线程获取锁之后，在执行相关的代码块时可继续调用加了同样的锁的方法，理解为嵌套锁。反之，不可重入锁称作自旋锁。</p>
<p><strong>独占锁</strong>指的是同一时间点锁只能被一个线程获取。</p>
</blockquote>
<p>同时ReentrantLock也分为<strong>公平锁</strong>和<strong>非公平锁</strong>，它们的区别体现在获取锁的机制是否公平。公平锁通过一个FIFO等待队列管理等待获取该锁的所有进程，而非公平锁不管是否在队列中，都直接获取该锁。</p>
<h3 id="ReentrantReedWriteLock"><a href="#ReentrantReedWriteLock" class="headerlink" title="ReentrantReedWriteLock"></a>ReentrantReedWriteLock</h3><p>顾名思义，ReentrantReadWriteLock维护了<strong>读取锁</strong>和<strong>写入锁</strong>。</p>
<p>读取锁用于只读操作，是<strong>共享锁</strong>，能被多个线程获取；</p>
<p>写入锁用于写入操作，是<strong>独占锁</strong>，只能被一个线程获取。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>新建（new）</li>
<li>就绪（Runnable）</li>
<li>阻塞（Blocked）<ul>
<li>调用<code>sleep(milliseconds)</code>方法使任务休眠</li>
<li>调用<code>wait()</code>方法挂起</li>
<li>等待输入输出完成</li>
<li>获取锁失败</li>
</ul>
</li>
<li>死亡（Dead）</li>
</ul>
<h3 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p>与<code>sleep()</code>和<code>yield()</code>不同，调用<code>wait()</code>时<strong>需要释放当前线程获取的锁</strong>，由于某个条件不成立使得当前线程进入阻塞状态，直到其他修改使得此条件发生了变化调用了<code>notifyAll()</code>方法时，线程被唤醒。</p>
<p>但是要注意，使用<code>wait()</code>的时候需要用<code>while</code>循环包围：</p>
<ul>
<li>为了检查线程是否被意外唤醒</li>
</ul>
<h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h4><p><code>notifyAll()</code>用来唤醒等待<strong>某个锁</strong>的所有<strong>挂起的任务</strong>。<code>等待某个锁</code>指的是某些需要获取共同的锁的线程，<code>notifyAll()</code>可以唤醒这些线程，而不是程序中所有被挂起的线程。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个并发进程因争夺系统资源而产生相互等待的现象。</p>
<p>四个必要条件：</p>
<ul>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<h3 id="免锁容器"><a href="#免锁容器" class="headerlink" title="免锁容器"></a>免锁容器</h3><p>免锁容器的策略是：对容器的修改可以与读取操作<strong>同时发生</strong>，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。</p>
<p>这些容器允许并发的读取和写入，但是在任何修改完成之前，读取者仍然是不能够看到它们的。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>每次拿数据的时候认为别人不会修改，所以不会上锁，但是在更新的时候会判断此期间有没有别人更新这个数据。上述有提到的原子类就是使用了CAS实现的乐观锁。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。<code>synchronized</code>关键字的实现就是悲观锁。</p>
<h4 id="CAS-Compare-And-Swap-技术"><a href="#CAS-Compare-And-Swap-技术" class="headerlink" title="CAS(Compare And Swap)技术"></a>CAS(Compare And Swap)技术</h4><p>CAS是用来实现乐观锁的一种方法，原理见<a href="https://www.jianshu.com/p/ae25eb3cfb5d" target="_blank" rel="noopener">这里</a>。</p>
<p>CAS机制使用3个基本操作数：<strong>内存地址<code>V</code></strong>，<strong>旧的预期值<code>A</code></strong>，<strong>要修改的新值<code>B</code></strong>。</p>
<p>更新一个变量的时候，只有当<code>A</code>和<code>V</code>的实际值相同时，才会将<code>V</code>对应的值修改为<code>B</code>。</p>
<p>缺点：</p>
<ul>
<li>ABA问题：链表的头在变化了两次后恢复了原值，但是不代表链表就没有发生变化</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子性</li>
</ul>
<p>未完~</p>

      
    </div>

    

    
    
    

    
      <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/images/qcode.jpg" alt="Rui wechat" style="width: 200px; max-width: 100%;"/>
  <div>我们梦中见</div>
</div>

    

    
      
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>哟，小老板</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Rui WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Rui Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/05/数据库与内存数据库实验报告/" rel="next" title="数据库与内存数据库实验报告">
                <i class="fa fa-chevron-left"></i> 数据库与内存数据库实验报告
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/27/Java类与类加载器/" rel="prev" title="Java类与类加载器">
                Java类与类加载器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.png"
                alt="Rui"/>
            
              <p class="site-author-name" itemprop="name">Rui</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ruitan" title="GitHub &rarr; https://github.com/ruitan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:tanrui106@gmail.com" title="E-Mail &rarr; mailto:tanrui106@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收器—GC"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收器—GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#避免使用finalize"><span class="nav-number">1.1.</span> <span class="nav-text">避免使用finalize()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终结条件的验证"><span class="nav-number">1.2.</span> <span class="nav-text">终结条件的验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC如何工作"><span class="nav-number">1.3.</span> <span class="nav-text">GC如何工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数（未被使用过）"><span class="nav-number">1.3.1.</span> <span class="nav-text">引用计数（未被使用过）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止-复制（stop-and-copy）"><span class="nav-number">1.3.2.</span> <span class="nav-text">停止-复制（stop-and-copy）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-清扫（mark-and-sweep）"><span class="nav-number">1.3.3.</span> <span class="nav-text">标记-清扫（mark-and-sweep）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自适应技术"><span class="nav-number">1.3.4.</span> <span class="nav-text">自适应技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分代垃圾收集（Generational-Garbage-Collection）"><span class="nav-number">1.3.5.</span> <span class="nav-text">分代垃圾收集（Generational Garbage Collection）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HotSpot-JVM的垃圾收集器"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">HotSpot JVM的垃圾收集器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数列表"><span class="nav-number">2.</span> <span class="nav-text">可变参数列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数列表的重载"><span class="nav-number">2.1.</span> <span class="nav-text">可变参数列表的重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类对象对外围类对象的访问"><span class="nav-number">3.1.</span> <span class="nav-text">内部类对象对外围类对象的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类与静态内部类（嵌套类）"><span class="nav-number">3.2.</span> <span class="nav-text">内部类与静态内部类（嵌套类）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">创建方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名内部类"><span class="nav-number">3.3.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTTI"><span class="nav-number">4.</span> <span class="nav-text">RTTI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class对象"><span class="nav-number">4.1.</span> <span class="nav-text">Class对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛化的Class对象引用"><span class="nav-number">4.2.</span> <span class="nav-text">泛化的Class对象引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转型语法（不常用）"><span class="nav-number">4.3.</span> <span class="nav-text">转型语法（不常用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态的类型检测"><span class="nav-number">4.4.</span> <span class="nav-text">动态的类型检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#obj-instanceof-ClassType"><span class="nav-number">4.4.1.</span> <span class="nav-text">obj instanceof ClassType</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassType-isInstance"><span class="nav-number">4.4.2.</span> <span class="nav-text">ClassType.isInstance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-number">4.4.3.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">4.4.4.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射机制"><span class="nav-number">4.5.</span> <span class="nav-text">反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反射与RTTI的区别"><span class="nav-number">4.5.1.</span> <span class="nav-text">反射与RTTI的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类方法提取器"><span class="nav-number">4.5.2.</span> <span class="nav-text">类方法提取器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口与类型信息"><span class="nav-number">4.5.3.</span> <span class="nav-text">接口与类型信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包权限安全吗？"><span class="nav-number">4.5.4.</span> <span class="nav-text">包权限安全吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">5.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指定类型有保证吗？"><span class="nav-number">5.1.</span> <span class="nav-text">指定类型有保证吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与C-的区别"><span class="nav-number">5.2.</span> <span class="nav-text">与C++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#擦除带来的问题"><span class="nav-number">5.3.</span> <span class="nav-text">擦除带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界"><span class="nav-number">5.4.</span> <span class="nav-text">边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通配符"><span class="nav-number">5.5.</span> <span class="nav-text">通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">6.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">6.1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Entry数组长度为2的次幂"><span class="nav-number">6.1.1.</span> <span class="nav-text">Entry数组长度为2的次幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resize"><span class="nav-number">6.1.2.</span> <span class="nav-text">resize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8优化"><span class="nav-number">6.1.3.</span> <span class="nav-text">JDK1.8优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable"><span class="nav-number">6.2.</span> <span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">6.3.</span> <span class="nav-text">ConcurrentHashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">7.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brian-Goetz的线程同步规则"><span class="nav-number">7.1.</span> <span class="nav-text">Brian Goetz的线程同步规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">7.2.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">7.3.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务的返回值"><span class="nav-number">7.4.</span> <span class="nav-text">任务的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级"><span class="nav-number">7.5.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-yield-可靠吗？"><span class="nav-number">7.6.</span> <span class="nav-text">Thread.yield()可靠吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后台线程"><span class="nav-number">7.7.</span> <span class="nav-text">后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread还是Runnable"><span class="nav-number">7.8.</span> <span class="nav-text">Thread还是Runnable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享资源"><span class="nav-number">7.9.</span> <span class="nav-text">共享资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized"><span class="nav-number">7.9.1.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock"><span class="nav-number">7.9.2.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性与易变性"><span class="nav-number">7.9.3.</span> <span class="nav-text">原子性与易变性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子类"><span class="nav-number">7.10.</span> <span class="nav-text">原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReetrantLock"><span class="nav-number">7.11.</span> <span class="nav-text">ReetrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReedWriteLock"><span class="nav-number">7.12.</span> <span class="nav-text">ReentrantReedWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程状态"><span class="nav-number">7.13.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程协作"><span class="nav-number">7.14.</span> <span class="nav-text">线程协作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-number">7.14.1.</span> <span class="nav-text">wait()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#notifyAll"><span class="nav-number">7.14.2.</span> <span class="nav-text">notifyAll()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">7.15.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#免锁容器"><span class="nav-number">7.16.</span> <span class="nav-text">免锁容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#乐观锁"><span class="nav-number">7.16.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观锁"><span class="nav-number">7.16.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-Compare-And-Swap-技术"><span class="nav-number">7.16.3.</span> <span class="nav-text">CAS(Compare And Swap)技术</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  

<script>
  var disqus_config = function() {
    this.page.url = "http://blog.guitoubing.top/2019/03/06/深入学习Java（更新中）/";
    this.page.identifier = "2019/03/06/深入学习Java（更新中）/";
    this.page.title = '深入学习Java（更新中）';
    };
  function loadComments() {
    var d = document, s = d.createElement('script');
    s.src = 'https://guitoubing-top.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    $(function() {
      var offsetTop = $('#comments').offset().top - $(window).height();
      if (offsetTop <= 0) {
        // load directly when there's no a scrollbar
        loadComments();
      } else {
        $(window).on('scroll.disqus_scroll', function() {
          // offsetTop may changes because of manually resizing browser window or lazy loading images.
          var offsetTop = $('#comments').offset().top - $(window).height();
          var scrollTop = $(window).scrollTop();

          // pre-load comments a bit? (margin or anything else)
          if (offsetTop - scrollTop < 60) {
            $(window).off('.disqus_scroll');
            loadComments();
          }
        });
      }
    });
  
</script>





  


  




  

  

  

  

  

  

  

  

  

  

  

  
<style>
  .copy-btn {
    display: inline-block;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 700;
    line-height: 20px;
    color: #333;
    white-space: nowrap;
    vertical-align: middle;
    cursor: pointer;
    
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
    
    user-select: none;
    outline: 0;
  }

  .highlight-wrap .copy-btn {
    transition: opacity .3s ease-in-out;
    opacity: 0;
    padding: 2px 6px;
    position: absolute;
    
      right: 4px;
      top: 8px;
    
  }

  .highlight-wrap:hover .copy-btn,
  .highlight-wrap .copy-btn:focus {
    opacity: 1;
  }

  .highlight-wrap {
    position: relative;
  }
</style>
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('Copy');
      }, 300);
    }).append(e);
  })
</script>


</body>
</html>
