{"meta":{"title":"Archer","subtitle":null,"description":null,"author":"Rui","url":"http://blog.guitoubing.top"},"pages":[{"title":"关于我","date":"2017-10-20T13:04:41.000Z","updated":"2018-11-06T14:05:46.600Z","comments":true,"path":"about/index.html","permalink":"http://blog.guitoubing.top/about/index.html","excerpt":"","text":"用心写文，用脚上传每日一问 芳芳到底什么时候下班呢？"},{"title":"404 Not Found 该页无法显示","date":"2018-11-05T17:08:58.000Z","updated":"2018-11-05T17:11:24.740Z","comments":true,"path":"/404.html","permalink":"http://blog.guitoubing.top//404.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-05T17:00:28.000Z","updated":"2018-11-05T17:00:28.083Z","comments":true,"path":"tags/index.html","permalink":"http://blog.guitoubing.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"感谢Docker,让我远离环境配置","slug":"使用Docker安装Oracle-12c","date":"2018-11-12T15:26:45.000Z","updated":"2018-11-12T16:16:01.078Z","comments":true,"path":"2018/11/12/使用Docker安装Oracle-12c/","link":"","permalink":"http://blog.guitoubing.top/2018/11/12/使用Docker安装Oracle-12c/","excerpt":"Why Docker自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。 这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。 偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。","text":"Why Docker自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。 这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。 偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。 正题Docker安装并启动Oracle 12c安装12345# 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的docker search oracledocker pull sath89/oracle-12c# 查看已安装的镜像docker images 由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：Docker切换国内镜像下载源 初始化123456# 使用log记录oracle启动的容器号log=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)# 显示当前容器初始化进程docker logs -f $log# 显示docker中当前运行的容器(可查看到容器ID)sudo docker ps 正常情况下，第一次创建容器应称之为初始化，而以后创建的容器都应基于上次的历史数据，称作容器的数据持久化，在上述命令中-v后的:之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，:后面是在容器中想要访问当前系统的共享文件的路径。 因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^： 12&gt; sudo docker run -it -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c&gt; 至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。 同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。 进入容器123# 进入特定的容器，$&#123;ContainerID&#125;为上述查看到的容器ID# env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)sudo docker exec -it $&#123;ContainerID&#125; env LANG=C.UTF-8 /bin/bash 连接oracle数据库123root@1386ef844664:/# su oracleoracle@1386ef844664:/$ cd $ORACLE_HOMEoracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba 升华Docker真的好用！（俗","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.guitoubing.top/tags/Docker/"},{"name":"Oracle","slug":"Oracle","permalink":"http://blog.guitoubing.top/tags/Oracle/"}]},{"title":"记一次Win10+Fedora双系统的小折腾","slug":"记一次Win10-Fedora双系统的小折腾","date":"2018-11-06T13:21:10.000Z","updated":"2018-11-07T02:57:04.095Z","comments":true,"path":"2018/11/06/记一次Win10-Fedora双系统的小折腾/","link":"","permalink":"http://blog.guitoubing.top/2018/11/06/记一次Win10-Fedora双系统的小折腾/","excerpt":"问题描述因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。我在Google上搜了类似的问题，大多是诸如以下的原因：","text":"问题描述因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。我在Google上搜了类似的问题，大多是诸如以下的原因： 主板供电不足（我使用的是台式机应该不会有这个问题） BIOS中系统时间不正确（我也未曾修改过该时间） 这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在 问题出现的环境背景及自己尝试过哪些方法系统相关信息：主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中） 尝试过得方法： 曾使用PE系统中的引导修复工具修复Win10引导，无果 在Fedora中安装了grub工具尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件\\Windows\\System32\\winload.efi上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性） 至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果 问题截图 如上所示，错误信息提示文件\\Windows\\System32\\winload.efi出错，导致我一直陷入找winload.efi文件错误的怪圈。 问题解决方法鼓捣大半天，我仍然无法解决此问题，便在SegmentFault上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主冯恒智，一言点睛。 具体解决方法如下（划重点）：在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的【启动设备】项下的启动磁盘和启动分区项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见此博客）。 疑问：我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的启动磁盘和启动分区两项，而其他都未曾影响？待解…… 就很玄学（挠头11月7日更新SegmentFault上的答主冯恒智又回复了我的问题，如下： 并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.guitoubing.top/tags/Win10/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.guitoubing.top/tags/Linux/"},{"name":"双系统","slug":"双系统","permalink":"http://blog.guitoubing.top/tags/双系统/"},{"name":"引导修复","slug":"引导修复","permalink":"http://blog.guitoubing.top/tags/引导修复/"}]},{"title":"JavaFX 学习小记","slug":"JavaFX-学习小记","date":"2018-10-27T16:08:25.000Z","updated":"2018-11-06T13:19:33.866Z","comments":true,"path":"2018/10/28/JavaFX-学习小记/","link":"","permalink":"http://blog.guitoubing.top/2018/10/28/JavaFX-学习小记/","excerpt":"JavaFX小记简介 JavaFX JavaFX是由甲骨文(Oracle)公司推出的一系列的产品和技术，主要应用于创建Rich Internet application(RIAs)，它是一个跨平台的桌面应用程序开发框架。","text":"JavaFX小记简介 JavaFX JavaFX是由甲骨文(Oracle)公司推出的一系列的产品和技术，主要应用于创建Rich Internet application(RIAs)，它是一个跨平台的桌面应用程序开发框架。 典型的MVC架构 定义Model，使用javafx.beans封装类型定义属性类型 使用fxml文件创建View，利用SceneBuilder工具进行布局 创建Controller实现动作操作以及Model和View的联系 View 创建FXML文件，利用SceneBuilder工具进行布局 Model 定义Model中的Person类，使用Property和Bind java.beans包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，Property和Bind方便我们实现以下功能：当某个属性如First Name被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考JavaFX文档。 Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.tanrui.model;import java.time.LocalDate;import javafx.beans.property.IntegerProperty;import javafx.beans.property.ObjectProperty;import javafx.beans.property.SimpleIntegerProperty;import javafx.beans.property.SimpleObjectProperty;import javafx.beans.property.SimpleStringProperty;import javafx.beans.property.StringProperty;/** * Model class for a Person. */public class Person &#123; private final StringProperty firstName; private final StringProperty lastName; private final StringProperty street; private final IntegerProperty postalCode; private final StringProperty city; private final ObjectProperty&lt;LocalDate&gt; birthday; /** * Default constructor. */ public Person() &#123; this(null, null); &#125; /** * Constructor with some initial data. * * @param firstName * @param lastName */ public Person(String firstName, String lastName) &#123; this.firstName = new SimpleStringProperty(firstName); this.lastName = new SimpleStringProperty(lastName); // Some initial dummy data, just for convenient testing. this.street = new SimpleStringProperty(\"some street\"); this.postalCode = new SimpleIntegerProperty(1234); this.city = new SimpleStringProperty(\"some city\"); this.birthday = new SimpleObjectProperty&lt;LocalDate&gt;(LocalDate.of(1999, 2, 21)); &#125; public String getFirstName() &#123; return firstName.get(); &#125; public void setFirstName(String firstName) &#123; this.firstName.set(firstName); &#125; public StringProperty firstNameProperty() &#123; return firstName; &#125; public String getLastName() &#123; return lastName.get(); &#125; public void setLastName(String lastName) &#123; this.lastName.set(lastName); &#125; public StringProperty lastNameProperty() &#123; return lastName; &#125; public String getStreet() &#123; return street.get(); &#125; public void setStreet(String street) &#123; this.street.set(street); &#125; public StringProperty streetProperty() &#123; return street; &#125; public int getPostalCode() &#123; return postalCode.get(); &#125; public void setPostalCode(int postalCode) &#123; this.postalCode.set(postalCode); &#125; public IntegerProperty postalCodeProperty() &#123; return postalCode; &#125; public String getCity() &#123; return city.get(); &#125; public void setCity(String city) &#123; this.city.set(city); &#125; public StringProperty cityProperty() &#123; return city; &#125; public LocalDate getBirthday() &#123; return birthday.get(); &#125; public void setBirthday(LocalDate birthday) &#123; this.birthday.set(birthday); &#125; public ObjectProperty&lt;LocalDate&gt; birthdayProperty() &#123; return birthday; &#125;&#125; 使用ObservableList管理Person 前一点所述的后续操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是ObservableList，ObservableList继承了List类、实现了Observable接口，其实现视图和数据同步的方法是在声明ObservableList时为方法传递一个监听器，此监听器需要会通过监听personData的变化同步改变视图中对应的值，可参考ObservableList文档 Main.java: 12345678910111213141516171819202122232425262728293031public class Main extends Application &#123; /*......Other variables......*/ /** * * The data of a observable list of Persons */ private ObservableList&lt;Person&gt; personData = FXCollections.observableArrayList(); public ObservableList&lt;Person&gt; getPersonData() &#123; return personData; &#125; public Main()&#123; personData.add(new Person(\"Tan\", \"Rui\")); personData.add(new Person(\"Chen\", \"Chao\")); personData.add(new Person(\"Liang\", \"Chengwei\")); personData.add(new Person(\"Xiao\", \"Xin\")); personData.add(new Person(\"Li\", \"Yang\")); personData.add(new Person(\"Chen\", \"Runqian\")); personData.add(new Person(\"Liang\", \"Yongchao\")); personData.add(new Person(\"Luo\", \"Jihao\")); personData.add(new Person(\"Chen\", \"Zhi\")); personData.add(new Person(\"Fan\", \"Fan\")); &#125; /* ......Other function..... */&#125; ControllerPersonOverviewController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.tanrui.view;import javafx.fxml.FXML;import javafx.scene.control.Label;import javafx.scene.control.TableColumn;import javafx.scene.control.TableView;import com.tanrui.Main;import com.tanrui.model.Person;public class PersonOverviewController &#123; @FXML private TableView&lt;Person&gt; personTable; @FXML private TableColumn&lt;Person, String&gt; firstNameColumn; @FXML private TableColumn&lt;Person, String&gt; lastNameColumn; @FXML private Label firstNameLabel; @FXML private Label lastNameLabel; @FXML private Label streetLabel; @FXML private Label postalCodeLabel; @FXML private Label cityLabel; @FXML private Label birthdayLabel; // Reference to the main application. private Main main; /** * The constructor. * The constructor is called before the initialize() method. */ public PersonOverviewController() &#123; &#125; /** * Initializes the controller class. This method is automatically called * after the fxml file has been loaded. */ @FXML private void initialize() &#123; // Initialize the person table with the two columns. firstNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().firstNameProperty()); lastNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().lastNameProperty()); &#125; /** * Is called by the main application to give a reference back to itself. * * @param main */ public void setMain(Main main) &#123; this.main = main; // Add observable list data to the table personTable.setItems(main.getPersonData()); &#125;&#125; @FXML注解（Annotation） 使用@FXML注解可以将操作的属性、方法绑定到FXML文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用@FXML注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！ initialize()方法 initialize()字面意思可知其是用于初始化对应FXML文件中的属性，此方法会在加载FXML文件时被自动执行，此时，所有的FXML属性都应已被初始化 setCellValueFactory(...)方法 我们对表格列上使用setCellValueFactory(...)方法来确定为特定列使用前面Person的某个属性。-&gt;表示使用的是Lambdas特性；另外一种方法是使用PropertyValueFactory(待研究…)。 这里我们之所以可以使用cellData -&gt; cellData.getValue().firstNameProperty()，便是因为之前我们将Person的属性都定义为javafx.beans中的封装属性，firstNameProperty()等方法都会在声明成Beans封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便 连接Main和PersonOverviewController showPersonOverview() 方法 Main.java 12345678910111213141516171819202122 /** * Shows the person overview inside the root layout. */public void showPersonOverview() &#123; try &#123; // Load person overview. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/PersonOverview.fxml\")); AnchorPane personOverview = (AnchorPane) loader.load(); // Set person overview into the center of root layout. rootLayout.setCenter(personOverview); // Give the controller access to the main app. PersonOverviewController controller = loader.getController(); controller.setMain(this); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 将View与Controller绑定我们还需要为FXML文件指定其对应的Controller，以及FXML元素与控制器的属性的对应关系，这是因为FXML文件中的元素只能被对应Controller修改更新，若在其他方法中修改会产生运行时错误。例如：在PersonOverviewController.java中将某个Label返回到Main.java中而后在其中修改该Label的值，意即在非FX线程中执行FX线程相关的任务，则会造成当前的线程阻塞，解决方法之一是使用Platform.runLater()方法，如下所示，括号中的FX线程相关任务便不会阻塞当前进程。 123Platform.runLater(() -&gt; &#123; ………相关FX线程代码………&#125;); 当然，最好的选择还是讲FX线程任务和其他任务区分开来，将特定的FXML文件与对应的Controller联系起来，当需要建立联系时可通过之前所说的使用java.beans、ObservableList等方法实现动态更新视图。 为FXML文件指定Controller 在Eclipse中好像有图形化界面直接为FXML文件选择Controller的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。 PersonOverview.fxml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;AnchorPane maxHeight=\"-Infinity\" maxWidth=\"-Infinity\" minHeight=\"-Infinity\" minWidth=\"-Infinity\" prefHeight=\"300.0\" prefWidth=\"600.0\" xmlns=\"http://javafx.com/javafx/8.0.121\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"com.tanrui.view.PersonOverviewController\"&gt; &lt;children&gt; &lt;? ... 内容省略 ... ?&gt; &lt;/children&gt;&lt;/AnchorPane&gt; 如上述代码所述，在顶层节点（此处是AnchorPane）标签中添加属性如下：fx:controller=&quot;com.tanrui.view.PersonOverviewController”，以此为FXML文件指定Controller 为FXML元素指定fx:id，使其绑定对应的控制器属性 如图，选定特定元素，在右侧界面找到Code-&gt;fx:id，将其对应的控制器属性填入即可 Details界面更新 showPersonDetails(Person person)方法 showPersonDetails(Person person)方法用于使用Person实例的数据填写标签。 PersonOverviewController.java 123456789101112131415161718192021222324252627/** * Fills all text fields to show details about the person. * If the specified person is null, all text fields are cleared. * * @param person the person or null */private void showPersonDetails(Person person) &#123; if (person != null) &#123; // Fill the labels with info from the person object. firstNameLabel.setText(person.getFirstName()); lastNameLabel.setText(person.getLastName()); streetLabel.setText(person.getStreet()); postalCodeLabel.setText(Integer.toString(person.getPostalCode())); cityLabel.setText(person.getCity()); // TODO: We need a way to convert the birthday into a String! // birthdayLabel.setText(...); &#125; else &#123; // Person is null, remove all the text. firstNameLabel.setText(\"\"); lastNameLabel.setText(\"\"); streetLabel.setText(\"\"); postalCodeLabel.setText(\"\"); cityLabel.setText(\"\"); birthdayLabel.setText(\"\"); &#125;&#125; 监听用户在人员表中的选择 PersonOverviewController.java 123456789101112131415@FXMLprivate void initialize() &#123; // Initialize the person table with the two columns. firstNameColumn.setCellValueFactory( cellData -&gt; cellData.getValue().firstNameProperty()); lastNameColumn.setCellValueFactory( cellData -&gt; cellData.getValue().lastNameProperty()); // Clear person details. showPersonDetails(null); // Listen for selection changes and show the person details when changed. personTable.getSelectionModel().selectedItemProperty().addListener( (observable, oldValue, newValue) -&gt; showPersonDetails(newValue));&#125; 删除按钮事件我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下： PersonOverviewController.java: 12345678910111213/** * Called when the user clicks on the delete button. */ @FXML private void handleDeletePerson() &#123; int selectedIndex = personTable.getSelectionModel().getSelectedIndex(); if (selectedIndex &gt;= 0)&#123; personTable.getItems().remove(selectedIndex); &#125; else&#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125; &#125; 错误处理从上述代码可以看到我们使用了条件判断语句来判断selectedIndex的值，当其小于0时，正常情况我们应该会让其抛出ArrayIndexOutOfBoundsException异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了controlsfx包，用于弹出各类提示框（可在ControlsFX官网获取）。 controlsfx有两个主要的版本，同时对于不同的版本，二者的用法也不同： 对于Java 8，需要下载ControlsFX 8.40.14包 对于Java 9及以上，需要下载ControlsFX 9.0.0包 我们这里用到的是Java 10，因此使用ControlsFX 9.0.0，使用方法如下： ShowDialog.java: 1234567891011121314151617181920212223242526272829303132package com.tanrui.util;import javafx.scene.control.Alert;import javafx.stage.Stage;/** * Util to create and show Dialog. * * @author Tan Rui */public class ShowDialog &#123; private Stage stage; private Alert.AlertType type; private String title; private String message; public ShowDialog(Stage stage, Alert.AlertType type, String title, String message)&#123; this.stage = stage; this.type = type; this.title = title; this.message = message; &#125; public void ShowSpecificDialog()&#123; Alert dlg = new Alert(type); dlg.initOwner(stage); dlg.setTitle(title); dlg.getDialogPane().setContentText(message); dlg.show(); &#125;&#125; PersonOverviewController.java 12345678910111213/** * Called when the user clicks on the delete button. */ @FXML private void handleDeletePerson() &#123; int selectedIndex = personTable.getSelectionModel().getSelectedIndex(); if (selectedIndex &gt;= 0)&#123; personTable.getItems().remove(selectedIndex); &#125; else&#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125; &#125; 新建和编辑对话框 Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是： 创建FXML文件，使用SceneBuilder编辑界面； 创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等； 连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性； 在Main函数中加载该控制器 为之前的New和Edit按钮添加动作，弹出对话框（新的Stage）。 设计对话框创建PersonEditDialog.fxml，完成弹出对话框的设计： 创建控制器为对话框创建控制器PersonEditDialogController.java。 PersonEditDialogController.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.tanrui.view;import com.tanrui.util.ShowDialog;import javafx.fxml.FXML;import javafx.scene.control.Alert;import javafx.scene.control.TextField;import javafx.stage.Stage;import com.tanrui.model.Person;import com.tanrui.util.DateUtil;/** * Dialog to edit details of a person. * * @author Marco Jakob */public class PersonEditDialogController &#123; @FXML private TextField firstNameField; @FXML private TextField lastNameField; @FXML private TextField streetField; @FXML private TextField postalCodeField; @FXML private TextField cityField; @FXML private TextField birthdayField; private Stage dialogStage; private Person person; private boolean okClicked = false; /** * Initializes the controller class. This method is automatically called * after the fxml file has been loaded. */ @FXML private void initialize() &#123; &#125; /** * Sets the stage of this dialog. * * @param dialogStage */ public void setDialogStage(Stage dialogStage) &#123; this.dialogStage = dialogStage; &#125; /** * Sets the person to be edited in the dialog. * * @param person */ public void setPerson(Person person) &#123; this.person = person; firstNameField.setText(person.getFirstName()); lastNameField.setText(person.getLastName()); streetField.setText(person.getStreet()); postalCodeField.setText(Integer.toString(person.getPostalCode())); cityField.setText(person.getCity()); birthdayField.setText(DateUtil.format(person.getBirthday())); birthdayField.setPromptText(\"dd.mm.yyyy\"); &#125; /** * Returns true if the user clicked OK, false otherwise. * * @return */ public boolean isOkClicked() &#123; return okClicked; &#125; /** * Called when the user clicks ok. */ @FXML private void handleOk() &#123; if (isInputValid()) &#123; person.setFirstName(firstNameField.getText()); person.setLastName(lastNameField.getText()); person.setStreet(streetField.getText()); person.setPostalCode(Integer.parseInt(postalCodeField.getText())); person.setCity(cityField.getText()); person.setBirthday(DateUtil.parse(birthdayField.getText())); okClicked = true; dialogStage.close(); &#125; &#125; /** * Called when the user clicks cancel. */ @FXML private void handleCancel() &#123; dialogStage.close(); &#125; /** * Validates the user input in the text fields. * * @return true if the input is valid */ private boolean isInputValid() &#123; String errorMessage = \"\"; if (firstNameField.getText() == null || firstNameField.getText().length() == 0) &#123; errorMessage += \"No valid first name!\\n\"; &#125; if (lastNameField.getText() == null || lastNameField.getText().length() == 0) &#123; errorMessage += \"No valid last name!\\n\"; &#125; if (streetField.getText() == null || streetField.getText().length() == 0) &#123; errorMessage += \"No valid street!\\n\"; &#125; if (postalCodeField.getText() == null || postalCodeField.getText().length() == 0) &#123; errorMessage += \"No valid postal code!\\n\"; &#125; else &#123; try &#123; Integer.parseInt(postalCodeField.getText()); &#125; catch (NumberFormatException e) &#123; errorMessage += \"No valid postal code (must be an integer)!\\n\"; &#125; &#125; if (cityField.getText() == null || cityField.getText().length() == 0) &#123; errorMessage += \"No valid city!\\n\"; &#125; if (birthdayField.getText() == null || birthdayField.getText().length() == 0) &#123; errorMessage += \"No valid birthday!\\n\"; &#125; else &#123; if (!DateUtil.validDate(birthdayField.getText())) &#123; errorMessage += \"No valid birthday. Use the format dd.mm.yyyy!\\n\"; &#125; &#125; if (errorMessage.length() == 0) &#123; return true; &#125; else &#123; new ShowDialog(dialogStage, Alert.AlertType.ERROR, \"Invalid Fields\", \"Please correct invalid fields\").ShowSpecificDialog(); return false; &#125; &#125;&#125; 关于该控制器的一些事情应该注意： setPerson(…)方法可以从其它类中调用，用来设置编辑的人员。 当用户点击OK按钮时，调用handleOK()方法。首先，通过调用isInputValid()方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给setPerson(…)。 布尔值okClicked被使用，以便调用者决定用户是否点击OK或者Cancel按钮。 连接视图和控制器使用已经创建的视图（FXML）和控制器，需要连接到一起。 使用SceneBuilder打开PersonEditDialog.fxml文件 在左边的Controller组中选择PersonEditDialogController作为控制器类 设置所有TextField的fx:id到相应的控制器字段上。 设置两个按钮的onAction到相应的处理方法上。 在Main中部署该控制器Main.java: 12345678910111213141516171819202122232425262728293031323334353637/** * Opens a dialog to edit details for the specified person. If the user * clicks OK, the changes are saved into the provided person object and true * is returned. * * @param person the person object to be edited * @return true if the user clicked OK, false otherwise. */public boolean showPersonEditDialog(Person person) &#123; try &#123; // Load the fxml file and create a new stage for the popup dialog. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/PersonEditDialog.fxml\")); AnchorPane page = (AnchorPane) loader.load(); // Create the dialog Stage. Stage dialogStage = new Stage(); dialogStage.setTitle(\"Edit Person\"); dialogStage.initModality(Modality.WINDOW_MODAL); dialogStage.initOwner(primaryStage); Scene scene = new Scene(page); dialogStage.setScene(scene); // Set the person into the controller. PersonEditDialogController controller = loader.getController(); controller.setDialogStage(dialogStage); controller.setPerson(person); // Show the dialog and wait until the user closes it dialogStage.showAndWait(); return controller.isOkClicked(); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125;&#125; 为主界面中New和Edit按钮创建OnAction方法，这些方法将从Main中调用showPersonEditDialog(…)方法。 PersonOverviewController.java: 123456789101112131415161718192021222324252627282930/** * Called when the user clicks the new button. Opens a dialog to edit * details for a new person. */@FXMLprivate void handleNewPerson() &#123; Person tempPerson = new Person(); boolean okClicked = main.showPersonEditDialog(tempPerson); if (okClicked) &#123; main.getPersonData().add(tempPerson); &#125;&#125;/** * Called when the user clicks the edit button. Opens a dialog to edit * details for the selected person. */@FXMLprivate void handleEditPerson() &#123; Person selectedPerson = personTable.getSelectionModel().getSelectedItem(); if (selectedPerson != null) &#123; boolean okClicked = main.showPersonEditDialog(selectedPerson); if (okClicked) &#123; showPersonDetails(selectedPerson); &#125; &#125; else &#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125;&#125; 而后在PersonOverview.fxml中为New和Edit两个按钮绑定对应的OnAction方法： 数据持久化我们有很多种方法来实现应用数据的持久化，例如： 使用数据库存储 使用Json文件存储 使用XML文件存储 …… 这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是： 每次打开应用可加载上一次的用户数据 用户可选择保存当前数据到指定XML文件 用户可选择从指定XML文件加载数据 使用Preferences保存应用状态Java提供了Preferences类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），Preferences类底层对各类操作系统进行了封装（实际上是Windows系统、OS X系统和类Unix文件系统三种），用户配置在Windows系统上可能保存在注册表中、在类Unix文件系统上可能保存在/tmp下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道Preferences类是用来保存用户配置即可。用法如下： Main.java: 1234567891011121314151617181920212223242526272829303132333435/** * Returns the person file preference, i.e. the file that was last opened. * The preference is read from the OS specific registry. If no such * preference can be found, null is returned. * * @return */ public File getPersonFilePath() &#123; Preferences prefs = Preferences.userNodeForPackage(Main.class); String filePath = prefs.get(\"filePath\", null); if (filePath != null) &#123; return new File(filePath); &#125; else &#123; return null; &#125; &#125; /** * Sets the file path of the currently loaded file. The path is persisted in * the OS specific registry. * * @param file the file or null to remove the path */ public void setPersonFilePath(File file) &#123; Preferences prefs = Preferences.userNodeForPackage(Main.class); if (file != null) &#123; prefs.put(\"filePath\", file.getPath()); // Update the stage title. primaryStage.setTitle(\"AddressApp - \" + file.getName()); &#125; else &#123; prefs.remove(\"filePath\"); // Update the stage title. primaryStage.setTitle(\"AddressApp\"); &#125; &#125; 使用JAXBJAXB包是Java中提供的对数据进行编列(marshall)成XML文件以及对XML文件反编列(unmarshall)为数据结构的包，Java SE中有如下支持类型：JAXB 2.0是JDK 1.6的组成部分。JAXB 2.2.3是JDK 1.7以上的组成部分，而实际上在Java 9之后就已将JAXB包移除，因此使用时需添加额外的lib包，详情可见博客真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException。 JAXB模型类我们希望持久化的数据应该是Main中的personData，而JAXB有以下要求： 使用@XmlRootElement定义XML根元素的名称 使用@XmlElement指定一个XML元素，可选 而Main中的personData是ObservableList类型，由于ObservableList类型不支持添加注解，因此我们需要创建另外一个能保存Person列表同时又能存储为XML文件的类，如下。 PersonListWrapper.java: 12345678910111213141516171819202122232425package com.tanrui.model;import java.util.List;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;/** * Helper class to wrap a list of persons. This is used for saving the * list of persons to XML. */@XmlRootElement(name = \"persons\")public class PersonListWrapper &#123; private List&lt;Person&gt; persons; @XmlElement(name = \"person\") public List&lt;Person&gt; getPersons() &#123; return persons; &#125; public void setPersons(List&lt;Person&gt; persons) &#123; this.persons = persons; &#125;&#125; 使用JAXB读写数据到XML文件我们将读写XML文件的逻辑放到Main类中，Controller在用到相应的逻辑时，直接调用Main中的方法即可。 Main.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Loads person data from the specified file. The current person data will * be replaced. * * @param file */public void loadPersonDataFromFile(File file) &#123; try &#123; JAXBContext context = JAXBContext .newInstance(PersonListWrapper.class); Unmarshaller um = context.createUnmarshaller(); // Reading XML from the file and unmarshalling. PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file); personData.clear(); personData.addAll(wrapper.getPersons()); // Save the file path to the registry. setPersonFilePath(file); &#125; catch (Exception e) &#123; // catches ANY exception new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog(); &#125;&#125;/** * Saves the current person data to the specified file. * * @param file */public void savePersonDataToFile(File file) &#123; try &#123; JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class); Marshaller m = context.createMarshaller(); m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); // Wrapping our person data. PersonListWrapper wrapper = new PersonListWrapper(); wrapper.setPersons(personData); // Marshalling and saving XML to the file. m.marshal(wrapper, file); // Save the file path to the registry. setPersonFilePath(file); &#125; catch (Exception e) &#123; // catches ANY exception new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog(); &#125;&#125; 编组(marshall):savePersonDataToFile(…)和解组(unmarshall):loadPersonDataFromFile(…)已准备好，下面在界面中使用它。 创建打开和保存菜单为File菜单添加子项 处理菜单相应动作Controller中使用FileChooser的方法，FileChooser同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。 本类中使用了FileChooser.ExtensionFilter，对文件系统中文件进行过滤，保留.xml结尾的文件。 当用户选择特定文件而后点击打开按钮时，会返回该文件，否则返回Null。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.tanrui.view;import com.tanrui.Main;import com.tanrui.util.ShowDialog;import javafx.fxml.FXML;import javafx.scene.control.Alert;import javafx.stage.FileChooser;import java.io.File;/** * The controller for the root layout. The root layout provides the basic * application layout containing a menu bar and space where other JavaFX * elements can be placed. */public class RootLayoutController &#123; // Reference to the main application private Main main; /** * Is called by the main application to give a reference back to itself. * * @param main */ public void setMain(Main main) &#123; this.main = main; &#125; /** * Creates an empty address book. */ @FXML private void handleNew() &#123; main.getPersonData().clear(); main.setPersonFilePath(null); &#125; /** * Opens a FileChooser to let the user select an address book to load. */ @FXML private void handleOpen() &#123; FileChooser fileChooser = new FileChooser(); // Set extension filter FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter( \"XML files (*.xml)\", \"*.xml\"); fileChooser.getExtensionFilters().add(extFilter); // Show save file dialog File file = fileChooser.showOpenDialog(main.getPrimaryStage()); if (file != null) &#123; main.loadPersonDataFromFile(file); &#125; &#125; /** * Saves the file to the person file that is currently open. If there is no * open file, the \"save as\" dialog is shown. */ @FXML private void handleSave() &#123; File personFile = main.getPersonFilePath(); if (personFile != null) &#123; main.savePersonDataToFile(personFile); &#125; else &#123; handleSaveAs(); &#125; &#125; /** * Opens a FileChooser to let the user select a file to save to. */ @FXML private void handleSaveAs() &#123; FileChooser fileChooser = new FileChooser(); // Set extension filter FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter( \"XML files (*.xml)\", \"*.xml\"); fileChooser.getExtensionFilters().add(extFilter); // Show save file dialog File file = fileChooser.showSaveDialog(main.getPrimaryStage()); if (file != null) &#123; // Make sure it has the correct extension if (!file.getPath().endsWith(\".xml\")) &#123; file = new File(file.getPath() + \".xml\"); &#125; main.savePersonDataToFile(file); &#125; &#125; /** * Opens an about dialog. */ @FXML private void handleAbout() &#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, \"About\", \"Author: Tan\\\\nWebsite: https://guitoubing.top\").ShowSpecificDialog(); &#125; /** * Closes the application. */ @FXML private void handleExit() &#123; System.exit(0); &#125; /** * Opens the birthday statistics. */ @FXML private void handleShowBirthdayStatistics() &#123; main.showBirthdayStatistics(); &#125;&#125; 连接FXML文件和Controller、绑定菜单和对应动作 在Main中部署该控制器Main.java: 123456789101112131415161718192021222324252627/** * Initializes the root layout. */ public void initRootLayout() &#123; try &#123; // Load root layout from fxml file. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/RootLayout.fxml\")); rootLayout = (BorderPane) loader.load(); // Show the scene containing the root layout. Scene scene = new Scene(rootLayout); primaryStage.setScene(scene); RootLayoutController controller = loader.getController(); controller.setMain(this); primaryStage.show(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; File file = getPersonFilePath(); if (file != null)&#123; loadPersonDataFromFile(file); &#125; &#125; 参考资料 code.makery —— JavaFX中文教程 JavaFX Tutorial 真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException fxexperience —— ControlFX Java SE8 —— Lambda ………… 写在后面本博主要是在学习code.makery —— JavaFX中文教程博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是JDK 8u40，我这里使用的是Java 10 2018-03-20）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击JavaFX-Test中获取源码。 希望藉此次JavaFX学习开启我的Java源码学习之旅，道阻且长！","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"JavaFX","slug":"JavaFX","permalink":"http://blog.guitoubing.top/tags/JavaFX/"},{"name":"Java源码学习之旅","slug":"Java源码学习之旅","permalink":"http://blog.guitoubing.top/tags/Java源码学习之旅/"},{"name":"Java","slug":"Java","permalink":"http://blog.guitoubing.top/tags/Java/"}]},{"title":"TimesTen内存数据库课程笔记（更新中）","slug":"TimesTen内存数据库课程笔记","date":"2018-09-02T12:59:50.000Z","updated":"2018-11-06T13:19:33.866Z","comments":true,"path":"2018/09/02/TimesTen内存数据库课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/02/TimesTen内存数据库课程笔记/","excerpt":"内存计算与内存数据库第零章OLTP：行存储（记录：元组），联机事务处理 OLAP：列存储（key-value），联机分析处理 Timesten操作小记","text":"内存计算与内存数据库第零章OLTP：行存储（记录：元组），联机事务处理 OLAP：列存储（key-value），联机分析处理 Timesten操作小记 平台 系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga) 创建DSN（Data Source Name） 逻辑名，用于标识某一数据库连接 打开数据库配置文件(通常称为系统ODBC.INI配置文件)12$ cd $TT_HOME/info$ gedit sys.odbc.ini 在数据库DSN列表中添加需要新建的数据库名称123456789101112# 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示[ODBC Data Sources]my_ttdb=TimesTen 11.2.2 DriverTT_1122=TimesTen 11.2.2 Driversampledb_1122=TimesTen 11.2.2 Drivercachedb1_1122=TimesTen 11.2.2 Driverrepdb1_1122=TimesTen 11.2.2 Driverrepdb2_1122=TimesTen 11.2.2 DriversampledbCS_1122=TimesTen 11.2.2 Client Drivercachedb1CS_1122=TimesTen 11.2.2 Client Driverrepdb1CS_1122=TimesTen 11.2.2 Client Driverrepdb2CS_1122=TimesTen 11.2.2 Client Driver 为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中12345678910111213# 配置my_ttdb[my_ttdb]# 数据库监听器驱动位置Driver=/home/oracle/TimesTen/tt1122/lib/libtten.so # DataStore为检查点文件存储位置DataStore=/u02/ttdata/datastores/my_ttdb # LogDir为日志文件存储位置LogDir=/u03/ttdata/logs# 以下两个Size是TimesTen内存数据库的内存分配PermSize=40TempSize=32# 数据库的字符集DatabaseCharacterSet=AL32UTF8 TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客如何更改TimesTen数据库的大小。 保存配置文件并关闭数据库服务器基本命令查看服务器状态12345678[oracle@timesten-hol info]$ ttstatusTimesTen status report as of Thu Sep 27 04:08:30 2018Daemon pid 2637 port 53392 instance tt1122TimesTen server pid 2646 started on port 53393------------------------------------------------------------------------Accessible by group oracleEnd of report 启动/停止数据库12345678910111213141516[oracle@timesten-hol info]$ ttdaemonadmin -stopTimesTen Daemon stopped.[oracle@timesten-hol info]$ ttstatusttStatus: Could not connect to the TimesTen daemon.If the TimesTen daemon is not running, please start itby running \"ttDaemonAdmin -start\".[oracle@timesten-hol info]$ ttdaemonadmin -startTimesTen Daemon startup OK.[oracle@timesten-hol info]$ ttstatusTimesTen status report as of Thu Sep 27 04:10:00 2018Daemon pid 6522 port 53392 instance tt1122TimesTen server pid 6531 started on port 53393------------------------------------------------------------------------Accessible by group oracleEnd of report 创建TimesTen内存数据库 默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过ttadmin -RAMPolicy修改，后面会说到。 也就是说，默认情况下（前提是RAM策略为inUse，下一节会讲到RAM策略的修改），每次在执行connect “dsn=ttdb_name”连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是创建而不是连接到。 连接到特定DSN，创建内存数据库12345678[oracle@timesten-hol info]$ ttisqlCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.Command&gt; connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1) 或者直接在ttisql中指定DSN名称： 12345678910111213141516[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\"Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1)[oracle@timesten-hol ~]$ ttisql my_ttdbCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"DSN=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1) 问题：重复运行connect “dsn=ttdb_name”命令可以看到命令行中显示了多了连接，这是什么作用呢？ 1234567891011121314&gt; Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con1: Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con2: Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con3: Command&gt; &gt; 查看内存数据库的内存分配及容量12345678Command&gt; dssize PERM_ALLOCATED_SIZE: 40960 PERM_IN_USE_SIZE: 9453 PERM_IN_USE_HIGH_WATER: 9453 TEMP_ALLOCATED_SIZE: 32768 TEMP_IN_USE_SIZE: 9442 TEMP_IN_USE_HIGH_WATER: 9505 使用Host命令可以调用操作系统级别的指令1234567891011121314151617181920212223242526272829Command&gt; host ttstatus;TimesTen status report as of Thu Sep 27 04:37:28 2018Daemon pid 6522 port 53392 instance tt1122TimesTen server pid 6531 started on port 53393------------------------------------------------------------------------Data store /u01/ttdata/datastores/my_ttdbThere are 12 connections to the data storeShared Memory KEY 0x1200c904 ID 2785297PL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000Type PID Context Connection Name ConnIDProcess 6973 0x0000000000c72c00 my_ttdb 1Subdaemon 6529 0x00000000012d3360 Manager 142Subdaemon 6529 0x000000000132a1e0 Rollback 141Subdaemon 6529 0x000000000140b360 HistGC 139Subdaemon 6529 0x0000000001420070 AsyncMV 140Subdaemon 6529 0x00000000014b4e00 Log Marker 136Subdaemon 6529 0x0000000001509a30 Deadlock Detector 135Subdaemon 6529 0x000000000151e620 Flusher 134Subdaemon 6529 0x0000000001533210 Checkpoint 133Subdaemon 6529 0x00000000016286b0 Monitor 132Subdaemon 6529 0x00007f95880208e0 Aging 138Subdaemon 6529 0x00007f958808f900 IndexGC 137Replication policy : ManualCache Agent policy : ManualPL/SQL enabled.------------------------------------------------------------------------Accessible by group oracleEnd of report 修改RAM策略 上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为inUse的情况，下面会讲到当RAM策略设置为Manual时创建内存数据库的过程。 Manual策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而inUse策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。 查看当前RAM策略123456[oracle@timesten-hol info]$ ttadmin my_ttdbRAM Residence Policy : inUseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False 修改RAM策略为手动模式（Manual） 手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载 1234567891011121314151617[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdbRAM Residence Policy : manualManually Loaded In RAM : FalseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\"; 707: Attempt to connect to a data store that has been manually unloaded from RAMThe command failed.Done.[oracle@timesten-hol info]$ 向内存中装载数据12345678910111213141516[oracle@timesten-hol info]$ ttadmin -ramload my_ttdbRAM Residence Policy : manualManually Loaded In RAM : TrueReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1)Command&gt; 从内存中卸载数据1234567891011121314151617[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdbRAM Residence Policy : manualManually Loaded In RAM : FalseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\"; 707: Attempt to connect to a data store that has been manually unloaded from RAMThe command failed.Done.[oracle@timesten-hol info]$ 日志和检查点查看日志文件，提交之前会预写日志12345Command&gt; host ls -al /u03/ttdata/logs/my*-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2 查看检查点123Command&gt; host ls -al /u02/ttdata/datastores/my*-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1 手动更新检查点文件 非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。 如下调用检查点文件： 12Command&gt; call ttckpt;Command&gt; call ttckpt; ttisql基本命令——用户操作创建用户，可在表sys.all_users中查找所有的用户信息123456789101112131415161718192021Command&gt; select * from sys.all_users;&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;6 rows found.Command&gt; create user tthr identified by tthr;User created.Command&gt; select * from sys.all_users;&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;&lt; TTHR, 12, 2018-09-28 23:11:57.126074 &gt;7 rows found. 给用户分配权限1234Command&gt; grant create session to tthr;Command&gt; grant create table to tthr;Command&gt; grant create view to tthr;Command&gt; grant create sequence to tthr; 查看当前数据库系统内用户权限1234567891011Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;9 rows found. 撤回用户权限 以下示例展示了如何从用户撤回权限（赋予delete any table权限后再撤回该权限） 12345678910111213141516171819202122232425Command&gt; grant delete any table to tthr;Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, DELETE ANY TABLE, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;10 rows found.Command&gt; revoke delete any table from tthr;Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;9 rows found. ttisql基本命令——数据库对象操作关闭自动提交 意即每次执行事务后，均需要执行commit以提交事务。 1Command&gt; autocommit off; 建表、插入数据123456789101112Command&gt; create table ttemployees &gt; (employee_id NUMBER(6) NOT NULL, &gt; last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB, &gt; PRIMARY KEY (employee_id) ) &gt; UNIQUE HASH ON (employee_id) PAGES = 1;Command&gt; insert into ttemployees values (1, &apos;Smith&apos;, &apos;2009-02-23&apos;, &apos;excellent&apos;); 1 row inserted.Command&gt; insert into ttemployees values (2, &apos;King&apos;, &apos;2005-08-05&apos;, &apos;great&apos;);1 row inserted.Command&gt; insert into ttemployees values (3, &apos;Taylor&apos;, &apos;2012-01-28&apos;, EMPTY_CLOB());1 row inserted.Command&gt; commit; 一些命令总结 tables and alltables - Lists tables indexes and allindexes - Lists indexes views and allviews - Lists views sequences and allsequences - Lists sequences synonyms and allsynonyms - Lists synonyms functions and allfunctions - Lists PL/SQL functions procedures and allprocedures - Lists PL/SQL procedures packages and allpackages - Lists PL/SQL packages PLSQL编程创建plsqldb、pls用户、运行sql脚本12call ttOptUpdateStats;// 更新统计数据，用于分析生成最优执行计划 使用sql developer连接TimesTen和Oracle配置如下： plsql语法 What Is a PL/SQL Package?A package is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The specification (spec for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The body fully defines cursors and subprograms, and so implements the spec. 包是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，规范和主体，主体不是必要的。规范是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。主体将完全定义游标和子程序，以此实现规范。 As Figure 9-1 shows, you can think of the spec as an operational interface and of the body as a “black box.” You can debug, enhance, or replace a package body without changing the interface (package spec) to the package. ——Oracle PL/SQL Package文档 1_package.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243CREATE OR REPLACE PACKAGE test AS -- Declare a record for the desired EMP fields TYPE empRecType IS RECORD ( r_empno EMP.EMPNO%TYPE, -- 使用EMP表中EMPNO的类型 r_ename EMP.ENAME%TYPE, r_salary EMP.SAL%TYPE ); -- Declare a Ref Cursor type TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值 -- A parameterized cursor，定义 -- 游标 CURSOR low_paid (num PLS_INTEGER) IS SELECT empno FROM emp WHERE rownum &lt;= num ORDER BY sal ASC; -- 过程(IN表示输入，OUT表示输出) PROCEDURE ddl_dml (myComment IN VARCHAR2, errCode OUT PLS_INTEGER, -- 整型 errText OUT VARCHAR2); PROCEDURE givePayRise (num IN PLS_INTEGER, name OUT EMP.ENAME%TYPE, -- name是plsql中的保留字，应该尽量避免使用保留字 errCode OUT PLS_INTEGER, errText OUT VARCHAR2); PROCEDURE getCommEmps (empRefCur IN OUT EmpCurType, errCode OUT PLS_INTEGER, errText OUT VARCHAR2); -- Associative array TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type INDEX BY PLS_INTEGER; -- indexed by pls_integer FUNCTION get_sum_multiples ( multiple IN PLS_INTEGER, num IN PLS_INTEGER ) RETURN sum_multiples;END test;/CREATE OR REPLACE PACKAGE BODY test AS PROCEDURE ddl_dml (myComment IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS sql_str VARCHAR2(256); name_already_exists EXCEPTION; insufficient_privileges EXCEPTION; PRAGMA EXCEPTION_INIT(name_already_exists, -0955); PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031); seq_value number; BEGIN BEGIN sql_str := &apos;create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))&apos;; DBMS_OUTPUT.PUT_LINE(sql_str); execute immediate sql_str; EXCEPTION WHEN name_already_exists THEN DBMS_OUTPUT.PUT_LINE(&apos; Ignore existing table errors&apos;); WHEN insufficient_privileges THEN DBMS_OUTPUT.PUT_LINE(&apos; Ignore insufficient privileges errors&apos;); END; -- Cast num_col1 and char_col values insert into temp values (1, 1, myComment); commit; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN name_already_exists THEN errCode := 0; errtext := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END ddl_dml; PROCEDURE givePayRise (num IN PLS_INTEGER, name OUT EMP.ENAME%TYPE, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Can use PLSQL collections within TimesTen PLSQL TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE; lowest_paid lowest_paid_type; i PLS_INTEGER; numRows PLS_INTEGER; lucky_index PLS_INTEGER; lucky_emp EMP.EMPNO%TYPE; BEGIN -- Initialize the output variable name := &apos;Nobody&apos;; -- Initialize the collection lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9); i := 1; -- Constrain the resultset size IF num &lt; 1 OR num &gt; 10 THEN -- If bad inputs, default to 5 rows numRows := 5; ELSE numRows := num; END IF; -- Create the cursor resultset with up to &apos;numRows&apos; rows OPEN low_paid( numRows ); LOOP -- Get the current empid FETCH low_paid INTO lowest_paid(i); EXIT WHEN low_paid%NOTFOUND; -- Increment the PLSQL table index i := i + 1; END LOOP; -- Close the cursor CLOSE low_paid; -- List the subset of lowest paid employees FOR j in lowest_paid.FIRST .. numRows LOOP DBMS_OUTPUT.PUT_LINE(&apos; Lowest paid empno &apos; || j || &apos; is &apos; || lowest_paid(j) ); END LOOP; -- Randomly choose one of the lowest paid employees for a 10% pay raise. lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); lucky_emp := lowest_paid(lucky_index); -- Give lucky_emp a 10% pay raise and return their name UPDATE emp SET sal = sal * 1.1 WHERE empno = lucky_emp RETURNING ename INTO name; COMMIT; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END givePayRise; PROCEDURE getCommEmps (empRefCur IN OUT EmpCurType, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS salesGuy empRecType; BEGIN DBMS_OUTPUT.PUT_LINE(&apos; &apos;); DBMS_OUTPUT.PUT_LINE(&apos;Displaying the refcursor for the sales people&apos;); -- The refcursor (empRefCur) result was opened before calling this procedure LOOP FETCH empRefCur INTO salesGuy; EXIT WHEN empRefCur%NOTFOUND; DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename); END LOOP; CLOSE empRefCur; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END getCommEmps; FUNCTION get_sum_multiples ( multiple IN PLS_INTEGER, num IN PLS_INTEGER ) RETURN sum_multiples IS s sum_multiples; BEGIN FOR i in 1..num LOOP s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples END LOOP; RETURN s; END get_sum_multiples;BEGIN -- package initialization goes here DBMS_OUTPUT.PUT_LINE(&apos;Initialized package test&apos;);END test;/ 2_call_package.sql: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556set serveroutput on;declare errCode PLS_INTEGER; errtext VARCHAR2(256); myRefCur test.EmpCurType; -- 使用test包中定义的类型 salesPerson test.empRecType; name EMP.ENAME%TYPE; n PLS_INTEGER := 5; -- number of multiples to sum for display sn PLS_INTEGER := 10; -- number of multiples to sum m PLS_INTEGER := 3; -- multiple begin dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Find some of the lowest paid employees and give a random employee a 10% pay raise&apos;); -- Give a lowely paid random employee a 10% pay raise test.givePayRise(5, name, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); else dbms_output.put_line(name || &apos; got the 10% payraise&apos;); end if; -- Open a refcursor OPEN myRefCur FOR SELECT empno, ename, sal FROM emp WHERE comm IS NOT NULL; -- display the resultset of the refcursor test.getCommEmps(myRefCur, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Do some DDL and DML in a stored procedure&apos;); test.ddl_dml(&apos;hi&apos;, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; -- associative arrays dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Use an associative array to compute the sum of multiples&apos;); dbms_output.put_line( &apos;Sum of the first &apos; || TO_CHAR(n) || &apos; multiples of &apos; || TO_CHAR(m) || &apos; is &apos; || TO_CHAR(test.get_sum_multiples (m, sn)(n))); end;/ 3_create_package_workload.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234CREATE OR REPLACE PACKAGE workload AS PROCEDURE oltp_read_only ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, errCode OUT PLS_INTEGER, errText OUT VARCHAR2); PROCEDURE oltp_read_write ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, v_c IN CHAR, v_p IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2);END workload;/CREATE OR REPLACE PACKAGE BODY workload AS -- Private package variables used for package initialization theErrCode PLS_INTEGER := 0; theErrText VARCHAR2(256) := &apos;OK&apos;; -- Using shared package cursors for efficiency CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT c FROM sbtest WHERE id BETWEEN n AND m; CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT c FROM sbtest WHERE id BETWEEN n AND m ORDER BY c; CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT DISTINCT c FROM sbtest WHERE id BETWEEN n AND m ORDER BY c; -- The workload read only workload PROCEDURE oltp_read_only ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Store the result of the column &apos;c&apos; cValue char(120); -- Store the sum of the rows in (n..m) sumK number(38,0); BEGIN errCode := 0; errtext := &apos;OK&apos;; -- oltp point query FOR i in 1 .. 10 LOOP -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;); SELECT c INTO cValue FROM sbtest WHERE id = v_id; -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; -- oltp range query (using a cursor for loop)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;); FOR range_rows IN range_query(v_n, v_m) LOOP-- DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c); null; END LOOP; -- olpt range SUM() query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;); SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;-- DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK); -- oltp range ORDER BY query (using explicit fetches)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;); OPEN range_order_query(v_n, v_m); LOOP FETCH range_order_query INTO cValue; EXIT WHEN range_order_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_order_query; -- oltp range DISTINCT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;); OPEN range_distinct_query(v_n, v_m); LOOP FETCH range_distinct_query INTO cValue; EXIT WHEN range_distinct_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_distinct_query; EXCEPTION WHEN NO_DATA_FOUND THEN errCode := 0; errText := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END oltp_read_only; -- The workload read + write workload PROCEDURE oltp_read_write ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, v_c IN CHAR, v_p IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Store the result of the column &apos;c&apos; cValue char(120); -- Store the sum of the rows in (n..m) sumK number(38,0); BEGIN errCode := 0; errtext := &apos;OK&apos;; -- oltp point query FOR i in 1 .. 10 LOOP -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;); SELECT c INTO cValue FROM sbtest WHERE id = v_id; -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; -- oltp range query (using a cursor for loop)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;); FOR range_rows IN range_query(v_n, v_m) LOOP-- DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c); null; END LOOP; -- olpt range SUM() query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;); SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;-- DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK); -- oltp range ORDER BY query (using explict fetches)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;); OPEN range_order_query(v_n, v_m); LOOP FETCH range_order_query INTO cValue; EXIT WHEN range_order_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_order_query; -- oltp range DISTINCT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;); OPEN range_distinct_query(v_n, v_m); LOOP FETCH range_distinct_query INTO cValue; EXIT WHEN range_distinct_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_distinct_query; -- oltp UPDATES on index column-- DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on index column&apos;); UPDATE sbtest SET k = k + 1 WHERE id = v_n; -- oltp UPDATES on non-index column-- DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on non-index column&apos;); UPDATE sbtest SET c = v_n WHERE id = v_m; -- oltp DELETE query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp DELETE query&apos;); DELETE FROM sbtest WHERE id = v_n; -- oltp INSERT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp INSERT query&apos;); INSERT INTO sbtest (id, k, c, pad) VALUES (v_n, v_m, v_c, v_p); -- Commit the changes COMMIT; EXCEPTION WHEN NO_DATA_FOUND THEN errCode := 0; errText := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END oltp_read_write;BEGIN -- package initialization goes here -- Run the procedures once to initialize everything oltp_read_only(1, 1, 10, theErrCode, theErrText ); oltp_read_write(1, 1, 10, &apos;abc&apos;, &apos;def&apos;, theErrCode, theErrText ); DBMS_OUTPUT.PUT_LINE(&apos;Initialized the workload package&apos;);END workload;/ 4_call_workload.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778set serveroutput on;declare counter PLS_INTEGER; errCode PLS_INTEGER; errtext VARCHAR2(256); line1 VARCHAR2(256); line2 VARCHAR2(256); someText sbtest.c%TYPE; moreText VARCHAR2(256); i PLS_INTEGER; iterations PLS_INTEGER; startTime NUMBER; endTime NUMBER; duration NUMBER;begin -- Initialize the someText string line1 := &apos;The quick brown foxy did da jumping thing over that lazy doggy. &apos;; line2 := &apos;Question three, who was scott and who or what was tiger?&apos;; someText := line1 || line2; moreText := &apos;&apos;; -- Initialize the moreText string FOR i in 1 .. 60 LOOP moreText := moreText || &apos;a&apos;; END LOOP; -- Get the start time in centi-seconds startTime := DBMS_UTILITY.GET_TIME(); iterations := 10000; for counter in 1 .. iterations LOOP workload.oltp_read_only(1, 1, 1100, errCode, errtext); if errCode != 0 then exit; end if; end loop; -- Get the end time in centi-seconds endTime := DBMS_UTILITY.GET_TIME(); if errCode !=0 then dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; duration := endTime - startTime; IF duration &gt; 0 THEN dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Called workload.oltp_read_only &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) ); ELSE dbms_output.put_line(&apos;Could not get valid timing info&apos;); END IF; iterations := 10000; for counter in 1 .. iterations LOOP workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext); if errCode != 0 then exit; end if; end loop; -- Get the end time in centi-seconds endTime := DBMS_UTILITY.GET_TIME(); if errCode !=0 then dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; duration := endTime - startTime; IF duration &gt; 0 THEN dbms_output.put_line(&apos;Called workload.oltp_read_write &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) ); ELSE dbms_output.put_line(&apos;Could not get valid timing info&apos;); END IF;end;/","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"TimesTen","slug":"TimesTen","permalink":"http://blog.guitoubing.top/tags/TimesTen/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://blog.guitoubing.top/tags/内存数据库/"},{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"}]},{"title":"软件工程课程笔记（更新中）","slug":"软件工程课程笔记","date":"2018-09-01T13:22:10.000Z","updated":"2018-11-06T13:19:33.866Z","comments":true,"path":"2018/09/01/软件工程课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/01/软件工程课程笔记/","excerpt":"软件工程第一章第二章 软件工程 定义软件工程的框架(Framework) 软件工程的定义 软件工程是：（1）将系统化的(systematic)、规范的(disciplined)、可量化(quantifiable)的方法应用于软件的开发(development)、运行(operation)和维护(maintenance). （2）对（1）中所述方法(approaches)的研究.","text":"软件工程第一章第二章 软件工程 定义软件工程的框架(Framework) 软件工程的定义 软件工程是：（1）将系统化的(systematic)、规范的(disciplined)、可量化(quantifiable)的方法应用于软件的开发(development)、运行(operation)和维护(maintenance). （2）对（1）中所述方法(approaches)的研究. 软件工程层次图 工具-方法-过程-质量关注点 软件过程 软件过程的定义 软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合，一个活动(activity)包含多个动作(action)，一个动作包含多个任务(task). 过程框架 最经典的过程框架： 需求调研(RE)→需求分析建模(Require Analysis Model)→概要设计(Architecture Design)→详细设计(CLD)→编码(Coding)→单元测试(Unit testing)→整合测试(Integrating testing)→系统测试(System testing)→交付或发布(Delivery or Release) 通用的过程框架： 沟通(Communication)→策划(Planning)→建模(Modeling)→构建(Construction)→部署(Deployment) 沟通包含需求调研； 策划是一个普适性活动或者庇护维活动或质量控制维活动(Umbrella activity)，与开发维(devolope demention)或框架活动(framework)不重合 建模包含需求分析建模、概要设计、详细设计 构建包含编码、单元测试、整合测试、系统测试 部署包含发布 milestone milestone是项目管理中用于标记项目时间轴上特定点的工具，用于某一过程活动完成的标志，以使工程能够成功过渡到下一阶段。 普适性活动包含： 软件项目跟踪和控制(Software project tracking and control，以Planning为基础) 风险管理(Risk management) 首先进行风险识别，得到初始识别的风险表(risk list)，利用以下公式将风险按照RE从高到低排序列出。 12&gt; risk exposure(RE，风险曝光度) = impact(影响度) * productivity(影响比例)&gt; 制定风险缓解计划(risk mitigation planning) 风险跟踪(risk tranking)： 可能风险缓解 可能风险真的发生，要有对应的风险处理对策 软件质量保证(Software quality assurance) 例子：SQA，GitHub的bug检查合并 技术评审(Technical review) 按照代码逻辑或者代码行进行评审、检查 测量(Measurement) 定量化， 软件配置管理(Software configuration management) 在整个软件过程中管理变更所带来的影响 可复用管理(Reusability management) 工作产品的准备和生产(Work product preparation and production) 工作分解结构(WBS)： ​ 工作分解结构（简称WBS）跟因数分解是一个原理，就是把一个项目，按一定的原则分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中，直到分解不下去为止。即：项目→任务→工作→日常活动。工作分解结构以可交付成果为导向，对项目要素进行的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。WBS总是处于计划过程的中心，也是制定进度计划、资源需求、成本预算、风险管理计划和采购计划等的重要基础。——百度百科 过程的适应性调整 软件工程过程并不是教条的规则，也不要求软件团队机械地执行，而应该是灵活可适应的（根据软件所需解决的问题、项目特点、开发团队和组织文化等进行适应性调整）。 软件工程实践 具体实施通用框架活动的过程就是软件实践。 实践的精髓 理解问题（沟通和分析）—— Understand the problem (communication and analysis) 策划解决方案（建模和软件设计）—— Plan a solution (modeling and software design) 包含概要设计建模和分析设计建模，最重要的是概要设计建模（体系结构、数据库设计、接口设计） 实施计划（代码生成）—— Carry out the plan (code generation) 就是写代码 检查结果的正确性（测试和质量保证）—— Examine the result for accuracy (tesing and quality assurance) 通过设计足够的测试来发现尽可能多的错误 通用原则 存在价值（The reason it all exists） 保持简洁（KISS, Keep it simple, stupid） 保持愿景（Maintain the Vision） 关注使用者（What You Produce， Others Will Consume） 面向未来（Be Open To The Future） 提前计划复用（Plan Ahead for Reuse） 认真思考（Think！） 软件开发神话Exercise: 找到Tools第三章 软件过程结构通用过程模型 过程流 线性过程流 迭代过程流 演化过程流 并行过程流 定义框架活动过程模式第四章 过程模型（Process Models）传统（惯用）过程模型（Prescriptive Process Models）瀑布模型（Waterfall Model） 又称经典生命周期（Classic life cycle） 瀑布模型可能会有反复的过程，但无迭代的过程，但反复会使得开发过程产生混乱。 瀑布模型的变种：V模型（V-model），V模型拉直后与Generic Process Framework一致。 箭头表示测试过程与设计过程的关系（相关性） 增量过程模型（Incremental Process Models） 增量过程模型没有迭代过程，因为其开发过程没有环 特点： 每1个增量交叉并行 每1个增量都是可以供用户直接使用的系统 第1个增量往往包含主要的、核心的功能 模型的选择：时间限制、资金限制、技术限制 例如项目的99%的需求已经完善，项目需要6个月完成，若时间充足可使用瀑布模型，但若甲方所给时间比较少，则可先完成一部分主要的内容，先交付，后来的需求可在后面的增量中开发，这就是增量模型的一个例子。 演化过程模型（Evolutionary Process Model） 演化模型是迭代的过程模型","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"},{"name":"软件工程","slug":"软件工程","permalink":"http://blog.guitoubing.top/tags/软件工程/"}]},{"title":"计算机网络课程笔记（更新中）","slug":"计算机网络课程笔记","date":"2018-09-01T12:51:13.000Z","updated":"2018-11-06T13:19:33.866Z","comments":true,"path":"2018/09/01/计算机网络课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/01/计算机网络课程笔记/","excerpt":"计算机网络简介 网络通信是进程间的通信，进程的表示： 1IP:port //IP为服务器IP地址，port为服务器上的进程号","text":"计算机网络简介 网络通信是进程间的通信，进程的表示： 1IP:port //IP为服务器IP地址，port为服务器上的进程号 网络组成： Management Application Hardware Cable：电缆、光纤 Network Interface Card：网卡 Switch：交换机 Router：路由器 传播介质（第7章）对传播介质的度量 传播延时 信号在介质中往返一次所需的时间 信道容量 介质可以支持的最大数据速率 频率范围 介质可接受的最大的频率变化范围 带宽 每秒所收到的数据量（Bit） 奈奎斯特定理1234D=2*B*log2KK:传输系统使用的信号电平数B:模拟带宽D:以每秒位元数计算的最大数据速率 香农定理1234C=B*log2(1+S/N)B:硬件带宽S/N:信噪比C:用每秒位数表示的对信道容量的有效限制 分贝(db)和信噪比(S/N)是指数关系 12345dB=10*log10S/Neg: dB = 20 =&gt; S/N = 100 db = 30 =&gt; S/N = 1000 例子：电话线 123Bandwidth = 3000HZS/N ratio = 30db=&gt; C = 30Kps 传输模式（第9章）传输模式分类 串行传输 并行传输 传输数据 例子：Byte 正序(big-endian) &amp;&amp; Bit 逆序(little-endian) 串行传输方式 异步传输 键盘输入，RS-232异步字符传输 RS-232异步字符传输标准 把一串字符串通过铜线进行传输 S1:把字符用ASCII码表示出来；S2: 状态机：电压变化表示状态切换 空闲状态： ​ 接受”-“：保持空闲状态 ​ 接受”+“：变成传输状态 传输状态： ​ 接受”-“：保持传输状态，传1 ​ 接受“+”：保持传输状态，传0 传输的数据前后各需要一位，分别作为起始位(+)、终止位(-) 结束按照“翻转”时间确定，传输完成保持负电压 最终传输到接收方是9位，多一位校验码 同步传输 以太网 原理同对表一样 实现方法：采用先传输一部分规定好的数据，来检测发送方和接收方是否一致 等时传输 利用缓冲区实现 标准 波特率匹配 例子：传输Z(0x5A)，检测波特率提高一倍 通信信道 单工信道 Eg：广播、收音机 全双工信道 数据线路设备(DCE)和数据终端设备(DTE) 反接线 半双工信道 Eg：对讲机 调制和调制解调器（第10章）远距离传输 考虑：干扰、信号衰减 解决方案：载波传输 载波传输方式 连续性好 载波改变方式——调制（Modulation）与解调（Demodulation）1234S(t)=Asin(2πFt+P)// A: Amplitude Modulation(调幅)// F: Frequency Modulation(调频，单位时间内波的个数)// P: Phase Modulation(调相) 调幅 调幅的大小有一定的限制（香农定理的限制） 调频 调相 键控（Shift keying）调制技术的比较 调相的效率要高一点，变化一次可传输不止一位（通过相位分隔，例如将2π分为8份，则有8种信号，可传输3位数据） 正交调幅(QAM, Quadrature Amplitude Modulation) 结合调幅和移相键控，使用同时包含相位和振幅的改变来表示数据，QAM最大可以表示1024个 公式：Y~m~(t) = A~m~sinwt+B~m~coswt，运算为矢量运算 调制解调器类型 无线猫（RF，Radio Frequency） 光纤猫（optical modems） 拨号猫（Dialup modem） 拨号调制解调器模式 Calling mode Answer mode 复用与解复用（第11章）分类频分多路复用FDM 多个逻辑信道，实际上只有一个物理信道。 防止频道之间干扰，通常有个区间为防护带区间。 信号的漂移现象 解决方法：子信道分配 分级FDM 分布式平铺 波分多路复用WDM 是指应用于光纤中的频分复用技术 时分多路复用TDM 同步TDM 问题：空闲时隙 应用：电话通话 分级TDM 统计TDM 应用：网络 逆转复用 将单个高速数字输入被分配到多个低速连接上，传输后再重新复合而形成输入的副本 码分多路复用CDM 矢量（Vector） 矢量的运算 结论 可靠性和信道编码（第8章）数据传输错误的3个源头 干扰 失真 衰减 传输差错对数据的影响 单个差错 突发差错 擦除（模糊） 处理信道差错的两种策略（信道编码） 发送数据的同时，发送校验码 前向纠错（FEC） 自动重传请求（ARQ） FEC机制 单奇偶检验 奇偶性定义为1的个数，且校验位的添加会使得码字始终保持奇数或偶数，保持奇数就是奇校验，保持偶数就是偶校验. 限制：校验能力有限，出两个错误时便无法校验 分组码数学与（n, k）表示 汉明距离 先计算最小汉明距d，而后得出可检查的最大的有效位长度：E&lt;=d-1 纵横奇偶校验 作用：可以找出错误的位置，并改正错误 缺点：效率低下，一般不用 校验和 码的长度一般为字节的倍数，进位需加回到原和中 优点： 校验和的大小比较小 计算很简单 开支很低 缺点： 对纵向错误无法校验（导致校验和方法一般不用在硬件上） 一般情况下，校验和位取的是算数反码，校验时所有数据位相加，得到结果取补码为0则数据正确 1IP包的头部长度：20Bytes 循环冗余校验码（CRC码，适宜用在硬件上，例如网卡） 关键特性 任意长度报文 出色的检错能力 快速硬件实现 线性码、循环线性码 线性码是一个码的集合C，且C~1~、C~2~∈C，则C~1~、C~2~∈C的线性组合仍然∈C； 循环线性码是指码循环移位后的码仍然属于该集合。 原理 硬件实现 异或门实现基本运算 算法 自动重传请求(ARQ)机制 数据传输成功会发送回执，错误则不发送回执 ​ OSI Reference Model 数据流（Data Flow）： Service服务：下一层对上一层提供服务（接口、方法） Protocol协议 Physical物理 物理层（5 7 9 10 11） 数据链路层（8） 将一条物理上有差错的传输信道通过通知和管理而变成逻辑上无差错的 因特网应用与网络编程（第3章）线路交换网络（circuit switched network）包交换网络（packet switched network） 特征：轮流 ​ 异步 不用安装 主要区别在于二者的共享性 局域网：分组、帧和拓扑（第13章）以太网的接受方式 广播式： MAC子层拷贝每个包 LLC子层提取每个包的拷贝 LLC子层只接受那些单一传播、广播或多路传播的地址相匹配的包 帧 帧头、帧尾用于检测传输过程是否发生错误，同时用作边界 边界采用两个ASC码中很少使用的字符： SOH（01）头部起始字符 EOT（04）传输结束字符 此方案的缺陷假如使用此两个字符，将会发生接受解析问题 解决方案 字填充（ABC可换成“任意”字符，但是效率不同，找一些不太会出现的字符会提高效率）： soh → esc + A eot → esc + B esc → esc + C 位填充： 5个1出现了便插入1个0，首尾使用01111110作为边界 IEEE MAC子层（第14章）受控介入协议（Control Access Protocols）轮询 方式： 按循环顺序 按优先级顺序 算法： 12345678&gt; 目的：&gt; 通过轮询来控制分组的发送&gt; 方法：&gt; 控制器不断重复&#123;&gt; 选择站点S，发送一个查询报文给S；&gt; 等待S发送一个分组来进行响应或跳过；&gt; &#125;&gt; 预定 算法： 12345678&gt; 目的：&gt; 通过预约来控制分组的发送&gt; 方法：&gt; 控制器不断重复&#123;&gt; 形成一个需要发送分组的站点列表；&gt; 允许列表中的站点发送分组；&gt; &#125;&gt; 令牌传递 令牌是一个特殊的帧，不管有没有数据都会在环状网络中传输 令牌有两个状态（空和忙的切换只能由同一个站点切换）： 空 → 可以发送（数据在传输时转变为忙令牌） 忙 → 无法发送（只能当数据在环网中发送一周时，才能将忙令牌转换为空令牌） 算法： 123456789&gt; 目的：&gt; 通过令牌传递来控制分组的发送&gt; 方法：&gt; 网络上的每台计算机重复执行&#123;&gt; 等待令牌的到达；&gt; 如果本计算机有分组正在等待发送，则发送一个分组；&gt; 将令牌发送到下一站；&gt; &#125;&gt; 12345678&gt; 1）空令牌传递到下一个节点；&gt; 2）节点是否要发送？不发送，转向1）&gt; 3）填充帧到令牌中，并置为忙&gt; 4）忙令牌传递到下一个节点&gt; 5）是否接受节点？是，复制该帧；转向4）&gt; 6）节点是否发送节点？是，销毁令牌中的帧，并置空，返回1）&gt; 7）返回4）&gt; 随机接入协议（Random Access Protocol）ALOHACSMA/CD（Collision Detect） 以太网中一个网卡数据一旦发送，便不能停下，需等到数据发送完 算法： 123456&gt; 1）监听网络状态；如果空闲，转向3）&gt; 2）等待，返回1）&gt; 3）发送，在发送的过程中同时进行碰撞监听&gt; 4）一旦发生碰撞，立即停止发送&gt; 5）推后一个随机时间，返回1）&gt; 检测冲突的方法： 载波侦听 冲突检测 二进制指数退避 CSMA/CA（Collision Avoidance） 算法： 有限局域网技术（第15章）以太网帧格式 以太网帧结构（截自维基百科） Question：(Using 广播 ) How does the sender know the target physical address？（注意：网卡无法识别IP地址） 地址解析（Address Resolution）目的地地址解析Sender： 发送广播，征询目的节点的物理地址 接到目的节点应答，取出目的节点物理地址 All Receivers： 接到广播，取出源节点物理地址,比较主机名是否相同 目标节点，匹配，就取出源节点物理地址，以该地址为目的地址，本物理地址为源地址，作询问应答 其他节点，因不匹配不需要作回答 帧类型（Frame Type） 用于区分帧的类型，是ARP包还是IP包（区分协议类型） IP：0800 ARP：0806 IEEE’s 802.3 Ethernet Frame（一种新的帧格式）网卡 NIC Network Interface Card NIC可以直接访问Memory，NIC与CPU仅存在指令关系 过程： 发送 Before sending data, CPU forms a packet in memory 发送数据之前，CPU在内存中产生一个数据包 CPU then instructs the NIC to begin transmission CPU给NIC发送播送指令 NIC transmits the frame containing the packet After finishing transmission, NIC uses the computer’s interrupt mechanism to inform the CPU 接收 The NIC waits for a frame to cross the network The NIC makes a copy of the frame The NIC verifies the frame CRC and checks the destination address If the destination address is correct，the NIC stores a copy of the packet in memory The NIC then interrupts the CPU Otherwise，the NIC discards the frame 网卡产品（NIC Evolution）粗缆（Original Thick Ethernet Wiring） IEEE802.310Base5 最大长度：500m（摩天大楼的高度） 组成： 网卡（连在设备上） 收发器 电缆 Terminator（终结器）：将信号能量消耗掉，防止信号反弹造成干扰，原理是电阻 Connection Multiplexor（多路连接器）：允许多台计算机连接到单个收发器，且提供与传统收发器完全相同的信号 细缆（Thin Ethernet） 将前者的三部分组合起来，结构和环网很像，但传输方式仍然是广播式的，Terminator仍然需要。 双绞线以太网（Twisted Pair Ethernet） HUB（集线器）里面包含了主线 集成网卡 RJ-45：双绞线 AUI：粗缆 BNC：细缆 双绞线网卡拓扑结构 Tips：网络上的逻辑上和结构上的拓扑结构可以不同！ 物理上：星形结构 逻辑上：总线结构 举例： 布线工程 无线联网技术（第16章）个域网（PAN，802.15） 蓝牙 红外 蓝牙耗电比较低，红外耗电高 紫峰（ZigBee） ISM无线 无线局域网（WLAN、WiFi，802.11） 为降低信号衰减采用FDM分布式平铺技术（第11章） AP，Access Point through the air （Base Station），相当于集线器 类型 专门构建型（Ad hoc） 点到点，不通过AP 基础结构型（Infrastructure） 通过AP Manet（Mobile Ad-hoc Networks）","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.guitoubing.top/tags/计算机网络/"}]},{"title":"dotnet基本配置及EFCore连接Mysql","slug":"Dotnet","date":"2018-06-26T08:57:08.000Z","updated":"2018-11-06T13:19:33.867Z","comments":true,"path":"2018/06/26/Dotnet/","link":"","permalink":"http://blog.guitoubing.top/2018/06/26/Dotnet/","excerpt":"前奏部分 下载并安装dotnet core 下载并安装vscode（需要把vscode添加到path中）","text":"前奏部分 下载并安装dotnet core 下载并安装vscode（需要把vscode添加到path中） vscode中搜索并安装C#插件、NuGet Package Manager插件 新建项目 12345&gt; mkdir dotnet&gt; cd dotnet&gt; dotnet new mvc&gt; code .&gt; commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择 添加包时以下代码将自动在dotnet.csproj中添加： 12345678910&gt; &lt;ItemGroup&gt;&gt; &lt;PackageReference Include=\"Microsoft.AspNetCore.All\" Version=\"2.0.6\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite\" Version=\"2.1.0\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"2.1.0\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite.Design\" Version=\"2.0.0-preview1-final\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/&gt;&gt; &lt;PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql\" Version=\"2.1.0-rc1-final\"/&gt;&gt; &lt;PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql.Design\" Version=\"1.1.2\"/&gt;&gt; &lt;/ItemGroup&gt;&gt; Model部分 连接数据库创建实体： 在vscode终端中输入以下命令 1dotnet ef dbcontext scaffold &quot;server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;&quot; Pomelo.EntityFrameworkCore.MySql -o Models dotnet ef两个问题 问题1：No executable found matching command “dotnet-ef”解决方法：dotnet.csproj中添加如下行： 1234&gt; &lt;ItemGroup&gt;&gt; &lt;DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/&gt;&gt; &lt;/ItemGroup&gt;&gt; 问题2：Version for package Microsoft.EntityFrameworkCore.Tools.DotNet could not be resolved. 原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可 此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。至此MVC已完成Model部分。 Controller及View部分 目前项目Models文件夹下已有DBFirst模式生成的实体文件： 我们选择Student的Model创建C-V视图 这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index： 1234&gt; public IActionResult Index()&#123;&gt; return View(_context.Student.ToList());&gt; &#125;&gt; 如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，View只负责处理布局，Controller只负责处理逻辑。 创建StudentController.cs 123456789101112131415161718192021222324252627282930313233343536&gt; using System;&gt; using System.Collections.Generic;&gt; using System.Diagnostics;&gt; using System.Linq;&gt; using System.Threading.Tasks;&gt; using Microsoft.AspNetCore.Mvc;&gt; using dotnet.Models;&gt; using dotnet;&gt; &gt; public class StudentController : Controller&#123;&gt; private universityContext _context;&gt; &gt; public StudentController(universityContext context)&#123;&gt; _context = context;&gt; &#125;&gt; &gt; public IActionResult Index()&#123;&gt; return View(_context.Student.ToList());&gt; &#125;&gt; &gt; public IActionResult Register()&#123;&gt; return View();&gt; &#125;&gt; &gt; [HttpPost]&gt; [ValidateAntiForgeryToken]&gt; public IActionResult Register(Student student)&#123;&gt; if(ModelState.IsValid)&#123;&gt; _context.Student.Add(student);&gt; _context.SaveChanges();&gt; return RedirectToAction(&quot;Index&quot;);&gt; &#125;&gt; return View(student);&gt; &#125;&gt; &#125;&gt; 创建Student文件夹，以及对应路由的cshtml Index.cshtml 1234567891011121314151617181920212223242526272829303132&gt; @&#123;&gt; ViewData[\"Title\"] = \"学生主页\";&gt; &#125;&gt; &gt; &lt;!-- 此处这个model声明不能忘记 --&gt;&gt; @model IEnumerable&lt;dotnet.Student&gt;&gt; &gt; &lt;table class=\"table\"&gt;&gt; &lt;tr&gt;&gt; &lt;th&gt;Id&lt;/th&gt;&gt; &lt;th&gt;姓名&lt;/th&gt;&gt; &lt;th&gt;系&lt;/th&gt;&gt; &lt;th&gt;学分&lt;/th&gt;&gt; &lt;/tr&gt;&gt; @foreach (var item in Model)&#123;&gt; &lt;tr&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.Id)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.Name)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.DeptName)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.TotCred)&gt; &lt;/td&gt;&gt; &lt;/tr&gt;&gt; &#125;&gt; &lt;/table&gt;&gt; Register.cshtml 12345678910111213141516171819202122232425262728293031323334&gt; @model dotnet.Student&gt; &gt; @&#123;&gt; ViewData[\"Title\"] = \"注册\";&gt; &#125;&gt; &gt; &lt;form asp-controller=\"Student\" asp-action=\"Register\" method=\"POST\"&gt;&gt; &lt;div class=\"form-group\"&gt;&gt; &lt;label asp-for=\"Id\" class=\"col-md-2 control-label\"&gt;编号：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"Id\"/&gt;&gt; &lt;span asp-validation-for=\"Id\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"Name\" class=\"col-md-2 control-label\"&gt;名字：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"Name\"/&gt;&gt; &lt;span asp-validation-for=\"Name\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"DeptName\" class=\"col-md-2 control-label\"&gt;系：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"DeptName\"/&gt;&gt; &lt;span asp-validation-for=\"DeptName\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"TotCred\" class=\"col-md-2 control-label\"&gt;学分：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"TotCred\"/&gt;&gt; &lt;span asp-validation-for=\"TotCred\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;div class=\"col-md-offset-2 col-md-10\"&gt;&gt; &lt;input type=\"submit\" value=\"保存\" class=\"btn btn-default\"/&gt;&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; &lt;/form&gt;&gt; 关于抛出以下错误的解决方法 错误： 解决方法： 注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码： 123456&gt; public void ConfigureServices(IServiceCollection services)&gt; &#123;&gt; services.AddDbContext&lt;universityContext&gt;();&gt; services.AddMvc();&gt; &#125;&gt; 即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下： 1234&gt; //if (!optionsBuilder.IsConfigured)&#123; &gt; optionsBuilder.UseMySql(&quot;server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;&quot;);&gt; //&#125;&gt; 运行项目 调试的方法 vscode下点按“开始调试” 浏览器将会自动跳转至localhost:5000 在URL中添加/student或student/index跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中： 戳这里下载Asp.net Core开发实战.pdf","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Dotnet","slug":"Dotnet","permalink":"http://blog.guitoubing.top/tags/Dotnet/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.guitoubing.top/tags/数据库/"}]},{"title":"我们梦中见","slug":"2017-10-14","date":"2018-06-26T04:29:17.000Z","updated":"2018-11-06T13:19:33.866Z","comments":true,"path":"2018/06/26/2017-10-14/","link":"","permalink":"http://blog.guitoubing.top/2018/06/26/2017-10-14/","excerpt":"“Yeah It’s on. ” 26/06/2018当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。 14/10/2017（是不是个技博自己心里没点B数？","text":"“Yeah It’s on. ” 26/06/2018当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。 14/10/2017（是不是个技博自己心里没点B数？ 应该说天明学长在技术方面给予了很大的支持，为她打call！ 说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？ 买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。 接下来是干货了（扯淡然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到天明学长了，在她网站中得知有了个Hexo的框架，仿佛看到了未来。至于Hexo怎么用，官方文档里面都很详尽了，这里讲几点用的时候踩过的坑，以备。 _config.YML配置，比较重要的几个地方路径URL12url: http://guitoubing.top/root: / url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错 在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。 Disqus插件12# Disqus settingsdisqus_username: guitoubing 因为多说已经关闭服务了，只能用Disqus，而Disqus又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题hexo-theme-huxblog已经集成了Disqus的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 Analytics123456# Analytics settings# Baidu Analyticsba_track_id: bcfce8e737b***********04c164dc96# Google Analyticsga_track_id: &apos;UA-10*******-1&apos; # Format: UA-xxxxxx-xxga_domain: guitoubing.top deploy1234567deploy: type: ftpsync host: guitoubing.top user: webmaster@HK****** pass: tanrui106 remote: /WEB/ port: 21 deploy就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。 _config.YML配置完成了就可以开始创作咯123hexo new &quot;blog&quot; hexo ghexo s Hexo官方文档都有详细使用方法，不赘述。 有几句MMP当讲1古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？ 从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）","categories":[{"name":"life","slug":"life","permalink":"http://blog.guitoubing.top/categories/life/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.guitoubing.top/tags/Hexo/"}]}]}