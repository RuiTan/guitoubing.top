{"meta":{"title":"Archer","subtitle":null,"description":null,"author":"Rui","url":"http://blog.guitoubing.top"},"pages":[{"title":"404 Not Found 该页无法显示","date":"2018-11-05T17:08:58.000Z","updated":"2018-11-05T17:11:24.000Z","comments":true,"path":"/404.html","permalink":"http://blog.guitoubing.top//404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-10-20T13:04:41.000Z","updated":"2018-11-06T14:05:46.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.guitoubing.top/about/index.html","excerpt":"","text":"用心写文，用脚上传每日一问 芳芳到底什么时候下班呢？"},{"title":"tags","date":"2018-11-05T17:00:28.000Z","updated":"2018-11-05T17:00:28.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.guitoubing.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hadoop-Tags","slug":"Hadoop-Tags","date":"2018-12-11T16:33:02.000Z","updated":"2018-12-11T16:39:31.379Z","comments":true,"path":"2018/12/12/Hadoop-Tags/","link":"","permalink":"http://blog.guitoubing.top/2018/12/12/Hadoop-Tags/","excerpt":"更新中……","text":"更新中…… Hadoop TagsHDFS NameNode内存要求较高，存储文件系统元结构（文件目录结构、分块情况、每块位置、权限等） 文件分块默认最小块128M jps命令查看NameNode/DataNode是否启动 jps在jdk8u191中好像不适用，暂未找到解决方法 ip:9870利用web界面查看Hadoop节点信息（Mac上端口号为50070） 进入用户目录下的.ssh目录，执行ssh-keygen -t rsa创建公钥私钥，使用ssh-copy-id ${hostname}将公钥传给每个节点（NameNode和DataNode都需要） 使用hadoop fs -ls /查看Hadoop上所有文件，使用hadoop fs -put ${filename} /上传文件… hdfs-site.xml中修改dfs.replication配置可修改文件备份份数（默认为3），修改dfs.namenode.heartbead.recheck-interval指定Hadoop检查机器运行情况的时间间隔（默认3000000ms） 注意： 例如当备份份数为2时，现在有三台DataNode机器，文件被分为2个block，block1位于1和2上，block2位于1和3上，这是若机器3宕机了，hdfs会在设定的dfs.namenode.heartbead.recheck-interval时间间隔内检查出机器3，此时block2数量变为1，hdfs会自动将1中的block2复制一份到另外一台可用机器上（此处为2）。当机器3恢复运行时，3中备份的block2会自动删除。 当使用java访问hdfs时，不会使用hdfs-site.xml中的dfs.replication，而会默认使用3，可在java的configuration中配置为指定值 分鱼展:分块、冗余、可扩展 Yarn ResourceManage NodeManage一般与DataNode放一起 Yarn逻辑上与HDFS完全分离，但一般绑定HDFS一起使用 yarn-site.xml的配置 注意：master与slaves都需要进行配置。 1234&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt;&lt;/property&gt; mapred-site.xml的配置 注意： 仅NameNode需要配置 MapReduce不一定需要Yarn 若不配MapReduce，其会仅在单机跑 1234&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; TODO List 安全与权限（kerberos） Secondary NameNode（check point NameNode） HA（High Ability）实现 Federation，超大规模数据中心","categories":[{"name":"-- archive","slug":"archive","permalink":"http://blog.guitoubing.top/categories/archive/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://blog.guitoubing.top/tags/Hadoop/"},{"name":"云计算","slug":"云计算","permalink":"http://blog.guitoubing.top/tags/云计算/"}]},{"title":"Best Practice","slug":"Practice","date":"2018-11-24T06:18:44.000Z","updated":"2018-12-05T11:30:20.453Z","comments":true,"path":"2018/11/24/Practice/","link":"","permalink":"http://blog.guitoubing.top/2018/11/24/Practice/","excerpt":"Oracle专家的三次授课。","text":"Oracle专家的三次授课。 Lesson 1创建用户并分配权限创建测试schema，命名为test1create user test identified by test; 分配连接资源123grant connect,resource to test;grant execute on dbms_lock to test;grant execute on UTL_FILE to test; 为test用户创建external_data目录以及分配权限12create directory external_data as &apos;/home/oracle/data&apos;;grant read,write on directory external_data to test; 要注意oracle用户必须拥有对这里的external_data路径读写的权限。 分配表空间权限我们知道oracle中没有库的概念，取而代之的是表空间（Tablespace），在oracle初次被安装时，数据库中只有系统本身内置的表空间： SYSTEM - 存储数据字典 SYSAUX - 存储辅助应用程序的数据 TEMP - 存储数据库临时对象 USERS - 存储各个用户创建的对象 UNDOTBS - 存储不一致数据，用于事物回滚、数据库恢复、读一致性、闪回查询 …… 而当第一次通过管理员创建一个用户且未为其创建并指定表空间时，数据库系统会为其指定默认的表空间为SYSTEM，而他并没有使用SYSTEM表空间的权限，因此该用户无法完成建表等操作，可通过执行以下操作： 123456789-- DBA下执行：-- 查看数据库中的所有表空间select * from v$tablespace;-- 查看当前用户所在的表空间(注意oracle系统表中存储的用户名字段都是大写，要注意这与“oracle中不区分大小写”这一概念区分开来)select username,default_tablespace from dba_users where username=&apos;TEST&apos;;-- 为用户赋予当前表空间下的权限alter user test quota unlimited on users;-- 或者制定用户可用大小：alter user test quota 50M on users; 连接用户，建表，跑存储过程和函数连接test用户123-- 在系统命令下连接cd $ORACLE_HOME/bin./sqlplus test/test 12-- 在进入sqlplus后的连接conn test/test 创建表123456789101112131415161718192021create table t_mobiles(f_id number(6),f_mobile_head varchar2(50),f_province varchar2(50),f_city varchar2(50),f_platform varchar2(50),f_tel_head varchar2(50),f_zipcode varchar2(50),primary key(f_id));COMMENT ON COLUMN T_MOBILES.F_ID IS &apos;主键&apos;;COMMENT ON COLUMN T_MOBILES.F_MOBILE_HEAD IS &apos;手机号段&apos;;COMMENT ON COLUMN T_MOBILES.F_PROVINCE IS &apos;省份地区&apos;;COMMENT ON COLUMN T_MOBILES.F_CITY IS &apos;城市&apos;;COMMENT ON COLUMN T_MOBILES.F_PLATFORM IS &apos;运营商&apos;;COMMENT ON COLUMN T_MOBILES.F_TEL_HEAD IS &apos;固话区号&apos;;COMMENT ON COLUMN T_MOBILES.F_ZIPCODE IS &apos;邮政编码&apos;;COMMENT ON TABLE T_MOBILES IS &apos;号段表&apos;;create table t_records(f_id number(6),f_no varchar2(50),f_begin_time date,f_end_time date,f_duration number(10,0),f_province VARCHAR2(50), f_platform varchar2(50), f_mobile NUMBER(1) DEFAULT -1);--*注：因f_id导入时缺少数据，所有先不设置为PK.COMMENT ON COLUMN T_RECORDS.F_ID IS &apos;主键&apos;;COMMENT ON COLUMN T_RECORDS.F_NO IS &apos;通话号码&apos;;COMMENT ON COLUMN T_RECORDS.F_BEGIN_TIME IS &apos;开始时间&apos;;COMMENT ON COLUMN T_RECORDS.F_END_TIME IS &apos;结束时间&apos;;COMMENT ON COLUMN T_RECORDS.F_DURATION IS &apos;通话时长&apos;;COMMENT ON COLUMN T_RECORDS.F_PROVINCE IS &apos;省份地区&apos;;COMMENT ON COLUMN T_RECORDS.F_PLATFORM IS &apos;运营商&apos;;COMMENT ON COLUMN T_RECORDS.F_MOBILE IS &apos;手机号码标志&apos;;COMMENT ON TABLE T_RECORDS IS &apos;通话清单表&apos;; 创建ctl文件导入csv数据进入external_data路径下并创建以下文件： 123$ cd /home/oracle/data$ vi control_mobiles.ctl$ vi control_records.ctl control_mobiles.ctl: 123456789101112131415LOAD DATACHARACTERSET UTF8INFILE &apos;/home/oracle/data/mobiles.csv&apos;TRUNCATE INTO TABLE t_mobilesFIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;TRAILING NULLCOLS( F_ID, F_MOBILE_HEAD, F_PROVINCE, F_CITY, F_PLATFORM, F_TEL_HEAD, F_ZIPCODE) control_records.ctl: 123456789101112LOAD DATACHARACTERSET UTF8INFILE &apos;/home/oracle/data/records.csv&apos;TRUNCATE INTO TABLE t_recordsFIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;TRAILING NULLCOLS( F_NO, F_BEGIN_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;, F_END_TIME DATE &quot;YYYY-MM-DD HH24:MI:SS&quot;, F_DURATION INTEGER EXTERNAL) 在该路径下执行导入操作： 12$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_mobiles.ctl$ $ORACLE_HOME/bin/sqlldr userid=test/test control=control_records.ctl 教程中命令为： 12&gt; $ sqlldr userid=test/test@orcl control=control_mobiles.ctl&gt; 即在导入时指定连接字符串（这里的orcl实际上是连接字符串的别名），其在$ORACLE_HOME/network/admin/tnsname.ora中被声明，但是默认状态下oracle中并没有配置该连接字符串，意味着我们在连接时不需要为其指定值。 既然如此，应用程序该如何在未进行上述配置的情况下连接到该字符串呢？这里就是连接字符串和服务名的区别，oracle有个默认服务名XE，实际上oracle中还有多个备用服务，当XE服务崩掉的时候会自动切换到备用服务。连接字符串如下： 12&gt; jdbc:oracle:thin:@localhost:1521:XE&gt; 那么没有配置连接字符串别名时，sqlplus如何通过此方法连接呢？如下直接将连接字符串全部写全： 123&gt; # 命令格式：sqlplus username/password@host:port/service_name&gt; $ sqlplus tanrui/tanrui@127.0.0.1:1521/xe&gt; 数据预处理123456789101112131415161718192021222324-- 1、创建序列seq_records_pk用于生成通话记录表t_records的主键create sequence seq_records increment by 1 start with 1 ;-- 2、修补通话记录表t_records的主键数据，并把f_id改为主键update t_records set f_id=seq_records.nextval;alter table t_records add constraint t_records_pk primary key (f_id);-- 3、创建并初始化同步锁表，用于多线程同步控制CREATE TABLE T_LOCK(F_NAME VARCHAR2(30),F_INDEX NUMBER(20,0),PRIMARY KEY(F_NAME));COMMENT ON COLUMN T_LOCK.F_NAME IS &apos;锁名&apos;;COMMENT ON COLUMN T_LOCK.F_INDEX IS &apos;锁的当前值&apos;;COMMENT ON TABLE T_LOCK IS &apos;同步锁表&apos;;insert into T_LOCK values(&apos;_RECORD_INDEX&apos;,0);-- 4、在电话号段表中创建唯一性索引，提高号段检索速度create unique index uniq_mobile_head on t_mobiles(f_mobile_head);update t_mobiles set f_province = &apos;内蒙古&apos; where f_province = &apos;内蒙&apos;;-- 5、创建日志表，用于记录程序执行过程中的日志信息。create table t_log(f_time date, f_head varchar2(20), f_content varchar2(500));COMMENT ON COLUMN T_LOG.F_TIME IS &apos;日志时间&apos;;COMMENT ON COLUMN T_LOG.F_HEAD IS &apos;日志类型标志&apos;;COMMENT ON COLUMN T_LOG.F_CONTENT IS &apos;日志内容&apos;;COMMENT ON TABLE T_LOG IS &apos;日志表&apos;; 创建函数和存储过程声明函数和存储过程 函数is_mobile，判断通话号码是否为手机号码 1234567891011121314151617181920212223242526272829303132333435--函数：判断通话号码是否为手机号码CREATE OR REPLACE FUNCTION is_mobile(phone VARCHAR2) RETURN BOOLEAN IS v_phone VARCHAR2(20); v_head VARCHAR2(2);BEGIN --检查参数func IF phone IS NULL THEN RETURN FALSE; END IF; --去除前后空格 v_phone := TRIM(phone); --去除号码前面的0 IF substr(v_phone,0,1) = &apos;0&apos; THEN v_phone := substr(v_phone, 2); END IF; --检查手机号码长度 IF substr(v_phone,0,1) &lt;&gt; &apos;1&apos; OR LENGTH(v_phone) &lt;&gt; 11 THEN RETURN FALSE; END IF; --截取号码前两位 v_head := substr(v_phone,1,2); IF v_head = &apos;13&apos; OR v_head = &apos;14&apos; OR v_head =&apos;15&apos; OR v_head =&apos;17&apos; OR v_head = &apos;18&apos; THEN RETURN TRUE; ELSE RETURN FALSE; END IF;END;/ 存储过程init，清空t_log，同时t_lock置零 1234567891011121314151617181920--存储过程：初始化测试数据CREATE OR REPLACE PROCEDURE init IS CURSOR job_cursor IS SELECT JOB FROM user_jobs;BEGIN --重置处理位置为0 EXECUTE IMMEDIATE &apos;update t_lock set f_index=0&apos;; --清除日志表中的记录 EXECUTE IMMEDIATE &apos;truncate table t_log&apos;; --重置话单表中的记录 EXECUTE IMMEDIATE &apos;update t_records set f_province = NULL,f_platform=NULL, f_mobile=-1&apos;; COMMIT; FOR tmp_job IN job_cursor LOOP dbms_job.broken(tmp_job.JOB,TRUE,sysdate); dbms_job.REMOVE(tmp_job.JOB); END LOOP;END;/ 存储过程print，打印日志，存到T_LOG表中 123456789101112--存储过程：打印日志CREATE OR REPLACE PROCEDURE print(prefix VARCHAR2, content VARCHAR2) ISBEGIN --dbms_output.put_line(to_char(&apos;yyyy-mm-dd hh24:mi:ss&apos;)||&apos;,&apos;||prefix||&apos;,&apos;||content); INSERT INTO t_log VALUES(sysdate,prefix, content); COMMIT;EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&apos;Error code: &apos;||SQLCODE); dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);END;/ 存储过程show，显示当前处理情况 123456789101112131415161718192021222324252627282930--存储过程：显示当前处理情况CREATE OR REPLACE PROCEDURE show IS --待处理记录总数 v_record_count NUMBER; --当前日志表记录总数 v_log_count NUMBER; --当前数据处理位置 v_current_index NUMBER; --用户Job表游标 CURSOR job_cursor IS SELECT * FROM user_jobs;BEGIN SELECT COUNT(1) INTO v_log_count FROM t_log; SELECT f_index INTO v_current_index FROM t_lock; SELECT COUNT(1) INTO v_record_count FROM t_records; dbms_output.put_line(&apos;log count: &apos;||v_log_count); dbms_output.put_line(&apos;record count: &apos;||v_record_count); dbms_output.put_line(&apos;current index: &apos;||v_current_index); --清除用户job记录 FOR tmp_job IN job_cursor LOOP dbms_output.put_line(&apos;job:&apos;||tmp_job.JOB||&apos;,broken:&apos;||tmp_job.broken||&apos;,total_time:&apos;||tmp_job.total_time||&apos;,failures:&apos;||tmp_job.failures||&apos;,interval:&apos;||tmp_job.INTERVAL||&apos;,last_sec:&apos;||tmp_job.last_sec||&apos;,next_sec:&apos;||tmp_job.next_sec); END LOOP;END;/ 存储过程process_data，提交一个job处理数据 共享锁和排它锁: 当某事务对数据添加共享锁时，此时该事务只能读不能写，其他事务只能对该数据添加共享锁，而不能添加排它锁 当某事务对数据添加排它锁时，此时该事务既能读又能写，其他事务不能对该数据添加任何锁 autocommit需要关掉: 假设现在有三个job对T_LOCK表进行并发读写，如下： 步骤如下： 阻塞情况： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586--存储过程：处理数据CREATE OR REPLACE PROCEDURE process_data(process_no IN NUMBER, batch_size IN NUMBER) IS --定义常量 c_record_index CONSTANT VARCHAR2(20) :=&apos;_RECORD_INDEX&apos;; c_process_prefix CONSTANT VARCHAR2(20) := &apos;[ PROCESS ]&apos;; c_select_record_sql VARCHAR2(100) := &apos;select * from t_records where f_id &gt;= :x and f_id &lt;= :y&apos;; c_select_mobile_sql VARCHAR2(100) := &apos;select * from t_mobiles where f_mobile_head = :x&apos;; c_update_mobile_sql VARCHAR2(100) := &apos;update t_records set f_province = :x, f_platform = :y, f_mobile = 1 where f_id = :z&apos;; c_update_record_sql VARCHAR2(100) := &apos;update t_records set f_mobile = 0 where f_id = :n&apos;; v_record_count NUMBER; v_current_index NUMBER; v_begin_index NUMBER; v_end_index NUMBER; v_id NUMBER; v_phone VARCHAR2(20); v_province VARCHAR2(20); v_platform VARCHAR2(20); --定义动态游标 TYPE ty_record_cursor IS REF CURSOR; record_cursor ty_record_cursor; mobile_cursor ty_record_cursor; v_record_row t_records%rowtype; v_mobile_row t_mobiles%rowtype;BEGIN PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], running...&apos;); --获取待处理的记录总数 SELECT COUNT(1) INTO v_record_count FROM t_records; PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], records count: &apos;||v_record_count); LOOP --获取记录锁 SELECT f_index INTO v_current_index FROM t_lock WHERE f_name = c_record_index FOR UPDATE; PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], current index: &apos;||v_current_index); IF v_current_index = v_record_count THEN PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], finished.&apos;); EXIT; END IF; --记录本次处理的开始和结束记录位置 v_end_index := v_current_index + batch_size; IF v_end_index &gt; v_record_count THEN v_end_index := v_record_count; END IF; --提交事务，释放锁 UPDATE t_lock SET f_index = v_end_index WHERE f_name =c_record_index; COMMIT; --计算开始位置 v_begin_index := v_current_index +1; PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], begin index:&apos;||v_begin_index||&apos;, end index:&apos;||v_end_index); --test：dbms_lock.sleep(5); --查询一批记录进行逐个处理 OPEN record_cursor FOR c_select_record_sql USING v_begin_index, v_end_index; LOOP FETCH record_cursor INTO v_record_row; EXIT WHEN record_cursor%notfound; v_id := v_record_row.f_id; v_phone := v_record_row.f_no; IF is_mobile(v_phone) THEN v_phone := TRIM(v_phone); IF substr(v_phone,0,1) = &apos;0&apos; THEN v_phone := substr(v_phone, 2); END IF; --PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], id:&apos;||v_id||&apos;, phone:&apos;||v_phone); --更新话单记录中的省份、运营商以及手机类型标志 OPEN mobile_cursor FOR c_select_mobile_sql USING substr(v_phone,1,7); FETCH mobile_cursor INTO v_mobile_row; v_province := v_mobile_row.f_province; v_platform := v_mobile_row.f_platform; --FETCH mobile_cursor INTO v_province, v_platform; CLOSE mobile_cursor; --更新话单记录的运营商、省份地区信息 EXECUTE IMMEDIATE c_update_mobile_sql USING v_province,v_platform,v_id; ELSE --更新话单记录为非移动号码类型 EXECUTE IMMEDIATE c_update_record_sql USING v_id; END IF; --提交事务 COMMIT; END LOOP; CLOSE record_cursor; PRINT(c_process_prefix, &apos;process[&apos;||process_no||&apos;], processed index: &apos;||v_end_index); END LOOP;EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&apos;Error code: &apos;||SQLCODE); dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);END;/ 存储过程generate_csv_report，生成报表 123456789101112131415161718192021222324252627--存储过程：生成报表CREATE OR REPLACE PROCEDURE generate_csv_report IS c_report_prefix CONSTANT VARCHAR2(20) := &apos;[ REPORT ]&apos;; v_report_1 UTL_FILE.FILE_TYPE; v_report_2 UTL_FILE.FILE_TYPE; CURSOR report_1_cursor IS SELECT f_platform,f_province,SUM(f_duration) total FROM t_records WHERE f_mobile=1 GROUP BY f_platform,f_province ORDER BY f_platform ASC,SUM(f_duration) DESC; cursor report_2_cursor is select f_province,f_platform,sum(f_duration) total from t_records where f_mobile=1 group by f_province,f_platform order by f_province asc,sum(f_duration) desc;BEGIN --生成报表1，根据运营商分类汇总各省份地区的通话量 v_report_1 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report1.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767); FOR cur_tmp IN report_1_cursor LOOP UTL_FILE.PUT_LINE(v_report_1, cur_tmp.f_platform || &apos;,&apos; || cur_tmp.f_province || &apos;,&apos; || cur_tmp.total); END LOOP; UTL_FILE.FCLOSE(v_report_1); --生成报表2，根据各省份地区汇总各运营商的通话量 v_report_2 := UTL_FILE.FOPEN( LOCATION =&gt; &apos;EXTERNAL_DATA&apos;, filename =&gt; &apos;report2.csv&apos;, open_mode =&gt; &apos;w&apos;, max_linesize =&gt; 32767); FOR cur_tmp IN report_2_cursor LOOP UTL_FILE.PUT_LINE(v_report_2, cur_tmp.f_province || &apos;,&apos; || cur_tmp.f_platform || &apos;,&apos; || cur_tmp.total); END LOOP; UTL_FILE.FCLOSE(v_report_2); PRINT(c_report_prefix, &apos;generated reports.&apos;); EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&apos;Error code: &apos;||SQLCODE); dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);END;/ 存储过程analysis，调用上述函数，完成任务逻辑，支持指定任务个数和一批数量 dbms_job: 用于管理job的package oracle限定的job_queue_processes: oracle中有一个对任务可启动进程的数量进行限制的参数： 1234567&gt; SQL&gt; show parameter job_queue_processes;&gt; NAME TYPE VALUE&gt; ----------------------------------------------------------&gt; job_queue_processeses integer 10&gt;&gt; SQL&gt; alter system set job_queue_processes=0...1000;&gt; 使用ctrl+c是无法停止job的: 可使用top命令查看当前进程详情，如果需要结束特定job可kill对应job的进程号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CREATE OR REPLACE PROCEDURE analysis (job_count IN NUMBER, batch_size IN NUMBER)IS --定义常量 c_record_index CONSTANT VARCHAR2(20) :=&apos;_RECORD_INDEX&apos;; c_analysis_prefix CONSTANT VARCHAR2(20) := &apos;[ ANALYSIS ]&apos;; --当前处理位置 v_record_index NUMBER; --待处理的记录总数 v_record_count NUMBER; --保存临时创建的job no v_tmp_jobno NUMBER; --开始结束时间 v_begin_time NUMBER; v_process_end_time NUMBER; v_analysis_end_time NUMBER; --异常变量 e_invalid_input EXCEPTION;BEGIN PRINT(c_analysis_prefix, &apos; start analysis...&apos;); --输入参数检查 IF job_count &lt; 1 OR batch_size&lt;1 THEN RAISE e_invalid_input; END IF; PRINT(c_analysis_prefix, &apos; checked input parameters.&apos;); --记录开始时间 v_begin_time := dbms_utility.get_time; --获取待处理的记录总数 SELECT COUNT(1) INTO v_record_count FROM t_records; PRINT(c_analysis_prefix, &apos; records count: &apos;||v_record_count); --开始计算重置为0 UPDATE t_lock SET f_index=0 WHERE f_name=c_record_index; COMMIT; PRINT(c_analysis_prefix, &apos; reset index to zero.&apos;); --提交多个job FOR I IN 1.. job_count LOOP dbms_job.submit(v_tmp_jobno,&apos;begin process_data(&apos;||I||&apos;,&apos;||batch_size||&apos;); end;&apos;); PRINT(c_analysis_prefix, &apos; submitted new job, no: &apos;||v_tmp_jobno); END LOOP; PRINT(c_analysis_prefix, &apos; created &apos;||job_count||&apos; jobs.&apos;); --定时检查处理进度 LOOP SELECT f_index INTO v_record_index FROM t_lock WHERE f_name = c_record_index; PRINT(c_analysis_prefix, &apos; current index: &apos;||v_record_index); IF v_record_index = v_record_count THEN PRINT(c_analysis_prefix, &apos; processed all records, exiting...&apos;); EXIT; ELSE dbms_lock.sleep(5);--暂停等待5秒 END IF; END LOOP; v_process_end_time := dbms_utility.get_time; PRINT(c_analysis_prefix, &apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;); dbms_output.put_line(&apos;process, elapsed time: &apos;||(v_process_end_time-v_begin_time)/100||&apos; seconds.&apos;); --分类汇总产生报表 generate_csv_report; --结束时间 v_analysis_end_time := dbms_utility.get_time; PRINT(c_analysis_prefix, &apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;); dbms_output.put_line(&apos;report, elapsed time: &apos;||(v_analysis_end_time-v_process_end_time)/100||&apos; seconds.&apos;);--异常捕获部分EXCEPTION WHEN e_invalid_input THEN dbms_output.put_line(&apos;Invalid input values, job_count:&apos;||job_count||&apos;, batch_size:&apos;||batch_size); WHEN OTHERS THEN dbms_output.put_line(&apos;Error code: &apos;||SQLCODE); dbms_output.put_line(&apos;Error mesg: &apos;||sqlerrm);END;/ 存储过程mul_analysis，循环调用analysis，指定不同的任务个数和批数量，并将运行时间存入T_RESULT中 12345678910111213141516171819202122232425262728293031-- 调用多次analysis，指定不同的job数和批数create or replace procedure mul_analysis is -- 最小job数 v_begin_job_no NUMBER := 3; -- 最大job数 v_end_job_no NUMBER := 8; -- 每次增长的batch数量 v_range NUMBER := 2000; -- 最小batch数量 v_begin_range NUMBER := 1000; -- 最大batch数量 v_end_range NUMBER := 10000; -- 当前range range NUMBER; begin for I in v_begin_job_no..v_end_job_no LOOP range := v_begin_range; LOOP -- 清洗表 init(); -- 分析 analysis(I, range); range := range+v_range; -- range增长到10000则停止 if range &gt; v_end_range then exit; end if; end loop; end loop; end;/ 执行函数和存储过程 在sqlplus中执行函数和存储过程之前需先打开serveroutput，即： 12&gt; SQL&gt; set serveroutput on;&gt; 这是因为存储过程中用到了dbms_output.put_line，上述语句是相当于告诉pl/sql引擎将dbms_output.put_line传递到缓冲区的内容输出到主控制台上。 12call init();call analysis(4,1000); 结果分析通过执行mul_analysis()对一系列job和batch组合值进行测试，结果如下： Lesson 2创建用户并分配权限创建用户1create user audittest identified by audittest; 分配权限1234grant connect,resource to audittest;grant execute on dbms_lock to audittest;alter user audittest quota unlimited on users;conn audittest/audittest; 创建表及其他对象创建表 注意： 这里在创建表时添加了ENABLE限制条件，oracle中对表和列的约束有Enable/Disable(启用/禁用)和Validate/NoValidate(验证/不验证) 举两个例子： 需更改的错误： 1234567891011121314151617181920&gt; -- 创建表，对name字段添加唯一性约束&gt; drop table T_TEST;&gt; create table T_TEST(&gt; id int primary key ,&gt; name varchar2(10) constraint unique_name unique disable&gt; );&gt; -- 由于某些错误，添加的记录违反了唯一性约束，但添加不会报错&gt; begin&gt; insert into T_TEST values (1, &apos;tan&apos;);&gt; insert into T_TEST values (2, &apos;rui&apos;);&gt; insert into T_TEST values (3, &apos;tan&apos;);&gt; end;&gt; select * from T_TEST;&gt; -- 修改掉违反唯一性约束的值&gt; update T_TEST set name=&apos;chen&apos; where id=3;&gt; -- 使得唯一性约束生效&gt; alter table T_TEST modify constraint unique_name enable;&gt; select * from T_TEST;&gt;&gt; 需保留的错误： 1234567891011121314151617181920&gt; -- 创建表，无约束&gt; drop table T_TEST;&gt; create table T_TEST(&gt; id int primary key ,&gt; name varchar2(10)&gt; );&gt; -- 一些old的记录本身可能存在重复数据&gt; begin&gt; insert into T_TEST values (1, &apos;tan&apos;);&gt; insert into T_TEST values (2, &apos;rui&apos;);&gt; insert into T_TEST values (3, &apos;tan&apos;);&gt; end;&gt; select * from T_TEST;&gt; -- 对name列创建非唯一性索引&gt; create index i_name on T_TEST(name);&gt; -- 新要求需要对name添加唯一性约束unique_name，但保留旧值，注意这里一定要使用非唯一性索引&gt; alter table T_TEST add constraint unique_name unique(name) using index i_name ENABLE NOVALIDATE ;&gt; -- 此时无法插入name相同的数据了&gt; insert into T_TEST values (4, &apos;tan&apos;);&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159--部门表CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_PARENT_ID&quot; NUMBER(6,0), &quot;F_MANAGER&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)) ;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_CODE&quot; IS &apos;部门编号&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_MANAGER&quot; IS &apos;部门经理&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_DEPARTMENT&quot; IS &apos;部门表&apos;;--用户表CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(20 BYTE), &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL, &quot;F_MOBILE&quot; VARCHAR2(20 BYTE), &quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE), &quot;F_EMAIL&quot; VARCHAR2(50 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_CODE&quot; IS &apos;员工编号&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_TELEPHONE&quot; IS &apos;固话&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_USER&quot; IS &apos;用户表&apos;;--客户信息表CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE, &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE, &quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE), &quot;F_EMAIL&quot; VARCHAR2(60 BYTE), &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE), &quot;F_CITY&quot; VARCHAR2(45 BYTE), &quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE, &quot;F_PARTNER&quot; VARCHAR2(45 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), &quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE, &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, &quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, &quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE, PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER&quot; IS &apos;客户信息表&apos;;--CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_FULL_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE, &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE, &quot;F_TELEPHONE&quot; VARCHAR2(20 BYTE), &quot;F_EMAIL&quot; VARCHAR2(60 BYTE), &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE), &quot;F_CITY&quot; VARCHAR2(45 BYTE), &quot;F_BALANCE&quot; NUMBER(10,2) NOT NULL ENABLE, &quot;F_PARTNER&quot; VARCHAR2(45 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), &quot;F_SALESMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_DELETED_TAG&quot; NUMBER(1,0) DEFAULT 0 NOT NULL ENABLE, &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, &quot;F_MODIFIED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_MODIFIED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, &quot;F_VERSION&quot; NUMBER(6,0) DEFAULT 1 NOT NULL ENABLE, CONSTRAINT &quot;T_CUSTOMER_HISTORY_PK&quot; PRIMARY KEY (&quot;F_ID&quot;, &quot;F_VERSION&quot;));--客户信息历史表COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CODE&quot; IS &apos;客户编码&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_FULL_NAME&quot; IS &apos;客户全名&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_TELEPHONE&quot; IS &apos;联系固话&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CITY&quot; IS &apos;城市&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_BALANCE&quot; IS &apos;余额&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_PARTNER&quot; IS &apos;所属合作伙伴&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_SALESMAN&quot; IS &apos;业务员&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_DELETED_TAG&quot; IS &apos;删除标志，0：可用，1：已删除&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_ID&quot; IS &apos;最后修改人&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_MODIFIED_TIME&quot; IS &apos;最后修改时间&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot;.&quot;F_VERSION&quot; IS &apos;版本号&apos;;COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_CUSTOMER_HISTORY&quot; IS &apos;客户信息历史表&apos;;--审计表CREATE TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_TABLE_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_ROW_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NEW_VERSION&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_COLUMN_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_OLD_VALUE&quot; VARCHAR2(200 BYTE), &quot;F_NEW_VALUE&quot; VARCHAR2(200 BYTE), &quot;F_OPERATOR_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_OPERATION_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, CONSTRAINT &quot;T_AUDIT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ID&quot; IS &apos;主键&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_TABLE_NAME&quot; IS &apos;表名&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_ROW_ID&quot; IS &apos;业务数据主键&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VERSION&quot; IS &apos;新的版本号&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_COLUMN_NAME&quot; IS &apos;字段&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OLD_VALUE&quot; IS &apos;原值&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_NEW_VALUE&quot; IS &apos;新值&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATOR_ID&quot; IS &apos;操作用户&apos;;COMMENT ON COLUMN &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot;.&quot;F_OPERATION_TIME&quot; IS &apos;操作时间&apos;;COMMENT ON TABLE &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot; IS &apos;审计表&apos;; 创建索引、序列1234-- 创建复合索引CREATE INDEX &quot;AUDITTEST&quot;.&quot;IDX_TABLE_ROWID&quot; ON &quot;AUDITTEST&quot;.&quot;T_AUDIT&quot; (&quot;F_TABLE_NAME&quot;, &quot;F_ROW_ID&quot;) ;-- 创建序列CREATE SEQUENCE SEQ_AUDIT_PK INCREMENT BY 1 START WITH 1; 创建触发器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263--创建触发器create or replace trigger trg_customer_auditbefore update on t_customerfor each rowdeclare c_insert_sql constant varchar2(100) := &apos;insert into t_audit values(:1,:2,:3,:4,:5,:6,:7,:8,systimestamp)&apos;; c_table_name constant varchar2(20) := &apos;T_CUSTOMER&apos;; v_column_name varchar2(20);begin --记录当前数据到历史表 insert into t_customer_history values(:old.f_id,:old.f_code,:old.f_full_name,:old.f_linkman,:old.f_mobile,:old.f_telephone,:old.f_email,:old.f_address,:old.f_city,:old.f_balance,:old.f_partner,:old.f_remark,:old.f_salesman,:old.f_deleted_tag,:old.f_created_id,:old.f_created_time,:old.f_modified_id,:old.f_modified_time,:old.f_version); --递增记录的版本号 :new.f_version := :old.f_version+1; --判断字段变化 if updating(&apos;F_LINKMAN&apos;) then v_column_name := &apos;联系人&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_linkman,:new.f_linkman,:new.f_modified_id; end if; if updating(&apos;F_MOBILE&apos;) then v_column_name := &apos;手机号码&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_mobile,:new.f_mobile,:new.f_modified_id; end if; if updating(&apos;F_TELEPHONE&apos;) then v_column_name := &apos;固定电话&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_telephone,:new.f_telephone,:new.f_modified_id; end if; if updating(&apos;F_EMAIL&apos;) then v_column_name := &apos;电子邮箱&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_email,:new.f_email,:new.f_modified_id; end if; if updating(&apos;F_ADDRESS&apos;) then v_column_name := &apos;联系地址&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_address,:new.f_address,:new.f_modified_id; end if; if updating(&apos;F_BALANCE&apos;) then v_column_name := &apos;余额&apos;; execute immediate c_insert_sql using seq_audit_pk.nextval,c_table_name,:new.f_id,:old.f_version,v_column_name,:old.f_balance,:new.f_balance,:new.f_modified_id; end if;end;/--创建过程--过程：重设序列值create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )IS v_val NUMBER;BEGIN EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val; EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;; EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val; EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;end;/ 创建过程过程reset_seq 将序列为输入参数seq_name的值重置 1234567891011121314--过程：重设序列值create or replace PROCEDURE reset_seq( seq_name IN VARCHAR2 )IS v_val NUMBER;BEGIN EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val; EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY -&apos; || v_val ||&apos; MINVALUE 0&apos;; EXECUTE IMMEDIATE &apos;SELECT &apos; || seq_name || &apos;.NEXTVAL FROM dual&apos; INTO v_val; EXECUTE IMMEDIATE &apos;ALTER SEQUENCE &apos; || seq_name || &apos; INCREMENT BY 1 MINVALUE 0&apos;;end;/ 过程init truncate(截断)所有表，重设序列，并添加初始值 注意： truncate与delete的区别：delete通常用于删除表中的某些行或者所有行，且delete支持回滚，删除掉的记录的物理空间在commit前并不会被回收。truncate只能删除表的所有行且不支持回滚，删除掉的记录的物理空间也会被立刻回收。 truncate的好处在于当需要删除所有行它比delete要快，尤其在包含大量触发器、索引和其他依赖项的情况下；且它不会改变表结构、表依赖等关系，这一特性又使得它比重建表更有效，删除和重建表会使得表的依赖关系断开，因此需要重新创建依赖、创建约束、赋予权限等等操作。 但是truncate也有不好的地方，比如说当被truncate的表被依赖时，举例： 12345678910111213141516171819&gt; -- 创建表，f_id字段引用T_TEST的主码id&gt; drop table T_TEST2;&gt; create table T_TEST2(&gt; id1 int primary key ,&gt; f_id int,&gt; constraint fk&gt; foreign key (f_id)&gt; references T_TEST(id) on delete cascade&gt; );&gt; select *&gt; from T_TEST2;&gt; insert into T_TEST2 values(1, 1);&gt; -- 可级联删除&gt; delete from T_TEST;&gt; -- 将外码置为禁用&gt; alter table T_TEST2 modify constraint fk disable validate ;&gt; -- 可截断（当不禁用外码时无法截断）&gt; truncate table T_TEST;&gt; 可见，可通过禁用约束来完成truncate，但是这些主外键约束应是创建数据库时的我们定义的强制关系，上述方法可能会使得这种强制关系紊乱，因此需做好取舍决策。 12345678910111213141516171819202122232425262728293031323334--过程：数据初始化create or replace procedure init isbegin --清除数据 execute immediate &apos;truncate table t_audit&apos;; execute immediate &apos;truncate table t_customer_history&apos;; execute immediate &apos;truncate table t_customer&apos;; execute immediate &apos;truncate table t_user&apos;; execute immediate &apos;truncate table t_department&apos;; --重调序列 reset_seq(&apos;seq_audit_pk&apos;); --插入部门 insert into t_department values(1,&apos;销售部&apos;,&apos;D01&apos;,NULL,&apos;李明&apos;,&apos;备注1...&apos;); insert into t_department values(2,&apos;销售部-北京分部&apos;,&apos;D0101&apos;,1,&apos;赵军&apos;,&apos;备注2...&apos;); insert into t_department values(3,&apos;销售部-上海分部&apos;,&apos;D0102&apos;,1,&apos;张华&apos;,&apos;备注3...&apos;); insert into t_department values(4,&apos;销售部-深圳分部&apos;,&apos;D0103&apos;,1,&apos;王兵&apos;,&apos;备注4...&apos;); --插入用户 insert into t_user values(1,1,&apos;仲芳芳&apos;,&apos;U8201&apos;,&apos;女&apos;,&apos;13771234101&apos;,&apos;02131231011&apos;,&apos;use1@samtech.com&apos;,&apos;备注1...&apos;); insert into t_user values(2,1,&apos;李明申&apos;,&apos;U8202&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;02131231012&apos;,&apos;use2@samtech.com&apos;,&apos;备注2...&apos;); insert into t_user values(3,2,&apos;张雪&apos;, &apos;U8203&apos;,&apos;女&apos;,&apos;13771234103&apos;,&apos;02131231013&apos;,&apos;use3@samtech.com&apos;,&apos;备注3...&apos;); insert into t_user values(4,2,&apos;王刚&apos;, &apos;U8204&apos;,&apos;男&apos;,&apos;13771234104&apos;,&apos;02131231014&apos;,&apos;use4@samtech.com&apos;,&apos;备注4...&apos;); insert into t_user values(5,3,&apos;赵昌日&apos;,&apos;U8205&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;02131231015&apos;,&apos;use5@samtech.com&apos;,&apos;备注5...&apos;); insert into t_user values(6,3,&apos;孙晓华&apos;,&apos;U8206&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;02131231016&apos;,&apos;use6@samtech.com&apos;,&apos;备注6...&apos;); insert into t_user values(7,4,&apos;陈亚男&apos;,&apos;U8207&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;02131231017&apos;,&apos;use7@samtech.com&apos;,&apos;备注7...&apos;); insert into t_user values(8,4,&apos;刘兵超&apos;,&apos;U8208&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;02131231018&apos;,&apos;use8@samtech.com&apos;,&apos;备注8...&apos;); --插入客户 insert into t_customer values(1,&apos;C1808001&apos;,&apos;上海市永辉电子股份有限公司&apos;,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;02135681589&apos;,&apos;ming@google.com&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;上海市&apos;,12082,&apos;上海中远&apos;,&apos;备注...&apos;,&apos;张娜&apos;,0,1,sysdate,1,sysdate,1); commit;end;/ 修改客户信息过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120--过程：修改客户地址create or replace procedure modify_address(p_row_id in number,p_address in varchar2, p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_address=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_address,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated address successfully.&apos;); --异常捕获省略 --...end;/--过程：修改客户余额create or replace procedure modify_balance(p_row_id in number,p_balance in number, p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_balance=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_balance,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated balance successfully.&apos;); --异常捕获省略 --...end;/--过程：修改客户电子邮箱create or replace procedure modify_email(p_row_id in number,p_email in varchar2, p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_email=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_email,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated email successfully.&apos;); --异常捕获省略 --...end;/--过程：修改客户联系人create or replace procedure modify_linkman(p_row_id in number,p_linkman_name in varchar2, p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_linkman=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_linkman_name,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated linkman name successfully.&apos;); --异常捕获省略 --...end;/--过程：修改客户联系人信息create or replace procedure modify_linkman_info(p_row_id in number,p_linkman_name in varchar2,p_mobile in varchar2, p_telephone in varchar2,p_email in varchar2,p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_linkman=:1, f_mobile=:2, f_telephone=:3, f_email=:4, f_modified_id=:5, f_modified_time=sysdate where f_id=:6&apos; using p_linkman_name,p_mobile,p_telephone,p_email,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated linkman info successfully.&apos;); --异常捕获省略 --...end;/--过程：修改联系手机create or replace procedure modify_mobile(p_row_id in number,p_mobile in varchar2,p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_mobile=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_mobile,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated mobile successfully.&apos;); --异常捕获省略 --...end;/--过程：修改联系固话create or replace procedure modify_telephone(p_row_id in number,p_telephone in varchar2,p_operator in number)asbegin --校验参数省略 --... execute immediate &apos;update t_customer set f_telephone=:1,f_modified_id=:2, f_modified_time=sysdate where f_id=:3&apos; using p_telephone,p_operator,p_row_id; commit; dbms_output.put_line(&apos;Updated mobile successfully.&apos;); --异常捕获省略 --...end;/ 执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 初始化call init();-- 更改客户信息begin modify_linkman(1,&apos;李明顺&apos;,1); dbms_lock.sleep(1); modify_mobile(1,&apos;13771083211&apos;,2); dbms_lock.sleep(1); modify_balance(1,20020,3); dbms_lock.sleep(1); modify_address(1,&apos;中国上海市嘉定区xxx路&apos;,4); dbms_lock.sleep(1); modify_email(1,&apos;test1@163.com&apos;,5); dbms_lock.sleep(1); modify_telephone(1,&apos;02183652145&apos;,6); dbms_lock.sleep(1); modify_linkman_info(1,&apos;张雨轩&apos;,&apos;15332892301&apos;,&apos;02188881111&apos;,&apos;zhangyx@gmail.com&apos;,7);end;/-- 审计select * from T_AUDIT;-- 回滚客户信息-- 方法1：update t_customer aset(a.f_full_name,a.f_linkman,a.f_mobile,a.f_telephone,a.f_email,a.f_address,a.f_city,a.f_balance,a.f_partner,a.f_remark,a.f_salesman,a.f_deleted_tag,a.f_modified_id,a.f_modified_time)=(select b.f_full_name,b.f_linkman,b.f_mobile,b.f_telephone,b.f_email,b.f_address,b.f_city,b.f_balance,b.f_partner,b.f_remark,b.f_salesman,b.f_deleted_tag,5,sysdatefrom t_customer_history b where b.f_id=a.f_id and b.f_version=3)where a.f_id=1;-- 方法2：merge into t_customer a using t_customer_history b on (a.f_id=1 and a.f_id=b.f_id and b.f_version=3)when matched thenupdate set a.f_full_name=b.f_full_name,a.f_linkman=b.f_linkman,a.f_mobile=b.f_mobile,a.f_telephone=b.f_telephone,a.f_email=b.f_email,a.f_address=b.f_address,a.f_city=b.f_city,a.f_balance=b.f_balance,a.f_partner=b.f_partner,a.f_remark=b.f_remark,a.f_salesman=b.f_salesman,a.f_deleted_tag=b.f_deleted_tag,a.f_modified_id=5,a.f_modified_time=sysdate;-- 查看验证数据select * from t_customer where f_id=1unionselect * from t_customer_history where f_id=1 and f_version=3; Lesson 3创建用户并分配权限创建用户1create user permission identified by permission; 分配权限123grant connect,resource to permission;alter user permisson quota unlimited on users;conn permission/permission; 创建表及其他对象方案一 方案一在T_CUSTOMER表中存放创建人员ID，以查询该客户的直接负责人，在T_USER表中存放直属领导的ID，用于查询某领导所有下属的客户。 创建表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364--方案一--部门表CREATE TABLE T_DEPARTMENT( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_PARENT_ID&quot; NUMBER(6,0), &quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_DEPARTMENT_PK&quot; PRIMARY KEY (&quot;F_ID&quot;)) ;COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;T_DEPARTMENT&quot; IS &apos;部门表&apos;;--用户表CREATE TABLE &quot;T_USER&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL, &quot;F_MOBILE&quot; VARCHAR2(20 BYTE), &quot;F_EMAIL&quot; VARCHAR2(50 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_USER_PK&quot; PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;COMMENT ON COLUMN &quot;T_USER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;T_USER&quot; IS &apos;用户表&apos;;--客户信息表CREATE TABLE &quot;T_CUSTOMER&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE, &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE, &quot;F_EMAIL&quot; VARCHAR2(60 BYTE), &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;COMMENT ON TABLE &quot;T_CUSTOMER&quot; IS &apos;客户信息表&apos;; 创建过程初始化123456789101112131415161718192021222324252627282930313233343536373839--过程：数据初始化CREATE OR REPLACE PROCEDURE INIT ISBEGIN --清除数据 EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER&apos;; EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER&apos;; EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT&apos;; --插入部门 INSERT INTO T_DEPARTMENT VALUES(1,&apos;公司&apos;,NULL,1,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT VALUES(2,&apos;行政部&apos;,1,1,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT VALUES(3,&apos;销售部&apos;,1,2,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT VALUES(4,&apos;电销组&apos;,3,3,&apos;销售部电销组&apos;); INSERT INTO T_DEPARTMENT VALUES(5,&apos;推销组&apos;,3,6,&apos;销售部推销组&apos;); --插入用户 INSERT INTO T_USER VALUES(1,1,&apos;管理员&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;); INSERT INTO T_USER VALUES(2,3,&apos;李明申&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;); INSERT INTO T_USER VALUES(3,4,&apos;张雪&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;); INSERT INTO T_USER VALUES(4,4,&apos;王刚&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;); INSERT INTO T_USER VALUES(5,4,&apos;赵昌日&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;); INSERT INTO T_USER VALUES(6,5,&apos;孙晓华&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;); INSERT INTO T_USER VALUES(7,5,&apos;陈亚男&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;); INSERT INTO T_USER VALUES(8,5,&apos;刘兵超&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;); INSERT INTO T_USER VALUES(9,3,&apos;陈彬&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;); INSERT INTO T_USER VALUES(10,3,&apos;王军&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;); --插入客户 INSERT INTO T_CUSTOMER VALUES(1,&apos;上海市永辉电子股份有限公司&apos; ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,3,SYSDATE); INSERT INTO T_CUSTOMER VALUES(2,&apos;上海博运汽车销售有限公司&apos; ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,4,SYSDATE); INSERT INTO T_CUSTOMER VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos; ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,5,SYSDATE); INSERT INTO T_CUSTOMER VALUES(4,&apos;上海定丰霖贸易有限公司&apos; ,&apos;赵兰&apos; ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,6,SYSDATE); INSERT INTO T_CUSTOMER VALUES(5,&apos;上海东俊科技有限公司&apos; ,&apos;张军&apos; ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,7,SYSDATE); INSERT INTO T_CUSTOMER VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos; ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,8,SYSDATE); INSERT INTO T_CUSTOMER VALUES(7,&apos;南宁云讯科技有限公司&apos; ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,9,SYSDATE); INSERT INTO T_CUSTOMER VALUES(8,&apos;沈阳优速家政服务有限公司&apos; ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,10,SYSDATE); COMMIT;END;/ 执行初始化12set serveroutput on;exec init; 查询自己的客户1SELECT * FROM t_customer A WHERE A.f_created_id=&amp;id; &amp;id是所查询人员的ID 查询某领导下属人员的所有客户12345select * from t_user a where exists(SELECT 1 FROM t_department bWHERE a.f_dept_id=b.f_id and b.f_manager_id=&amp;idCONNECT BY b.F_PARENT_ID = PRIOR b.F_IDstart with b.F_ID = (select c.f_dept_id from t_user c where c.f_id=&amp;id)); &amp;id是该领导的ID 当部门结构或员工归属调整时，权限编码如何处理？对于方案一，只需要更改员工直属领导ID即可 方案二 方案二取消在T_USER中添加直属领导ID，改为在员工、部门、客户表中添加权限码，查看时直接搜索对应权限码即可 创建表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788--方案二--部门表CREATE TABLE T_DEPARTMENT_2( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_PARENT_ID&quot; NUMBER(6,0), &quot;F_MANAGER_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_DEPARTMENT_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;)) ;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_NAME&quot; IS &apos;部门名称&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_CODE&quot; IS &apos;部门编码&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_PARENT_ID&quot; IS &apos;上级部门ID&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_MANAGER_ID&quot; IS &apos;部门经理&apos;;COMMENT ON COLUMN &quot;T_DEPARTMENT_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;T_DEPARTMENT_2&quot; IS &apos;部门表2&apos;;--用户表CREATE TABLE &quot;T_USER_2&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_DEPT_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_SEX&quot; VARCHAR2(5 BYTE) DEFAULT NULL, &quot;F_MOBILE&quot; VARCHAR2(20 BYTE), &quot;F_EMAIL&quot; VARCHAR2(50 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), CONSTRAINT &quot;T_USER_PK2&quot; PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_DEPT_ID&quot; IS &apos;部门ID&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_NAME&quot; IS &apos;用户名&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_CODE&quot; IS &apos;用户编码&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_SEX&quot; IS &apos;性别&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_MOBILE&quot; IS &apos;手机&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_EMAIL&quot; IS &apos;邮箱&apos;;COMMENT ON COLUMN &quot;T_USER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON TABLE &quot;T_USER_2&quot; IS &apos;用户表2&apos;;--客户信息表CREATE TABLE &quot;T_CUSTOMER_2&quot;( &quot;F_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_NAME&quot; VARCHAR2(145 BYTE) NOT NULL ENABLE, &quot;F_LINKMAN&quot; VARCHAR2(45 BYTE) NOT NULL ENABLE, &quot;F_MOBILE&quot; VARCHAR2(11 BYTE) NOT NULL ENABLE, &quot;F_EMAIL&quot; VARCHAR2(60 BYTE), &quot;F_ADDRESS&quot; VARCHAR2(200 BYTE), &quot;F_REMARK&quot; VARCHAR2(200 BYTE), &quot;F_ACCESS_CODE&quot; VARCHAR2(50 BYTE) NOT NULL ENABLE, &quot;F_CREATED_ID&quot; NUMBER(6,0) NOT NULL ENABLE, &quot;F_CREATED_TIME&quot; TIMESTAMP (6) NOT NULL ENABLE, PRIMARY KEY (&quot;F_ID&quot;));COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ID&quot; IS &apos;PK&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_NAME&quot; IS &apos;客户全名&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_LINKMAN&quot; IS &apos;联系人&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_MOBILE&quot; IS &apos;联系手机&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_EMAIL&quot; IS &apos;联系邮箱&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ADDRESS&quot; IS &apos;地址&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_REMARK&quot; IS &apos;备注信息&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_ACCESS_CODE&quot; IS &apos;权限编码&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_ID&quot; IS &apos;创建人&apos;;COMMENT ON COLUMN &quot;T_CUSTOMER_2&quot;.&quot;F_CREATED_TIME&quot; IS &apos;创建时间&apos;;COMMENT ON TABLE &quot;T_CUSTOMER_2&quot; IS &apos;客户信息表2&apos;;-- 创建人员更改历史表CREATE TABLE T_USER_HISTORY( ID NUMBER(6,0) PRIMARY KEY , F_ID NUMBER(6,0) , O_DEP_ID NUMBER(6,0) , O_ACCESS_CODE VARCHAR2(50 BYTE) , N_DEP_ID NUMBER(6,0), N_ACCESS_CODE VARCHAR2(50 BYTE), TIME DATE);COMMENT ON COLUMN T_USER_HISTORY.ID IS &apos;PK&apos;;COMMENT ON COLUMN T_USER_HISTORY.F_ID IS &apos;修改的人员ID&apos;;COMMENT ON COLUMN T_USER_HISTORY.O_DEP_ID IS &apos;旧的部门&apos;;COMMENT ON COLUMN T_USER_HISTORY.O_ACCESS_CODE IS &apos;旧的权限&apos;;COMMENT ON COLUMN T_USER_HISTORY.N_DEP_ID IS &apos;新的部门&apos;;COMMENT ON COLUMN T_USER_HISTORY.N_ACCESS_CODE IS &apos;新的权限&apos;;COMMENT ON TABLE T_USER_HISTORY IS &apos;用户权限更改历史&apos;; 创建过程初始化12345678910111213141516171819202122232425262728293031323334353637383940--过程：数据初始化CREATE OR REPLACE PROCEDURE INIT2 ISBEGIN --清除数据 EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_CUSTOMER_2&apos;; EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_2&apos;; EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_DEPARTMENT_2&apos;; EXECUTE IMMEDIATE &apos;TRUNCATE TABLE T_USER_HISTORY&apos;; --插入部门 INSERT INTO T_DEPARTMENT_2 VALUES(1,&apos;公司&apos;,&apos;1&apos;,NULL,1,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT_2 VALUES(2,&apos;行政部&apos;,&apos;101&apos;,1,1,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT_2 VALUES(3,&apos;销售部&apos;,&apos;102&apos;,1,2,&apos;REMARK...&apos;); INSERT INTO T_DEPARTMENT_2 VALUES(4,&apos;电销组&apos;,&apos;10201&apos;,3,3,&apos;销售部电销组&apos;); INSERT INTO T_DEPARTMENT_2 VALUES(5,&apos;推销组&apos;,&apos;10202&apos;,3,6,&apos;销售部推销组&apos;); --插入用户 INSERT INTO T_USER_2 VALUES(1,1,&apos;管理员&apos;,&apos;1&apos;,&apos;男&apos;,&apos;13771234101&apos;,&apos;USE1@SAMTECH.COM&apos;,&apos;系统管理员&apos;); INSERT INTO T_USER_2 VALUES(2,3,&apos;李明申&apos;,&apos;102&apos;,&apos;男&apos;,&apos;13771234102&apos;,&apos;USE2@SAMTECH.COM&apos;,&apos;销售部经理&apos;); INSERT INTO T_USER_2 VALUES(3,4,&apos;张雪&apos;, &apos;10201&apos;, &apos;女&apos;,&apos;13771234103&apos;,&apos;USE3@SAMTECH.COM&apos;,&apos;销售部电销组主管&apos;); INSERT INTO T_USER_2 VALUES(4,4,&apos;王刚&apos;, &apos;1020101&apos;, &apos;男&apos;,&apos;13771234104&apos;,&apos;USE4@SAMTECH.COM&apos;,&apos;销售部电销组业务员1&apos;); INSERT INTO T_USER_2 VALUES(5,4,&apos;赵昌日&apos;,&apos;1020102&apos;,&apos;男&apos;,&apos;13771234105&apos;,&apos;USE5@SAMTECH.COM&apos;,&apos;销售部电销组业务员2&apos;); INSERT INTO T_USER_2 VALUES(6,5,&apos;孙晓华&apos;,&apos;10202&apos;,&apos;男&apos;,&apos;13771234106&apos;,&apos;USE6@SAMTECH.COM&apos;,&apos;销售部推销组主管&apos;); INSERT INTO T_USER_2 VALUES(7,5,&apos;陈亚男&apos;,&apos;1020201&apos;,&apos;女&apos;,&apos;13771234107&apos;,&apos;USE7@SAMTECH.COM&apos;,&apos;销售部推销组业务员3&apos;); INSERT INTO T_USER_2 VALUES(8,5,&apos;刘兵超&apos;,&apos;1020202&apos;,&apos;男&apos;,&apos;13771234108&apos;,&apos;USE8@SAMTECH.COM&apos;,&apos;销售部推销组业务员4&apos;); INSERT INTO T_USER_2 VALUES(9,3,&apos;陈彬&apos;, &apos;10203&apos;,&apos;女&apos;,&apos;13771234109&apos;,&apos;USE9@SAMTECH.COM&apos;,&apos;销售部业务员X1&apos;); INSERT INTO T_USER_2 VALUES(10,3,&apos;王军&apos;, &apos;10204&apos;,&apos;男&apos;,&apos;13771234110&apos;,&apos;USE10@SAMTECH.COM&apos;,&apos;销售部业务员X2&apos;); --插入客户 INSERT INTO T_CUSTOMER_2 VALUES(1,&apos;上海市永辉电子股份有限公司&apos; ,&apos;张明升&apos;,&apos;15352678121&apos;,&apos;MING1@GOOGLE.COM&apos;,&apos;上海市静安区城区安泰路1108号&apos;,&apos;电销组主管创建&apos;,&apos;10201&apos;,3,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(2,&apos;上海博运汽车销售有限公司&apos; ,&apos;朱荣荣&apos; ,&apos;13231289212&apos;,&apos;MING2@GOOGLE.COM&apos;,&apos;上海市徐汇区钦江路256号&apos;,&apos;电销组业务员1创建&apos;,&apos;1020101&apos;,4,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(3,&apos;安徽广宏顶管装备制造有限公司&apos; ,&apos;邱阳阳&apos; ,&apos;15328921231&apos;,&apos;MING3@GOOGLE.COM&apos;,&apos;安徽省广德县经济开发区东纬路5号&apos;,&apos;电销组业务员2创建&apos;,&apos;1020102&apos;,5,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(4,&apos;上海定丰霖贸易有限公司&apos; ,&apos;赵兰&apos; ,&apos;15532212322&apos;,&apos;MING4@GOOGLE.COM&apos;,&apos;上海市浦东新区东延路112号408室&apos;,&apos;推销组主管创建&apos;,&apos;10202&apos;,6,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(5,&apos;上海东俊科技有限公司&apos; ,&apos;张军&apos; ,&apos;15367823660&apos;,&apos;MING5@GOOGLE.COM&apos;,&apos;上海市长宁区王安路135号&apos;,&apos;推销组业务员1创建&apos;,&apos;1020201&apos;,7,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(6,&apos;中科创客（深圳）智能工业设备公司&apos;,&apos;李明&apos; ,&apos;17723180234&apos;,&apos;MING6@GOOGLE.COM&apos;,&apos;深圳市龙岗区富民工业园致康路301号&apos;,&apos;推销组业务员2创建&apos;,&apos;1020202&apos;,8,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(7,&apos;南宁云讯科技有限公司&apos; ,&apos;王永成&apos;,&apos;13568932166&apos;,&apos;MING7@GOOGLE.COM&apos;,&apos;广东省深圳市福田区长川路102号&apos;,&apos;销售部业务员X1创建&apos;,&apos;10203&apos;,9,SYSDATE); INSERT INTO T_CUSTOMER_2 VALUES(8,&apos;沈阳优速家政服务有限公司&apos; ,&apos;李东升&apos;,&apos;13392312343&apos;,&apos;MING8@GOOGLE.COM&apos;,&apos;辽宁省沈阳市铁西区北二路青年易居东门32号&apos;,&apos;销售部业务员X2创建&apos;,&apos;10204&apos;,10,SYSDATE); COMMIT;END;/ 将某员工调换到某部门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-- 更改用户到特定部门CREATE OR REPLACE PROCEDURE CHANGE_TO_DEPARTMENT(C_F_ID IN T_USER_2.F_ID%TYPE, N_DEP_ID IN T_DEPARTMENT_2.F_ID%TYPE) IS -- 旧部门 O_DEP_ID T_DEPARTMENT_2.F_ID%TYPE; -- 旧权限 O_ACCESS_CODE T_USER_2.F_CODE%TYPE; -- 部门权限前缀 DEP_ACCESS_CODE_PREFIX T_DEPARTMENT_2.F_CODE%TYPE; -- 部门当前人数 DEP_USER_COUNT T_USER_2.F_CODE%TYPE; -- 本部门下的部门数 DEP_DEP_COUNT T_DEPARTMENT_2.F_CODE%TYPE; -- 新权限 N_ACCESS_CODE T_USER_2.F_CODE%TYPE; -- 更新该员工权限 C_UPDATE_USER VARCHAR2(100) := &apos;UPDATE T_USER_2 SET F_CODE = :1, F_DEPT_ID = :2 WHERE F_ID = :3&apos;; -- 更新所有该员工的客户的ACCESS权限 C_UPDATE_CUSTOMER VARCHAR2(100) := &apos;UPDATE T_CUSTOMER_2 SET F_ACCESS_CODE = :1 WHERE F_CREATED_ID = :2&apos;; -- 插入一条修改记录 C_INSERT_HISTORY VARCHAR2(100) := &apos;INSERT INTO T_USER_HISTORY VALUES (:1, :2, :3, :4, :5, :6, :7)&apos;; BEGIN -- 旧部门 SELECT F_DEPT_ID INTO O_DEP_ID FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID; -- 旧权限 SELECT F_CODE INTO O_ACCESS_CODE FROM T_USER_2 WHERE T_USER_2.F_ID=C_F_ID; -- 新部门权限作为前缀 SELECT F_CODE INTO DEP_ACCESS_CODE_PREFIX FROM T_DEPARTMENT_2 WHERE T_DEPARTMENT_2.F_ID = N_DEP_ID; -- 计算该部门人员数量 SELECT MAX(T_USER_2.F_CODE) INTO DEP_USER_COUNT FROM T_USER_2 WHERE T_USER_2.F_DEPT_ID = N_DEP_ID; -- 计算子部门数量 SELECT MAX(T_DEPARTMENT_2.F_CODE) INTO DEP_DEP_COUNT FROM T_DEPARTMENT_2 WHERE SUBSTR(T_DEPARTMENT_2.F_CODE, 0, LENGTH(DEP_ACCESS_CODE_PREFIX))=DEP_ACCESS_CODE_PREFIX AND LENGTH(T_DEPARTMENT_2.F_CODE)=LENGTH(DEP_ACCESS_CODE_PREFIX)+2; -- 若新部门与旧部门相同，无需更改 IF N_DEP_ID=O_DEP_ID THEN RETURN; END IF; -- 新权限CODE IF DEP_DEP_COUNT &gt; DEP_USER_COUNT THEN N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_DEP_COUNT) + 1); ELSE N_ACCESS_CODE := TO_CHAR(TO_NUMBER(DEP_USER_COUNT) + 1); end if; -- 输出相关变量 dbms_output.put_line(&apos;DEP_USER_COUNT : &apos; || DEP_USER_COUNT); dbms_output.put_line(&apos;DEP_DEP_COUNT : &apos; || DEP_DEP_COUNT); -- 输出相关变量 dbms_output.put_line(&apos;DEP_ACCESS_CODE_PREFIX : &apos; || DEP_ACCESS_CODE_PREFIX); dbms_output.put_line(&apos;C_F_ID : &apos; || C_F_ID); dbms_output.put_line(&apos;O_ACCESS_CODE : &apos; || O_ACCESS_CODE); dbms_output.put_line(&apos;N_DEP_ID : &apos; || N_DEP_ID); dbms_output.put_line(&apos;N_ACCESS_CODE : &apos; || N_ACCESS_CODE); -- 更新该员工权限 EXECUTE IMMEDIATE C_UPDATE_USER USING N_ACCESS_CODE, N_DEP_ID, C_F_ID; -- 更新所有该员工的客户的ACCESS权限 EXECUTE IMMEDIATE C_UPDATE_CUSTOMER USING N_ACCESS_CODE, C_F_ID; -- 插入一条修改记录 EXECUTE IMMEDIATE C_INSERT_HISTORY USING USER_HISTORY.NEXTVAL, C_F_ID, O_DEP_ID, O_ACCESS_CODE, N_DEP_ID, N_ACCESS_CODE, SYSDATE; -- 提交 COMMIT; END; / 创建序列12-- 员工部门历史记录主码序列CREATE SEQUENCE USER_HISTORY INCREMENT BY 1 START WITH 1; 执行1select * from t_customer_2 where f_access_code like &apos;xxx%&apos;; xxx%指匹配所有以xxx开头的权限码 当部门结构或员工归属调整时，权限编码如何处理？方案二中，调用新增的过程CHANGE_TO_DEPARTMENT即可级联更改权限码。","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"TimesTen","slug":"TimesTen","permalink":"http://blog.guitoubing.top/tags/TimesTen/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://blog.guitoubing.top/tags/内存数据库/"}]},{"title":"感谢Docker,让我远离环境配置","slug":"使用Docker安装Oracle-12c","date":"2018-11-12T15:26:45.000Z","updated":"2018-11-25T14:17:59.444Z","comments":true,"path":"2018/11/12/使用Docker安装Oracle-12c/","link":"","permalink":"http://blog.guitoubing.top/2018/11/12/使用Docker安装Oracle-12c/","excerpt":"Why Docker自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。 这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。 偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。","text":"Why Docker自开始用Oracle以来，环境配置一直是让我掉头发的事。而如今也只是在Windows上的安装界面点点点成功安装了Oracle，Linux上就从来没成功过，Mac的话Oracle 11g后好像就没Mac版的了，就很头疼。 这学期上了门内存数据库，老师给了个镜像，RedHat+Oracle+TimesTen究极体镜像，扔到VirtualBox上打开直接登录用户名密码，无需安装组件，无需配置环境，即开即用。自由的气息。 偶然间在网上看到了有关于Docker安装oracle的说法，于是便尝试了一下。真的，简洁，优雅，自由，甚至比虚拟机好用多了。 正题Docker安装并启动Oracle 12c安装12345# 在docker中寻找oracle镜像，可看到一条sath89/oracle-12c的镜像，便是我们需要安装的docker search oracledocker pull sath89/oracle-12c# 查看已安装的镜像docker images 由于docker使用的是国外源，在拉取时的速度可能很慢，可参见博客切换国内源以加快拉取速度：Docker切换国内镜像下载源 初始化123456# 使用log记录oracle启动的容器号log=$(sudo docker run -d -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c)# 显示当前容器初始化进程docker logs -f $log# 显示docker中当前运行的容器(可查看到容器ID)sudo docker ps 正常情况下，第一次创建容器应称之为初始化，而以后创建的容器都应基于上次的历史数据，称作容器的数据持久化，在上述命令中-v后的:之前是当前系统想要存储持久性数据的路径，用户想要共享到容器中的文件也可放入其中，:后面是在容器中想要访问当前系统的共享文件的路径。 因此在初始化完成后，若仍然使用上述命令，会提示数据库未初始化，从而会重新创建持久性数据文件；因此以后的容器创建应该使用以下命令^1^： 1sudo docker run -it -p 8080:8080 -p 1521:1521 -v /Users/tanrui/Oracle/oradata:/u01/app/oracle sath89/oracle-12c 至于上述的重复初始化是会造成文件覆盖还是文件并存我没有尝试过，猜测应该会是覆盖。 同时，重复执行命令^1^时，还会产生端口冲突。因此如果想创建两个Oracle容器应该执行初始化命令，执行时将持久化数据路径更改到其他地方且需将端口号修改掉。 进入容器123# 进入特定的容器，$&#123;ContainerID&#125;为上述查看到的容器ID# env LANG=C.UTF-8 表示当前容器使用支持中文的UTF-8格式(默认为POSIX，不支持中文)sudo docker exec -it $&#123;ContainerID&#125; env LANG=C.UTF-8 /bin/bash 连接oracle数据库123root@1386ef844664:/# su oracleoracle@1386ef844664:/$ cd $ORACLE_HOMEoracle@1386ef844664:/u01/app/oracle/product/12.1.0/xe$ bin/sqlplus / as sysdba Oracle数据库设置字符集1234567891011121314151617## 查看数据库编码，结果最下面一行则是目前编码SQL&gt; select * from nls_database_parameters where parameter ='NLS_CHARACTERSET'; ## 关闭数据库SQL&gt; shutdown immediate; ## 启动到 mount状态，oracle分为4个状态，详情请百度SQL&gt; startup mount; ## 设置session ，下同SQL&gt; ALTER SYSTEM ENABLE RESTRICTED SESSION; SQL&gt; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;SQL&gt; ALTER SYSTEM SET AQ_TM_PROCESSES=0;## 打开oracle到 open状态SQL&gt; alter database open; ## 修改编码为 ZHS16GBKSQL&gt; ALTER DATABASE character set INTERNAL_USE ZHS16GBK; ## 重启oracle ，先关闭，再启动SQL&gt; shutdown immediate; SQL&gt; startup; 升华Docker真的好用！（俗","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.guitoubing.top/tags/Docker/"},{"name":"Oracle","slug":"Oracle","permalink":"http://blog.guitoubing.top/tags/Oracle/"}]},{"title":"记一次Win10+Fedora双系统的小折腾","slug":"记一次Win10-Fedora双系统的小折腾","date":"2018-11-06T13:21:10.000Z","updated":"2018-11-07T02:57:04.000Z","comments":true,"path":"2018/11/06/记一次Win10-Fedora双系统的小折腾/","link":"","permalink":"http://blog.guitoubing.top/2018/11/06/记一次Win10-Fedora双系统的小折腾/","excerpt":"问题描述因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。我在Google上搜了类似的问题，大多是诸如以下的原因：","text":"问题描述因课程需要，我在Win10上安装了Fedora双系统，结果出现了奇怪的问题，现Fedora系统可正常进入，Win10也有引导项，但无法进入Win10系统，报错信息见图。我在Google上搜了类似的问题，大多是诸如以下的原因： 主板供电不足（我使用的是台式机应该不会有这个问题） BIOS中系统时间不正确（我也未曾修改过该时间） 这些原因可能会造成与我类似的状况，但很显然这些都不是此处的问题所在 问题出现的环境背景及自己尝试过哪些方法系统相关信息：主系统Windows10专业版（安装在100G的SSD中），Fedora29（安装在由1T的HHD分出的50G硬盘中） 尝试过得方法： 曾使用PE系统中的引导修复工具修复Win10引导，无果 在Fedora中安装了grub工具尝试修复Win10引导，grub是用来配置启动时引导的系统，而我这里启动后切换到grub界面是有Win10引导的，因此问题应该不是出在这儿，而是出在Win10的引导文件\\Windows\\System32\\winload.efi上，感觉此方法应该是行不通的（到此处我排除了grub引导出错的可能性） 至此，我想既然问题出在引导文件上，我从我室友电脑上拷贝了一份该文件替换了我的引导文件，然后再使用PE中的引导修复工具修复了一遍，仍然无果 问题截图 如上所示，错误信息提示文件\\Windows\\System32\\winload.efi出错，导致我一直陷入找winload.efi文件错误的怪圈。 问题解决方法鼓捣大半天，我仍然无法解决此问题，便在SegmentFault上提问，希望藉此找到解答。在此要非常感谢解决了我的问题的答主冯恒智，一言点睛。 具体解决方法如下（划重点）：在PE中使用bootice的bcd编辑功能，打开了Win10所在磁盘中的BCD文件（C:\\EFI\\Microsoft\\Boot\\BCD），发现其中的【启动设备】项下的启动磁盘和启动分区项被置空了，我将其填写完毕后（如下图所示）发现Win10就可以正常启动了，我想这应该是我在安装Fedora时的一些不当操作使得BCD文件被修改的缘故而让Win10无法正常启动（Bootice使用方法可参见此博客）。 疑问：我在安装Fedora时应该说，和Win10所在盘是完全分隔开来的，为何Fedora安装好后会影响到Win10的Boot文件呢？更疑惑的是它只影响了配置中的启动磁盘和启动分区两项，而其他都未曾影响？待解…… 就很玄学（挠头11月7日更新SegmentFault上的答主冯恒智又回复了我的问题，如下： 并不是因为你编辑过bcd文件而导致启动磁盘和启动分区项被置空了，而是在win10安完后编辑过磁盘（比如分区啊，改盘符啊，调整容量什么的）导致找不到启动磁盘和启动分区，重新指定一下就行了","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.guitoubing.top/tags/Win10/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.guitoubing.top/tags/Linux/"},{"name":"双系统","slug":"双系统","permalink":"http://blog.guitoubing.top/tags/双系统/"},{"name":"引导修复","slug":"引导修复","permalink":"http://blog.guitoubing.top/tags/引导修复/"}]},{"title":"JavaFX 学习小记","slug":"JavaFX-学习小记","date":"2018-10-27T16:08:25.000Z","updated":"2018-11-13T10:52:26.000Z","comments":true,"path":"2018/10/28/JavaFX-学习小记/","link":"","permalink":"http://blog.guitoubing.top/2018/10/28/JavaFX-学习小记/","excerpt":"JavaFX小记简介 JavaFX JavaFX是由甲骨文(Oracle)公司推出的一系列的产品和技术，主要应用于创建Rich Internet application(RIAs)，它是一个跨平台的桌面应用程序开发框架。","text":"JavaFX小记简介 JavaFX JavaFX是由甲骨文(Oracle)公司推出的一系列的产品和技术，主要应用于创建Rich Internet application(RIAs)，它是一个跨平台的桌面应用程序开发框架。 典型的MVC架构 定义Model，使用javafx.beans封装类型定义属性类型 使用fxml文件创建View，利用SceneBuilder工具进行布局 创建Controller实现动作操作以及Model和View的联系 View 创建FXML文件，利用SceneBuilder工具进行布局 Model 定义Model中的Person类，使用Property和Bind java.beans包中的对象类型不是标准的Java原语，而是新的封装起来的类，它封装了Java原语并添加了一些额外的功能，Property和Bind方便我们实现以下功能：当某个属性如First Name被改变时，会自动收到通知而修改视图，从而保证视图与数据的同步。当然仅仅声明这种类型是不够的，声明只是为后续操作提供类型前提，还需要进一步操作，可参考JavaFX文档。 Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.tanrui.model;import java.time.LocalDate;import javafx.beans.property.IntegerProperty;import javafx.beans.property.ObjectProperty;import javafx.beans.property.SimpleIntegerProperty;import javafx.beans.property.SimpleObjectProperty;import javafx.beans.property.SimpleStringProperty;import javafx.beans.property.StringProperty;/** * Model class for a Person. */public class Person &#123; private final StringProperty firstName; private final StringProperty lastName; private final StringProperty street; private final IntegerProperty postalCode; private final StringProperty city; private final ObjectProperty&lt;LocalDate&gt; birthday; /** * Default constructor. */ public Person() &#123; this(null, null); &#125; /** * Constructor with some initial data. * * @param firstName * @param lastName */ public Person(String firstName, String lastName) &#123; this.firstName = new SimpleStringProperty(firstName); this.lastName = new SimpleStringProperty(lastName); // Some initial dummy data, just for convenient testing. this.street = new SimpleStringProperty(\"some street\"); this.postalCode = new SimpleIntegerProperty(1234); this.city = new SimpleStringProperty(\"some city\"); this.birthday = new SimpleObjectProperty&lt;LocalDate&gt;(LocalDate.of(1999, 2, 21)); &#125; public String getFirstName() &#123; return firstName.get(); &#125; public void setFirstName(String firstName) &#123; this.firstName.set(firstName); &#125; public StringProperty firstNameProperty() &#123; return firstName; &#125; public String getLastName() &#123; return lastName.get(); &#125; public void setLastName(String lastName) &#123; this.lastName.set(lastName); &#125; public StringProperty lastNameProperty() &#123; return lastName; &#125; public String getStreet() &#123; return street.get(); &#125; public void setStreet(String street) &#123; this.street.set(street); &#125; public StringProperty streetProperty() &#123; return street; &#125; public int getPostalCode() &#123; return postalCode.get(); &#125; public void setPostalCode(int postalCode) &#123; this.postalCode.set(postalCode); &#125; public IntegerProperty postalCodeProperty() &#123; return postalCode; &#125; public String getCity() &#123; return city.get(); &#125; public void setCity(String city) &#123; this.city.set(city); &#125; public StringProperty cityProperty() &#123; return city; &#125; public LocalDate getBirthday() &#123; return birthday.get(); &#125; public void setBirthday(LocalDate birthday) &#123; this.birthday.set(birthday); &#125; public ObjectProperty&lt;LocalDate&gt; birthdayProperty() &#123; return birthday; &#125;&#125; 使用ObservableList管理Person 前一点所述的后续操作便是此处了，JavaFX为了实现上述目的即保持视图和数据的同步，引入了一些新的集合类，这里我们用到的是ObservableList，ObservableList继承了List类、实现了Observable接口，其实现视图和数据同步的方法是在声明ObservableList时为方法传递一个监听器，此监听器需要会通过监听personData的变化同步改变视图中对应的值，可参考ObservableList文档 Main.java: 12345678910111213141516171819202122232425262728293031public class Main extends Application &#123; /*......Other variables......*/ /** * * The data of a observable list of Persons */ private ObservableList&lt;Person&gt; personData = FXCollections.observableArrayList(); public ObservableList&lt;Person&gt; getPersonData() &#123; return personData; &#125; public Main()&#123; personData.add(new Person(\"Tan\", \"Rui\")); personData.add(new Person(\"Chen\", \"Chao\")); personData.add(new Person(\"Liang\", \"Chengwei\")); personData.add(new Person(\"Xiao\", \"Xin\")); personData.add(new Person(\"Li\", \"Yang\")); personData.add(new Person(\"Chen\", \"Runqian\")); personData.add(new Person(\"Liang\", \"Yongchao\")); personData.add(new Person(\"Luo\", \"Jihao\")); personData.add(new Person(\"Chen\", \"Zhi\")); personData.add(new Person(\"Fan\", \"Fan\")); &#125; /* ......Other function..... */&#125; ControllerPersonOverviewController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.tanrui.view;import javafx.fxml.FXML;import javafx.scene.control.Label;import javafx.scene.control.TableColumn;import javafx.scene.control.TableView;import com.tanrui.Main;import com.tanrui.model.Person;public class PersonOverviewController &#123; @FXML private TableView&lt;Person&gt; personTable; @FXML private TableColumn&lt;Person, String&gt; firstNameColumn; @FXML private TableColumn&lt;Person, String&gt; lastNameColumn; @FXML private Label firstNameLabel; @FXML private Label lastNameLabel; @FXML private Label streetLabel; @FXML private Label postalCodeLabel; @FXML private Label cityLabel; @FXML private Label birthdayLabel; // Reference to the main application. private Main main; /** * The constructor. * The constructor is called before the initialize() method. */ public PersonOverviewController() &#123; &#125; /** * Initializes the controller class. This method is automatically called * after the fxml file has been loaded. */ @FXML private void initialize() &#123; // Initialize the person table with the two columns. firstNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().firstNameProperty()); lastNameColumn.setCellValueFactory(cellData -&gt; cellData.getValue().lastNameProperty()); &#125; /** * Is called by the main application to give a reference back to itself. * * @param main */ public void setMain(Main main) &#123; this.main = main; // Add observable list data to the table personTable.setItems(main.getPersonData()); &#125;&#125; @FXML注解（Annotation） 使用@FXML注解可以将操作的属性、方法绑定到FXML文件的界面元素，实际上，在属性、方法是非私有的情况下可以不使用@FXML注解，但是比起非私有声明，让他们保持私有并用注解标记的方式会更好！ initialize()方法 initialize()字面意思可知其是用于初始化对应FXML文件中的属性，此方法会在加载FXML文件时被自动执行，此时，所有的FXML属性都应已被初始化 setCellValueFactory(...)方法 我们对表格列上使用setCellValueFactory(...)方法来确定为特定列使用前面Person的某个属性。-&gt;表示使用的是Lambdas特性；另外一种方法是使用PropertyValueFactory(待研究…)。 这里我们之所以可以使用cellData -&gt; cellData.getValue().firstNameProperty()，便是因为之前我们将Person的属性都定义为javafx.beans中的封装属性，firstNameProperty()等方法都会在声明成Beans封装类型时被创建，其遵循了固定的命名规则，这使得我们使用起来特别方便 连接Main和PersonOverviewController showPersonOverview() 方法 Main.java 12345678910111213141516171819202122/** * Shows the person overview inside the root layout. */public void showPersonOverview() &#123; try &#123; // Load person overview. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/PersonOverview.fxml\")); AnchorPane personOverview = (AnchorPane) loader.load(); // Set person overview into the center of root layout. rootLayout.setCenter(personOverview); // Give the controller access to the main app. PersonOverviewController controller = loader.getController(); controller.setMain(this); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 将View与Controller绑定我们还需要为FXML文件指定其对应的Controller，以及FXML元素与控制器的属性的对应关系，这是因为FXML文件中的元素只能被对应Controller修改更新，若在其他方法中修改会产生运行时错误。例如：在PersonOverviewController.java中将某个Label返回到Main.java中而后在其中修改该Label的值，意即在非FX线程中执行FX线程相关的任务，则会造成当前的线程阻塞，解决方法之一是使用Platform.runLater()方法，如下所示，括号中的FX线程相关任务便不会阻塞当前进程。 123Platform.runLater(() -&gt; &#123; ………相关FX线程代码………&#125;); 当然，最好的选择还是讲FX线程任务和其他任务区分开来，将特定的FXML文件与对应的Controller联系起来，当需要建立联系时可通过之前所说的使用java.beans、ObservableList等方法实现动态更新视图。 为FXML文件指定Controller 在Eclipse中好像有图形化界面直接为FXML文件选择Controller的操作，但是我使用的是IDEA，没有此功能，只能在源代码中指定，如下所示。 PersonOverview.fxml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;AnchorPane maxHeight=\"-Infinity\" maxWidth=\"-Infinity\" minHeight=\"-Infinity\" minWidth=\"-Infinity\" prefHeight=\"300.0\" prefWidth=\"600.0\" xmlns=\"http://javafx.com/javafx/8.0.121\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"com.tanrui.view.PersonOverviewController\"&gt; &lt;children&gt; &lt;? ... 内容省略 ... ?&gt; &lt;/children&gt;&lt;/AnchorPane&gt; 如上述代码所述，在顶层节点（此处是AnchorPane）标签中添加属性如下：fx:controller=&quot;com.tanrui.view.PersonOverviewController”，以此为FXML文件指定Controller 为FXML元素指定fx:id，使其绑定对应的控制器属性 如图，选定特定元素，在右侧界面找到Code-&gt;fx:id，将其对应的控制器属性填入即可 Details界面更新 showPersonDetails(Person person)方法 showPersonDetails(Person person)方法用于使用Person实例的数据填写标签。 PersonOverviewController.java 123456789101112131415161718192021222324252627/** * Fills all text fields to show details about the person. * If the specified person is null, all text fields are cleared. * * @param person the person or null */private void showPersonDetails(Person person) &#123; if (person != null) &#123; // Fill the labels with info from the person object. firstNameLabel.setText(person.getFirstName()); lastNameLabel.setText(person.getLastName()); streetLabel.setText(person.getStreet()); postalCodeLabel.setText(Integer.toString(person.getPostalCode())); cityLabel.setText(person.getCity()); // TODO: We need a way to convert the birthday into a String! // birthdayLabel.setText(...); &#125; else &#123; // Person is null, remove all the text. firstNameLabel.setText(\"\"); lastNameLabel.setText(\"\"); streetLabel.setText(\"\"); postalCodeLabel.setText(\"\"); cityLabel.setText(\"\"); birthdayLabel.setText(\"\"); &#125;&#125; 监听用户在人员表中的选择 PersonOverviewController.java 123456789101112131415@FXMLprivate void initialize() &#123; // Initialize the person table with the two columns. firstNameColumn.setCellValueFactory( cellData -&gt; cellData.getValue().firstNameProperty()); lastNameColumn.setCellValueFactory( cellData -&gt; cellData.getValue().lastNameProperty()); // Clear person details. showPersonDetails(null); // Listen for selection changes and show the person details when changed. personTable.getSelectionModel().selectedItemProperty().addListener( (observable, oldValue, newValue) -&gt; showPersonDetails(newValue));&#125; 删除按钮事件我们的界面已经包含了一个删除的按钮 ，但是并没有为其制定实际的响应操作，因此我们定义一个响应函数，如下： PersonOverviewController.java: 12345678910111213/** * Called when the user clicks on the delete button. */ @FXML private void handleDeletePerson() &#123; int selectedIndex = personTable.getSelectionModel().getSelectedIndex(); if (selectedIndex &gt;= 0)&#123; personTable.getItems().remove(selectedIndex); &#125; else&#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125; &#125; 错误处理从上述代码可以看到我们使用了条件判断语句来判断selectedIndex的值，当其小于0时，正常情况我们应该会让其抛出ArrayIndexOutOfBoundsException异常，但是我们想尽量简洁明了的将错误或者警告信息展示给用户，因此这里我们使用了controlsfx包，用于弹出各类提示框（可在ControlsFX官网获取）。 controlsfx有两个主要的版本，同时对于不同的版本，二者的用法也不同： 对于Java 8，需要下载ControlsFX 8.40.14包 对于Java 9及以上，需要下载ControlsFX 9.0.0包 我们这里用到的是Java 10，因此使用ControlsFX 9.0.0，使用方法如下： ShowDialog.java: 1234567891011121314151617181920212223242526272829303132package com.tanrui.util;import javafx.scene.control.Alert;import javafx.stage.Stage;/** * Util to create and show Dialog. * * @author Tan Rui */public class ShowDialog &#123; private Stage stage; private Alert.AlertType type; private String title; private String message; public ShowDialog(Stage stage, Alert.AlertType type, String title, String message)&#123; this.stage = stage; this.type = type; this.title = title; this.message = message; &#125; public void ShowSpecificDialog()&#123; Alert dlg = new Alert(type); dlg.initOwner(stage); dlg.setTitle(title); dlg.getDialogPane().setContentText(message); dlg.show(); &#125;&#125; PersonOverviewController.java 12345678910111213/** * Called when the user clicks on the delete button. */ @FXML private void handleDeletePerson() &#123; int selectedIndex = personTable.getSelectionModel().getSelectedIndex(); if (selectedIndex &gt;= 0)&#123; personTable.getItems().remove(selectedIndex); &#125; else&#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125; &#125; 新建和编辑对话框 Tips：创建一个新的界面、新的Stage（承载新的View时），步骤一般都是： 创建FXML文件，使用SceneBuilder编辑界面； 创建对应的Controller，对FXML中的元素指定对应的属性。主要是为展示型元素指定数据、为控制型元素指定动作等； 连接FXML文件和Controller文件、连接FXML中的元素和Controller中的属性； 在Main函数中加载该控制器 为之前的New和Edit按钮添加动作，弹出对话框（新的Stage）。 设计对话框创建PersonEditDialog.fxml，完成弹出对话框的设计： 创建控制器为对话框创建控制器PersonEditDialogController.java。 PersonEditDialogController.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.tanrui.view;import com.tanrui.util.ShowDialog;import javafx.fxml.FXML;import javafx.scene.control.Alert;import javafx.scene.control.TextField;import javafx.stage.Stage;import com.tanrui.model.Person;import com.tanrui.util.DateUtil;/** * Dialog to edit details of a person. * * @author Marco Jakob */public class PersonEditDialogController &#123; @FXML private TextField firstNameField; @FXML private TextField lastNameField; @FXML private TextField streetField; @FXML private TextField postalCodeField; @FXML private TextField cityField; @FXML private TextField birthdayField; private Stage dialogStage; private Person person; private boolean okClicked = false; /** * Initializes the controller class. This method is automatically called * after the fxml file has been loaded. */ @FXML private void initialize() &#123; &#125; /** * Sets the stage of this dialog. * * @param dialogStage */ public void setDialogStage(Stage dialogStage) &#123; this.dialogStage = dialogStage; &#125; /** * Sets the person to be edited in the dialog. * * @param person */ public void setPerson(Person person) &#123; this.person = person; firstNameField.setText(person.getFirstName()); lastNameField.setText(person.getLastName()); streetField.setText(person.getStreet()); postalCodeField.setText(Integer.toString(person.getPostalCode())); cityField.setText(person.getCity()); birthdayField.setText(DateUtil.format(person.getBirthday())); birthdayField.setPromptText(\"dd.mm.yyyy\"); &#125; /** * Returns true if the user clicked OK, false otherwise. * * @return */ public boolean isOkClicked() &#123; return okClicked; &#125; /** * Called when the user clicks ok. */ @FXML private void handleOk() &#123; if (isInputValid()) &#123; person.setFirstName(firstNameField.getText()); person.setLastName(lastNameField.getText()); person.setStreet(streetField.getText()); person.setPostalCode(Integer.parseInt(postalCodeField.getText())); person.setCity(cityField.getText()); person.setBirthday(DateUtil.parse(birthdayField.getText())); okClicked = true; dialogStage.close(); &#125; &#125; /** * Called when the user clicks cancel. */ @FXML private void handleCancel() &#123; dialogStage.close(); &#125; /** * Validates the user input in the text fields. * * @return true if the input is valid */ private boolean isInputValid() &#123; String errorMessage = \"\"; if (firstNameField.getText() == null || firstNameField.getText().length() == 0) &#123; errorMessage += \"No valid first name!\\n\"; &#125; if (lastNameField.getText() == null || lastNameField.getText().length() == 0) &#123; errorMessage += \"No valid last name!\\n\"; &#125; if (streetField.getText() == null || streetField.getText().length() == 0) &#123; errorMessage += \"No valid street!\\n\"; &#125; if (postalCodeField.getText() == null || postalCodeField.getText().length() == 0) &#123; errorMessage += \"No valid postal code!\\n\"; &#125; else &#123; try &#123; Integer.parseInt(postalCodeField.getText()); &#125; catch (NumberFormatException e) &#123; errorMessage += \"No valid postal code (must be an integer)!\\n\"; &#125; &#125; if (cityField.getText() == null || cityField.getText().length() == 0) &#123; errorMessage += \"No valid city!\\n\"; &#125; if (birthdayField.getText() == null || birthdayField.getText().length() == 0) &#123; errorMessage += \"No valid birthday!\\n\"; &#125; else &#123; if (!DateUtil.validDate(birthdayField.getText())) &#123; errorMessage += \"No valid birthday. Use the format dd.mm.yyyy!\\n\"; &#125; &#125; if (errorMessage.length() == 0) &#123; return true; &#125; else &#123; new ShowDialog(dialogStage, Alert.AlertType.ERROR, \"Invalid Fields\", \"Please correct invalid fields\").ShowSpecificDialog(); return false; &#125; &#125;&#125; 关于该控制器的一些事情应该注意： setPerson(…)方法可以从其它类中调用，用来设置编辑的人员。 当用户点击OK按钮时，调用handleOK()方法。首先，通过调用isInputValid()方法做一些验证。只有验证成功，Person对象使用输入的数据填充。这些修改将直接应用到Person对象上，传递给setPerson(…)。 布尔值okClicked被使用，以便调用者决定用户是否点击OK或者Cancel按钮。 连接视图和控制器使用已经创建的视图（FXML）和控制器，需要连接到一起。 使用SceneBuilder打开PersonEditDialog.fxml文件 在左边的Controller组中选择PersonEditDialogController作为控制器类 设置所有TextField的fx:id到相应的控制器字段上。 设置两个按钮的onAction到相应的处理方法上。 在Main中部署该控制器Main.java: 12345678910111213141516171819202122232425262728293031323334353637/** * Opens a dialog to edit details for the specified person. If the user * clicks OK, the changes are saved into the provided person object and true * is returned. * * @param person the person object to be edited * @return true if the user clicked OK, false otherwise. */public boolean showPersonEditDialog(Person person) &#123; try &#123; // Load the fxml file and create a new stage for the popup dialog. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/PersonEditDialog.fxml\")); AnchorPane page = (AnchorPane) loader.load(); // Create the dialog Stage. Stage dialogStage = new Stage(); dialogStage.setTitle(\"Edit Person\"); dialogStage.initModality(Modality.WINDOW_MODAL); dialogStage.initOwner(primaryStage); Scene scene = new Scene(page); dialogStage.setScene(scene); // Set the person into the controller. PersonEditDialogController controller = loader.getController(); controller.setDialogStage(dialogStage); controller.setPerson(person); // Show the dialog and wait until the user closes it dialogStage.showAndWait(); return controller.isOkClicked(); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125;&#125; 为主界面中New和Edit按钮创建OnAction方法，这些方法将从Main中调用showPersonEditDialog(…)方法。 PersonOverviewController.java: 123456789101112131415161718192021222324252627282930/** * Called when the user clicks the new button. Opens a dialog to edit * details for a new person. */@FXMLprivate void handleNewPerson() &#123; Person tempPerson = new Person(); boolean okClicked = main.showPersonEditDialog(tempPerson); if (okClicked) &#123; main.getPersonData().add(tempPerson); &#125;&#125;/** * Called when the user clicks the edit button. Opens a dialog to edit * details for the selected person. */@FXMLprivate void handleEditPerson() &#123; Person selectedPerson = personTable.getSelectionModel().getSelectedItem(); if (selectedPerson != null) &#123; boolean okClicked = main.showPersonEditDialog(selectedPerson); if (okClicked) &#123; showPersonDetails(selectedPerson); &#125; &#125; else &#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.WARNING, \"No Person Selected\", \"Please select a person in the table.\").ShowSpecificDialog(); &#125;&#125; 而后在PersonOverview.fxml中为New和Edit两个按钮绑定对应的OnAction方法： 数据持久化我们有很多种方法来实现应用数据的持久化，例如： 使用数据库存储 使用Json文件存储 使用XML文件存储 …… 这里我们使用XML文件格式存储应用数据。之前的我们应用的数据都只是存在内存中，内存的特性使得关闭应用程序后数据便会丢失，因此我们下面要做的就是： 每次打开应用可加载上一次的用户数据 用户可选择保存当前数据到指定XML文件 用户可选择从指定XML文件加载数据 使用Preferences保存应用状态Java提供了Preferences类来帮助我们存储用户配置（本例中是XML数据文件的路径，用于下次打开从该文件中加载），Preferences类底层对各类操作系统进行了封装（实际上是Windows系统、OS X系统和类Unix文件系统三种），用户配置在Windows系统上可能保存在注册表中、在类Unix文件系统上可能保存在/tmp下的某个隐藏文件中，而对于使用者来说这些实现细节都不必考虑，只需知道Preferences类是用来保存用户配置即可。用法如下： Main.java: 1234567891011121314151617181920212223242526272829303132333435/** * Returns the person file preference, i.e. the file that was last opened. * The preference is read from the OS specific registry. If no such * preference can be found, null is returned. * * @return */ public File getPersonFilePath() &#123; Preferences prefs = Preferences.userNodeForPackage(Main.class); String filePath = prefs.get(\"filePath\", null); if (filePath != null) &#123; return new File(filePath); &#125; else &#123; return null; &#125; &#125; /** * Sets the file path of the currently loaded file. The path is persisted in * the OS specific registry. * * @param file the file or null to remove the path */ public void setPersonFilePath(File file) &#123; Preferences prefs = Preferences.userNodeForPackage(Main.class); if (file != null) &#123; prefs.put(\"filePath\", file.getPath()); // Update the stage title. primaryStage.setTitle(\"AddressApp - \" + file.getName()); &#125; else &#123; prefs.remove(\"filePath\"); // Update the stage title. primaryStage.setTitle(\"AddressApp\"); &#125; &#125; 使用JAXBJAXB包是Java中提供的对数据进行编列(marshall)成XML文件以及对XML文件反编列(unmarshall)为数据结构的包，Java SE中有如下支持类型：JAXB 2.0是JDK 1.6的组成部分。JAXB 2.2.3是JDK 1.7以上的组成部分，而实际上在Java 9之后就已将JAXB包移除，因此使用时需添加额外的lib包，详情可见博客真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException。 JAXB模型类我们希望持久化的数据应该是Main中的personData，而JAXB有以下要求： 使用@XmlRootElement定义XML根元素的名称 使用@XmlElement指定一个XML元素，可选 而Main中的personData是ObservableList类型，由于ObservableList类型不支持添加注解，因此我们需要创建另外一个能保存Person列表同时又能存储为XML文件的类，如下。 PersonListWrapper.java: 12345678910111213141516171819202122232425package com.tanrui.model;import java.util.List;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;/** * Helper class to wrap a list of persons. This is used for saving the * list of persons to XML. */@XmlRootElement(name = \"persons\")public class PersonListWrapper &#123; private List&lt;Person&gt; persons; @XmlElement(name = \"person\") public List&lt;Person&gt; getPersons() &#123; return persons; &#125; public void setPersons(List&lt;Person&gt; persons) &#123; this.persons = persons; &#125;&#125; 使用JAXB读写数据到XML文件我们将读写XML文件的逻辑放到Main类中，Controller在用到相应的逻辑时，直接调用Main中的方法即可。 Main.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Loads person data from the specified file. The current person data will * be replaced. * * @param file */public void loadPersonDataFromFile(File file) &#123; try &#123; JAXBContext context = JAXBContext .newInstance(PersonListWrapper.class); Unmarshaller um = context.createUnmarshaller(); // Reading XML from the file and unmarshalling. PersonListWrapper wrapper = (PersonListWrapper) um.unmarshal(file); personData.clear(); personData.addAll(wrapper.getPersons()); // Save the file path to the registry. setPersonFilePath(file); &#125; catch (Exception e) &#123; // catches ANY exception new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog(); &#125;&#125;/** * Saves the current person data to the specified file. * * @param file */public void savePersonDataToFile(File file) &#123; try &#123; JAXBContext context = JAXBContext.newInstance(PersonListWrapper.class); Marshaller m = context.createMarshaller(); m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); // Wrapping our person data. PersonListWrapper wrapper = new PersonListWrapper(); wrapper.setPersons(personData); // Marshalling and saving XML to the file. m.marshal(wrapper, file); // Save the file path to the registry. setPersonFilePath(file); &#125; catch (Exception e) &#123; // catches ANY exception new ShowDialog(this.getPrimaryStage(), Alert.AlertType.ERROR, \"Error\", \"Could not save data to file:\\n\" + file.getPath()).ShowSpecificDialog(); &#125;&#125; 编组(marshall):savePersonDataToFile(…)和解组(unmarshall):loadPersonDataFromFile(…)已准备好，下面在界面中使用它。 创建打开和保存菜单为File菜单添加子项 处理菜单相应动作Controller中使用FileChooser的方法，FileChooser同样封装了不同操作系统的具体实现，使用者仅需调用接口即可。 本类中使用了FileChooser.ExtensionFilter，对文件系统中文件进行过滤，保留.xml结尾的文件。 当用户选择特定文件而后点击打开按钮时，会返回该文件，否则返回Null。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.tanrui.view;import com.tanrui.Main;import com.tanrui.util.ShowDialog;import javafx.fxml.FXML;import javafx.scene.control.Alert;import javafx.stage.FileChooser;import java.io.File;/** * The controller for the root layout. The root layout provides the basic * application layout containing a menu bar and space where other JavaFX * elements can be placed. */public class RootLayoutController &#123; // Reference to the main application private Main main; /** * Is called by the main application to give a reference back to itself. * * @param main */ public void setMain(Main main) &#123; this.main = main; &#125; /** * Creates an empty address book. */ @FXML private void handleNew() &#123; main.getPersonData().clear(); main.setPersonFilePath(null); &#125; /** * Opens a FileChooser to let the user select an address book to load. */ @FXML private void handleOpen() &#123; FileChooser fileChooser = new FileChooser(); // Set extension filter FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter( \"XML files (*.xml)\", \"*.xml\"); fileChooser.getExtensionFilters().add(extFilter); // Show save file dialog File file = fileChooser.showOpenDialog(main.getPrimaryStage()); if (file != null) &#123; main.loadPersonDataFromFile(file); &#125; &#125; /** * Saves the file to the person file that is currently open. If there is no * open file, the \"save as\" dialog is shown. */ @FXML private void handleSave() &#123; File personFile = main.getPersonFilePath(); if (personFile != null) &#123; main.savePersonDataToFile(personFile); &#125; else &#123; handleSaveAs(); &#125; &#125; /** * Opens a FileChooser to let the user select a file to save to. */ @FXML private void handleSaveAs() &#123; FileChooser fileChooser = new FileChooser(); // Set extension filter FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter( \"XML files (*.xml)\", \"*.xml\"); fileChooser.getExtensionFilters().add(extFilter); // Show save file dialog File file = fileChooser.showSaveDialog(main.getPrimaryStage()); if (file != null) &#123; // Make sure it has the correct extension if (!file.getPath().endsWith(\".xml\")) &#123; file = new File(file.getPath() + \".xml\"); &#125; main.savePersonDataToFile(file); &#125; &#125; /** * Opens an about dialog. */ @FXML private void handleAbout() &#123; new ShowDialog(main.getPrimaryStage(), Alert.AlertType.INFORMATION, \"About\", \"Author: Tan\\\\nWebsite: https://guitoubing.top\").ShowSpecificDialog(); &#125; /** * Closes the application. */ @FXML private void handleExit() &#123; System.exit(0); &#125; /** * Opens the birthday statistics. */ @FXML private void handleShowBirthdayStatistics() &#123; main.showBirthdayStatistics(); &#125;&#125; 连接FXML文件和Controller、绑定菜单和对应动作 在Main中部署该控制器Main.java: 123456789101112131415161718192021222324252627/** * Initializes the root layout. */ public void initRootLayout() &#123; try &#123; // Load root layout from fxml file. FXMLLoader loader = new FXMLLoader(); loader.setLocation(Main.class.getResource(\"view/RootLayout.fxml\")); rootLayout = (BorderPane) loader.load(); // Show the scene containing the root layout. Scene scene = new Scene(rootLayout); primaryStage.setScene(scene); RootLayoutController controller = loader.getController(); controller.setMain(this); primaryStage.show(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; File file = getPersonFilePath(); if (file != null)&#123; loadPersonDataFromFile(file); &#125; &#125; 参考资料 code.makery —— JavaFX中文教程 JavaFX Tutorial 真正解决方案：java.lang.ClassNotFoundException: javax.xml.bind.JAXBException fxexperience —— ControlFX Java SE8 —— Lambda ………… 写在后面本博主要是在学习code.makery —— JavaFX中文教程博客中对于JavaFX的教程，跟着博主的项目逻辑和代码自己过了一遍，对一些由于版本不兼容（博主使用的是JDK 8u40，我这里使用的是Java 10 2018-03-20）造成的问题进行了解决，同时对项目过程中一些功能进行了拓展学习，研究了很多用到的包源码，收获颇多。可点击JavaFX-Test中获取源码。 希望藉此次JavaFX学习开启我的Java源码学习之旅，道阻且长！","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"JavaFX","slug":"JavaFX","permalink":"http://blog.guitoubing.top/tags/JavaFX/"},{"name":"Java源码学习之旅","slug":"Java源码学习之旅","permalink":"http://blog.guitoubing.top/tags/Java源码学习之旅/"},{"name":"Java","slug":"Java","permalink":"http://blog.guitoubing.top/tags/Java/"}]},{"title":"TimesTen内存数据库课程笔记（更新中）","slug":"TimesTen内存数据库课程笔记","date":"2018-09-02T12:59:50.000Z","updated":"2018-11-06T13:19:32.000Z","comments":true,"path":"2018/09/02/TimesTen内存数据库课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/02/TimesTen内存数据库课程笔记/","excerpt":"内存计算与内存数据库第零章OLTP：行存储（记录：元组），联机事务处理 OLAP：列存储（key-value），联机分析处理 Timesten操作小记","text":"内存计算与内存数据库第零章OLTP：行存储（记录：元组），联机事务处理 OLAP：列存储（key-value），联机分析处理 Timesten操作小记 平台 系统：Red Hat Enterprise Linux Server release 5.7 (Tikanga) 创建DSN（Data Source Name） 逻辑名，用于标识某一数据库连接 打开数据库配置文件(通常称为系统ODBC.INI配置文件)12$ cd $TT_HOME/info$ gedit sys.odbc.ini 在数据库DSN列表中添加需要新建的数据库名称123456789101112# 添加my_ttdb数据库，“=”后面是指该数据库使用某种驱动，如第3行所示[ODBC Data Sources]my_ttdb=TimesTen 11.2.2 DriverTT_1122=TimesTen 11.2.2 Driversampledb_1122=TimesTen 11.2.2 Drivercachedb1_1122=TimesTen 11.2.2 Driverrepdb1_1122=TimesTen 11.2.2 Driverrepdb2_1122=TimesTen 11.2.2 DriversampledbCS_1122=TimesTen 11.2.2 Client Drivercachedb1CS_1122=TimesTen 11.2.2 Client Driverrepdb1CS_1122=TimesTen 11.2.2 Client Driverrepdb2CS_1122=TimesTen 11.2.2 Client Driver 为2中创建的数据库添加配置，日志文件与检查点文件应存储在不同磁盘中12345678910111213# 配置my_ttdb[my_ttdb]# 数据库监听器驱动位置Driver=/home/oracle/TimesTen/tt1122/lib/libtten.so # DataStore为检查点文件存储位置DataStore=/u02/ttdata/datastores/my_ttdb # LogDir为日志文件存储位置LogDir=/u03/ttdata/logs# 以下两个Size是TimesTen内存数据库的内存分配PermSize=40TempSize=32# 数据库的字符集DatabaseCharacterSet=AL32UTF8 TimesTen的内存分配主要是PermSize和TempSize两块，可先参考博客如何更改TimesTen数据库的大小。 保存配置文件并关闭数据库服务器基本命令查看服务器状态12345678[oracle@timesten-hol info]$ ttstatusTimesTen status report as of Thu Sep 27 04:08:30 2018Daemon pid 2637 port 53392 instance tt1122TimesTen server pid 2646 started on port 53393------------------------------------------------------------------------Accessible by group oracleEnd of report 启动/停止数据库12345678910111213141516[oracle@timesten-hol info]$ ttdaemonadmin -stopTimesTen Daemon stopped.[oracle@timesten-hol info]$ ttstatusttStatus: Could not connect to the TimesTen daemon.If the TimesTen daemon is not running, please start itby running \"ttDaemonAdmin -start\".[oracle@timesten-hol info]$ ttdaemonadmin -startTimesTen Daemon startup OK.[oracle@timesten-hol info]$ ttstatusTimesTen status report as of Thu Sep 27 04:10:00 2018Daemon pid 6522 port 53392 instance tt1122TimesTen server pid 6531 started on port 53393------------------------------------------------------------------------Accessible by group oracleEnd of report 创建TimesTen内存数据库 默认情况下，TimesTen内存数据库在第一次连接到数据库时创建并加载到内存中，并在关闭数据库的最后一个连接时从内存卸载。当然此行为可通过ttadmin -RAMPolicy修改，后面会说到。 也就是说，默认情况下（前提是RAM策略为inUse，下一节会讲到RAM策略的修改），每次在执行connect “dsn=ttdb_name”连接到一个特定的DSN时，都是一个创建TimesTen内存数据库、加载数据到内存中等过程，因此本节的标题是创建而不是连接到。 连接到特定DSN，创建内存数据库12345678[oracle@timesten-hol info]$ ttisqlCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.Command&gt; connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1) 或者直接在ttisql中指定DSN名称： 12345678910111213141516[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\"Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1)[oracle@timesten-hol ~]$ ttisql my_ttdbCopyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"DSN=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1) 问题：重复运行connect “dsn=ttdb_name”命令可以看到命令行中显示了多了连接，这是什么作用呢？ 1234567891011121314&gt; Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con1: Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con2: Command&gt; connect \"dsn=my_ttdb\";&gt; Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;&gt; (Default setting AutoCommit=1)&gt; con3: Command&gt; &gt; 查看内存数据库的内存分配及容量12345678Command&gt; dssize PERM_ALLOCATED_SIZE: 40960 PERM_IN_USE_SIZE: 9453 PERM_IN_USE_HIGH_WATER: 9453 TEMP_ALLOCATED_SIZE: 32768 TEMP_IN_USE_SIZE: 9442 TEMP_IN_USE_HIGH_WATER: 9505 使用Host命令可以调用操作系统级别的指令1234567891011121314151617181920212223242526272829Command&gt; host ttstatus;TimesTen status report as of Thu Sep 27 04:37:28 2018Daemon pid 6522 port 53392 instance tt1122TimesTen server pid 6531 started on port 53393------------------------------------------------------------------------Data store /u01/ttdata/datastores/my_ttdbThere are 12 connections to the data storeShared Memory KEY 0x1200c904 ID 2785297PL/SQL Memory KEY 0x1300c904 ID 2818066 Address 0x7fa0000000Type PID Context Connection Name ConnIDProcess 6973 0x0000000000c72c00 my_ttdb 1Subdaemon 6529 0x00000000012d3360 Manager 142Subdaemon 6529 0x000000000132a1e0 Rollback 141Subdaemon 6529 0x000000000140b360 HistGC 139Subdaemon 6529 0x0000000001420070 AsyncMV 140Subdaemon 6529 0x00000000014b4e00 Log Marker 136Subdaemon 6529 0x0000000001509a30 Deadlock Detector 135Subdaemon 6529 0x000000000151e620 Flusher 134Subdaemon 6529 0x0000000001533210 Checkpoint 133Subdaemon 6529 0x00000000016286b0 Monitor 132Subdaemon 6529 0x00007f95880208e0 Aging 138Subdaemon 6529 0x00007f958808f900 IndexGC 137Replication policy : ManualCache Agent policy : ManualPL/SQL enabled.------------------------------------------------------------------------Accessible by group oracleEnd of report 修改RAM策略 上一节讲到每一次的连接到特定的DSN都是新建一个内存数据库的过程，当然这是基于默认RAM策略为inUse的情况，下面会讲到当RAM策略设置为Manual时创建内存数据库的过程。 Manual策略适用于当数据库中数据规模巨大，装载到内存中的时间可能很长，从而导致内存数据库效率低下；而inUse策略适用于大多数情况，数据规模不是很大，装载到内存中的时间很短或者说在业务需求中可以忽略不计。 查看当前RAM策略123456[oracle@timesten-hol info]$ ttadmin my_ttdbRAM Residence Policy : inUseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False 修改RAM策略为手动模式（Manual） 手动模式下，创建DSN连接时并不会将数据加载到内存中，需要手动进行数据装载和卸载 1234567891011121314151617[oracle@timesten-hol info]$ ttadmin -rampolicy manual my_ttdbRAM Residence Policy : manualManually Loaded In RAM : FalseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\"; 707: Attempt to connect to a data store that has been manually unloaded from RAMThe command failed.Done.[oracle@timesten-hol info]$ 向内存中装载数据12345678910111213141516[oracle@timesten-hol info]$ ttadmin -ramload my_ttdbRAM Residence Policy : manualManually Loaded In RAM : TrueReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\";Connection successful: DSN=my_ttdb;UID=oracle;DataStore=/u02/ttdata/datastores/my_ttdb;DatabaseCharacterSet=AL32UTF8;ConnectionCharacterSet=US7ASCII;DRIVER=/home/oracle/TimesTen/tt1122/lib/libtten.so;LogDir=/u03/ttdata/logs;PermSize=40;TempSize=32;TypeMode=0;(Default setting AutoCommit=1)Command&gt; 从内存中卸载数据1234567891011121314151617[oracle@timesten-hol info]$ ttadmin -ramunload my_ttdbRAM Residence Policy : manualManually Loaded In RAM : FalseReplication Agent Policy : manualReplication Manually Started : FalseCache Agent Policy : manualCache Agent Manually Started : False[oracle@timesten-hol info]$ ttisql \"dsn=my_ttdb\";Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.Type ? or \"help\" for help, type \"exit\" to quit ttIsql.connect \"dsn=my_ttdb\"; 707: Attempt to connect to a data store that has been manually unloaded from RAMThe command failed.Done.[oracle@timesten-hol info]$ 日志和检查点查看日志文件，提交之前会预写日志12345Command&gt; host ls -al /u03/ttdata/logs/my*-rw-rw---- 1 oracle oracle 18270208 Sep 28 23:00 /u03/ttdata/logs/my_ttdb.log4-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res0-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res1-rw-rw---- 1 oracle oracle 67108864 Sep 27 04:18 /u03/ttdata/logs/my_ttdb.res2 查看检查点123Command&gt; host ls -al /u02/ttdata/datastores/my*-rw-rw---- 1 oracle oracle 31906840 Sep 28 23:00 /u02/ttdata/datastores/my_ttdb.ds0-rw-rw---- 1 oracle oracle 31906840 Sep 28 22:57 /u02/ttdata/datastores/my_ttdb.ds1 手动更新检查点文件 非手动状态下检查点会每间隔一段时间执行一次，会将自上次检查点后提交的事务更新到检查点中；检查点文件是非阻塞的，即更新检查点文件时也可执行事务。 如下调用检查点文件： 12Command&gt; call ttckpt;Command&gt; call ttckpt; ttisql基本命令——用户操作创建用户，可在表sys.all_users中查找所有的用户信息123456789101112131415161718192021Command&gt; select * from sys.all_users;&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;6 rows found.Command&gt; create user tthr identified by tthr;User created.Command&gt; select * from sys.all_users;&lt; SYS, 0, 2018-09-27 04:18:18.063030 &gt;&lt; TTREP, 2, 2018-09-27 04:18:18.063030 &gt;&lt; SYSTEM, 3, 2018-09-27 04:18:18.063030 &gt;&lt; GRID, 4, 2018-09-27 04:18:18.063030 &gt;&lt; ORACLE, 10, 2018-09-27 04:18:18.063030 &gt;&lt; SCOTT, 11, 2018-09-27 05:06:39.267433 &gt;&lt; TTHR, 12, 2018-09-28 23:11:57.126074 &gt;7 rows found. 给用户分配权限1234Command&gt; grant create session to tthr;Command&gt; grant create table to tthr;Command&gt; grant create view to tthr;Command&gt; grant create sequence to tthr; 查看当前数据库系统内用户权限1234567891011Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;9 rows found. 撤回用户权限 以下示例展示了如何从用户撤回权限（赋予delete any table权限后再撤回该权限） 12345678910111213141516171819202122232425Command&gt; grant delete any table to tthr;Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, DELETE ANY TABLE, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;10 rows found.Command&gt; revoke delete any table from tthr;Command&gt; select * from sys.dba_sys_privs;&lt; SYS, ADMIN, YES &gt;&lt; SYSTEM, ADMIN, YES &gt;&lt; ORACLE, ADMIN, YES &gt;&lt; SCOTT, CREATE SESSION, NO &gt;&lt; SCOTT, CREATE TABLE, NO &gt;&lt; TTHR, CREATE SESSION, NO &gt;&lt; TTHR, CREATE TABLE, NO &gt;&lt; TTHR, CREATE VIEW, NO &gt;&lt; TTHR, CREATE SEQUENCE, NO &gt;9 rows found. ttisql基本命令——数据库对象操作关闭自动提交 意即每次执行事务后，均需要执行commit以提交事务。 1Command&gt; autocommit off; 建表、插入数据123456789101112Command&gt; create table ttemployees &gt; (employee_id NUMBER(6) NOT NULL, &gt; last_name VARCHAR2(10) NOT NULL, hire_date DATE, performance_report CLOB, &gt; PRIMARY KEY (employee_id) ) &gt; UNIQUE HASH ON (employee_id) PAGES = 1;Command&gt; insert into ttemployees values (1, &apos;Smith&apos;, &apos;2009-02-23&apos;, &apos;excellent&apos;); 1 row inserted.Command&gt; insert into ttemployees values (2, &apos;King&apos;, &apos;2005-08-05&apos;, &apos;great&apos;);1 row inserted.Command&gt; insert into ttemployees values (3, &apos;Taylor&apos;, &apos;2012-01-28&apos;, EMPTY_CLOB());1 row inserted.Command&gt; commit; 一些命令总结 tables and alltables - Lists tables indexes and allindexes - Lists indexes views and allviews - Lists views sequences and allsequences - Lists sequences synonyms and allsynonyms - Lists synonyms functions and allfunctions - Lists PL/SQL functions procedures and allprocedures - Lists PL/SQL procedures packages and allpackages - Lists PL/SQL packages PLSQL编程创建plsqldb、pls用户、运行sql脚本12call ttOptUpdateStats;// 更新统计数据，用于分析生成最优执行计划 使用sql developer连接TimesTen和Oracle配置如下： plsql语法 What Is a PL/SQL Package?A package is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages usually have two parts, a specification and a body, although sometimes the body is unnecessary. The specification (spec for short) is the interface to your applications; it declares the types, variables, constants, exceptions, cursors, and subprograms available for use. The body fully defines cursors and subprograms, and so implements the spec. 包是一个模式对象，它对逻辑上相关的PL/SQL类型、项和子程序进行分组。包通常有两个部分，规范和主体，主体不是必要的。规范是应用程序的接口：它声明可用的类型、变量、常量、异常、游标和子程序。主体将完全定义游标和子程序，以此实现规范。 As Figure 9-1 shows, you can think of the spec as an operational interface and of the body as a “black box.” You can debug, enhance, or replace a package body without changing the interface (package spec) to the package. ——Oracle PL/SQL Package文档 1_package.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243CREATE OR REPLACE PACKAGE test AS -- Declare a record for the desired EMP fields TYPE empRecType IS RECORD ( r_empno EMP.EMPNO%TYPE, -- 使用EMP表中EMPNO的类型 r_ename EMP.ENAME%TYPE, r_salary EMP.SAL%TYPE ); -- Declare a Ref Cursor type TYPE EmpCurType IS REF CURSOR RETURN empRecType; -- 游标类型需要有返回值 -- A parameterized cursor，定义 -- 游标 CURSOR low_paid (num PLS_INTEGER) IS SELECT empno FROM emp WHERE rownum &lt;= num ORDER BY sal ASC; -- 过程(IN表示输入，OUT表示输出) PROCEDURE ddl_dml (myComment IN VARCHAR2, errCode OUT PLS_INTEGER, -- 整型 errText OUT VARCHAR2); PROCEDURE givePayRise (num IN PLS_INTEGER, name OUT EMP.ENAME%TYPE, -- name是plsql中的保留字，应该尽量避免使用保留字 errCode OUT PLS_INTEGER, errText OUT VARCHAR2); PROCEDURE getCommEmps (empRefCur IN OUT EmpCurType, errCode OUT PLS_INTEGER, errText OUT VARCHAR2); -- Associative array TYPE sum_multiples IS TABLE OF PLS_INTEGER -- Associative array type INDEX BY PLS_INTEGER; -- indexed by pls_integer FUNCTION get_sum_multiples ( multiple IN PLS_INTEGER, num IN PLS_INTEGER ) RETURN sum_multiples;END test;/CREATE OR REPLACE PACKAGE BODY test AS PROCEDURE ddl_dml (myComment IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS sql_str VARCHAR2(256); name_already_exists EXCEPTION; insufficient_privileges EXCEPTION; PRAGMA EXCEPTION_INIT(name_already_exists, -0955); PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031); seq_value number; BEGIN BEGIN sql_str := &apos;create table foo (COL1 VARCHAR2 (20),COL2 NVARCHAR2 (60))&apos;; DBMS_OUTPUT.PUT_LINE(sql_str); execute immediate sql_str; EXCEPTION WHEN name_already_exists THEN DBMS_OUTPUT.PUT_LINE(&apos; Ignore existing table errors&apos;); WHEN insufficient_privileges THEN DBMS_OUTPUT.PUT_LINE(&apos; Ignore insufficient privileges errors&apos;); END; -- Cast num_col1 and char_col values insert into temp values (1, 1, myComment); commit; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN name_already_exists THEN errCode := 0; errtext := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END ddl_dml; PROCEDURE givePayRise (num IN PLS_INTEGER, name OUT EMP.ENAME%TYPE, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Can use PLSQL collections within TimesTen PLSQL TYPE lowest_paid_type IS TABLE OF emp.empno%TYPE; lowest_paid lowest_paid_type; i PLS_INTEGER; numRows PLS_INTEGER; lucky_index PLS_INTEGER; lucky_emp EMP.EMPNO%TYPE; BEGIN -- Initialize the output variable name := &apos;Nobody&apos;; -- Initialize the collection lowest_paid := lowest_paid_type(0, 1, 2, 3, 4, 5, 6, 7, 8, 9); i := 1; -- Constrain the resultset size IF num &lt; 1 OR num &gt; 10 THEN -- If bad inputs, default to 5 rows numRows := 5; ELSE numRows := num; END IF; -- Create the cursor resultset with up to &apos;numRows&apos; rows OPEN low_paid( numRows ); LOOP -- Get the current empid FETCH low_paid INTO lowest_paid(i); EXIT WHEN low_paid%NOTFOUND; -- Increment the PLSQL table index i := i + 1; END LOOP; -- Close the cursor CLOSE low_paid; -- List the subset of lowest paid employees FOR j in lowest_paid.FIRST .. numRows LOOP DBMS_OUTPUT.PUT_LINE(&apos; Lowest paid empno &apos; || j || &apos; is &apos; || lowest_paid(j) ); END LOOP; -- Randomly choose one of the lowest paid employees for a 10% pay raise. lucky_index := trunc(dbms_random.value(lowest_paid.FIRST, numRows)); lucky_emp := lowest_paid(lucky_index); -- Give lucky_emp a 10% pay raise and return their name UPDATE emp SET sal = sal * 1.1 WHERE empno = lucky_emp RETURNING ename INTO name; COMMIT; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END givePayRise; PROCEDURE getCommEmps (empRefCur IN OUT EmpCurType, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS salesGuy empRecType; BEGIN DBMS_OUTPUT.PUT_LINE(&apos; &apos;); DBMS_OUTPUT.PUT_LINE(&apos;Displaying the refcursor for the sales people&apos;); -- The refcursor (empRefCur) result was opened before calling this procedure LOOP FETCH empRefCur INTO salesGuy; EXIT WHEN empRefCur%NOTFOUND; DBMS_OUTPUT.PUT_LINE(salesGuy.r_ename); END LOOP; CLOSE empRefCur; errCode := 0; errtext := &apos;OK&apos;; EXCEPTION WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END getCommEmps; FUNCTION get_sum_multiples ( multiple IN PLS_INTEGER, num IN PLS_INTEGER ) RETURN sum_multiples IS s sum_multiples; BEGIN FOR i in 1..num LOOP s(i) := multiple * ((i * (i + 1)) / 2); -- sum of the multiples END LOOP; RETURN s; END get_sum_multiples;BEGIN -- package initialization goes here DBMS_OUTPUT.PUT_LINE(&apos;Initialized package test&apos;);END test;/ 2_call_package.sql: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556set serveroutput on;declare errCode PLS_INTEGER; errtext VARCHAR2(256); myRefCur test.EmpCurType; -- 使用test包中定义的类型 salesPerson test.empRecType; name EMP.ENAME%TYPE; n PLS_INTEGER := 5; -- number of multiples to sum for display sn PLS_INTEGER := 10; -- number of multiples to sum m PLS_INTEGER := 3; -- multiple begin dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Find some of the lowest paid employees and give a random employee a 10% pay raise&apos;); -- Give a lowely paid random employee a 10% pay raise test.givePayRise(5, name, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); else dbms_output.put_line(name || &apos; got the 10% payraise&apos;); end if; -- Open a refcursor OPEN myRefCur FOR SELECT empno, ename, sal FROM emp WHERE comm IS NOT NULL; -- display the resultset of the refcursor test.getCommEmps(myRefCur, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Do some DDL and DML in a stored procedure&apos;); test.ddl_dml(&apos;hi&apos;, errCode, errText); if errCode != 0 then dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; -- associative arrays dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Use an associative array to compute the sum of multiples&apos;); dbms_output.put_line( &apos;Sum of the first &apos; || TO_CHAR(n) || &apos; multiples of &apos; || TO_CHAR(m) || &apos; is &apos; || TO_CHAR(test.get_sum_multiples (m, sn)(n))); end;/ 3_create_package_workload.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234CREATE OR REPLACE PACKAGE workload AS PROCEDURE oltp_read_only ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, errCode OUT PLS_INTEGER, errText OUT VARCHAR2); PROCEDURE oltp_read_write ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, v_c IN CHAR, v_p IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2);END workload;/CREATE OR REPLACE PACKAGE BODY workload AS -- Private package variables used for package initialization theErrCode PLS_INTEGER := 0; theErrText VARCHAR2(256) := &apos;OK&apos;; -- Using shared package cursors for efficiency CURSOR range_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT c FROM sbtest WHERE id BETWEEN n AND m; CURSOR range_order_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT c FROM sbtest WHERE id BETWEEN n AND m ORDER BY c; CURSOR range_distinct_query (n PLS_INTEGER, m PLS_INTEGER) IS SELECT DISTINCT c FROM sbtest WHERE id BETWEEN n AND m ORDER BY c; -- The workload read only workload PROCEDURE oltp_read_only ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Store the result of the column &apos;c&apos; cValue char(120); -- Store the sum of the rows in (n..m) sumK number(38,0); BEGIN errCode := 0; errtext := &apos;OK&apos;; -- oltp point query FOR i in 1 .. 10 LOOP -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;); SELECT c INTO cValue FROM sbtest WHERE id = v_id; -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; -- oltp range query (using a cursor for loop)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;); FOR range_rows IN range_query(v_n, v_m) LOOP-- DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c); null; END LOOP; -- olpt range SUM() query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;); SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;-- DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK); -- oltp range ORDER BY query (using explicit fetches)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;); OPEN range_order_query(v_n, v_m); LOOP FETCH range_order_query INTO cValue; EXIT WHEN range_order_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_order_query; -- oltp range DISTINCT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;); OPEN range_distinct_query(v_n, v_m); LOOP FETCH range_distinct_query INTO cValue; EXIT WHEN range_distinct_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_distinct_query; EXCEPTION WHEN NO_DATA_FOUND THEN errCode := 0; errText := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END oltp_read_only; -- The workload read + write workload PROCEDURE oltp_read_write ( v_id IN PLS_INTEGER, v_n IN PLS_INTEGER, v_m IN PLS_INTEGER, v_c IN CHAR, v_p IN VARCHAR2, errCode OUT PLS_INTEGER, errText OUT VARCHAR2) IS -- Store the result of the column &apos;c&apos; cValue char(120); -- Store the sum of the rows in (n..m) sumK number(38,0); BEGIN errCode := 0; errtext := &apos;OK&apos;; -- oltp point query FOR i in 1 .. 10 LOOP -- DBMS_OUTPUT.PUT_LINE(&apos;oltp point query&apos;); SELECT c INTO cValue FROM sbtest WHERE id = v_id; -- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; -- oltp range query (using a cursor for loop)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range query&apos;); FOR range_rows IN range_query(v_n, v_m) LOOP-- DBMS_OUTPUT.PUT_LINE(range_query%ROWCOUNT || &apos; c = &apos; || range_rows.c); null; END LOOP; -- olpt range SUM() query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range SUM() query&apos;); SELECT sum(k) INTO sumK FROM sbtest WHERE id BETWEEN v_n AND v_m;-- DBMS_OUTPUT.PUT_LINE(&apos;sumK = &apos; || sumK); -- oltp range ORDER BY query (using explict fetches)-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range ORDER BY query&apos;); OPEN range_order_query(v_n, v_m); LOOP FETCH range_order_query INTO cValue; EXIT WHEN range_order_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_order_query; -- oltp range DISTINCT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp range DISTINCT query&apos;); OPEN range_distinct_query(v_n, v_m); LOOP FETCH range_distinct_query INTO cValue; EXIT WHEN range_distinct_query%NOTFOUND;-- DBMS_OUTPUT.PUT_LINE(&apos;c = &apos; || cValue); END LOOP; CLOSE range_distinct_query; -- oltp UPDATES on index column-- DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on index column&apos;); UPDATE sbtest SET k = k + 1 WHERE id = v_n; -- oltp UPDATES on non-index column-- DBMS_OUTPUT.PUT_LINE(&apos;oltp UPDATES on non-index column&apos;); UPDATE sbtest SET c = v_n WHERE id = v_m; -- oltp DELETE query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp DELETE query&apos;); DELETE FROM sbtest WHERE id = v_n; -- oltp INSERT query-- DBMS_OUTPUT.PUT_LINE(&apos;oltp INSERT query&apos;); INSERT INTO sbtest (id, k, c, pad) VALUES (v_n, v_m, v_c, v_p); -- Commit the changes COMMIT; EXCEPTION WHEN NO_DATA_FOUND THEN errCode := 0; errText := &apos;OK&apos;; WHEN OTHERS THEN errCode := SQLCODE; errText := SUBSTR(SQLERRM, 1, 200); END oltp_read_write;BEGIN -- package initialization goes here -- Run the procedures once to initialize everything oltp_read_only(1, 1, 10, theErrCode, theErrText ); oltp_read_write(1, 1, 10, &apos;abc&apos;, &apos;def&apos;, theErrCode, theErrText ); DBMS_OUTPUT.PUT_LINE(&apos;Initialized the workload package&apos;);END workload;/ 4_call_workload.sql: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778set serveroutput on;declare counter PLS_INTEGER; errCode PLS_INTEGER; errtext VARCHAR2(256); line1 VARCHAR2(256); line2 VARCHAR2(256); someText sbtest.c%TYPE; moreText VARCHAR2(256); i PLS_INTEGER; iterations PLS_INTEGER; startTime NUMBER; endTime NUMBER; duration NUMBER;begin -- Initialize the someText string line1 := &apos;The quick brown foxy did da jumping thing over that lazy doggy. &apos;; line2 := &apos;Question three, who was scott and who or what was tiger?&apos;; someText := line1 || line2; moreText := &apos;&apos;; -- Initialize the moreText string FOR i in 1 .. 60 LOOP moreText := moreText || &apos;a&apos;; END LOOP; -- Get the start time in centi-seconds startTime := DBMS_UTILITY.GET_TIME(); iterations := 10000; for counter in 1 .. iterations LOOP workload.oltp_read_only(1, 1, 1100, errCode, errtext); if errCode != 0 then exit; end if; end loop; -- Get the end time in centi-seconds endTime := DBMS_UTILITY.GET_TIME(); if errCode !=0 then dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; duration := endTime - startTime; IF duration &gt; 0 THEN dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Called workload.oltp_read_only &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) ); ELSE dbms_output.put_line(&apos;Could not get valid timing info&apos;); END IF; iterations := 10000; for counter in 1 .. iterations LOOP workload.oltp_read_write(1, 1, 1100, someText, moreText, errCode, errtext); if errCode != 0 then exit; end if; end loop; -- Get the end time in centi-seconds endTime := DBMS_UTILITY.GET_TIME(); if errCode !=0 then dbms_output.put_line(&apos; &apos;); dbms_output.put_line(&apos;Error code = &apos; || errCode || &apos; Error Text = &apos; || errtext); end if; duration := endTime - startTime; IF duration &gt; 0 THEN dbms_output.put_line(&apos;Called workload.oltp_read_write &apos; || iterations || &apos; times. TPS = &apos; || trunc(iterations / duration * 100, 1) ); ELSE dbms_output.put_line(&apos;Could not get valid timing info&apos;); END IF;end;/","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"},{"name":"TimesTen","slug":"TimesTen","permalink":"http://blog.guitoubing.top/tags/TimesTen/"},{"name":"内存数据库","slug":"内存数据库","permalink":"http://blog.guitoubing.top/tags/内存数据库/"}]},{"title":"软件工程课程笔记（更新中）","slug":"软件工程课程笔记","date":"2018-09-01T13:22:10.000Z","updated":"2018-11-06T13:19:32.000Z","comments":true,"path":"2018/09/01/软件工程课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/01/软件工程课程笔记/","excerpt":"软件工程第一章第二章 软件工程 定义软件工程的框架(Framework) 软件工程的定义 软件工程是：（1）将系统化的(systematic)、规范的(disciplined)、可量化(quantifiable)的方法应用于软件的开发(development)、运行(operation)和维护(maintenance). （2）对（1）中所述方法(approaches)的研究.","text":"软件工程第一章第二章 软件工程 定义软件工程的框架(Framework) 软件工程的定义 软件工程是：（1）将系统化的(systematic)、规范的(disciplined)、可量化(quantifiable)的方法应用于软件的开发(development)、运行(operation)和维护(maintenance). （2）对（1）中所述方法(approaches)的研究. 软件工程层次图 工具-方法-过程-质量关注点 软件过程 软件过程的定义 软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合，一个活动(activity)包含多个动作(action)，一个动作包含多个任务(task). 过程框架 最经典的过程框架： 需求调研(RE)→需求分析建模(Require Analysis Model)→概要设计(Architecture Design)→详细设计(CLD)→编码(Coding)→单元测试(Unit testing)→整合测试(Integrating testing)→系统测试(System testing)→交付或发布(Delivery or Release) 通用的过程框架： 沟通(Communication)→策划(Planning)→建模(Modeling)→构建(Construction)→部署(Deployment) 沟通包含需求调研； 策划是一个普适性活动或者庇护维活动或质量控制维活动(Umbrella activity)，与开发维(devolope demention)或框架活动(framework)不重合 建模包含需求分析建模、概要设计、详细设计 构建包含编码、单元测试、整合测试、系统测试 部署包含发布 milestone milestone是项目管理中用于标记项目时间轴上特定点的工具，用于某一过程活动完成的标志，以使工程能够成功过渡到下一阶段。 普适性活动包含： 软件项目跟踪和控制(Software project tracking and control，以Planning为基础) 风险管理(Risk management) 首先进行风险识别，得到初始识别的风险表(risk list)，利用以下公式将风险按照RE从高到低排序列出。 12&gt; risk exposure(RE，风险曝光度) = impact(影响度) * productivity(影响比例)&gt; 制定风险缓解计划(risk mitigation planning) 风险跟踪(risk tranking)： 可能风险缓解 可能风险真的发生，要有对应的风险处理对策 软件质量保证(Software quality assurance) 例子：SQA，GitHub的bug检查合并 技术评审(Technical review) 按照代码逻辑或者代码行进行评审、检查 测量(Measurement) 定量化， 软件配置管理(Software configuration management) 在整个软件过程中管理变更所带来的影响 可复用管理(Reusability management) 工作产品的准备和生产(Work product preparation and production) 工作分解结构(WBS)： ​ 工作分解结构（简称WBS）跟因数分解是一个原理，就是把一个项目，按一定的原则分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中，直到分解不下去为止。即：项目→任务→工作→日常活动。工作分解结构以可交付成果为导向，对项目要素进行的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。WBS总是处于计划过程的中心，也是制定进度计划、资源需求、成本预算、风险管理计划和采购计划等的重要基础。——百度百科 过程的适应性调整 软件工程过程并不是教条的规则，也不要求软件团队机械地执行，而应该是灵活可适应的（根据软件所需解决的问题、项目特点、开发团队和组织文化等进行适应性调整）。 软件工程实践 具体实施通用框架活动的过程就是软件实践。 实践的精髓 理解问题（沟通和分析）—— Understand the problem (communication and analysis) 策划解决方案（建模和软件设计）—— Plan a solution (modeling and software design) 包含概要设计建模和分析设计建模，最重要的是概要设计建模（体系结构、数据库设计、接口设计） 实施计划（代码生成）—— Carry out the plan (code generation) 就是写代码 检查结果的正确性（测试和质量保证）—— Examine the result for accuracy (tesing and quality assurance) 通过设计足够的测试来发现尽可能多的错误 通用原则 存在价值（The reason it all exists） 保持简洁（KISS, Keep it simple, stupid） 保持愿景（Maintain the Vision） 关注使用者（What You Produce， Others Will Consume） 面向未来（Be Open To The Future） 提前计划复用（Plan Ahead for Reuse） 认真思考（Think！） 软件开发神话Exercise: 找到Tools第三章 软件过程结构通用过程模型 过程流 线性过程流 迭代过程流 演化过程流 并行过程流 定义框架活动过程模式第四章 过程模型（Process Models）传统（惯用）过程模型（Prescriptive Process Models）瀑布模型（Waterfall Model） 又称经典生命周期（Classic life cycle） 瀑布模型可能会有反复的过程，但无迭代的过程，但反复会使得开发过程产生混乱。 瀑布模型的变种：V模型（V-model），V模型拉直后与Generic Process Framework一致。 箭头表示测试过程与设计过程的关系（相关性） 增量过程模型（Incremental Process Models） 增量过程模型没有迭代过程，因为其开发过程没有环 特点： 每1个增量交叉并行 每1个增量都是可以供用户直接使用的系统 第1个增量往往包含主要的、核心的功能 模型的选择：时间限制、资金限制、技术限制 例如项目的99%的需求已经完善，项目需要6个月完成，若时间充足可使用瀑布模型，但若甲方所给时间比较少，则可先完成一部分主要的内容，先交付，后来的需求可在后面的增量中开发，这就是增量模型的一个例子。 演化过程模型（Evolutionary Process Model） 演化模型是迭代的过程模型","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"},{"name":"软件工程","slug":"软件工程","permalink":"http://blog.guitoubing.top/tags/软件工程/"}]},{"title":"计算机网络课程笔记（更新中）","slug":"计算机网络课程笔记","date":"2018-09-01T12:51:13.000Z","updated":"2018-11-06T13:19:32.000Z","comments":true,"path":"2018/09/01/计算机网络课程笔记/","link":"","permalink":"http://blog.guitoubing.top/2018/09/01/计算机网络课程笔记/","excerpt":"计算机网络简介 网络通信是进程间的通信，进程的表示： 1IP:port //IP为服务器IP地址，port为服务器上的进程号","text":"计算机网络简介 网络通信是进程间的通信，进程的表示： 1IP:port //IP为服务器IP地址，port为服务器上的进程号 网络组成： Management Application Hardware Cable：电缆、光纤 Network Interface Card：网卡 Switch：交换机 Router：路由器 传播介质（第7章）对传播介质的度量 传播延时 信号在介质中往返一次所需的时间 信道容量 介质可以支持的最大数据速率 频率范围 介质可接受的最大的频率变化范围 带宽 每秒所收到的数据量（Bit） 奈奎斯特定理1234D=2*B*log2KK:传输系统使用的信号电平数B:模拟带宽D:以每秒位元数计算的最大数据速率 香农定理1234C=B*log2(1+S/N)B:硬件带宽S/N:信噪比C:用每秒位数表示的对信道容量的有效限制 分贝(db)和信噪比(S/N)是指数关系 12345dB=10*log10S/Neg: dB = 20 =&gt; S/N = 100 db = 30 =&gt; S/N = 1000 例子：电话线 123Bandwidth = 3000HZS/N ratio = 30db=&gt; C = 30Kps 传输模式（第9章）传输模式分类 串行传输 并行传输 传输数据 例子：Byte 正序(big-endian) &amp;&amp; Bit 逆序(little-endian) 串行传输方式 异步传输 键盘输入，RS-232异步字符传输 RS-232异步字符传输标准 把一串字符串通过铜线进行传输 S1:把字符用ASCII码表示出来；S2: 状态机：电压变化表示状态切换 空闲状态： ​ 接受”-“：保持空闲状态 ​ 接受”+“：变成传输状态 传输状态： ​ 接受”-“：保持传输状态，传1 ​ 接受“+”：保持传输状态，传0 传输的数据前后各需要一位，分别作为起始位(+)、终止位(-) 结束按照“翻转”时间确定，传输完成保持负电压 最终传输到接收方是9位，多一位校验码 同步传输 以太网 原理同对表一样 实现方法：采用先传输一部分规定好的数据，来检测发送方和接收方是否一致 等时传输 利用缓冲区实现 标准 波特率匹配 例子：传输Z(0x5A)，检测波特率提高一倍 通信信道 单工信道 Eg：广播、收音机 全双工信道 数据线路设备(DCE)和数据终端设备(DTE) 反接线 半双工信道 Eg：对讲机 调制和调制解调器（第10章）远距离传输 考虑：干扰、信号衰减 解决方案：载波传输 载波传输方式 连续性好 载波改变方式——调制（Modulation）与解调（Demodulation）1234S(t)=Asin(2πFt+P)// A: Amplitude Modulation(调幅)// F: Frequency Modulation(调频，单位时间内波的个数)// P: Phase Modulation(调相) 调幅 调幅的大小有一定的限制（香农定理的限制） 调频 调相 键控（Shift keying）调制技术的比较 调相的效率要高一点，变化一次可传输不止一位（通过相位分隔，例如将2π分为8份，则有8种信号，可传输3位数据） 正交调幅(QAM, Quadrature Amplitude Modulation) 结合调幅和移相键控，使用同时包含相位和振幅的改变来表示数据，QAM最大可以表示1024个 公式：Y~m~(t) = A~m~sinwt+B~m~coswt，运算为矢量运算 调制解调器类型 无线猫（RF，Radio Frequency） 光纤猫（optical modems） 拨号猫（Dialup modem） 拨号调制解调器模式 Calling mode Answer mode 复用与解复用（第11章）分类频分多路复用FDM 多个逻辑信道，实际上只有一个物理信道。 防止频道之间干扰，通常有个区间为防护带区间。 信号的漂移现象 解决方法：子信道分配 分级FDM 分布式平铺 波分多路复用WDM 是指应用于光纤中的频分复用技术 时分多路复用TDM 同步TDM 问题：空闲时隙 应用：电话通话 分级TDM 统计TDM 应用：网络 逆转复用 将单个高速数字输入被分配到多个低速连接上，传输后再重新复合而形成输入的副本 码分多路复用CDM 矢量（Vector） 矢量的运算 结论 可靠性和信道编码（第8章）数据传输错误的3个源头 干扰 失真 衰减 传输差错对数据的影响 单个差错 突发差错 擦除（模糊） 处理信道差错的两种策略（信道编码） 发送数据的同时，发送校验码 前向纠错（FEC） 自动重传请求（ARQ） FEC机制 单奇偶检验 奇偶性定义为1的个数，且校验位的添加会使得码字始终保持奇数或偶数，保持奇数就是奇校验，保持偶数就是偶校验. 限制：校验能力有限，出两个错误时便无法校验 分组码数学与（n, k）表示 汉明距离 先计算最小汉明距d，而后得出可检查的最大的有效位长度：E&lt;=d-1 纵横奇偶校验 作用：可以找出错误的位置，并改正错误 缺点：效率低下，一般不用 校验和 码的长度一般为字节的倍数，进位需加回到原和中 优点： 校验和的大小比较小 计算很简单 开支很低 缺点： 对纵向错误无法校验（导致校验和方法一般不用在硬件上） 一般情况下，校验和位取的是算数反码，校验时所有数据位相加，得到结果取补码为0则数据正确 1IP包的头部长度：20Bytes 循环冗余校验码（CRC码，适宜用在硬件上，例如网卡） 关键特性 任意长度报文 出色的检错能力 快速硬件实现 线性码、循环线性码 线性码是一个码的集合C，且C~1~、C~2~∈C，则C~1~、C~2~∈C的线性组合仍然∈C； 循环线性码是指码循环移位后的码仍然属于该集合。 原理 硬件实现 异或门实现基本运算 算法 自动重传请求(ARQ)机制 数据传输成功会发送回执，错误则不发送回执 ​ OSI Reference Model 数据流（Data Flow）： Service服务：下一层对上一层提供服务（接口、方法） Protocol协议 Physical物理 物理层（5 7 9 10 11） 数据链路层（8） 将一条物理上有差错的传输信道通过通知和管理而变成逻辑上无差错的 因特网应用与网络编程（第3章）线路交换网络（circuit switched network）包交换网络（packet switched network） 特征：轮流 ​ 异步 不用安装 主要区别在于二者的共享性 局域网：分组、帧和拓扑（第13章）以太网的接受方式 广播式： MAC子层拷贝每个包 LLC子层提取每个包的拷贝 LLC子层只接受那些单一传播、广播或多路传播的地址相匹配的包 帧 帧头、帧尾用于检测传输过程是否发生错误，同时用作边界 边界采用两个ASC码中很少使用的字符： SOH（01）头部起始字符 EOT（04）传输结束字符 此方案的缺陷假如使用此两个字符，将会发生接受解析问题 解决方案 字填充（ABC可换成“任意”字符，但是效率不同，找一些不太会出现的字符会提高效率）： soh → esc + A eot → esc + B esc → esc + C 位填充： 5个1出现了便插入1个0，首尾使用01111110作为边界 IEEE MAC子层（第14章）受控介入协议（Control Access Protocols）轮询 方式： 按循环顺序 按优先级顺序 算法： 12345678&gt; 目的：&gt; 通过轮询来控制分组的发送&gt; 方法：&gt; 控制器不断重复&#123;&gt; 选择站点S，发送一个查询报文给S；&gt; 等待S发送一个分组来进行响应或跳过；&gt; &#125;&gt; 预定 算法： 12345678&gt; 目的：&gt; 通过预约来控制分组的发送&gt; 方法：&gt; 控制器不断重复&#123;&gt; 形成一个需要发送分组的站点列表；&gt; 允许列表中的站点发送分组；&gt; &#125;&gt; 令牌传递 令牌是一个特殊的帧，不管有没有数据都会在环状网络中传输 令牌有两个状态（空和忙的切换只能由同一个站点切换）： 空 → 可以发送（数据在传输时转变为忙令牌） 忙 → 无法发送（只能当数据在环网中发送一周时，才能将忙令牌转换为空令牌） 算法： 123456789&gt; 目的：&gt; 通过令牌传递来控制分组的发送&gt; 方法：&gt; 网络上的每台计算机重复执行&#123;&gt; 等待令牌的到达；&gt; 如果本计算机有分组正在等待发送，则发送一个分组；&gt; 将令牌发送到下一站；&gt; &#125;&gt; 12345678&gt; 1）空令牌传递到下一个节点；&gt; 2）节点是否要发送？不发送，转向1）&gt; 3）填充帧到令牌中，并置为忙&gt; 4）忙令牌传递到下一个节点&gt; 5）是否接受节点？是，复制该帧；转向4）&gt; 6）节点是否发送节点？是，销毁令牌中的帧，并置空，返回1）&gt; 7）返回4）&gt; 随机接入协议（Random Access Protocol）ALOHACSMA/CD（Collision Detect） 以太网中一个网卡数据一旦发送，便不能停下，需等到数据发送完 算法： 123456&gt; 1）监听网络状态；如果空闲，转向3）&gt; 2）等待，返回1）&gt; 3）发送，在发送的过程中同时进行碰撞监听&gt; 4）一旦发生碰撞，立即停止发送&gt; 5）推后一个随机时间，返回1）&gt; 检测冲突的方法： 载波侦听 冲突检测 二进制指数退避 CSMA/CA（Collision Avoidance） 算法： 有限局域网技术（第15章）以太网帧格式 以太网帧结构（截自维基百科） Question：(Using 广播 ) How does the sender know the target physical address？（注意：网卡无法识别IP地址） 地址解析（Address Resolution）目的地地址解析Sender： 发送广播，征询目的节点的物理地址 接到目的节点应答，取出目的节点物理地址 All Receivers： 接到广播，取出源节点物理地址,比较主机名是否相同 目标节点，匹配，就取出源节点物理地址，以该地址为目的地址，本物理地址为源地址，作询问应答 其他节点，因不匹配不需要作回答 帧类型（Frame Type） 用于区分帧的类型，是ARP包还是IP包（区分协议类型） IP：0800 ARP：0806 IEEE’s 802.3 Ethernet Frame（一种新的帧格式）网卡 NIC Network Interface Card NIC可以直接访问Memory，NIC与CPU仅存在指令关系 过程： 发送 Before sending data, CPU forms a packet in memory 发送数据之前，CPU在内存中产生一个数据包 CPU then instructs the NIC to begin transmission CPU给NIC发送播送指令 NIC transmits the frame containing the packet After finishing transmission, NIC uses the computer’s interrupt mechanism to inform the CPU 接收 The NIC waits for a frame to cross the network The NIC makes a copy of the frame The NIC verifies the frame CRC and checks the destination address If the destination address is correct，the NIC stores a copy of the packet in memory The NIC then interrupts the CPU Otherwise，the NIC discards the frame 网卡产品（NIC Evolution）粗缆（Original Thick Ethernet Wiring） IEEE802.310Base5 最大长度：500m（摩天大楼的高度） 组成： 网卡（连在设备上） 收发器 电缆 Terminator（终结器）：将信号能量消耗掉，防止信号反弹造成干扰，原理是电阻 Connection Multiplexor（多路连接器）：允许多台计算机连接到单个收发器，且提供与传统收发器完全相同的信号 细缆（Thin Ethernet） 将前者的三部分组合起来，结构和环网很像，但传输方式仍然是广播式的，Terminator仍然需要。 双绞线以太网（Twisted Pair Ethernet） HUB（集线器）里面包含了主线 集成网卡 RJ-45：双绞线 AUI：粗缆 BNC：细缆 双绞线网卡拓扑结构 Tips：网络上的逻辑上和结构上的拓扑结构可以不同！ 物理上：星形结构 逻辑上：总线结构 举例： 布线工程 无线联网技术（第16章）个域网（PAN，802.15） 蓝牙 红外 蓝牙耗电比较低，红外耗电高 紫峰（ZigBee） ISM无线 无线局域网（WLAN、WiFi，802.11） 为降低信号衰减采用FDM分布式平铺技术（第11章） AP，Access Point through the air （Base Station），相当于集线器 类型 专门构建型（Ad hoc） 点到点，不通过AP 基础结构型（Infrastructure） 通过AP Manet（Mobile Ad-hoc Networks）","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"大三上笔记","slug":"大三上笔记","permalink":"http://blog.guitoubing.top/tags/大三上笔记/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.guitoubing.top/tags/计算机网络/"}]},{"title":"dotnet基本配置及EFCore连接Mysql","slug":"Dotnet","date":"2018-06-26T08:57:08.000Z","updated":"2018-12-11T16:33:44.757Z","comments":true,"path":"2018/06/26/Dotnet/","link":"","permalink":"http://blog.guitoubing.top/2018/06/26/Dotnet/","excerpt":"前奏部分 下载并安装dotnet core 下载并安装vscode（需要把vscode添加到path中）","text":"前奏部分 下载并安装dotnet core 下载并安装vscode（需要把vscode添加到path中） vscode中搜索并安装C#插件、NuGet Package Manager插件 新建项目 12345&gt; mkdir dotnet&gt; cd dotnet&gt; dotnet new mvc&gt; code .&gt; commond + shift + p输入nuget add package安装以下依赖包，各个包的Version可在添加时选择 添加包时以下代码将自动在dotnet.csproj中添加： 12345678910&gt; &lt;ItemGroup&gt;&gt; &lt;PackageReference Include=\"Microsoft.AspNetCore.All\" Version=\"2.0.6\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite\" Version=\"2.1.0\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"2.1.0\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Sqlite.Design\" Version=\"2.0.0-preview1-final\"/&gt;&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/&gt;&gt; &lt;PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql\" Version=\"2.1.0-rc1-final\"/&gt;&gt; &lt;PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql.Design\" Version=\"1.1.2\"/&gt;&gt; &lt;/ItemGroup&gt;&gt; Model部分 连接数据库创建实体： 在vscode终端中输入以下命令 1dotnet ef dbcontext scaffold &quot;server=localhost;userid=user;pwd=password;port=3306;database=university;sslmode=none;&quot; Pomelo.EntityFrameworkCore.MySql -o Models dotnet ef两个问题 问题1：No executable found matching command “dotnet-ef”解决方法：dotnet.csproj中添加如下行： 1234&gt; &lt;ItemGroup&gt;&gt; &lt;DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"2.1.0-preview1-final\"/&gt;&gt; &lt;/ItemGroup&gt;&gt; 问题2：Version for package Microsoft.EntityFrameworkCore.Tools.DotNet could not be resolved. 原因：上述配置中Version版本与包引用中的版本不一致，修改上述添加代码的Version即可 此时将会在Models文件夹下创建所有数据库表的实体，同时会创建一个universityContext.cs实体（university为我数据库名称，自行定义），用于对整个数据库的操作。至此MVC已完成Model部分。 Controller及View部分 目前项目Models文件夹下已有DBFirst模式生成的实体文件： 我们选择Student的Model创建C-V视图 这里说明一下，MVC模式中Model顾名思义是数据模型、实体，而View和Controller是相互依存的。一般步骤是先创建StudentController.cs文件，定义其中的路由(URL映射，定义了路由之后可以直接通过URL访问该函数)，如本项目中的StudentController.cs中定义的Index： 1234&gt; public IActionResult Index()&#123;&gt; return View(_context.Student.ToList());&gt; &#125;&gt; 如此定义后，再在Views文件夹下创建对应Controller的文件夹，此处为Student，而在Controller中定义的每一个路由，都要有对应的一个cshtml文件，此处在Student下创建Index.cshtml。简而言之，View只负责处理布局，Controller只负责处理逻辑。 创建StudentController.cs 123456789101112131415161718192021222324252627282930313233343536&gt; using System;&gt; using System.Collections.Generic;&gt; using System.Diagnostics;&gt; using System.Linq;&gt; using System.Threading.Tasks;&gt; using Microsoft.AspNetCore.Mvc;&gt; using dotnet.Models;&gt; using dotnet;&gt; &gt; public class StudentController : Controller&#123;&gt; private universityContext _context;&gt; &gt; public StudentController(universityContext context)&#123;&gt; _context = context;&gt; &#125;&gt; &gt; public IActionResult Index()&#123;&gt; return View(_context.Student.ToList());&gt; &#125;&gt; &gt; public IActionResult Register()&#123;&gt; return View();&gt; &#125;&gt; &gt; [HttpPost]&gt; [ValidateAntiForgeryToken]&gt; public IActionResult Register(Student student)&#123;&gt; if(ModelState.IsValid)&#123;&gt; _context.Student.Add(student);&gt; _context.SaveChanges();&gt; return RedirectToAction(&quot;Index&quot;);&gt; &#125;&gt; return View(student);&gt; &#125;&gt; &#125;&gt; 创建Student文件夹，以及对应路由的cshtml Index.cshtml 1234567891011121314151617181920212223242526272829303132&gt; @&#123;&gt; ViewData[\"Title\"] = \"学生主页\";&gt; &#125;&gt; &gt; &lt;!-- 此处这个model声明不能忘记 --&gt;&gt; @model IEnumerable&lt;dotnet.Student&gt;&gt; &gt; &lt;table class=\"table\"&gt;&gt; &lt;tr&gt;&gt; &lt;th&gt;Id&lt;/th&gt;&gt; &lt;th&gt;姓名&lt;/th&gt;&gt; &lt;th&gt;系&lt;/th&gt;&gt; &lt;th&gt;学分&lt;/th&gt;&gt; &lt;/tr&gt;&gt; @foreach (var item in Model)&#123;&gt; &lt;tr&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.Id)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.Name)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.DeptName)&gt; &lt;/td&gt;&gt; &lt;td&gt;&gt; @Html.DisplayFor(modelItem =&gt; item.TotCred)&gt; &lt;/td&gt;&gt; &lt;/tr&gt;&gt; &#125;&gt; &lt;/table&gt;&gt; Register.cshtml 12345678910111213141516171819202122232425262728293031323334&gt; @model dotnet.Student&gt; &gt; @&#123;&gt; ViewData[\"Title\"] = \"注册\";&gt; &#125;&gt; &gt; &lt;form asp-controller=\"Student\" asp-action=\"Register\" method=\"POST\"&gt;&gt; &lt;div class=\"form-group\"&gt;&gt; &lt;label asp-for=\"Id\" class=\"col-md-2 control-label\"&gt;编号：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"Id\"/&gt;&gt; &lt;span asp-validation-for=\"Id\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"Name\" class=\"col-md-2 control-label\"&gt;名字：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"Name\"/&gt;&gt; &lt;span asp-validation-for=\"Name\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"DeptName\" class=\"col-md-2 control-label\"&gt;系：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"DeptName\"/&gt;&gt; &lt;span asp-validation-for=\"DeptName\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;label asp-for=\"TotCred\" class=\"col-md-2 control-label\"&gt;学分：&lt;/label&gt;&gt; &lt;div class=\"col-md-10\"&gt;&gt; &lt;input class=\"form-control\" asp-for=\"TotCred\"/&gt;&gt; &lt;span asp-validation-for=\"TotCred\" class=\"text-danger\"&gt;&lt;/span&gt;&gt; &lt;/div&gt;&gt; &lt;div class=\"col-md-offset-2 col-md-10\"&gt;&gt; &lt;input type=\"submit\" value=\"保存\" class=\"btn btn-default\"/&gt;&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; &lt;/form&gt;&gt; 关于抛出以下错误的解决方法 错误： 解决方法： 注意最下面的Tip：由于我们在Startup.cs中已经添加如下代码： 123456&gt; public void ConfigureServices(IServiceCollection services)&gt; &#123;&gt; services.AddDbContext&lt;universityContext&gt;();&gt; services.AddMvc();&gt; &#125;&gt; 即满足条件“already configured outside of the context in Startup.cs”，因此我们需要将上述图片中的if语句注释掉，如下： 1234&gt; //if (!optionsBuilder.IsConfigured)&#123; &gt; optionsBuilder.UseMySql(&quot;server=localhost;userid=root;pwd=tanrui;port=3306;database=university;sslmode=none;&quot;);&gt; //&#125;&gt; 运行项目 调试的方法 vscode下点按“开始调试” 浏览器将会自动跳转至localhost:5000 在URL中添加/student或student/index跳转到我们定义的Controller中，一般情况下index路由是可以忽略不写的，此时自动定位到index中： 戳这里下载Asp.net Core开发实战.pdf","categories":[{"name":"archives","slug":"archives","permalink":"http://blog.guitoubing.top/categories/archives/"}],"tags":[{"name":"Dotnet","slug":"Dotnet","permalink":"http://blog.guitoubing.top/tags/Dotnet/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.guitoubing.top/tags/数据库/"}]},{"title":"我们梦中见","slug":"2017-10-14","date":"2018-06-26T04:29:17.000Z","updated":"2018-11-06T13:19:32.000Z","comments":true,"path":"2018/06/26/2017-10-14/","link":"","permalink":"http://blog.guitoubing.top/2018/06/26/2017-10-14/","excerpt":"“Yeah It’s on. ” 26/06/2018当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。 14/10/2017（是不是个技博自己心里没点B数？","text":"“Yeah It’s on. ” 26/06/2018当兵回来用的虚拟主机建的博客，hexo建在本地。前段时间电脑重装了，以前的博客就落满了灰，现迁移过来，换个心情。 14/10/2017（是不是个技博自己心里没点B数？ 应该说天明学长在技术方面给予了很大的支持，为她打call！ 说要建站已经是三年前了，那时候在某课网上闲逛看到了关于Linux搭建服务器的视频，学了点，发现，what are you fk saying？后来自己买了本书，噢~ 更™不懂了。然后，就去了号子（？？）。转眼两年过去了，是该重新做人了，该搬的砖还得搬，搬不完还想吃饭？ 买的第一个虚拟主机是景安一台国内主机，这个时候还是不知道国内主机和海外主机有啥区别，只知道国内主机便宜，不，新用户免费。于是买了个试了下。配套的买了个top域名¥15.00/月，是贼贵了。绑定域名时发现需要备案，备案就备案吧，流程走下去。一大堆东西拍了照填了表提交上去了想的差不多了吧。结果跟我说非上海本地户口要™居住证或者临时居住证，我哪里去办，户口都没迁过来，想想要不找个备案不怎么严的省份备案下，看了下河南（？？？）以及其他，要么是要本地手机号要么就是居住证，算了，贵国厉害，我买海外。于是买了个HK主机，¥199/年（后来看到阿里云服务器学生价¥10/月+com域名就扇了自己一巴掌，你有钱行了吧）。 接下来是干货了（扯淡然后就是绑定域名了没啥说的。 对于一个毫无前端经验的人来说，有了这些又有啥用，别人进你网站就为了看你在云里面存了多少种子？ 这里又要提到天明学长了，在她网站中得知有了个Hexo的框架，仿佛看到了未来。至于Hexo怎么用，官方文档里面都很详尽了，这里讲几点用的时候踩过的坑，以备。 _config.YML配置，比较重要的几个地方路径URL12url: http://guitoubing.top/root: / url和root一定要注意，最后面的“/”千万不要忘了，不然在hexo generate的时候肯定会报错 在generate后要注意public文件夹的位置，public文件夹一般自动创建在当前目录下，我在server后，本地服务器浏览是没有问题的，但是点开public文件夹里面的index就会连不上css，当然上传到服务器之后肯定也是连不上的了，因为root: /这行代码认为你当前工作目录是在根目录下（硬盘根目录或者服务器根目录），有的同学会想那我把root改成我当前位置不就好了，我也试过，此时public里面的index可以正常浏览，但是传到deploy到服务器上就又连不上了，因为服务器里面没有你当前这样的路径呀。这里我用的笨办法，把创建好的public文件夹复制到硬盘根目录下，然后发现本地服务器上index是可以正常显示了，传到服务器上之后也是可以的。 Disqus插件12# Disqus settingsdisqus_username: guitoubing 因为多说已经关闭服务了，只能用Disqus，而Disqus又是需要科学上网才能加载的，所以也没办法了。如果你能科学上网，那只要把这里的disqus_username改成自己注册的账号即可，我用的主题hexo-theme-huxblog已经集成了Disqus的js代码，所以不需要其他设置，如果用的其他主题/themes/layout里面的ejs文件中添加js代码即可。 Analytics123456# Analytics settings# Baidu Analyticsba_track_id: bcfce8e737b***********04c164dc96# Google Analyticsga_track_id: &apos;UA-10*******-1&apos; # Format: UA-xxxxxx-xxga_domain: guitoubing.top deploy1234567deploy: type: ftpsync host: guitoubing.top user: webmaster@HK****** pass: tanrui106 remote: /WEB/ port: 21 deploy就是部署到服务器上咯，因为我用的是HK虚拟主机，所以配置如上，这里的各个信息都是你所部署的服务器信息没什么好说的。 _config.YML配置完成了就可以开始创作咯123hexo new &quot;blog&quot; hexo ghexo s Hexo官方文档都有详细使用方法，不赘述。 有几句MMP当讲1古有一商人，于川中收购一批苎麻、小麦、桔子、兽皮，从水路出川。船至半途，水急桨朽，桨折断而顺水去，船夫甚急，问商人： 无桨不得行船，你所携货物中可有长直之物当桨？ 商人安慰他： 莫急，我有桔麻麦皮不知当桨不当桨？ 从开始接触hexo到成功deploy到服务器上，算下来该有一下午加一晚上了。应该说两年没接触编程了，那句“程序员写了一段让自己不用再写代码的代码”已经不是笑话，也许是两年之前也啥屁不懂，现在越来越觉得放眼看世界是多重要。当我还熬夜敲着基础代码时，互联网上已经有了其他解决方案，倒不是说基础代码不重要，而是已经有人用基础代码敲出了不用再敲基础代码的代码，那么，吃肉，还是喝汤，看自己选择了。（我选择狗带）","categories":[{"name":"life","slug":"life","permalink":"http://blog.guitoubing.top/categories/life/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.guitoubing.top/tags/Hexo/"}]}]}